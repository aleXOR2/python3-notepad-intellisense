<?xml version="1.0" encoding="Windows-1252" ?>
	<!--
	@author Gregori Gerebtzoff
	@version 1.3
	-->
<NotepadPlus>
	<AutoComplete>
		<Environment ignoreCase="no" startFunc="(" stopFunc=")" paramSeparator="," additionalWordChar = "._" />
		<KeyWord name="ABCMeta" func="yes">
			<Overload retVal="" descr="Function of abc.ABCMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="ARRAY" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="AbstractEventLoop" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="AbstractEventLoopPolicy" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoopPolicy">
			</Overload>
		</KeyWord>
		<KeyWord name="AbstractFormatter" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="AbstractServer" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractServer">
			</Overload>
		</KeyWord>
		<KeyWord name="AbstractWriter" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="AddPackagePath" func="yes">
			<Overload retVal="" descr="Function of modulefinder">
			</Overload>
		</KeyWord>
		<KeyWord name="AddressValueError" func="yes">
			<Overload retVal="" descr="Function of ipaddress.AddressValueError">
			</Overload>
		</KeyWord>
		<KeyWord name="Aifc_read" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="Aifc_write" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="AmbiguousOptionError" func="yes">
			<Overload retVal="" descr="Function of optparse.AmbiguousOptionError">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgInfo" func="yes">
			<Overload retVal="" descr="Function of inspect.ArgInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgSpec" func="yes">
			<Overload retVal="" descr="Function of inspect.ArgSpec">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgumentDefaultsHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgumentError" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentError">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgumentParser" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="ArgumentTypeError" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentTypeError">
			</Overload>
		</KeyWord>
		<KeyWord name="Arguments" func="yes">
			<Overload retVal="" descr="Function of inspect.Arguments">
			</Overload>
		</KeyWord>
		<KeyWord name="ArithmeticError" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Array" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ArticleInfo" func="yes">
			<Overload retVal="" descr="Function of nntplib.ArticleInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="AssertionError" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="AsyncGeneratorType" func="yes">
			<Overload retVal="" descr="Function of types.AsyncGeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="Attribute" func="yes">
			<Overload retVal="" descr="Function of inspect.Attribute">
			</Overload>
		</KeyWord>
		<KeyWord name="AttributeError" func="yes">
			<Overload retVal="" descr="Attribute not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Au_read" func="yes">
			<Overload retVal="" descr="Function of sunau.Au_read">
			</Overload>
		</KeyWord>
		<KeyWord name="Au_write" func="yes">
			<Overload retVal="" descr="Function of sunau.Au_write">
			</Overload>
		</KeyWord>
		<KeyWord name="AuthenticationError" func="yes">
			<Overload retVal="" descr="Function of multiprocessing.AuthenticationError">
			</Overload>
		</KeyWord>
		<KeyWord name="AvailableDistributions" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.AvailableDistributions">
			</Overload>
		</KeyWord>
		<KeyWord name="BZ2Compressor" func="yes">
			<Overload retVal="" descr="Function of bz2.BZ2Compressor">
			</Overload>
		</KeyWord>
        		<KeyWord name="BZ2Decompressor" func="yes">
			<Overload retVal="" descr="Function of bz2.BZ2Decompressor">
			</Overload>
		</KeyWord>
		<KeyWord name="Babyl" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="BabylMessage" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="BackgroundBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.BackgroundBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="BadOptionError" func="yes">
			<Overload retVal="" descr="Function of optparse.BadOptionError">
			</Overload>
		</KeyWord>
		<KeyWord name="BadZipFile" func="yes">
			<Overload retVal="" descr="Function of zipfile.BadZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="BadZipfile" func="yes">
			<Overload retVal="" descr="Function of zipfile.BadZipfile">
			</Overload>
		</KeyWord>
		<KeyWord name="Barrier" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.BaseBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseEventLoop" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseException" func="yes">
			<Overload retVal="" descr="Common base class for all exceptions">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseProtocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseRequestHandler" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseRequestHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseServer" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseTestSuite" func="yes">
			<Overload retVal="" descr="Function of unittest.BaseTestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="BaseTransport" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="BasicInterpolation" func="yes">
			<Overload retVal="" descr="Function of configparser.BasicInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="Bdb" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="BdbQuit" func="yes">
			<Overload retVal="" descr="Function of bdb.BdbQuit">
			</Overload>
		</KeyWord>
		<KeyWord name="Beep" func="yes">
			<Overload retVal="" descr="Function of winsound">
			</Overload>
		</KeyWord>
		<KeyWord name="BinHex" func="yes">
			<Overload retVal="" descr="Function of binhex.BinHex">
			</Overload>
		</KeyWord>
		<KeyWord name="Binary" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Binary">
			</Overload>
		</KeyWord>
		<KeyWord name="BlockFinder" func="yes">
			<Overload retVal="" descr="Function of inspect.BlockFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="BlockingIOError" func="yes">
			<Overload retVal="" descr="I/O operation would block.">
			</Overload>
		</KeyWord>
		<KeyWord name="BoundArguments" func="yes">
			<Overload retVal="" descr="Function of inspect.BoundArguments">
			</Overload>
		</KeyWord>
		<KeyWord name="BoundedSemaphore" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="Breakpoint" func="yes">
			<Overload retVal="" descr="Function of bdb.Breakpoint">
			</Overload>
		</KeyWord>
		<KeyWord name="BrokenBarrierError" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.BrokenBarrierError">
			</Overload>
		</KeyWord>
		<KeyWord name="BrokenPipeError" func="yes">
			<Overload retVal="" descr="Broken pipe.">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferError" func="yes">
			<Overload retVal="" descr="Buffer error.">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferTooShort" func="yes">
			<Overload retVal="" descr="Function of multiprocessing.BufferTooShort">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedIncrementalDecoder" func="yes">
			<Overload retVal="" descr="Function of codecs.BufferedIncrementalDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedIncrementalEncoder" func="yes">
			<Overload retVal="" descr="Function of codecs.BufferedIncrementalEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedRWPair" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRWPair">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedRandom" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRandom">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedReader" func="yes">
			<Overload retVal="" descr="Function of io.BufferedReader">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferedWriter" func="yes">
			<Overload retVal="" descr="Function of io.BufferedWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="BufferingFormatter" func="yes">
			<Overload retVal="" descr="Function of logging.BufferingFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="Bytecode" func="yes">
			<Overload retVal="" descr="Function of dis.Bytecode">
			</Overload>
		</KeyWord>
		<KeyWord name="BytesIO" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="BytesWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about bytes and buffer related problems, mostly&#10;related to conversion from str or comparing to str.">
			</Overload>
		</KeyWord>
        		<KeyWord name="CAB" func="yes">
			<Overload retVal="" descr="Function of msilib.CAB">
			</Overload>
		</KeyWord>
		<KeyWord name="CFUNCTYPE" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Cache" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cache">
			</Overload>
		</KeyWord>
		<KeyWord name="Calendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="CallableMeta" func="yes">
			<Overload retVal="" descr="Function of typing.CallableMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="CalledProcessError" func="yes">
			<Overload retVal="" descr="Function of subprocess.CalledProcessError">
			</Overload>
		</KeyWord>
		<KeyWord name="CancelledError" func="yes">
			<Overload retVal="" descr="Function of asyncio.CancelledError">
			</Overload>
		</KeyWord>
		<KeyWord name="Catalog" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="CertificateError" func="yes">
			<Overload retVal="" descr="Function of ssl.CertificateError">
			</Overload>
		</KeyWord>
		<KeyWord name="ChildProcessError" func="yes">
			<Overload retVal="" descr="Child process error.">
			</Overload>
		</KeyWord>
		<KeyWord name="Chrome" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Chrome">
			</Overload>
		</KeyWord>
		<KeyWord name="Chromium" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Chromium">
			</Overload>
		</KeyWord>
		<KeyWord name="Chunk" func="yes">
			<Overload retVal="" descr="Function of aifc.Chunk">
			</Overload>
		</KeyWord>
		<KeyWord name="Clamped" func="yes">
			<Overload retVal="" descr="Function of decimal.Clamped">
			</Overload>
		</KeyWord>
		<KeyWord name="Class" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="Close" func="yes">
			<Overload retVal="" descr="Function of subprocess.Handle">
			</Overload>
		</KeyWord>
		<KeyWord name="ClosureVars" func="yes">
			<Overload retVal="" descr="Function of inspect.ClosureVars">
			</Overload>
		</KeyWord>
		<KeyWord name="Cmd" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="Codec" func="yes">
			<Overload retVal="" descr="Function of codecs.Codec">
			</Overload>
		</KeyWord>
		<KeyWord name="CodecInfo" func="yes">
			<Overload retVal="" descr="Function of codecs.CodecInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="CodecRegistryError" func="yes">
			<Overload retVal="" descr="Function of encodings.CodecRegistryError">
			</Overload>
		</KeyWord>
		<KeyWord name="Command" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="CommandError" func="yes">
			<Overload retVal="" descr="Function of pip.CommandError">
			</Overload>
		</KeyWord>
		<KeyWord name="CompletedProcess" func="yes">
			<Overload retVal="" descr="Function of subprocess.CompletedProcess">
			</Overload>
		</KeyWord>
		<KeyWord name="Completer" func="yes">
			<Overload retVal="" descr="Function of rlcompleter.Completer">
			</Overload>
		</KeyWord>
		<KeyWord name="CompressionError" func="yes">
			<Overload retVal="" descr="Function of tarfile.CompressionError">
			</Overload>
		</KeyWord>
		<KeyWord name="Condition" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ConfigOptionParser" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="Connection" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="ConnectionAbortedError" func="yes">
			<Overload retVal="" descr="Connection aborted.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConnectionError" func="yes">
			<Overload retVal="" descr="Connection error.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConnectionRefusedError" func="yes">
			<Overload retVal="" descr="Connection refused.">
			</Overload>
		</KeyWord>
		<KeyWord name="ConnectionResetError" func="yes">
			<Overload retVal="" descr="Connection reset.">
			</Overload>
		</KeyWord>
		<KeyWord name="Context" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="ContextualVersionConflict" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualVersionConflict">
			</Overload>
		</KeyWord>
		<KeyWord name="ContextualZipFile" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="Control" func="yes">
			<Overload retVal="" descr="Function of msilib.Control">
			</Overload>
		</KeyWord>
		<KeyWord name="ConversionError" func="yes">
			<Overload retVal="" descr="Function of xdrlib.ConversionError">
			</Overload>
		</KeyWord>
		<KeyWord name="ConversionSyntax" func="yes">
			<Overload retVal="" descr="Function of decimal.ConversionSyntax">
			</Overload>
		</KeyWord>
		<KeyWord name="CoroutineType" func="yes">
			<Overload retVal="" descr="Function of types.CoroutineType">
			</Overload>
		</KeyWord>
		<KeyWord name="Counter" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="CoverageResults" func="yes">
			<Overload retVal="" descr="Function of trace.CoverageResults">
			</Overload>
		</KeyWord>
		<KeyWord name="CreateRecord" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="Cursor" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="DER_cert_to_PEM_cert" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="Data" func="yes">
			<Overload retVal="" descr="Function of plistlib.Data">
			</Overload>
		</KeyWord>
		<KeyWord name="DataError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.DataError">
			</Overload>
		</KeyWord>
		<KeyWord name="DatabaseError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.DatabaseError">
			</Overload>
		</KeyWord>
		<KeyWord name="DatagramProtocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.DatagramProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="DatagramRequestHandler" func="yes">
			<Overload retVal="" descr="Function of socketserver.DatagramRequestHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="DatagramTransport" func="yes">
			<Overload retVal="" descr="Function of asyncio.DatagramTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="Date" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Date">
			</Overload>
		</KeyWord>
		<KeyWord name="DateFromTicks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="DebugRunner" func="yes">
			<Overload retVal="" descr="Function of doctest.DebugRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="DebuggingServer" func="yes">
			<Overload retVal="" descr="Function of smtpd.DebuggingServer">
			</Overload>
		</KeyWord>
		<KeyWord name="Decimal" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="DecimalException" func="yes">
			<Overload retVal="" descr="Function of decimal.DecimalException">
			</Overload>
		</KeyWord>
		<KeyWord name="DecimalTuple" func="yes">
			<Overload retVal="" descr="Function of decimal.DecimalTuple">
			</Overload>
		</KeyWord>
		<KeyWord name="DefaultEventLoopPolicy" func="yes">
			<Overload retVal="" descr="Function of asyncio.DefaultEventLoopPolicy">
			</Overload>
		</KeyWord>
		<KeyWord name="DefaultProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="DefaultVerifyPaths" func="yes">
			<Overload retVal="" descr="Function of ssl.DefaultVerifyPaths">
			</Overload>
		</KeyWord>
		<KeyWord name="DependencyWarning" func="yes">
			<Overload retVal="" descr="Function of pip.DependencyWarning">
			</Overload>
		</KeyWord>
		<KeyWord name="DeprecationWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about deprecated features.">
			</Overload>
		</KeyWord>
		<KeyWord name="Detach" func="yes">
			<Overload retVal="" descr="Function of subprocess.Handle">
			</Overload>
		</KeyWord>
		<KeyWord name="Devnull" func="yes">
			<Overload retVal="" descr="Function of smtpd.Devnull">
			</Overload>
		</KeyWord>
		<KeyWord name="Dialog" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="Dict" func="yes">
			<Overload retVal="" descr="Function of plistlib.Dict">
			</Overload>
		</KeyWord>
		<KeyWord name="DictWriter" func="yes">
			<Overload retVal="" descr="Function of csv.DictWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="Differ" func="yes">
			<Overload retVal="" descr="Function of difflib.Differ">
			</Overload>
		</KeyWord>
		<KeyWord name="DirEntry" func="yes">
			<Overload retVal="" descr="Function of os.DirEntry">
			</Overload>
		</KeyWord>
		<KeyWord name="Directory" func="yes">
			<Overload retVal="" descr="Function of msilib.Directory">
			</Overload>
		</KeyWord>
		<KeyWord name="DistInfoDistribution" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="Distribution" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="DistributionNotFound" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistributionNotFound">
			</Overload>
		</KeyWord>
		<KeyWord name="DivisionByZero" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionByZero">
			</Overload>
		</KeyWord>
		<KeyWord name="DivisionImpossible" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionImpossible">
			</Overload>
		</KeyWord>
		<KeyWord name="DivisionUndefined" func="yes">
			<Overload retVal="" descr="Function of decimal.DivisionUndefined">
			</Overload>
		</KeyWord>
		<KeyWord name="DllCanUnloadNow" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="DllGetClassObject" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Doc" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="DocFileCase" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="DocFileSuite" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="DocFileTest" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestCase" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestFailure" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestFailure">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestFinder" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestParser" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestParser">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestRunner" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="DocTestSuite" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="DumbWriter" func="yes">
			<Overload retVal="" descr="Function of formatter.DumbWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="DuplicateOptionError" func="yes">
			<Overload retVal="" descr="Function of configparser.DuplicateOptionError">
			</Overload>
		</KeyWord>
		<KeyWord name="DuplicateSectionError" func="yes">
			<Overload retVal="" descr="Function of configparser.DuplicateSectionError">
			</Overload>
		</KeyWord>
		<KeyWord name="DynamicClassAttribute" func="yes">
			<Overload retVal="" descr="Function of enum.DynamicClassAttribute">
			</Overload>
		</KeyWord>
		<KeyWord name="EGG_NAME" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="EOFError" func="yes">
			<Overload retVal="" descr="Read beyond end of file.">
			</Overload>
		</KeyWord>
		<KeyWord name="EOFHeaderError" func="yes">
			<Overload retVal="" descr="Function of tarfile.EOFHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="EggInfoDistribution" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EggInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="EggMetadata" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EggMetadata">
			</Overload>
		</KeyWord>
		<KeyWord name="EggProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EggProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="Elinks" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Elinks">
			</Overload>
		</KeyWord>
		<KeyWord name="Empty" func="yes">
			<Overload retVal="" descr="Function of queue.Empty">
			</Overload>
		</KeyWord>
		<KeyWord name="EmptyHeaderError" func="yes">
			<Overload retVal="" descr="Function of tarfile.EmptyHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="EmptyProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EmptyProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="EncodedFile" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="EndOfBlock" func="yes">
			<Overload retVal="" descr="Function of inspect.EndOfBlock">
			</Overload>
		</KeyWord>
		<KeyWord name="EntryPoint" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EntryPoint">
			</Overload>
		</KeyWord>
		<KeyWord name="EnumMeta" func="yes">
			<Overload retVal="" descr="Function of enum.EnumMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="EnvBuilder" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="Environment" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.Environment">
			</Overload>
		</KeyWord>
		<KeyWord name="EnvironmentError" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="Error" func="yes">
			<Overload retVal="" descr="Function of aifc.Error">
			</Overload>
		</KeyWord>
		<KeyWord name="ErrorDuringImport" func="yes">
			<Overload retVal="" descr="Function of pydoc.ErrorDuringImport">
			</Overload>
		</KeyWord>
		<KeyWord name="ErrorString" func="yes">
			<Overload retVal="" descr="Function of pyexpat">
			</Overload>
		</KeyWord>
		<KeyWord name="Etiny" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="Etop" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="Event" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ExFileObject" func="yes">
			<Overload retVal="" descr="Function of tarfile.ExFileObject">
			</Overload>
		</KeyWord>
		<KeyWord name="Exception" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ExecError" func="yes">
			<Overload retVal="" descr="Function of shutil.ExecError">
			</Overload>
		</KeyWord>
		<KeyWord name="ExitNow" func="yes">
			<Overload retVal="" descr="Function of asyncore.ExitNow">
			</Overload>
		</KeyWord>
		<KeyWord name="ExpatError" func="yes">
			<Overload retVal="" descr="Function of pyexpat.ExpatError">
			</Overload>
		</KeyWord>
		<KeyWord name="ExtendedInterpolation" func="yes">
			<Overload retVal="" descr="Function of configparser.ExtendedInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="ExternalClashError" func="yes">
			<Overload retVal="" descr="Function of mailbox.ExternalClashError">
			</Overload>
		</KeyWord>
		<KeyWord name="ExternalEntityParserCreate" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="ExtractError" func="yes">
			<Overload retVal="" descr="Function of tarfile.ExtractError">
			</Overload>
		</KeyWord>
		<KeyWord name="ExtractionError" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ExtractionError">
			</Overload>
		</KeyWord>
		<KeyWord name="FCICreate" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="FTP" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="FTP_TLS" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP_TLS">
			</Overload>
		</KeyWord>
		<KeyWord name="False" />
		<KeyWord name="Feature" func="yes">
			<Overload retVal="" descr="Function of msilib.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="FeedParser" func="yes">
			<Overload retVal="" descr="Function of cgi.FeedParser">
			</Overload>
		</KeyWord>
		<KeyWord name="FieldStorage" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="FileExistsError" func="yes">
			<Overload retVal="" descr="File already exists.">
			</Overload>
		</KeyWord>
		<KeyWord name="FileHandler" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="FileHeader" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="FileIO" func="yes">
			<Overload retVal="" descr="Function of io.FileIO">
			</Overload>
		</KeyWord>
		<KeyWord name="FileInput" func="yes">
			<Overload retVal="" descr="Function of fileinput.FileInput">
			</Overload>
		</KeyWord>
		<KeyWord name="FileMetadata" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.FileMetadata">
			</Overload>
		</KeyWord>
		<KeyWord name="FileNotFoundError" func="yes">
			<Overload retVal="" descr="File not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="Filter" func="yes">
			<Overload retVal="" descr="Function of logging.Filter">
			</Overload>
		</KeyWord>
		<KeyWord name="Filterer" func="yes">
			<Overload retVal="" descr="Function of logging.Filterer">
			</Overload>
		</KeyWord>
		<KeyWord name="FloatOperation" func="yes">
			<Overload retVal="" descr="Function of decimal.FloatOperation">
			</Overload>
		</KeyWord>
		<KeyWord name="FloatingPointError" func="yes">
			<Overload retVal="" descr="Floating point operation failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="FormatError" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Formatter" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="FrameInfo" func="yes">
			<Overload retVal="" descr="Function of inspect.FrameInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="FrameType" func="yes">
			<Overload retVal="" descr="Function of types.FrameType">
			</Overload>
		</KeyWord>
		<KeyWord name="FrozenRequirement" func="yes">
			<Overload retVal="" descr="Function of pip.FrozenRequirement">
			</Overload>
		</KeyWord>
		<KeyWord name="Full" func="yes">
			<Overload retVal="" descr="Function of queue.Full">
			</Overload>
		</KeyWord>
		<KeyWord name="FullArgSpec" func="yes">
			<Overload retVal="" descr="Function of inspect.FullArgSpec">
			</Overload>
		</KeyWord>
		<KeyWord name="Function" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="FunctionTestCase" func="yes">
			<Overload retVal="" descr="Function of unittest.FunctionTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="Future" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="FutureWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about constructs that will change semantically&#10;in the future.">
			</Overload>
		</KeyWord>
		<KeyWord name="GNUTranslations" func="yes">
			<Overload retVal="" descr="Function of gettext.GNUTranslations">
			</Overload>
		</KeyWord>
		<KeyWord name="Galeon" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Galeon">
			</Overload>
		</KeyWord>
		<KeyWord name="GeneratorExit" func="yes">
			<Overload retVal="" descr="Request that a generator exit.">
			</Overload>
		</KeyWord>
		<KeyWord name="GeneratorType" func="yes">
			<Overload retVal="" descr="Function of types.GeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="GenericBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.GenericBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="GenericMeta" func="yes">
			<Overload retVal="" descr="Function of typing.GenericMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="GetBase" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="GetInputContext" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="GetPassWarning" func="yes">
			<Overload retVal="" descr="Function of getpass.GetPassWarning">
			</Overload>
		</KeyWord>
		<KeyWord name="GetoptError" func="yes">
			<Overload retVal="" descr="Function of getopt.GetoptError">
			</Overload>
		</KeyWord>
		<KeyWord name="Grail" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Grail">
			</Overload>
		</KeyWord>
		<KeyWord name="GroupInfo" func="yes">
			<Overload retVal="" descr="Function of nntplib.GroupInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="HMAC" func="yes">
			<Overload retVal="" descr="Function of hmac.HMAC">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLDoc" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="HTMLRepr" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="Handle" func="yes">
			<Overload retVal="" descr="Function of asyncio.Handle">
			</Overload>
		</KeyWord>
		<KeyWord name="Handler" func="yes">
			<Overload retVal="" descr="Function of logging.Handler">
			</Overload>
		</KeyWord>
		<KeyWord name="HeaderError" func="yes">
			<Overload retVal="" descr="Function of tarfile.HeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="HelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="Helper" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="HexBin" func="yes">
			<Overload retVal="" descr="Function of binhex.HexBin">
			</Overload>
		</KeyWord>
		<KeyWord name="Hook" func="yes">
			<Overload retVal="" descr="Function of cgitb.Hook">
			</Overload>
		</KeyWord>
		<KeyWord name="HtmlDiff" func="yes">
			<Overload retVal="" descr="Function of difflib.HtmlDiff">
			</Overload>
		</KeyWord>
		<KeyWord name="IMAP4" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="IMAP4_SSL" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4_SSL">
			</Overload>
		</KeyWord>
		<KeyWord name="IMAP4_stream" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4_stream">
			</Overload>
		</KeyWord>
		<KeyWord name="IMetadataProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.IMetadataProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="IOError" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="IPv4Network" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="IPv6Network" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv6Network">
			</Overload>
		</KeyWord>
		<KeyWord name="IResourceProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.IResourceProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="ISEOF" func="yes">
			<Overload retVal="" descr="Function of token">
			</Overload>
		</KeyWord>
		<KeyWord name="ISNONTERMINAL" func="yes">
			<Overload retVal="" descr="Function of token">
			</Overload>
		</KeyWord>
		<KeyWord name="ISTERMINAL" func="yes">
			<Overload retVal="" descr="Function of token">
			</Overload>
		</KeyWord>
		<KeyWord name="IS_CHARACTER_JUNK" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="IS_LINE_JUNK" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="IllegalMonthError" func="yes">
			<Overload retVal="" descr="Function of calendar.IllegalMonthError">
			</Overload>
		</KeyWord>
		<KeyWord name="IllegalWeekdayError" func="yes">
			<Overload retVal="" descr="Function of calendar.IllegalWeekdayError">
			</Overload>
		</KeyWord>
		<KeyWord name="ImpImporter" func="yes">
			<Overload retVal="" descr="Function of pkgutil.ImpImporter">
			</Overload>
		</KeyWord>
		<KeyWord name="ImpLoader" func="yes">
			<Overload retVal="" descr="Function of pkgutil.ImpLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="ImportError" func="yes">
			<Overload retVal="" descr="Import can't find module, or can't find name in module.">
			</Overload>
		</KeyWord>
		<KeyWord name="ImportWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about probable mistakes in module imports">
			</Overload>
		</KeyWord>
		<KeyWord name="IncompleteReadError" func="yes">
			<Overload retVal="" descr="Function of asyncio.IncompleteReadError">
			</Overload>
		</KeyWord>
		<KeyWord name="IncrementalDecoder" func="yes">
			<Overload retVal="" descr="Function of codecs.IncrementalDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="IncrementalEncoder" func="yes">
			<Overload retVal="" descr="Function of codecs.IncrementalEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="IncrementalNewlineDecoder" func="yes">
			<Overload retVal="" descr="Function of io.IncrementalNewlineDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="IndentationError" func="yes">
			<Overload retVal="" descr="Improper indentation.">
			</Overload>
		</KeyWord>
		<KeyWord name="IndentedHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of optparse.IndentedHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="IndexError" func="yes">
			<Overload retVal="" descr="Sequence index out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="Inexact" func="yes">
			<Overload retVal="" descr="Function of decimal.Inexact">
			</Overload>
		</KeyWord>
		<KeyWord name="InsecureRequestWarning" func="yes">
			<Overload retVal="" descr="Function of pip.InsecureRequestWarning">
			</Overload>
		</KeyWord>
		<KeyWord name="InstallationError" func="yes">
			<Overload retVal="" descr="Function of pip.InstallationError">
			</Overload>
		</KeyWord>
		<KeyWord name="Instruction" func="yes">
			<Overload retVal="" descr="Function of dis.Instruction">
			</Overload>
		</KeyWord>
		<KeyWord name="Int2AP" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="IntegrityError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.IntegrityError">
			</Overload>
		</KeyWord>
		<KeyWord name="InteractiveConsole" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="InteractiveInterpreter" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveInterpreter">
			</Overload>
		</KeyWord>
		<KeyWord name="InterfaceError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.InterfaceError">
			</Overload>
		</KeyWord>
		<KeyWord name="InternalError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.InternalError">
			</Overload>
		</KeyWord>
		<KeyWord name="Internaldate2tuple" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="Interpolation" func="yes">
			<Overload retVal="" descr="Function of configparser.Interpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="InterpolationDepthError" func="yes">
			<Overload retVal="" descr="Function of configparser.InterpolationDepthError">
			</Overload>
		</KeyWord>
		<KeyWord name="InterpolationError" func="yes">
			<Overload retVal="" descr="Function of configparser.InterpolationError">
			</Overload>
		</KeyWord>
		<KeyWord name="InterpolationMissingOptionError" func="yes">
			<Overload retVal="" descr="Function of configparser.InterpolationMissingOptionError">
			</Overload>
		</KeyWord>
		<KeyWord name="InterpolationSyntaxError" func="yes">
			<Overload retVal="" descr="Function of configparser.InterpolationSyntaxError">
			</Overload>
		</KeyWord>
		<KeyWord name="InterruptedError" func="yes">
			<Overload retVal="" descr="Interrupted by signal.">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidContext" func="yes">
			<Overload retVal="" descr="Function of decimal.InvalidContext">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidFileException" func="yes">
			<Overload retVal="" descr="Function of plistlib.InvalidFileException">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidHeaderError" func="yes">
			<Overload retVal="" descr="Function of tarfile.InvalidHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidOperation" func="yes">
			<Overload retVal="" descr="Function of decimal.InvalidOperation">
			</Overload>
		</KeyWord>
		<KeyWord name="InvalidStateError" func="yes">
			<Overload retVal="" descr="Function of asyncio.InvalidStateError">
			</Overload>
		</KeyWord>
		<KeyWord name="IocpProactor" func="yes">
			<Overload retVal="" descr="Function of asyncio.IocpProactor">
			</Overload>
		</KeyWord>
		<KeyWord name="IsADirectoryError" func="yes">
			<Overload retVal="" descr="Operation doesn't work on directories.">
			</Overload>
		</KeyWord>
		<KeyWord name="JSONDecodeError" func="yes">
			<Overload retVal="" descr="Function of json.JSONDecodeError">
			</Overload>
		</KeyWord>
		<KeyWord name="JSONDecoder" func="yes">
			<Overload retVal="" descr="Function of json.JSONDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="JSONEncoder" func="yes">
			<Overload retVal="" descr="Function of json.JSONEncoder">
			</Overload>
		</KeyWord>
		<KeyWord name="JoinableQueue" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="KeyError" func="yes">
			<Overload retVal="" descr="Mapping key not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="KeyboardInterrupt" func="yes">
			<Overload retVal="" descr="Program interrupted by user.">
			</Overload>
		</KeyWord>
		<KeyWord name="Konqueror" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Konqueror">
			</Overload>
		</KeyWord>
		<KeyWord name="LMTP" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="LZMACompressor" func="yes">
			<Overload retVal="" descr="Function of lzma.LZMACompressor">
			</Overload>
		</KeyWord>
		<KeyWord name="LZMADecompressor" func="yes">
			<Overload retVal="" descr="Function of lzma.LZMADecompressor">
			</Overload>
		</KeyWord>
		<KeyWord name="LZMAError" func="yes">
			<Overload retVal="" descr="Function of lzma.LZMAError">
			</Overload>
		</KeyWord>
		<KeyWord name="LargeZipFile" func="yes">
			<Overload retVal="" descr="Function of zipfile.LargeZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="LegacyInterpolation" func="yes">
			<Overload retVal="" descr="Function of configparser.LegacyInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="LibraryLoader" func="yes">
			<Overload retVal="" descr="Function of ctypes.LibraryLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="LifoQueue" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="LimitOverrunError" func="yes">
			<Overload retVal="" descr="Function of asyncio.LimitOverrunError">
			</Overload>
		</KeyWord>
		<KeyWord name="LoadLibrary" func="yes">
			<Overload retVal="" descr="Function of ctypes.LibraryLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="LocaleHTMLCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleHTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="LocaleTextCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="Lock" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="LogRecord" func="yes">
			<Overload retVal="" descr="Function of logging.LogRecord">
			</Overload>
		</KeyWord>
		<KeyWord name="Logger" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="LoggerAdapter" func="yes">
			<Overload retVal="" descr="Function of logging.LoggerAdapter">
			</Overload>
		</KeyWord>
		<KeyWord name="LookupError" func="yes">
			<Overload retVal="" descr="Base class for lookup errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="MH" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="MHMessage" func="yes">
			<Overload retVal="" descr="Function of mailbox.MHMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="MMDF" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDF">
			</Overload>
		</KeyWord>
		<KeyWord name="MMDFMessage" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="MODULE" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="MSIError" func="yes">
			<Overload retVal="" descr="Function of msilib.MSIError">
			</Overload>
		</KeyWord>
		<KeyWord name="Mailbox" func="yes">
			<Overload retVal="" descr="Function of mailbox.Mailbox">
			</Overload>
		</KeyWord>
		<KeyWord name="Maildir" func="yes">
			<Overload retVal="" descr="Function of mailbox.Maildir">
			</Overload>
		</KeyWord>
		<KeyWord name="MaildirMessage" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="MailmanProxy" func="yes">
			<Overload retVal="" descr="Function of smtpd.MailmanProxy">
			</Overload>
		</KeyWord>
		<KeyWord name="Manager" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="MappingProxyType" func="yes">
			<Overload retVal="" descr="Function of enum.MappingProxyType">
			</Overload>
		</KeyWord>
		<KeyWord name="Match" func="yes">
			<Overload retVal="" descr="Function of difflib.Match">
			</Overload>
		</KeyWord>
		<KeyWord name="MemoizedZipManifests" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.MemoizedZipManifests">
			</Overload>
		</KeyWord>
		<KeyWord name="MemoryBIO" func="yes">
			<Overload retVal="" descr="Function of ssl.MemoryBIO">
			</Overload>
		</KeyWord>
		<KeyWord name="MemoryError" func="yes">
			<Overload retVal="" descr="Out of memory.">
			</Overload>
		</KeyWord>
		<KeyWord name="Message" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="MessageBeep" func="yes">
			<Overload retVal="" descr="Function of winsound">
			</Overload>
		</KeyWord>
		<KeyWord name="MetavarTypeHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.MetavarTypeHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="MimeTypes" func="yes">
			<Overload retVal="" descr="Function of mimetypes.MimeTypes">
			</Overload>
		</KeyWord>
		<KeyWord name="MissingSectionHeaderError" func="yes">
			<Overload retVal="" descr="Function of configparser.MissingSectionHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="ModuleFinder" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="ModuleInfo" func="yes">
			<Overload retVal="" descr="Function of pkgutil.ModuleInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="ModuleNotFoundError" func="yes">
			<Overload retVal="" descr="Module not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="ModuleScanner" func="yes">
			<Overload retVal="" descr="Function of pydoc.ModuleScanner">
			</Overload>
		</KeyWord>
		<KeyWord name="Mozilla" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Mozilla">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTP" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTPDataError" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTPDataError">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTPError" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTPError">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTPPermanentError" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTPPermanentError">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTPProtocolError" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTPProtocolError">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTPReplyError" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTPReplyError">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTPTemporaryError" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTPTemporaryError">
			</Overload>
		</KeyWord>
		<KeyWord name="NNTP_SSL" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP_SSL">
			</Overload>
		</KeyWord>
		<KeyWord name="NameError" func="yes">
			<Overload retVal="" descr="Name not found globally.">
			</Overload>
		</KeyWord>
		<KeyWord name="NamedTemporaryFile" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="NamedTupleMeta" func="yes">
			<Overload retVal="" descr="Function of typing.NamedTupleMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="NannyNag" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="NetmaskValueError" func="yes">
			<Overload retVal="" descr="Function of ipaddress.NetmaskValueError">
			</Overload>
		</KeyWord>
		<KeyWord name="NetrcParseError" func="yes">
			<Overload retVal="" descr="Function of netrc.NetrcParseError">
			</Overload>
		</KeyWord>
		<KeyWord name="Netscape" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Netscape">
			</Overload>
		</KeyWord>
		<KeyWord name="NewType" func="yes">
			<Overload retVal="" descr="Function of typing">
			</Overload>
		</KeyWord>
		<KeyWord name="NoOptionError" func="yes">
			<Overload retVal="" descr="Function of configparser.NoOptionError">
			</Overload>
		</KeyWord>
		<KeyWord name="NoSectionError" func="yes">
			<Overload retVal="" descr="Function of configparser.NoSectionError">
			</Overload>
		</KeyWord>
		<KeyWord name="NoSuchMailboxError" func="yes">
			<Overload retVal="" descr="Function of mailbox.NoSuchMailboxError">
			</Overload>
		</KeyWord>
		<KeyWord name="NodeTransformer" func="yes">
			<Overload retVal="" descr="Function of ast.NodeTransformer">
			</Overload>
		</KeyWord>
		<KeyWord name="NodeVisitor" func="yes">
			<Overload retVal="" descr="Function of ast.NodeVisitor">
			</Overload>
		</KeyWord>
		<KeyWord name="None" />
		<KeyWord name="NotADirectoryError" func="yes">
			<Overload retVal="" descr="Operation only works on directories.">
			</Overload>
		</KeyWord>
		<KeyWord name="NotEmptyError" func="yes">
			<Overload retVal="" descr="Function of mailbox.NotEmptyError">
			</Overload>
		</KeyWord>
		<KeyWord name="NotImplementedError" func="yes">
			<Overload retVal="" descr="Method or function hasn't been implemented yet.">
			</Overload>
		</KeyWord>
		<KeyWord name="NotSupportedError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.NotSupportedError">
			</Overload>
		</KeyWord>
		<KeyWord name="NullFormatter" func="yes">
			<Overload retVal="" descr="Function of formatter.NullFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="NullHandler" func="yes">
			<Overload retVal="" descr="Function of logging.NullHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="NullImporter" func="yes">
			<Overload retVal="" descr="Function of imp.NullImporter">
			</Overload>
		</KeyWord>
		<KeyWord name="NullProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.NullProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="NullTranslations" func="yes">
			<Overload retVal="" descr="Function of gettext.NullTranslations">
			</Overload>
		</KeyWord>
		<KeyWord name="NullWriter" func="yes">
			<Overload retVal="" descr="Function of formatter.NullWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="OSError" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="OpenDatabase" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="OpenWrapper" func="yes">
			<Overload retVal="" descr="Function of io">
			</Overload>
		</KeyWord>
		<KeyWord name="Opera" func="yes">
			<Overload retVal="" descr="Function of webbrowser.Opera">
			</Overload>
		</KeyWord>
		<KeyWord name="OperationalError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.OperationalError">
			</Overload>
		</KeyWord>
		<KeyWord name="OptParseError" func="yes">
			<Overload retVal="" descr="Function of optparse.OptParseError">
			</Overload>
		</KeyWord>
		<KeyWord name="OptimizedUnicode" func="yes">
			<Overload retVal="" descr="Function of sqlite3.OptimizedUnicode">
			</Overload>
		</KeyWord>
		<KeyWord name="Option" func="yes">
			<Overload retVal="" descr="Function of optparse.Option">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionConflictError" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionConflictError">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionContainer" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionError" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionError">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionGroup" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionGroup">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionParser" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="OptionValueError" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionValueError">
			</Overload>
		</KeyWord>
		<KeyWord name="OrderedDict" func="yes">
			<Overload retVal="" descr="Function of collections.OrderedDict">
			</Overload>
		</KeyWord>
		<KeyWord name="OutputChecker" func="yes">
			<Overload retVal="" descr="Function of doctest.OutputChecker">
			</Overload>
		</KeyWord>
		<KeyWord name="Overflow" func="yes">
			<Overload retVal="" descr="Function of decimal.Overflow">
			</Overload>
		</KeyWord>
		<KeyWord name="OverflowError" func="yes">
			<Overload retVal="" descr="Result too large to be represented.">
			</Overload>
		</KeyWord>
		<KeyWord name="PEM_cert_to_DER_cert" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="PEP420PackageFinder" func="yes">
			<Overload retVal="" descr="Function of setuptools.PEP420PackageFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="PEP440Warning" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.PEP440Warning">
			</Overload>
		</KeyWord>
		<KeyWord name="POINTER" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="POP3" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="POP3_SSL" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3_SSL">
			</Overload>
		</KeyWord>
		<KeyWord name="PYFUNCTYPE" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="PackageFinder" func="yes">
			<Overload retVal="" descr="Function of setuptools.PackageFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="Packer" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="Parameter" func="yes">
			<Overload retVal="" descr="Function of inspect.Parameter">
			</Overload>
		</KeyWord>
		<KeyWord name="Parse" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="ParseFile" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="ParseFlags" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="ParserCreate" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="ParsingError" func="yes">
			<Overload retVal="" descr="Function of configparser.ParsingError">
			</Overload>
		</KeyWord>
		<KeyWord name="Path" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="PathMetadata" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.PathMetadata">
			</Overload>
		</KeyWord>
		<KeyWord name="Pattern" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Pattern">
			</Overload>
		</KeyWord>
		<KeyWord name="Pdb" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="PendingDeprecationWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about features which will be deprecated&#10;in the future.">
			</Overload>
		</KeyWord>
		<KeyWord name="PercentStyle" func="yes">
			<Overload retVal="" descr="Function of logging.PercentStyle">
			</Overload>
		</KeyWord>
		<KeyWord name="PermissionError" func="yes">
			<Overload retVal="" descr="Not enough permissions.">
			</Overload>
		</KeyWord>
		<KeyWord name="PickleError" func="yes">
			<Overload retVal="" descr="Function of pickle.PickleError">
			</Overload>
		</KeyWord>
		<KeyWord name="Pickler" func="yes">
			<Overload retVal="" descr="Function of pickle.Pickler">
			</Overload>
		</KeyWord>
		<KeyWord name="PicklingError" func="yes">
			<Overload retVal="" descr="Function of pickle.PicklingError">
			</Overload>
		</KeyWord>
		<KeyWord name="PipError" func="yes">
			<Overload retVal="" descr="Function of pip.PipError">
			</Overload>
		</KeyWord>
		<KeyWord name="Pipe" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="PlaceHolder" func="yes">
			<Overload retVal="" descr="Function of logging.PlaceHolder">
			</Overload>
		</KeyWord>
		<KeyWord name="PlaySound" func="yes">
			<Overload retVal="" descr="Function of winsound">
			</Overload>
		</KeyWord>
		<KeyWord name="Plist" func="yes">
			<Overload retVal="" descr="Function of plistlib.Plist">
			</Overload>
		</KeyWord>
		<KeyWord name="Pool" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="Popen" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="PosixPath" func="yes">
			<Overload retVal="" descr="Function of pathlib.PosixPath">
			</Overload>
		</KeyWord>
		<KeyWord name="PrettyPrinter" func="yes">
			<Overload retVal="" descr="Function of pprint.PrettyPrinter">
			</Overload>
		</KeyWord>
		<KeyWord name="PriorityQueue" func="yes">
			<Overload retVal="" descr="Function of asyncio.PriorityQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="ProactorEventLoop" func="yes">
			<Overload retVal="" descr="Function of asyncio.ProactorEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="Process" func="yes">
			<Overload retVal="" descr="Function of multiprocessing.Process">
			</Overload>
		</KeyWord>
		<KeyWord name="ProcessError" func="yes">
			<Overload retVal="" descr="Function of multiprocessing.ProcessError">
			</Overload>
		</KeyWord>
		<KeyWord name="ProcessLookupError" func="yes">
			<Overload retVal="" descr="Process not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="ProcessPoolExecutor" func="yes">
			<Overload retVal="" descr="Function of compileall.ProcessPoolExecutor">
			</Overload>
		</KeyWord>
		<KeyWord name="Profile" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="ProgrammingError" func="yes">
			<Overload retVal="" descr="Function of sqlite3.ProgrammingError">
			</Overload>
		</KeyWord>
		<KeyWord name="Protocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.Protocol">
			</Overload>
		</KeyWord>
		<KeyWord name="PurePath" func="yes">
			<Overload retVal="" descr="Function of pathlib.PurePath">
			</Overload>
		</KeyWord>
		<KeyWord name="PurePosixPath" func="yes">
			<Overload retVal="" descr="Function of pathlib.PurePosixPath">
			</Overload>
		</KeyWord>
		<KeyWord name="PureProxy" func="yes">
			<Overload retVal="" descr="Function of smtpd.PureProxy">
			</Overload>
		</KeyWord>
		<KeyWord name="PureWindowsPath" func="yes">
			<Overload retVal="" descr="Function of pathlib.PureWindowsPath">
			</Overload>
		</KeyWord>
		<KeyWord name="PyCompileError" func="yes">
			<Overload retVal="" descr="Function of py_compile.PyCompileError">
			</Overload>
		</KeyWord>
		<KeyWord name="PyZipFile" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="Queue" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="QueueEmpty" func="yes">
			<Overload retVal="" descr="Function of asyncio.QueueEmpty">
			</Overload>
		</KeyWord>
		<KeyWord name="QueueFull" func="yes">
			<Overload retVal="" descr="Function of asyncio.QueueFull">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_add" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_bytes" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_egd" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_pseudo_bytes" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="RAND_status" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="RLock" func="yes">
			<Overload retVal="" descr="Function of bz2">
			</Overload>
		</KeyWord>
		<KeyWord name="RadioButtonGroup" func="yes">
			<Overload retVal="" descr="Function of msilib.RadioButtonGroup">
			</Overload>
		</KeyWord>
		<KeyWord name="Random" func="yes">
			<Overload retVal="" descr="Function of random.Random">
			</Overload>
		</KeyWord>
		<KeyWord name="RawArray" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="RawDescriptionHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.RawDescriptionHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="RawTextHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of argparse.RawTextHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="RawValue" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ReadError" func="yes">
			<Overload retVal="" descr="Function of shutil.ReadError">
			</Overload>
		</KeyWord>
		<KeyWord name="ReadTransport" func="yes">
			<Overload retVal="" descr="Function of asyncio.ReadTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="RecursionError" func="yes">
			<Overload retVal="" descr="Recursion limit exceeded.">
			</Overload>
		</KeyWord>
		<KeyWord name="ReferenceError" func="yes">
			<Overload retVal="" descr="Weak ref proxy used after referent went away.">
			</Overload>
		</KeyWord>
		<KeyWord name="RegistryError" func="yes">
			<Overload retVal="" descr="Function of shutil.RegistryError">
			</Overload>
		</KeyWord>
		<KeyWord name="ReplacePackage" func="yes">
			<Overload retVal="" descr="Function of modulefinder">
			</Overload>
		</KeyWord>
		<KeyWord name="Repr" func="yes">
			<Overload retVal="" descr="Function of pydoc.Repr">
			</Overload>
		</KeyWord>
		<KeyWord name="Require" func="yes">
			<Overload retVal="" descr="Function of setuptools.Require">
			</Overload>
		</KeyWord>
		<KeyWord name="Requirement" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.Requirement">
			</Overload>
		</KeyWord>
		<KeyWord name="RequirementParseError" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.RequirementParseError">
			</Overload>
		</KeyWord>
		<KeyWord name="ResolutionError" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ResolutionError">
			</Overload>
		</KeyWord>
		<KeyWord name="ResourceManager" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ResourceManager">
			</Overload>
		</KeyWord>
		<KeyWord name="ResourceWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about resource usage.">
			</Overload>
		</KeyWord>
		<KeyWord name="Restart" func="yes">
			<Overload retVal="" descr="Function of pdb.Restart">
			</Overload>
		</KeyWord>
		<KeyWord name="RootLogger" func="yes">
			<Overload retVal="" descr="Function of logging.RootLogger">
			</Overload>
		</KeyWord>
		<KeyWord name="Rounded" func="yes">
			<Overload retVal="" descr="Function of decimal.Rounded">
			</Overload>
		</KeyWord>
		<KeyWord name="Row" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Row">
			</Overload>
		</KeyWord>
		<KeyWord name="RuntimeError" func="yes">
			<Overload retVal="" descr="Unspecified run-time error.">
			</Overload>
		</KeyWord>
		<KeyWord name="RuntimeWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about dubious runtime behavior.">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTP" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPAuthenticationError" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPAuthenticationError">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPChannel" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPConnectError" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPConnectError">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPDataError" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPDataError">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPException" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPException">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPHeloError" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPHeloError">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPNotSupportedError" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPNotSupportedError">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPRecipientsRefused" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPRecipientsRefused">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPResponseException" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPResponseException">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPSenderRefused" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPSenderRefused">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPServer" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTPServerDisconnected" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTPServerDisconnected">
			</Overload>
		</KeyWord>
		<KeyWord name="SMTP_SSL" func="yes">
			<Overload retVal="" descr="Function of smtplib.SMTP_SSL">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLContext" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLEOFError" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLEOFError">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLError" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLError">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLObject" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLSocket" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLSyscallError" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSyscallError">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLWantReadError" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLWantReadError">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLWantWriteError" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLWantWriteError">
			</Overload>
		</KeyWord>
		<KeyWord name="SSLZeroReturnError" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLZeroReturnError">
			</Overload>
		</KeyWord>
		<KeyWord name="S_IFMT" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_IMODE" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISBLK" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISCHR" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISDIR" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISDOOR" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISFIFO" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISLNK" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISPORT" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISREG" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISSOCK" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="S_ISWHT" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="SameFileError" func="yes">
			<Overload retVal="" descr="Function of shutil.SameFileError">
			</Overload>
		</KeyWord>
		<KeyWord name="Scanner" func="yes">
			<Overload retVal="" descr="Function of re.Scanner">
			</Overload>
		</KeyWord>
		<KeyWord name="SelectorEventLoop" func="yes">
			<Overload retVal="" descr="Function of asyncio.SelectorEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="SelectorKey" func="yes">
			<Overload retVal="" descr="Function of selectors.SelectorKey">
			</Overload>
		</KeyWord>
		<KeyWord name="Semaphore" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="SequenceMatcher" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="SetBase" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="SetParamEntityParsing" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="SetPointerType" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Signature" func="yes">
			<Overload retVal="" descr="Function of inspect.Signature">
			</Overload>
		</KeyWord>
		<KeyWord name="SimpleQueue" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="SkipDocTestCase" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="SkipTest" func="yes">
			<Overload retVal="" descr="Function of unittest.SkipTest">
			</Overload>
		</KeyWord>
		<KeyWord name="Snapshot" func="yes">
			<Overload retVal="" descr="Function of tracemalloc.Snapshot">
			</Overload>
		</KeyWord>
		<KeyWord name="SndHeaders" func="yes">
			<Overload retVal="" descr="Function of sndhdr.SndHeaders">
			</Overload>
		</KeyWord>
		<KeyWord name="Sniffer" func="yes">
			<Overload retVal="" descr="Function of csv.Sniffer">
			</Overload>
		</KeyWord>
		<KeyWord name="SocketType" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="SourcelessFileLoader" func="yes">
			<Overload retVal="" descr="Function of imp.SourcelessFileLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="SpecialFileError" func="yes">
			<Overload retVal="" descr="Function of shutil.SpecialFileError">
			</Overload>
		</KeyWord>
		<KeyWord name="SpooledTemporaryFile" func="yes">
			<Overload retVal="" descr="Function of tempfile.SpooledTemporaryFile">
			</Overload>
		</KeyWord>
		<KeyWord name="StackSummary" func="yes">
			<Overload retVal="" descr="Function of traceback.StackSummary">
			</Overload>
		</KeyWord>
		<KeyWord name="StatisticsError" func="yes">
			<Overload retVal="" descr="Function of statistics.StatisticsError">
			</Overload>
		</KeyWord>
		<KeyWord name="Stats" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="StopAsyncIteration" func="yes">
			<Overload retVal="" descr="Signal the end from iterator.__anext__().">
			</Overload>
		</KeyWord>
		<KeyWord name="StopIteration" func="yes">
			<Overload retVal="" descr="Signal the end from iterator.__next__().">
			</Overload>
		</KeyWord>
		<KeyWord name="StopTokenizing" func="yes">
			<Overload retVal="" descr="Function of tokenize.StopTokenizing">
			</Overload>
		</KeyWord>
		<KeyWord name="StrFormatStyle" func="yes">
			<Overload retVal="" descr="Function of logging.StrFormatStyle">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamError" func="yes">
			<Overload retVal="" descr="Function of tarfile.StreamError">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamHandler" func="yes">
			<Overload retVal="" descr="Function of logging.StreamHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamReader" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamReaderProtocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReaderProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamReaderWriter" func="yes">
			<Overload retVal="" descr="Function of codecs.StreamReaderWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamRecoder" func="yes">
			<Overload retVal="" descr="Function of codecs.StreamRecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamRequestHandler" func="yes">
			<Overload retVal="" descr="Function of socketserver.StreamRequestHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="StreamWriter" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="StringIO" func="yes">
			<Overload retVal="" descr="Function of cgi.StringIO">
			</Overload>
		</KeyWord>
		<KeyWord name="StringTemplateStyle" func="yes">
			<Overload retVal="" descr="Function of logging.StringTemplateStyle">
			</Overload>
		</KeyWord>
		<KeyWord name="Struct" func="yes">
			<Overload retVal="" descr="Function of struct.Struct">
			</Overload>
		</KeyWord>
		<KeyWord name="SubPattern" func="yes">
			<Overload retVal="" descr="Function of sre_parse.SubPattern">
			</Overload>
		</KeyWord>
		<KeyWord name="Subnormal" func="yes">
			<Overload retVal="" descr="Function of decimal.Subnormal">
			</Overload>
		</KeyWord>
		<KeyWord name="SubprocessError" func="yes">
			<Overload retVal="" descr="Function of subprocess.SubprocessError">
			</Overload>
		</KeyWord>
		<KeyWord name="SubprocessProtocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="SubprocessTransport" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="SubsequentHeaderError" func="yes">
			<Overload retVal="" descr="Function of tarfile.SubsequentHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="Symbol" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="SymbolTable" func="yes">
			<Overload retVal="" descr="Function of symtable.SymbolTable">
			</Overload>
		</KeyWord>
		<KeyWord name="SymbolTableFactory" func="yes">
			<Overload retVal="" descr="Function of symtable.SymbolTableFactory">
			</Overload>
		</KeyWord>
		<KeyWord name="SyntaxError" func="yes">
			<Overload retVal="" descr="Invalid syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="SyntaxWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about dubious syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="SystemError" func="yes">
			<Overload retVal="" descr="Internal error in the Python interpreter.&#10;&#10;Please report this to the Python maintainer, along with the traceback,&#10;the Python version, and the hardware/OS platform and version.">
			</Overload>
		</KeyWord>
		<KeyWord name="SystemExit" func="yes">
			<Overload retVal="" descr="Request to exit from the interpreter.">
			</Overload>
		</KeyWord>
		<KeyWord name="SystemRandom" func="yes">
			<Overload retVal="" descr="Function of random.SystemRandom">
			</Overload>
		</KeyWord>
		<KeyWord name="TCPServer" func="yes">
			<Overload retVal="" descr="Function of socketserver.TCPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="TabError" func="yes">
			<Overload retVal="" descr="Improper mixture of spaces and tabs.">
			</Overload>
		</KeyWord>
		<KeyWord name="Table" func="yes">
			<Overload retVal="" descr="Function of msilib.Table">
			</Overload>
		</KeyWord>
		<KeyWord name="TarError" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarError">
			</Overload>
		</KeyWord>
		<KeyWord name="TarFile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="TarInfo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="Task" func="yes">
			<Overload retVal="" descr="Function of asyncio.Task">
			</Overload>
		</KeyWord>
		<KeyWord name="Tdb" func="yes">
			<Overload retVal="" descr="Function of bdb.Tdb">
			</Overload>
		</KeyWord>
		<KeyWord name="Telnet" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="Template" func="yes">
			<Overload retVal="" descr="Function of pipes.Template">
			</Overload>
		</KeyWord>
		<KeyWord name="TemporaryDirectory" func="yes">
			<Overload retVal="" descr="Function of tempfile.TemporaryDirectory">
			</Overload>
		</KeyWord>
		<KeyWord name="TemporaryFile" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="TestCase" func="yes">
			<Overload retVal="" descr="Function of unittest.TestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="TestLoader" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="TestProgram" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="TestResult" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="TestResults" func="yes">
			<Overload retVal="" descr="Function of doctest.TestResults">
			</Overload>
		</KeyWord>
		<KeyWord name="TestSuite" func="yes">
			<Overload retVal="" descr="Function of unittest.TestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="Text" func="yes">
			<Overload retVal="" descr="Function of typing.Text">
			</Overload>
		</KeyWord>
		<KeyWord name="TextCalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.TextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="TextDoc" func="yes">
			<Overload retVal="" descr="Function of pydoc.TextDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="TextIOWrapper" func="yes">
			<Overload retVal="" descr="Function of cgi.TextIOWrapper">
			</Overload>
		</KeyWord>
		<KeyWord name="TextRepr" func="yes">
			<Overload retVal="" descr="Function of pydoc.TextRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="TextTestResult" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="TextTestRunner" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="TextWrapper" func="yes">
			<Overload retVal="" descr="Function of textwrap.TextWrapper">
			</Overload>
		</KeyWord>
		<KeyWord name="Thread" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="ThreadError" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.ThreadError">
			</Overload>
		</KeyWord>
		<KeyWord name="ThreadingMixIn" func="yes">
			<Overload retVal="" descr="Function of socketserver.ThreadingMixIn">
			</Overload>
		</KeyWord>
		<KeyWord name="ThreadingTCPServer" func="yes">
			<Overload retVal="" descr="Function of socketserver.ThreadingTCPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="ThreadingUDPServer" func="yes">
			<Overload retVal="" descr="Function of socketserver.ThreadingUDPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="Time" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Time">
			</Overload>
		</KeyWord>
		<KeyWord name="Time2Internaldate" func="yes">
			<Overload retVal="" descr="Function of imaplib">
			</Overload>
		</KeyWord>
		<KeyWord name="TimeFromTicks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="TimeoutError" func="yes">
			<Overload retVal="" descr="Timeout expired.">
			</Overload>
		</KeyWord>
		<KeyWord name="TimeoutExpired" func="yes">
			<Overload retVal="" descr="Function of subprocess.TimeoutExpired">
			</Overload>
		</KeyWord>
		<KeyWord name="Timer" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Timer">
			</Overload>
		</KeyWord>
		<KeyWord name="TimerHandle" func="yes">
			<Overload retVal="" descr="Function of asyncio.TimerHandle">
			</Overload>
		</KeyWord>
		<KeyWord name="Timestamp" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Timestamp">
			</Overload>
		</KeyWord>
		<KeyWord name="TimestampFromTicks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="TitledHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of optparse.TitledHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="TokenError" func="yes">
			<Overload retVal="" descr="Function of tokenize.TokenError">
			</Overload>
		</KeyWord>
		<KeyWord name="TokenInfo" func="yes">
			<Overload retVal="" descr="Function of tokenize.TokenInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="Tokenizer" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Tokenizer">
			</Overload>
		</KeyWord>
		<KeyWord name="Trace" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="Traceback" func="yes">
			<Overload retVal="" descr="Function of inspect.Traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="TracebackException" func="yes">
			<Overload retVal="" descr="Function of traceback.TracebackException">
			</Overload>
		</KeyWord>
		<KeyWord name="Transport" func="yes">
			<Overload retVal="" descr="Function of asyncio.Transport">
			</Overload>
		</KeyWord>
		<KeyWord name="True" />
		<KeyWord name="TruncatedHeaderError" func="yes">
			<Overload retVal="" descr="Function of tarfile.TruncatedHeaderError">
			</Overload>
		</KeyWord>
		<KeyWord name="TupleComp" func="yes">
			<Overload retVal="" descr="Function of pstats.TupleComp">
			</Overload>
		</KeyWord>
		<KeyWord name="TupleMeta" func="yes">
			<Overload retVal="" descr="Function of typing.TupleMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="TypeError" func="yes">
			<Overload retVal="" descr="Inappropriate argument type.">
			</Overload>
		</KeyWord>
		<KeyWord name="TypingMeta" func="yes">
			<Overload retVal="" descr="Function of typing.TypingMeta">
			</Overload>
		</KeyWord>
		<KeyWord name="UCD" func="yes">
			<Overload retVal="" descr="Function of unicodedata.UCD">
			</Overload>
		</KeyWord>
		<KeyWord name="UDPServer" func="yes">
			<Overload retVal="" descr="Function of socketserver.UDPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="UnboundLocalError" func="yes">
			<Overload retVal="" descr="Local name referenced but not bound to a value.">
			</Overload>
		</KeyWord>
		<KeyWord name="Underflow" func="yes">
			<Overload retVal="" descr="Function of decimal.Underflow">
			</Overload>
		</KeyWord>
		<KeyWord name="UnexpectedException" func="yes">
			<Overload retVal="" descr="Function of doctest.UnexpectedException">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeDecodeError" func="yes">
			<Overload retVal="" descr="Unicode decoding error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeEncodeError" func="yes">
			<Overload retVal="" descr="Unicode encoding error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeError" func="yes">
			<Overload retVal="" descr="Unicode related error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeTranslateError" func="yes">
			<Overload retVal="" descr="Unicode translation error.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnicodeWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings about Unicode related problems, mostly&#10;related to conversion problems.">
			</Overload>
		</KeyWord>
		<KeyWord name="UnixBrowser" func="yes">
			<Overload retVal="" descr="Function of webbrowser.UnixBrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="UnknownExtra" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.UnknownExtra">
			</Overload>
		</KeyWord>
		<KeyWord name="Unpacker" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="Unpickler" func="yes">
			<Overload retVal="" descr="Function of pickle.Unpickler">
			</Overload>
		</KeyWord>
		<KeyWord name="UnpicklingError" func="yes">
			<Overload retVal="" descr="Function of pickle.UnpicklingError">
			</Overload>
		</KeyWord>
		<KeyWord name="UnsupportedOperation" func="yes">
			<Overload retVal="" descr="Function of io.UnsupportedOperation">
			</Overload>
		</KeyWord>
		<KeyWord name="Untokenizer" func="yes">
			<Overload retVal="" descr="Function of tokenize.Untokenizer">
			</Overload>
		</KeyWord>
		<KeyWord name="UpdatingDefaultsHelpFormatter" func="yes">
			<Overload retVal="" descr="Function of pip.UpdatingDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="UseForeignDTD" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="UserWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings generated by user code.">
			</Overload>
		</KeyWord>
		<KeyWord name="UuidCreate" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="Value" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="ValueError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="Values" func="yes">
			<Overload retVal="" descr="Function of optparse.Values">
			</Overload>
		</KeyWord>
		<KeyWord name="Verbose" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Verbose">
			</Overload>
		</KeyWord>
		<KeyWord name="VersionConflict" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.VersionConflict">
			</Overload>
		</KeyWord>
		<KeyWord name="WINFUNCTYPE" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="Warning" func="yes">
			<Overload retVal="" descr="Base class for warning categories.">
			</Overload>
		</KeyWord>
		<KeyWord name="Wave_read" func="yes">
			<Overload retVal="" descr="Function of wave.Wave_read">
			</Overload>
		</KeyWord>
		<KeyWord name="Wave_write" func="yes">
			<Overload retVal="" descr="Function of wave.Wave_write">
			</Overload>
		</KeyWord>
		<KeyWord name="WeakSet" func="yes">
			<Overload retVal="" descr="Function of abc.WeakSet">
			</Overload>
		</KeyWord>
		<KeyWord name="Whitespace" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="WinError" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="WindowsDefault" func="yes">
			<Overload retVal="" descr="Function of webbrowser.WindowsDefault">
			</Overload>
		</KeyWord>
		<KeyWord name="WindowsError" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="WindowsPath" func="yes">
			<Overload retVal="" descr="Function of pathlib.WindowsPath">
			</Overload>
		</KeyWord>
		<KeyWord name="WorkingSet" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.WorkingSet">
			</Overload>
		</KeyWord>
		<KeyWord name="WriteTransport" func="yes">
			<Overload retVal="" descr="Function of asyncio.WriteTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="XMLParserType" func="yes">
			<Overload retVal="" descr="Function of pyexpat.XMLParserType">
			</Overload>
		</KeyWord>
		<KeyWord name="ZeroDivisionError" func="yes">
			<Overload retVal="" descr="Second argument to a division or modulo operation was zero.">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipAppError" func="yes">
			<Overload retVal="" descr="Function of zipapp.ZipAppError">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipFile" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipInfo" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipManifests" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ZipManifests">
			</Overload>
		</KeyWord>
		<KeyWord name="ZipProvider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ZipProvider">
			</Overload>
		</KeyWord>
        		<KeyWord name="a2b_qp" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="a85decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="a85encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="abc" func="yes">
			<Overload retVal="" descr="Abstract Base Classes (ABCs) according to PEP 3119.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABC" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABCMeta" func="yes">
			<Overload retVal="" descr="Metaclass for defining Abstract Base Classes (ABCs).&#10;&#10;Use this metaclass to create an ABC.  An ABC can be subclassed&#10;directly, and then acts as a mix-in class.  You can also register&#10;unrelated concrete classes (even built-in classes) and unrelated&#10;ABCs as 'virtual subclasses' -- these and their descendants will&#10;be considered subclasses of the registering ABC by the built-in&#10;issubclass() function, but the registering ABC won't show up in&#10;their MRO (Method Resolution Order) nor will method&#10;implementations defined by the registering ABC be callable (not&#10;even via super()).">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABCMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.ABCMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.&#10;&#10;Returns the subclass, to allow usage as a class decorator.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
        <KeyWord name="abc.WeakSet" />
		<KeyWord name="abc.WeakSet.add" />
		<KeyWord name="abc.WeakSet.clear" />
		<KeyWord name="abc.WeakSet.copy" />
		<KeyWord name="abc.WeakSet.difference" />
		<KeyWord name="abc.WeakSet.difference_update" />
		<KeyWord name="abc.WeakSet.discard" />
		<KeyWord name="abc.WeakSet.intersection" />
		<KeyWord name="abc.WeakSet.intersection_update" />
		<KeyWord name="abc.WeakSet.isdisjoint" />
		<KeyWord name="abc.WeakSet.issubset" />
		<KeyWord name="abc.WeakSet.issuperset" />
		<KeyWord name="abc.WeakSet.pop" />
		<KeyWord name="abc.WeakSet.remove" />
		<KeyWord name="abc.WeakSet.symmetric_difference" />
		<KeyWord name="abc.WeakSet.symmetric_difference_update" />
		<KeyWord name="abc.WeakSet.union" />
		<KeyWord name="abc.WeakSet.update" />
		<KeyWord name="abc.abstractclassmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract classmethods.&#10;&#10;Similar to abstractmethod.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractclassmethod&#10;        def my_abstract_classmethod(cls, ...):&#10;            ...&#10;&#10;'abstractclassmethod' is deprecated. Use 'classmethod' with&#10;'abstractmethod' instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract methods.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract methods are overridden.&#10;The abstract methods can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractmethod&#10;        def my_abstract_method(self, ...):&#10;            ...">
				<Param name="funcobj" />
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract properties.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract properties are overridden.&#10;The abstract properties can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractproperty&#10;        def my_abstract_property(self):&#10;            ...&#10;&#10;This defines a read-only property; you can also define a read-write&#10;abstract property using the 'long' form of property declaration:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        def getx(self): ...&#10;        def setx(self, value): ...&#10;        x = abstractproperty(getx, setx)&#10;&#10;'abstractproperty' is deprecated. Use 'property' with 'abstractmethod'&#10;instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.deleter" func="yes">
			<Overload retVal="" descr="Descriptor to change the deleter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.fdel" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.fget" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.fset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.getter" func="yes">
			<Overload retVal="" descr="Descriptor to change the getter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractproperty.setter" func="yes">
			<Overload retVal="" descr="Descriptor to change the setter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.abstractstaticmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract staticmethods.&#10;&#10;Similar to abstractmethod.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractstaticmethod&#10;        def my_abstract_staticmethod(...):&#10;            ...&#10;&#10;'abstractstaticmethod' is deprecated. Use 'staticmethod' with&#10;'abstractmethod' instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="abc.get_cache_token" func="yes">
			<Overload retVal="" descr="Returns the current ABC cache token.&#10;&#10;The token is an opaque object (supporting equality testing) identifying the&#10;current version of the ABC cache for virtual subclasses. The token changes&#10;with every call to ``register()`` on any ABC.">
			</Overload>
		</KeyWord>
		<KeyWord name="abort" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="abs" func="yes">
			<Overload retVal="" descr="Return the absolute value of the argument.">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="abs_paths" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="absolute" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="abspath" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="abstractmethod" func="yes">
			<Overload retVal="" descr="Function of abc">
			</Overload>
		</KeyWord>
		<KeyWord name="abstractproperty" func="yes">
			<Overload retVal="" descr="Function of abc.abstractproperty">
			</Overload>
		</KeyWord>
		<KeyWord name="accept" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="accept_pipe" func="yes">
			<Overload retVal="" descr="Function of asyncio.IocpProactor">
			</Overload>
		</KeyWord>
		<KeyWord name="access" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="acct" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="aclose" func="yes">
			<Overload retVal="" descr="Function of types.AsyncGeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="acquire" func="yes">
			<Overload retVal="" descr="Function of asyncio.BoundedSemaphore">
			</Overload>
		</KeyWord>
		<KeyWord name="acquire_lock" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="activate" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="activeCount" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="active_children" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="active_count" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="adapt" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="add" func="yes">
			<Overload retVal="" descr="Add an element to a set.&#10;&#10;This has no effect if the element is already present.">
			</Overload>
		</KeyWord>
		<KeyWord name="addCleanup" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="addError" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addExpectedFailure" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addFailure" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addFilter" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="addHandler" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="addLevelName" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="addSkip" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addSubTest" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addSuccess" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="addTest" func="yes">
			<Overload retVal="" descr="Function of unittest.BaseTestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="addTests" func="yes">
			<Overload retVal="" descr="Function of unittest.BaseTestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="addUnexpectedSuccess" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="add_activation_listener" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="add_argument" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_argument_group" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_arguments" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_callers" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="add_channel" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="add_data" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="add_done_callback" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="add_entry" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.WorkingSet">
			</Overload>
		</KeyWord>
		<KeyWord name="add_extension" func="yes">
			<Overload retVal="" descr="Function of copyreg">
			</Overload>
		</KeyWord>
		<KeyWord name="add_fallback" func="yes">
			<Overload retVal="" descr="Function of gettext.GNUTranslations">
			</Overload>
		</KeyWord>
		<KeyWord name="add_field" func="yes">
			<Overload retVal="" descr="Function of msilib.Table">
			</Overload>
		</KeyWord>
		<KeyWord name="add_file" func="yes">
			<Overload retVal="" descr="Function of msilib.Directory">
			</Overload>
		</KeyWord>
		<KeyWord name="add_flag" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="add_flowing_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_folder" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="add_func_stats" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="add_header" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="add_hor_rule" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_label" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="add_label_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_line_break" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_literal_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_module" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="add_mutually_exclusive_group" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_option" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="add_option_group" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_options" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="add_reader" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="add_sequence" func="yes">
			<Overload retVal="" descr="Function of mailbox.MHMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="add_signal_handler" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="add_stream" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="add_subparsers" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="add_tables" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="add_text" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_type" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="add_usage" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="add_whitespace" func="yes">
			<Overload retVal="" descr="Function of tokenize.Untokenizer">
			</Overload>
		</KeyWord>
		<KeyWord name="add_writer" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="addfile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="addpackage" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="address_exclude" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="addressof" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="addsitedir" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="addsitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="addusersitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="adjusted" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc" func="yes">
			<Overload retVal="" descr="Stuff to parse AIFF-C and AIFF files.&#10;&#10;Unless explicitly stated otherwise, the description below is true&#10;both for AIFF-C files and AIFF files.&#10;&#10;An AIFF-C file has the following structure.&#10;&#10;  +-----------------+&#10;  | FORM            |&#10;  +-----------------+&#10;  | &lt;size&gt;          |&#10;  +----+------------+&#10;  |    | AIFC       |&#10;  |    +------------+&#10;  |    | &lt;chunks&gt;   |&#10;  |    |    .       |&#10;  |    |    .       |&#10;  |    |    .       |&#10;  +----+------------+&#10;&#10;An AIFF file has the string &quot;AIFF&quot; instead of &quot;AIFC&quot;.&#10;&#10;A chunk consists of an identifier (4 bytes) followed by a size (4 bytes,&#10;big endian order), followed by the data.  The size field does not include&#10;the size of the 8 byte header.&#10;&#10;The following chunk types are recognized.&#10;&#10;  FVER&#10;      &lt;version number of AIFF-C defining document&gt; (AIFF-C only).&#10;  MARK&#10;      &lt;# of markers&gt; (2 bytes)&#10;      list of markers:&#10;          &lt;marker ID&gt; (2 bytes, must be &gt; 0)&#10;          &lt;position&gt; (4 bytes)&#10;          &lt;marker name&gt; (&quot;pstring&quot;)&#10;  COMM&#10;      &lt;# of channels&gt; (2 bytes)&#10;      &lt;# of sound frames&gt; (4 bytes)&#10;      &lt;size of the samples&gt; (2 bytes)&#10;      &lt;sampling frequency&gt; (10 bytes, IEEE 80-bit extended&#10;          floating point)&#10;      in AIFF-C files only:&#10;      &lt;compression type&gt; (4 bytes)&#10;      &lt;human-readable version of compression type&gt; (&quot;pstring&quot;)&#10;  SSND&#10;      &lt;offset&gt; (4 bytes, not used by this program)&#10;      &lt;blocksize&gt; (4 bytes, not used by this program)&#10;      &lt;sound data&gt;&#10;&#10;A pstring consists of 1 byte length, a string of characters, and 0 or 1&#10;byte pad to make the total length even.&#10;&#10;Usage.&#10;&#10;Reading AIFF files:&#10;  f = aifc.open(file, 'r')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods read(), seek(), and close().&#10;In some types of audio files, if the setpos() method is not used,&#10;the seek() method is not necessary.&#10;&#10;This returns an instance of a class with the following public methods:&#10;  getnchannels()  -- returns number of audio channels (1 for&#10;             mono, 2 for stereo)&#10;  getsampwidth()  -- returns sample width in bytes&#10;  getframerate()  -- returns sampling frequency&#10;  getnframes()    -- returns number of audio frames&#10;  getcomptype()   -- returns compression type ('NONE' for AIFF files)&#10;  getcompname()   -- returns human-readable version of&#10;             compression type ('not compressed' for AIFF files)&#10;  getparams() -- returns a namedtuple consisting of all of the&#10;             above in the above order&#10;  getmarkers()    -- get the list of marks in the audio file or None&#10;             if there are no marks&#10;  getmark(id) -- get mark with the specified id (raises an error&#10;             if the mark does not exist)&#10;  readframes(n)   -- returns at most n frames of audio&#10;  rewind()    -- rewind to the beginning of the audio stream&#10;  setpos(pos) -- seek to the specified position&#10;  tell()      -- return the current position&#10;  close()     -- close the instance (make it unusable)&#10;The position returned by tell(), the position given to setpos() and&#10;the position of marks are all compatible and have nothing to do with&#10;the actual position in the file.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;Writing AIFF files:&#10;  f = aifc.open(file, 'w')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods write(), tell(), seek(), and&#10;close().&#10;&#10;This returns an instance of a class with the following public methods:&#10;  aiff()      -- create an AIFF file (AIFF-C default)&#10;  aifc()      -- create an AIFF-C file&#10;  setnchannels(n) -- set the number of channels&#10;  setsampwidth(n) -- set the sample width&#10;  setframerate(n) -- set the frame rate&#10;  setnframes(n)   -- set the number of frames&#10;  setcomptype(type, name)&#10;          -- set the compression type and the&#10;             human-readable compression type&#10;  setparams(tuple)&#10;          -- set all parameters at once&#10;  setmark(id, pos, name)&#10;          -- add specified mark to the list of marks&#10;  tell()      -- return current position in output file (useful&#10;             in combination with setmark())&#10;  writeframesraw(data)&#10;          -- write audio frames without pathing up the&#10;             file header&#10;  writeframes(data)&#10;          -- write audio frames and patch up the file header&#10;  close()     -- patch up the file header and close the&#10;             output file&#10;You should set the parameters before the first writeframesraw or&#10;writeframes.  The total number of frames does not need to be set,&#10;but when it is set to the correct value, the header does not have to&#10;be patched up.&#10;It is best to first set all parameters, perhaps possibly the&#10;compression type, and then write audio frames using writeframesraw.&#10;When all frames have been written, either call writeframes(b'') or&#10;close() to patch up the sizes in the header.&#10;Marks can be added anytime.  If there are any marks, you must call&#10;close() after all frames have been written.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;When a file is opened with the extension '.aiff', an AIFF file is&#10;written, otherwise an AIFF-C file is written.  This default can be&#10;changed by calling aiff() or aifc() before the first writeframes or&#10;writeframesraw.">
			</Overload>
		</KeyWord>
        		<KeyWord name="aifc.Aifc_read" />
		<KeyWord name="aifc.Aifc_read.close" />
		<KeyWord name="aifc.Aifc_read.getcompname" />
		<KeyWord name="aifc.Aifc_read.getcomptype" />
		<KeyWord name="aifc.Aifc_read.getfp" />
		<KeyWord name="aifc.Aifc_read.getframerate" />
		<KeyWord name="aifc.Aifc_read.getmark" />
		<KeyWord name="aifc.Aifc_read.getmarkers" />
		<KeyWord name="aifc.Aifc_read.getnchannels" />
		<KeyWord name="aifc.Aifc_read.getnframes" />
		<KeyWord name="aifc.Aifc_read.getparams" />
		<KeyWord name="aifc.Aifc_read.getsampwidth" />
		<KeyWord name="aifc.Aifc_read.initfp" />
		<KeyWord name="aifc.Aifc_read.readframes" />
		<KeyWord name="aifc.Aifc_read.rewind" />
		<KeyWord name="aifc.Aifc_read.setpos" />
		<KeyWord name="aifc.Aifc_read.tell" />
		<KeyWord name="aifc.Aifc_write" />
		<KeyWord name="aifc.Aifc_write.aifc" />
		<KeyWord name="aifc.Aifc_write.aiff" />
		<KeyWord name="aifc.Aifc_write.close" />
		<KeyWord name="aifc.Aifc_write.getcompname" />
		<KeyWord name="aifc.Aifc_write.getcomptype" />
		<KeyWord name="aifc.Aifc_write.getframerate" />
		<KeyWord name="aifc.Aifc_write.getmark" />
		<KeyWord name="aifc.Aifc_write.getmarkers" />
		<KeyWord name="aifc.Aifc_write.getnchannels" />
		<KeyWord name="aifc.Aifc_write.getnframes" />
		<KeyWord name="aifc.Aifc_write.getparams" />
		<KeyWord name="aifc.Aifc_write.getsampwidth" />
		<KeyWord name="aifc.Aifc_write.initfp" />
		<KeyWord name="aifc.Aifc_write.setcomptype" />
		<KeyWord name="aifc.Aifc_write.setframerate" />
		<KeyWord name="aifc.Aifc_write.setmark" />
		<KeyWord name="aifc.Aifc_write.setnchannels" />
		<KeyWord name="aifc.Aifc_write.setnframes" />
		<KeyWord name="aifc.Aifc_write.setparams" />
		<KeyWord name="aifc.Aifc_write.setsampwidth" />
		<KeyWord name="aifc.Aifc_write.tell" />
		<KeyWord name="aifc.Aifc_write.writeframes" />
		<KeyWord name="aifc.Aifc_write.writeframesraw" />
		<KeyWord name="aifc.Chunk" />
		<KeyWord name="aifc.Chunk.close" />
		<KeyWord name="aifc.Chunk.getname" func="yes">
			<Overload retVal="" descr="Return the name (ID) of the current chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Chunk.getsize" func="yes">
			<Overload retVal="" descr="Return the size of the current chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Chunk.isatty" />
		<KeyWord name="aifc.Chunk.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes from the chunk.&#10;If size is omitted or negative, read until the end&#10;of the chunk.">
				<Param name="self" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Chunk.seek" func="yes">
			<Overload retVal="" descr="Seek to specified position into the chunk.&#10;Default position is 0 (start of chunk).&#10;If the file is not seekable, this will result in an error.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Chunk.skip" func="yes">
			<Overload retVal="" descr="Skip the rest of the chunk.&#10;If you are not interested in the contents of the chunk,&#10;this method should be called so that the file points to&#10;the start of the next chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Chunk.tell" />
		<KeyWord name="aifc.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.open" func="yes">
			<Overload retVal="" descr="">
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="aifc.openfp" func="yes">
			<Overload retVal="" descr="">
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="aiff" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="alignment" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="all" func="yes">
			<Overload retVal="" descr="Return True if bool(x) is True for all values x in the iterable.&#10;&#10;If the iterable is empty, return True.">
				<Param name="iterable" />
			</Overload>
		</KeyWord>
		<KeyWord name="all_tasks" func="yes">
			<Overload retVal="" descr="Function of asyncio.Task">
			</Overload>
		</KeyWord>
		<KeyWord name="allmethods" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="allow_connection_pickling" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="and" />
		<KeyWord name="announce" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="antigravity" />
		<KeyWord name="antigravity.geohash" func="yes">
			<Overload retVal="" descr="Compute geohash() using the Munroe algorithm.&#10;&#10;&gt;&gt;&gt; geohash(37.421542, -122.085589, b'2005-05-26-10458.68')&#10;37.857713 -122.544543">
				<Param name="latitude" />
				<Param name="longitude" />
				<Param name="datedow" />
			</Overload>
		</KeyWord>
		<KeyWord name="any" func="yes">
			<Overload retVal="" descr="Return True if bool(x) is True for any x in the iterable.&#10;&#10;If the iterable is empty, return False.">
				<Param name="iterable" />
			</Overload>
		</KeyWord>
		<KeyWord name="any_missing" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="any_missing_maybe" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="apop" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="append" func="yes">
			<Overload retVal="" descr="L.append(object) -&gt; None -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="appendleft" func="yes">
			<Overload retVal="" descr="Function of asynchat.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="apply_defaults" func="yes">
			<Overload retVal="" descr="Function of inspect.BoundArguments">
			</Overload>
		</KeyWord>
		<KeyWord name="apropos" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="architecture" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse" func="yes">
			<Overload retVal="" descr="Command-line parsing library&#10;&#10;This module is an optparse-inspired command-line parsing library that:&#10;&#10;    - handles both optional and positional arguments&#10;    - produces highly informative usage messages&#10;    - supports parsers that dispatch to sub-parsers&#10;&#10;The following is a simple usage example that sums integers from the&#10;command-line and writes the result to a file::&#10;&#10;    parser = argparse.ArgumentParser(&#10;        description='sum the integers at the command line')&#10;    parser.add_argument(&#10;        'integers', metavar='int', nargs='+', type=int,&#10;        help='an integer to be summed')&#10;    parser.add_argument(&#10;        '--log', default=sys.stdout, type=argparse.FileType('w'),&#10;        help='the file where the sum should be written')&#10;    args = parser.parse_args()&#10;    args.log.write('%s' % sum(args.integers))&#10;    args.log.close()&#10;&#10;The module contains the following public classes:&#10;&#10;    - ArgumentParser -- The main entry point for command-line parsing. As the&#10;        example above shows, the add_argument() method is used to populate&#10;        the parser with actions for optional and positional arguments. Then&#10;        the parse_args() method is invoked to convert the args at the&#10;        command-line into an object with attributes.&#10;&#10;    - ArgumentError -- The exception raised by ArgumentParser objects when&#10;        there are errors with the parser's actions. Errors raised while&#10;        parsing the command-line are caught by ArgumentParser and emitted&#10;        as command-line messages.&#10;&#10;    - FileType -- A factory for defining types of files to be created. As the&#10;        example above shows, instances of FileType are typically passed as&#10;        the type= argument of add_argument() calls.&#10;&#10;    - Action -- The base class for parser actions. Typically actions are&#10;        selected by passing strings like 'store_true' or 'append_const' to&#10;        the action= argument of add_argument(). However, for greater&#10;        customization of ArgumentParser actions, subclasses of Action may&#10;        be defined and passed as the action= argument.&#10;&#10;    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,&#10;        ArgumentDefaultsHelpFormatter -- Formatter classes which&#10;        may be passed as the formatter_class= argument to the&#10;        ArgumentParser constructor. HelpFormatter is the default,&#10;        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser&#10;        not to change the formatting for help text, and&#10;        ArgumentDefaultsHelpFormatter adds information about argument defaults&#10;        to the help.&#10;&#10;All other classes in this module are considered implementation details.&#10;(Also note that HelpFormatter and RawDescriptionHelpFormatter are only&#10;considered public as object names -- the API of the formatter objects is&#10;still considered an implementation detail.)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.Action" func="yes">
			<Overload retVal="" descr="Information about how to convert command line strings to Python objects.&#10;&#10;Action objects are used by an ArgumentParser to represent the information&#10;needed to parse a single argument from one or more strings from the&#10;command line. The keyword arguments to the Action constructor are also&#10;all attributes of Action instances.&#10;&#10;Keyword Arguments:&#10;&#10;    - option_strings -- A list of command-line option strings which&#10;        should be associated with this action.&#10;&#10;    - dest -- The name of the attribute to hold the created object(s)&#10;&#10;    - nargs -- The number of command-line arguments that should be&#10;        consumed. By default, one argument will be consumed and a single&#10;        value will be produced.  Other values include:&#10;            - N (an integer) consumes N arguments (and produces a list)&#10;            - '?' consumes zero or one arguments&#10;            - '*' consumes zero or more arguments (and produces a list)&#10;            - '+' consumes one or more arguments (and produces a list)&#10;        Note that the difference between the default and nargs=1 is that&#10;        with the default, a single value will be produced, while with&#10;        nargs=1, a list containing a single value will be produced.&#10;&#10;    - const -- The value to be produced if the option is specified and the&#10;        option uses an action that takes no values.&#10;&#10;    - default -- The value to be produced if the option is not specified.&#10;&#10;    - type -- A callable that accepts a single string argument, and&#10;        returns the converted value.  The standard Python types str, int,&#10;        float, and complex are useful examples of such callables.  If None,&#10;        str is used.&#10;&#10;    - choices -- A container of values that should be allowed. If not None,&#10;        after a command-line argument has been converted to the appropriate&#10;        type, an exception will be raised if it is not a member of this&#10;        collection.&#10;&#10;    - required -- True if the action must always be specified at the&#10;        command line. This is only meaningful for optional command-line&#10;        arguments.&#10;&#10;    - help -- The help string describing the argument.&#10;&#10;    - metavar -- The name to be used for the option's argument with the&#10;        help string. If None, the 'dest' value will be used as the name.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which adds default values to argument help.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_argument" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_arguments" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_text" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.end_section" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.format_help" />
		<KeyWord name="argparse.ArgumentDefaultsHelpFormatter.start_section" />
		<KeyWord name="argparse.ArgumentError" func="yes">
			<Overload retVal="" descr="An error from creating or using an argument (optional or positional).&#10;&#10;The string value of this exception is the message, augmented with&#10;information about the argument that caused it.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser" func="yes">
			<Overload retVal="" descr="Object for parsing command line strings into Python objects.&#10;&#10;Keyword Arguments:&#10;    - prog -- The name of the program (default: sys.argv[0])&#10;    - usage -- A usage message (default: auto-generated from arguments)&#10;    - description -- A description of what the program does&#10;    - epilog -- Text following the argument descriptions&#10;    - parents -- Parsers whose arguments should be copied into this one&#10;    - formatter_class -- HelpFormatter class for printing help messages&#10;    - prefix_chars -- Characters that prefix optional arguments&#10;    - fromfile_prefix_chars -- Characters that prefix files containing&#10;        additional arguments&#10;    - argument_default -- The default value for all arguments&#10;    - conflict_handler -- String indicating how to handle conflicts&#10;    - add_help -- Add a -h/-help option&#10;    - allow_abbrev -- Allow long options to be abbreviated unambiguously">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_argument" func="yes">
			<Overload retVal="" descr="add_argument(dest, ..., name=value, ...)&#10;add_argument(option_string, option_string, ..., name=value, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_argument_group" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_mutually_exclusive_group" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.add_subparsers" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.convert_arg_line_to_args" />
		<KeyWord name="argparse.ArgumentParser.error" func="yes">
			<Overload retVal="" descr="error(message: string)&#10;&#10;Prints a usage message incorporating the message to stderr and&#10;exits.&#10;&#10;If you override this in a subclass, it should not return -- it&#10;should either exit or raise an exception.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.exit" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[status=0" />
				<Param name="[message=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.format_help" />
		<KeyWord name="argparse.ArgumentParser.format_usage" />
		<KeyWord name="argparse.ArgumentParser.get_default" />
		<KeyWord name="argparse.ArgumentParser.parse_args" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[namespace=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.parse_known_args" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[namespace=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.print_help" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.print_usage" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentParser.register" />
		<KeyWord name="argparse.ArgumentParser.set_defaults" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentTypeError" func="yes">
			<Overload retVal="" descr="An error from trying to convert a command line string to a type.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentTypeError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ArgumentTypeError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.FileType" func="yes">
			<Overload retVal="" descr="Factory for creating file object types&#10;&#10;Instances of FileType are typically passed as type= arguments to the&#10;ArgumentParser add_argument() method.&#10;&#10;Keyword Arguments:&#10;    - mode -- A string indicating how the file is to be opened. Accepts the&#10;        same values as the builtin open() function.&#10;    - bufsize -- The file's desired buffer size. Accepts the same values as&#10;        the builtin open() function.&#10;    - encoding -- The file's encoding. Accepts the same values as the&#10;        builtin open() function.&#10;    - errors -- A string indicating how encoding and decoding errors are to&#10;        be handled. Accepts the same value as the builtin open() function.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.HelpFormatter" func="yes">
			<Overload retVal="" descr="Formatter for generating usage messages and argument help strings.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.HelpFormatter.add_argument" />
		<KeyWord name="argparse.HelpFormatter.add_arguments" />
		<KeyWord name="argparse.HelpFormatter.add_text" />
		<KeyWord name="argparse.HelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.HelpFormatter.end_section" />
		<KeyWord name="argparse.HelpFormatter.format_help" />
		<KeyWord name="argparse.HelpFormatter.start_section" />
		<KeyWord name="argparse.MetavarTypeHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which uses the argument 'type' as the default&#10;metavar value (instead of the argument 'dest')&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.MetavarTypeHelpFormatter.add_argument" />
		<KeyWord name="argparse.MetavarTypeHelpFormatter.add_arguments" />
		<KeyWord name="argparse.MetavarTypeHelpFormatter.add_text" />
		<KeyWord name="argparse.MetavarTypeHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.MetavarTypeHelpFormatter.end_section" />
		<KeyWord name="argparse.MetavarTypeHelpFormatter.format_help" />
		<KeyWord name="argparse.MetavarTypeHelpFormatter.start_section" />
		<KeyWord name="argparse.Namespace" func="yes">
			<Overload retVal="" descr="Simple object for storing attributes.&#10;&#10;Implements equality by attribute names and values, and provides a simple&#10;string representation.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ONE_OR_MORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.OPTIONAL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.PARSER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.REMAINDER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawDescriptionHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which retains any formatting in descriptions.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_argument" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_arguments" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_text" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawDescriptionHelpFormatter.end_section" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.format_help" />
		<KeyWord name="argparse.RawDescriptionHelpFormatter.start_section" />
		<KeyWord name="argparse.RawTextHelpFormatter" func="yes">
			<Overload retVal="" descr="Help message formatter which retains formatting of all help text.&#10;&#10;Only the name of this class is considered a public API. All the methods&#10;provided by the class are considered an implementation detail.">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawTextHelpFormatter.add_argument" />
		<KeyWord name="argparse.RawTextHelpFormatter.add_arguments" />
		<KeyWord name="argparse.RawTextHelpFormatter.add_text" />
		<KeyWord name="argparse.RawTextHelpFormatter.add_usage" func="yes">
			<Overload retVal="" descr="">
				<Param name="self" />
				<Param name="usage" />
				<Param name="actions" />
				<Param name="groups" />
				<Param name="[prefix=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.RawTextHelpFormatter.end_section" />
		<KeyWord name="argparse.RawTextHelpFormatter.format_help" />
		<KeyWord name="argparse.RawTextHelpFormatter.start_section" />
		<KeyWord name="argparse.SUPPRESS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ZERO_OR_MORE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="argparse.ngettext" />
		<KeyWord name="article" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="as" />
		<KeyWord name="asBase64" func="yes">
			<Overload retVal="" descr="Function of plistlib.Data">
			</Overload>
		</KeyWord>
		<KeyWord name="as_bytes" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="as_completed" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="as_integer_ratio" func="yes">
			<Overload retVal="" descr="float.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;float and with a positive denominator.&#10;Raise OverflowError on infinities and a ValueError on NaNs.&#10;&#10;&gt;&gt;&gt; (10.0).as_integer_ratio()&#10;(10, 1)&#10;&gt;&gt;&gt; (0.0).as_integer_ratio()&#10;(0, 1)&#10;&gt;&gt;&gt; (-.25).as_integer_ratio()&#10;(-1, 4)">
			</Overload>
		</KeyWord>
		<KeyWord name="as_posix" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="as_requirement" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="as_string" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="as_tuple" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="as_uri" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="ascii" func="yes">
			<Overload retVal="" descr="Return an ASCII-only representation of an object.&#10;&#10;As repr(), return a string containing a printable representation of an&#10;object, but escape the non-ASCII characters in the string returned by&#10;repr() using \\x, \\u or \\U escapes. This generates a string similar&#10;to that returned by repr() in Python 2.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="ascii_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="ascii_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="asend" func="yes">
			<Overload retVal="" descr="Function of types.AsyncGeneratorType">
			</Overload>
		</KeyWord>
        		<KeyWord name="assert" />
		<KeyWord name="assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertAlmostEquals" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertCountEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertDictEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertEquals" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertFalse" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertGreater" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIn" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIs" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsInstance" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsNone" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsNot" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertIsNotNone" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertLess" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertLessEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertListEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertLogs" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotEquals" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotIn" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotRegex" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRaises" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRaisesRegex" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRaisesRegexp" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRegex" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertRegexpMatches" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertSequenceEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertSetEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertTrue" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertTupleEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertWarns" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assertWarnsRegex" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="assert_line_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="ast" func="yes">
			<Overload retVal="" descr="ast&#10;~~~&#10;&#10;The `ast` module helps Python applications to process trees of the Python&#10;abstract syntax grammar.  The abstract syntax itself might change with&#10;each Python release; this module helps to find out programmatically what&#10;the current grammar looks like and allows modifications of it.&#10;&#10;An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as&#10;a flag to the `compile()` builtin function or by using the `parse()`&#10;function from this module.  The result will be a tree of objects whose&#10;classes all inherit from `ast.AST`.&#10;&#10;A modified abstract syntax tree can be compiled into a Python code object&#10;using the built-in `compile()` function.&#10;&#10;Additionally various helper functions are provided that make working with&#10;the trees simpler.  The main intention of the helper functions and this&#10;module in general is to provide an easy to use interface for libraries&#10;that work tightly with the python syntax (template engines for example).&#10;&#10;&#10;:copyright: Copyright 2008 by Armin Ronacher.&#10;:license: Python License.">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.AST" />
		<KeyWord name="ast.Add" />
		<KeyWord name="ast.And" />
		<KeyWord name="ast.AnnAssign" />
		<KeyWord name="ast.Assert" />
		<KeyWord name="ast.Assign" />
		<KeyWord name="ast.AsyncFor" />
		<KeyWord name="ast.AsyncFunctionDef" />
		<KeyWord name="ast.AsyncWith" />
		<KeyWord name="ast.Attribute" />
		<KeyWord name="ast.AugAssign" />
		<KeyWord name="ast.AugLoad" />
		<KeyWord name="ast.AugStore" />
		<KeyWord name="ast.Await" />
		<KeyWord name="ast.BinOp" />
		<KeyWord name="ast.BitAnd" />
		<KeyWord name="ast.BitOr" />
		<KeyWord name="ast.BitXor" />
		<KeyWord name="ast.BoolOp" />
		<KeyWord name="ast.Break" />
		<KeyWord name="ast.Bytes" />
		<KeyWord name="ast.Call" />
		<KeyWord name="ast.ClassDef" />
		<KeyWord name="ast.Compare" />
		<KeyWord name="ast.Constant" />
		<KeyWord name="ast.Continue" />
		<KeyWord name="ast.Del" />
		<KeyWord name="ast.Delete" />
		<KeyWord name="ast.Dict" />
		<KeyWord name="ast.DictComp" />
		<KeyWord name="ast.Div" />
		<KeyWord name="ast.Ellipsis" />
		<KeyWord name="ast.Eq" />
		<KeyWord name="ast.ExceptHandler" />
		<KeyWord name="ast.Expr" />
		<KeyWord name="ast.Expression" />
		<KeyWord name="ast.ExtSlice" />
		<KeyWord name="ast.FloorDiv" />
		<KeyWord name="ast.For" />
		<KeyWord name="ast.FormattedValue" />
		<KeyWord name="ast.FunctionDef" />
		<KeyWord name="ast.GeneratorExp" />
		<KeyWord name="ast.Global" />
		<KeyWord name="ast.Gt" />
		<KeyWord name="ast.GtE" />
		<KeyWord name="ast.If" />
		<KeyWord name="ast.IfExp" />
		<KeyWord name="ast.Import" />
		<KeyWord name="ast.ImportFrom" />
		<KeyWord name="ast.In" />
		<KeyWord name="ast.Index" />
		<KeyWord name="ast.Interactive" />
		<KeyWord name="ast.Invert" />
		<KeyWord name="ast.Is" />
		<KeyWord name="ast.IsNot" />
		<KeyWord name="ast.JoinedStr" />
		<KeyWord name="ast.LShift" />
		<KeyWord name="ast.Lambda" />
		<KeyWord name="ast.List" />
		<KeyWord name="ast.ListComp" />
		<KeyWord name="ast.Load" />
		<KeyWord name="ast.Lt" />
		<KeyWord name="ast.LtE" />
		<KeyWord name="ast.MatMult" />
		<KeyWord name="ast.Mod" />
		<KeyWord name="ast.Module" />
		<KeyWord name="ast.Mult" />
		<KeyWord name="ast.Name" />
		<KeyWord name="ast.NameConstant" />
		<KeyWord name="ast.NodeTransformer" func="yes">
			<Overload retVal="" descr="A :class:`NodeVisitor` subclass that walks the abstract syntax tree and&#10;allows modification of nodes.&#10;&#10;The `NodeTransformer` will walk the AST and use the return value of the&#10;visitor methods to replace or remove the old node.  If the return value of&#10;the visitor method is ``None``, the node will be removed from its location,&#10;otherwise it is replaced with the return value.  The return value may be the&#10;original node in which case no replacement takes place.&#10;&#10;Here is an example transformer that rewrites all occurrences of name lookups&#10;(``foo``) to ``data['foo']``::&#10;&#10;   class RewriteName(NodeTransformer):&#10;&#10;       def visit_Name(self, node):&#10;           return copy_location(Subscript(&#10;               value=Name(id='data', ctx=Load()),&#10;               slice=Index(value=Str(s=node.id)),&#10;               ctx=node.ctx&#10;           ), node)&#10;&#10;Keep in mind that if the node you're operating on has child nodes you must&#10;either transform the child nodes yourself or call the :meth:`generic_visit`&#10;method for the node first.&#10;&#10;For nodes that were part of a collection of statements (that applies to all&#10;statement nodes), the visitor may also return a list of nodes rather than&#10;just a single node.&#10;&#10;Usually you use the transformer like this::&#10;&#10;   node = YourTransformer().visit(node)">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeTransformer.generic_visit" func="yes">
			<Overload retVal="" descr="Called if no explicit visitor function exists for a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeTransformer.visit" func="yes">
			<Overload retVal="" descr="Visit a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeVisitor" func="yes">
			<Overload retVal="" descr="A node visitor base class that walks the abstract syntax tree and calls a&#10;visitor function for every node found.  This function may return a value&#10;which is forwarded by the `visit` method.&#10;&#10;This class is meant to be subclassed, with the subclass adding visitor&#10;methods.&#10;&#10;Per default the visitor functions for the nodes are ``'visit_'`` +&#10;class name of the node.  So a `TryFinally` node visit function would&#10;be `visit_TryFinally`.  This behavior can be changed by overriding&#10;the `visit` method.  If no visitor function exists for a node&#10;(return value `None`) the `generic_visit` visitor is used instead.&#10;&#10;Don't use the `NodeVisitor` if you want to apply changes to nodes during&#10;traversing.  For this a special visitor exists (`NodeTransformer`) that&#10;allows modifications.">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeVisitor.generic_visit" func="yes">
			<Overload retVal="" descr="Called if no explicit visitor function exists for a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.NodeVisitor.visit" func="yes">
			<Overload retVal="" descr="Visit a node.">
				<Param name="self" />
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.Nonlocal" />
		<KeyWord name="ast.Not" />
		<KeyWord name="ast.NotEq" />
		<KeyWord name="ast.NotIn" />
		<KeyWord name="ast.Num" />
		<KeyWord name="ast.Or" />
		<KeyWord name="ast.Param" />
		<KeyWord name="ast.Pass" />
		<KeyWord name="ast.Pow" />
		<KeyWord name="ast.PyCF_ONLY_AST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ast.RShift" />
		<KeyWord name="ast.Raise" />
		<KeyWord name="ast.Return" />
		<KeyWord name="ast.Set" />
		<KeyWord name="ast.SetComp" />
		<KeyWord name="ast.Slice" />
		<KeyWord name="ast.Starred" />
		<KeyWord name="ast.Store" />
		<KeyWord name="ast.Str" />
		<KeyWord name="ast.Sub" />
		<KeyWord name="ast.Subscript" />
		<KeyWord name="ast.Suite" />
		<KeyWord name="ast.Try" />
		<KeyWord name="ast.Tuple" />
		<KeyWord name="ast.UAdd" />
		<KeyWord name="ast.USub" />
		<KeyWord name="ast.UnaryOp" />
		<KeyWord name="ast.While" />
		<KeyWord name="ast.With" />
		<KeyWord name="ast.Yield" />
		<KeyWord name="ast.YieldFrom" />
		<KeyWord name="ast.alias" />
		<KeyWord name="ast.arg" />
		<KeyWord name="ast.arguments" />
		<KeyWord name="ast.boolop" />
		<KeyWord name="ast.cmpop" />
		<KeyWord name="ast.comprehension" />
		<KeyWord name="ast.copy_location" func="yes">
			<Overload retVal="" descr="Copy source location (`lineno` and `col_offset` attributes) from&#10;*old_node* to *new_node* if possible, and return *new_node*.">
				<Param name="new_node" />
				<Param name="old_node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.dump" func="yes">
			<Overload retVal="" descr="Return a formatted dump of the tree in *node*.  This is mainly useful for&#10;debugging purposes.  The returned string will show the names and the values&#10;for fields.  This makes the code impossible to evaluate, so if evaluation is&#10;wanted *annotate_fields* must be set to False.  Attributes such as line&#10;numbers and column offsets are not dumped by default.  If this is wanted,&#10;*include_attributes* can be set to True.">
				<Param name="node" />
				<Param name="[annotate_fields=True" />
				<Param name="[include_attributes=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.excepthandler" />
		<KeyWord name="ast.expr" />
		<KeyWord name="ast.expr_context" />
		<KeyWord name="ast.fix_missing_locations" func="yes">
			<Overload retVal="" descr="When you compile a node tree with compile(), the compiler expects lineno and&#10;col_offset attributes for every node that supports them.  This is rather&#10;tedious to fill in for generated nodes, so this helper adds these attributes&#10;recursively where not already set, by setting them to the values of the&#10;parent node.  It works recursively starting at *node*.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.get_docstring" func="yes">
			<Overload retVal="" descr="Return the docstring for the given node or None if no docstring can&#10;be found.  If the node provided does not have docstrings a TypeError&#10;will be raised.">
				<Param name="node" />
				<Param name="[clean=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.increment_lineno" func="yes">
			<Overload retVal="" descr='Increment the line number of each node in the tree starting at *node* by *n*.&#10;This is useful to "move code" to a different location in a file.'>
				<Param name="node" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.iter_child_nodes" func="yes">
			<Overload retVal="" descr="Yield all direct child nodes of *node*, that is, all fields that are nodes&#10;and all items of fields that are lists of nodes.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.iter_fields" func="yes">
			<Overload retVal="" descr="Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``&#10;that is present on *node*.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.keyword" />
		<KeyWord name="ast.literal_eval" func="yes">
			<Overload retVal="" descr="Safely evaluate an expression node or a string containing a Python&#10;expression.  The string or node provided may only consist of the following&#10;Python literal structures: strings, bytes, numbers, tuples, lists, dicts,&#10;sets, booleans, and None.">
				<Param name="node_or_string" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.mod" />
		<KeyWord name="ast.operator" />
		<KeyWord name="ast.parse" func="yes">
			<Overload retVal="" descr="Parse the source into an AST node.&#10;Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).">
				<Param name="source" />
				<Param name="[filename=<unknown>" />
				<Param name="[mode=exec]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.slice" />
		<KeyWord name="ast.stmt" />
		<KeyWord name="ast.unaryop" />
		<KeyWord name="ast.walk" func="yes">
			<Overload retVal="" descr="Recursively yield all descendant nodes in the tree starting at *node*&#10;(including *node* itself), in no specified order.  This is useful if you&#10;only want to modify nodes in place and don't care about the context.">
				<Param name="node" />
			</Overload>
		</KeyWord>
		<KeyWord name="ast.withitem" />
		<KeyWord name="astimezone" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
        		<KeyWord name="async" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="async_chat" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat" func="yes">
			<Overload retVal="" descr="A class supporting chat-style (command/response) protocols.&#10;&#10;This class adds support for 'chat' style protocols - where one side&#10;sends a 'command', and the other sends a response (examples would be&#10;the common internet protocols - smtp, nntp, ftp, etc..).&#10;&#10;The handle_read() method looks at the input stream for the current&#10;'terminator' (usually '\r\n' for single-line responses, '\r\n.\r\n'&#10;for multi-line output), calling self.found_terminator() on its&#10;receipt.&#10;&#10;for example:&#10;Say you build an async nntp client using this class.  At the start&#10;of the connection, you'll have self.terminator set to '\r\n', in&#10;order to process the single-line greeting.  Just before issuing a&#10;'LIST' command you'll set it to '\r\n.\r\n'.  The output of the LIST&#10;command will be accumulated (using your own 'collect_incoming_data'&#10;method) up to the terminator, and then control will be returned to&#10;you - by calling your self.found_terminator() method.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat" func="yes">
			<Overload retVal="" descr="This is an abstract class.  You must derive from this class, and add&#10;the two methods collect_incoming_data() and found_terminator()">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.ac_in_buffer_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.ac_out_buffer_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.accept" />
		<KeyWord name="asynchat.async_chat.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.bind" />
		<KeyWord name="asynchat.async_chat.close" />
		<KeyWord name="asynchat.async_chat.close_when_done" func="yes">
			<Overload retVal="" descr="automatically close this channel once the outgoing queue is empty">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.collect_incoming_data" />
		<KeyWord name="asynchat.async_chat.connect" />
		<KeyWord name="asynchat.async_chat.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.discard_buffers" />
		<KeyWord name="asynchat.async_chat.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.found_terminator" />
		<KeyWord name="asynchat.async_chat.get_terminator" />
		<KeyWord name="asynchat.async_chat.handle_accept" />
		<KeyWord name="asynchat.async_chat.handle_accepted" />
		<KeyWord name="asynchat.async_chat.handle_close" />
		<KeyWord name="asynchat.async_chat.handle_connect" />
		<KeyWord name="asynchat.async_chat.handle_connect_event" />
		<KeyWord name="asynchat.async_chat.handle_error" />
		<KeyWord name="asynchat.async_chat.handle_expt" />
		<KeyWord name="asynchat.async_chat.handle_expt_event" />
		<KeyWord name="asynchat.async_chat.handle_read" />
		<KeyWord name="asynchat.async_chat.handle_read_event" />
		<KeyWord name="asynchat.async_chat.handle_write" />
		<KeyWord name="asynchat.async_chat.handle_write_event" />
		<KeyWord name="asynchat.async_chat.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.initiate_send" />
		<KeyWord name="asynchat.async_chat.listen" />
		<KeyWord name="asynchat.async_chat.log" />
		<KeyWord name="asynchat.async_chat.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.push" />
		<KeyWord name="asynchat.async_chat.push_with_producer" />
		<KeyWord name="asynchat.async_chat.readable" func="yes">
			<Overload retVal="" descr="predicate for inclusion in the readable for select()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.recv" />
		<KeyWord name="asynchat.async_chat.send" />
		<KeyWord name="asynchat.async_chat.set_reuse_addr" />
		<KeyWord name="asynchat.async_chat.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.set_terminator" func="yes">
			<Overload retVal="" descr="Set the input delimiter.&#10;&#10;Can be a fixed string of any length, an integer, or None.">
				<Param name="self" />
				<Param name="term" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.async_chat.writable" func="yes">
			<Overload retVal="" descr="predicate for inclusion in the writable for select()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;A list-like sequence optimized for data accesses near its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.index" func="yes">
			<Overload retVal="" descr="D.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.insert" func="yes">
			<Overload retVal="" descr="D.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="asynchat.find_prefix_at_end" />
		<KeyWord name="asynchat.simple_producer" />
		<KeyWord name="asynchat.simple_producer.more" />
		<KeyWord name="asyncio" func="yes">
			<Overload retVal="" descr="The asyncio package, tracking PEP 3156.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ALL_COMPLETED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop" func="yes">
			<Overload retVal="" descr="Abstract event loop.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.add_reader" />
		<KeyWord name="asyncio.AbstractEventLoop.add_signal_handler" />
		<KeyWord name="asyncio.AbstractEventLoop.add_writer" />
		<KeyWord name="asyncio.AbstractEventLoop.call_at" />
		<KeyWord name="asyncio.AbstractEventLoop.call_exception_handler" />
		<KeyWord name="asyncio.AbstractEventLoop.call_later" />
		<KeyWord name="asyncio.AbstractEventLoop.call_soon" />
		<KeyWord name="asyncio.AbstractEventLoop.call_soon_threadsafe" />
		<KeyWord name="asyncio.AbstractEventLoop.close" func="yes">
			<Overload retVal="" descr="Close the loop.&#10;&#10;The loop should not be running.&#10;&#10;This is idempotent and irreversible.&#10;&#10;No other methods should be called after this one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.connect_read_pipe" func="yes">
			<Overload retVal="" descr="Register read pipe in event loop. Set the pipe to non-blocking mode.&#10;&#10;protocol_factory should instantiate object with Protocol interface.&#10;pipe is a file-like object.&#10;Return pair (transport, protocol), where transport supports the&#10;ReadTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.connect_write_pipe" func="yes">
			<Overload retVal="" descr="Register write pipe in event loop.&#10;&#10;protocol_factory should instantiate object with BaseProtocol interface.&#10;Pipe is file-like object already switched to nonblocking.&#10;Return pair (transport, protocol), where transport support&#10;WriteTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.create_connection" />
		<KeyWord name="asyncio.AbstractEventLoop.create_datagram_endpoint" func="yes">
			<Overload retVal="" descr="A coroutine which creates a datagram endpoint.&#10;&#10;This method will try to establish the endpoint in the background.&#10;When successful, the coroutine returns a (transport, protocol) pair.&#10;&#10;protocol_factory must be a callable returning a protocol instance.&#10;&#10;socket family AF_INET or socket.AF_INET6 depending on host (or&#10;family if specified), socket type SOCK_DGRAM.&#10;&#10;reuse_address tells the kernel to reuse a local socket in&#10;TIME_WAIT state, without waiting for its natural timeout to&#10;expire. If not specified it will automatically be set to True on&#10;UNIX.&#10;&#10;reuse_port tells the kernel to allow this endpoint to be bound to&#10;the same port as other existing endpoints are bound to, so long as&#10;they all set this flag when being created. This option is not&#10;supported on Windows and some UNIX's. If the&#10;:py:data:`~socket.SO_REUSEPORT` constant is not defined then this&#10;capability is unsupported.&#10;&#10;allow_broadcast tells the kernel to allow this endpoint to send&#10;messages to the broadcast address.&#10;&#10;sock can optionally be specified in order to use a preexisting&#10;socket object.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.create_future" />
		<KeyWord name="asyncio.AbstractEventLoop.create_server" func="yes">
			<Overload retVal="" descr="A coroutine which creates a TCP server bound to host and port.&#10;&#10;The return value is a Server object which can be used to stop&#10;the service.&#10;&#10;If host is an empty string or None all interfaces are assumed&#10;and a list of multiple sockets will be returned (most likely&#10;one for IPv4 and another one for IPv6). The host parameter can also be a&#10;sequence (e.g. list) of hosts to bind to.&#10;&#10;family can be set to either AF_INET or AF_INET6 to force the&#10;socket to use IPv4 or IPv6. If not set it will be determined&#10;from host (defaults to AF_UNSPEC).&#10;&#10;flags is a bitmask for getaddrinfo().&#10;&#10;sock can optionally be specified in order to use a preexisting&#10;socket object.&#10;&#10;backlog is the maximum number of queued connections passed to&#10;listen() (defaults to 100).&#10;&#10;ssl can be set to an SSLContext to enable SSL over the&#10;accepted connections.&#10;&#10;reuse_address tells the kernel to reuse a local socket in&#10;TIME_WAIT state, without waiting for its natural timeout to&#10;expire. If not specified will automatically be set to True on&#10;UNIX.&#10;&#10;reuse_port tells the kernel to allow this endpoint to be bound to&#10;the same port as other existing endpoints are bound to, so long as&#10;they all set this flag when being created. This option is not&#10;supported on Windows.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.create_task" />
		<KeyWord name="asyncio.AbstractEventLoop.create_unix_connection" />
		<KeyWord name="asyncio.AbstractEventLoop.create_unix_server" func="yes">
			<Overload retVal="" descr="A coroutine which creates a UNIX Domain Socket server.&#10;&#10;The return value is a Server object, which can be used to stop&#10;the service.&#10;&#10;path is a str, representing a file systsem path to bind the&#10;server socket to.&#10;&#10;sock can optionally be specified in order to use a preexisting&#10;socket object.&#10;&#10;backlog is the maximum number of queued connections passed to&#10;listen() (defaults to 100).&#10;&#10;ssl can be set to an SSLContext to enable SSL over the&#10;accepted connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.default_exception_handler" />
		<KeyWord name="asyncio.AbstractEventLoop.get_debug" />
		<KeyWord name="asyncio.AbstractEventLoop.get_exception_handler" />
		<KeyWord name="asyncio.AbstractEventLoop.get_task_factory" />
		<KeyWord name="asyncio.AbstractEventLoop.getaddrinfo" />
		<KeyWord name="asyncio.AbstractEventLoop.getnameinfo" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sockaddr" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.is_closed" func="yes">
			<Overload retVal="" descr="Returns True if the event loop was closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.is_running" func="yes">
			<Overload retVal="" descr="Return whether the event loop is currently running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.remove_reader" />
		<KeyWord name="asyncio.AbstractEventLoop.remove_signal_handler" />
		<KeyWord name="asyncio.AbstractEventLoop.remove_writer" />
		<KeyWord name="asyncio.AbstractEventLoop.run_forever" func="yes">
			<Overload retVal="" descr="Run the event loop until stop() is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.run_in_executor" />
		<KeyWord name="asyncio.AbstractEventLoop.run_until_complete" func="yes">
			<Overload retVal="" descr="Run the event loop until a Future is done.&#10;&#10;Return the Future's result, or raise its exception.">
				<Param name="self" />
				<Param name="future" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.set_debug" />
		<KeyWord name="asyncio.AbstractEventLoop.set_default_executor" />
		<KeyWord name="asyncio.AbstractEventLoop.set_exception_handler" />
		<KeyWord name="asyncio.AbstractEventLoop.set_task_factory" />
		<KeyWord name="asyncio.AbstractEventLoop.shutdown_asyncgens" func="yes">
			<Overload retVal="" descr="Shutdown all active asynchronous generators.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.sock_accept" />
		<KeyWord name="asyncio.AbstractEventLoop.sock_connect" />
		<KeyWord name="asyncio.AbstractEventLoop.sock_recv" />
		<KeyWord name="asyncio.AbstractEventLoop.sock_sendall" />
		<KeyWord name="asyncio.AbstractEventLoop.stop" func="yes">
			<Overload retVal="" descr="Stop the event loop as soon as reasonable.&#10;&#10;Exactly how soon that is may depend on the implementation, but&#10;no more I/O callbacks should be scheduled.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoop.subprocess_exec" />
		<KeyWord name="asyncio.AbstractEventLoop.subprocess_shell" />
		<KeyWord name="asyncio.AbstractEventLoop.time" />
		<KeyWord name="asyncio.AbstractEventLoopPolicy" func="yes">
			<Overload retVal="" descr="Abstract policy for accessing the event loop.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoopPolicy.get_child_watcher" func="yes">
			<Overload retVal="" descr="Get the watcher for child processes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoopPolicy.get_event_loop" func="yes">
			<Overload retVal="" descr="Get the event loop for the current context.&#10;&#10;Returns an event loop object implementing the BaseEventLoop interface,&#10;or raises an exception in case no event loop has been set for the&#10;current context and the current policy does not specify to create one.&#10;&#10;It should never return None.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoopPolicy.new_event_loop" func="yes">
			<Overload retVal="" descr="Create and return a new event loop object according to this&#10;policy's rules. If there's need to set this loop as the event loop for&#10;the current context, set_event_loop must be called explicitly.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoopPolicy.set_child_watcher" func="yes">
			<Overload retVal="" descr="Set the watcher for child processes.">
				<Param name="self" />
				<Param name="watcher" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractEventLoopPolicy.set_event_loop" func="yes">
			<Overload retVal="" descr="Set the event loop for the current context to loop.">
				<Param name="self" />
				<Param name="loop" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractServer" func="yes">
			<Overload retVal="" descr="Abstract server returned by create_server().">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractServer.close" func="yes">
			<Overload retVal="" descr="Stop serving.  This leaves existing connections open.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.AbstractServer.wait_closed" func="yes">
			<Overload retVal="" descr="Coroutine to wait until service is closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop" func="yes">
			<Overload retVal="" descr="Abstract event loop.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.add_reader" />
		<KeyWord name="asyncio.BaseEventLoop.add_signal_handler" />
		<KeyWord name="asyncio.BaseEventLoop.add_writer" />
		<KeyWord name="asyncio.BaseEventLoop.call_at" func="yes">
			<Overload retVal="" descr="Like call_later(), but uses an absolute time.&#10;&#10;Absolute time corresponds to the event loop's time() method.">
				<Param name="self" />
				<Param name="when" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.call_exception_handler" func="yes">
			<Overload retVal="" descr="Call the current event loop's exception handler.&#10;&#10;The context argument is a dict containing the following keys:&#10;&#10;- 'message': Error message;&#10;- 'exception' (optional): Exception object;&#10;- 'future' (optional): Future instance;&#10;- 'handle' (optional): Handle instance;&#10;- 'protocol' (optional): Protocol instance;&#10;- 'transport' (optional): Transport instance;&#10;- 'socket' (optional): Socket instance;&#10;- 'asyncgen' (optional): Asynchronous generator that caused&#10;                         the exception.&#10;&#10;New keys maybe introduced in the future.&#10;&#10;Note: do not overload this method in an event loop subclass.&#10;For custom exception handling, use the&#10;`set_exception_handler()` method.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.call_later" func="yes">
			<Overload retVal="" descr="Arrange for a callback to be called at a given time.&#10;&#10;Return a Handle: an opaque object with a cancel() method that&#10;can be used to cancel the call.&#10;&#10;The delay can be an int or float, expressed in seconds.  It is&#10;always relative to the current time.&#10;&#10;Each callback will be called exactly once.  If two callbacks&#10;are scheduled for exactly the same time, it undefined which&#10;will be called first.&#10;&#10;Any positional arguments after the callback will be passed to&#10;the callback when it is called.">
				<Param name="self" />
				<Param name="delay" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.call_soon" func="yes">
			<Overload retVal="" descr="Arrange for a callback to be called as soon as possible.&#10;&#10;This operates as a FIFO queue: callbacks are called in the&#10;order in which they are registered.  Each callback will be&#10;called exactly once.&#10;&#10;Any positional arguments after the callback will be passed to&#10;the callback when it is called.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.call_soon_threadsafe" func="yes">
			<Overload retVal="" descr="Like call_soon(), but thread-safe.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.close" func="yes">
			<Overload retVal="" descr="Close the event loop.&#10;&#10;This clears the queues and shuts down the executor,&#10;but does not wait for the executor to finish.&#10;&#10;The event loop must not be running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.connect_accepted_socket" func="yes">
			<Overload retVal="" descr="Handle an accepted connection.&#10;&#10;This is used by servers that accept connections outside of&#10;asyncio but that use asyncio to handle connections.&#10;&#10;This method is a coroutine.  When completed, the coroutine&#10;returns a (transport, protocol) pair.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.connect_read_pipe" func="yes">
			<Overload retVal="" descr="Register read pipe in event loop. Set the pipe to non-blocking mode.&#10;&#10;protocol_factory should instantiate object with Protocol interface.&#10;pipe is a file-like object.&#10;Return pair (transport, protocol), where transport supports the&#10;ReadTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.connect_write_pipe" func="yes">
			<Overload retVal="" descr="Register write pipe in event loop.&#10;&#10;protocol_factory should instantiate object with BaseProtocol interface.&#10;Pipe is file-like object already switched to nonblocking.&#10;Return pair (transport, protocol), where transport support&#10;WriteTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.create_connection" func="yes">
			<Overload retVal="" descr="Connect to a TCP server.&#10;&#10;Create a streaming transport connection to a given Internet host and&#10;port: socket family AF_INET or socket.AF_INET6 depending on host (or&#10;family if specified), socket type SOCK_STREAM. protocol_factory must be&#10;a callable returning a protocol instance.&#10;&#10;This method is a coroutine which will try to establish the connection&#10;in the background.  When successful, the coroutine returns a&#10;(transport, protocol) pair.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.create_datagram_endpoint" func="yes">
			<Overload retVal="" descr="Create datagram connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.create_future" func="yes">
			<Overload retVal="" descr="Create a Future object attached to the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.create_server" func="yes">
			<Overload retVal="" descr="Create a TCP server.&#10;&#10;The host parameter can be a string, in that case the TCP server is bound&#10;to host and port.&#10;&#10;The host parameter can also be a sequence of strings and in that case&#10;the TCP server is bound to all hosts of the sequence. If a host&#10;appears multiple times (possibly indirectly e.g. when hostnames&#10;resolve to the same IP address), the server is only bound once to that&#10;host.&#10;&#10;Return a Server object which can be used to stop the service.&#10;&#10;This method is a coroutine.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.create_task" func="yes">
			<Overload retVal="" descr="Schedule a coroutine object.&#10;&#10;Return a task object.">
				<Param name="self" />
				<Param name="coro" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.create_unix_connection" />
		<KeyWord name="asyncio.BaseEventLoop.create_unix_server" func="yes">
			<Overload retVal="" descr="A coroutine which creates a UNIX Domain Socket server.&#10;&#10;The return value is a Server object, which can be used to stop&#10;the service.&#10;&#10;path is a str, representing a file systsem path to bind the&#10;server socket to.&#10;&#10;sock can optionally be specified in order to use a preexisting&#10;socket object.&#10;&#10;backlog is the maximum number of queued connections passed to&#10;listen() (defaults to 100).&#10;&#10;ssl can be set to an SSLContext to enable SSL over the&#10;accepted connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.default_exception_handler" func="yes">
			<Overload retVal="" descr="Default exception handler.&#10;&#10;This is called when an exception occurs and no exception&#10;handler is set, and can be called by a custom exception&#10;handler that wants to defer to the default behavior.&#10;&#10;This default handler logs the error message and other&#10;context-dependent information.  In debug mode, a truncated&#10;stack trace is also appended showing where the given object&#10;(e.g. a handle or future or task) was created, if any.&#10;&#10;The context parameter has the same meaning as in&#10;`call_exception_handler()`.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.get_debug" />
		<KeyWord name="asyncio.BaseEventLoop.get_exception_handler" func="yes">
			<Overload retVal="" descr="Return an exception handler, or None if the default one is in use.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.get_task_factory" func="yes">
			<Overload retVal="" descr="Return a task factory, or None if the default one is in use.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.getaddrinfo" />
		<KeyWord name="asyncio.BaseEventLoop.getnameinfo" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sockaddr" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.is_closed" func="yes">
			<Overload retVal="" descr="Returns True if the event loop was closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.is_running" func="yes">
			<Overload retVal="" descr="Returns True if the event loop is running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.remove_reader" />
		<KeyWord name="asyncio.BaseEventLoop.remove_signal_handler" />
		<KeyWord name="asyncio.BaseEventLoop.remove_writer" />
		<KeyWord name="asyncio.BaseEventLoop.run_forever" func="yes">
			<Overload retVal="" descr="Run until stop() is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.run_in_executor" />
		<KeyWord name="asyncio.BaseEventLoop.run_until_complete" func="yes">
			<Overload retVal="" descr="Run until the Future is done.&#10;&#10;If the argument is a coroutine, it is wrapped in a Task.&#10;&#10;WARNING: It would be disastrous to call run_until_complete()&#10;with the same coroutine twice -- it would wrap it in two&#10;different Tasks and that can't be good.&#10;&#10;Return the Future's result, or raise its exception.">
				<Param name="self" />
				<Param name="future" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.set_debug" />
		<KeyWord name="asyncio.BaseEventLoop.set_default_executor" />
		<KeyWord name="asyncio.BaseEventLoop.set_exception_handler" func="yes">
			<Overload retVal="" descr="Set handler as the new event loop exception handler.&#10;&#10;If handler is None, the default exception handler will&#10;be set.&#10;&#10;If handler is a callable object, it should have a&#10;signature matching '(loop, context)', where 'loop'&#10;will be a reference to the active event loop, 'context'&#10;will be a dict object (see `call_exception_handler()`&#10;documentation for details about context).">
				<Param name="self" />
				<Param name="handler" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.set_task_factory" func="yes">
			<Overload retVal="" descr="Set a task factory that will be used by loop.create_task().&#10;&#10;If factory is None the default task factory will be set.&#10;&#10;If factory is a callable, it should have a signature matching&#10;'(loop, coro)', where 'loop' will be a reference to the active&#10;event loop, 'coro' will be a coroutine object.  The callable&#10;must return a Future.">
				<Param name="self" />
				<Param name="factory" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.shutdown_asyncgens" func="yes">
			<Overload retVal="" descr="Shutdown all active asynchronous generators.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.sock_accept" />
		<KeyWord name="asyncio.BaseEventLoop.sock_connect" />
		<KeyWord name="asyncio.BaseEventLoop.sock_recv" />
		<KeyWord name="asyncio.BaseEventLoop.sock_sendall" />
		<KeyWord name="asyncio.BaseEventLoop.stop" func="yes">
			<Overload retVal="" descr="Stop running the event loop.&#10;&#10;Every callback already scheduled will still run.  This simply informs&#10;run_forever to stop looping after a complete iteration.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseEventLoop.subprocess_exec" />
		<KeyWord name="asyncio.BaseEventLoop.subprocess_shell" />
		<KeyWord name="asyncio.BaseEventLoop.time" func="yes">
			<Overload retVal="" descr="Return the time according to the event loop's clock.&#10;&#10;This is a float expressed in seconds since an epoch, but the&#10;epoch, precision, accuracy and drift are unspecified and may&#10;differ per event loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseProtocol" func="yes">
			<Overload retVal="" descr="Common base class for protocol interfaces.&#10;&#10;Usually user implements protocols that derived from BaseProtocol&#10;like Protocol or ProcessProtocol.&#10;&#10;The only case when BaseProtocol should be implemented directly is&#10;write-only transport like write pipe">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseProtocol.connection_lost" func="yes">
			<Overload retVal="" descr="Called when the connection is lost or closed.&#10;&#10;The argument is an exception object or None (the latter&#10;meaning a regular EOF is received or the connection was&#10;aborted or closed).">
				<Param name="self" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseProtocol.connection_made" func="yes">
			<Overload retVal="" descr="Called when a connection is made.&#10;&#10;The argument is the transport representing the pipe connection.&#10;To receive data, wait for data_received() calls.&#10;When the connection is closed, connection_lost() is called.">
				<Param name="self" />
				<Param name="transport" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseProtocol.pause_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer goes over the high-water mark.&#10;&#10;Pause and resume calls are paired -- pause_writing() is called&#10;once when the buffer goes strictly over the high-water mark&#10;(even if subsequent writes increases the buffer size even&#10;more), and eventually resume_writing() is called once when the&#10;buffer size reaches the low-water mark.&#10;&#10;Note that if the buffer size equals the high-water mark,&#10;pause_writing() is not called -- it must go strictly over.&#10;Conversely, resume_writing() is called when the buffer size is&#10;equal or lower than the low-water mark.  These end conditions&#10;are important to ensure that things go as expected when either&#10;mark is zero.&#10;&#10;NOTE: This is the only Protocol callback that is not called&#10;through EventLoop.call_soon() -- if it were, it would have no&#10;effect when it's most needed (when the app keeps writing&#10;without yielding until pause_writing() is called).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseProtocol.resume_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer drains below the low-water mark.&#10;&#10;See pause_writing() for details.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseTransport" func="yes">
			<Overload retVal="" descr="Base class for transports.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseTransport.close" func="yes">
			<Overload retVal="" descr="Close the transport.&#10;&#10;Buffered data will be flushed asynchronously.  No more data&#10;will be received.  After all buffered data is flushed, the&#10;protocol's connection_lost() method will (eventually) called&#10;with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseTransport.get_extra_info" func="yes">
			<Overload retVal="" descr="Get optional transport information.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseTransport.get_protocol" func="yes">
			<Overload retVal="" descr="Return the current protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseTransport.is_closing" func="yes">
			<Overload retVal="" descr="Return True if the transport is closing or closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BaseTransport.set_protocol" func="yes">
			<Overload retVal="" descr="Set a new protocol.">
				<Param name="self" />
				<Param name="protocol" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="A bounded semaphore implementation.&#10;&#10;This raises ValueError in release() if it would increase the value&#10;above the initial value.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BoundedSemaphore.acquire" func="yes">
			<Overload retVal="" descr="Acquire a semaphore.&#10;&#10;If the internal counter is larger than zero on entry,&#10;decrement it by one and return True immediately.  If it is&#10;zero on entry, block, waiting until some other coroutine has&#10;called release() to make it larger than 0, and then return&#10;True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BoundedSemaphore.locked" func="yes">
			<Overload retVal="" descr="Returns True if semaphore can not be acquired immediately.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.BoundedSemaphore.release" func="yes">
			<Overload retVal="" descr="Release a semaphore, incrementing the internal counter by one.&#10;When it was zero on entry and another coroutine is waiting for it to&#10;become larger than zero again, wake up that coroutine.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.CancelledError" func="yes">
			<Overload retVal="" descr="The Future was cancelled.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.CancelledError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.CancelledError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Condition" func="yes">
			<Overload retVal="" descr="Asynchronous equivalent to threading.Condition.&#10;&#10;This class implements condition variable objects. A condition variable&#10;allows one or more coroutines to wait until they are notified by another&#10;coroutine.&#10;&#10;A new Lock object is created and used as the underlying lock.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Condition.notify" func="yes">
			<Overload retVal="" descr="By default, wake up one coroutine waiting on this condition, if any.&#10;If the calling coroutine has not acquired the lock when this method&#10;is called, a RuntimeError is raised.&#10;&#10;This method wakes up at most n of the coroutines waiting for the&#10;condition variable; it is a no-op if no coroutines are waiting.&#10;&#10;Note: an awakened coroutine does not actually return from its&#10;wait() call until it can reacquire the lock. Since notify() does&#10;not release the lock, its caller should.">
				<Param name="self" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Condition.notify_all" func="yes">
			<Overload retVal="" descr="Wake up all threads waiting on this condition. This method acts&#10;like notify(), but wakes up all waiting threads instead of one. If the&#10;calling thread has not acquired the lock when this method is called,&#10;a RuntimeError is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Condition.wait" func="yes">
			<Overload retVal="" descr="Wait until notified.&#10;&#10;If the calling coroutine has not acquired the lock when this&#10;method is called, a RuntimeError is raised.&#10;&#10;This method releases the underlying lock, and then blocks&#10;until it is awakened by a notify() or notify_all() call for&#10;the same condition variable in another coroutine.  Once&#10;awakened, it re-acquires the lock and returns True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Condition.wait_for" func="yes">
			<Overload retVal="" descr="Wait until a predicate becomes true.&#10;&#10;The predicate should be a callable which result will be&#10;interpreted as a boolean value.  The final predicate value is&#10;the return value.">
				<Param name="self" />
				<Param name="predicate" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol" func="yes">
			<Overload retVal="" descr="Interface for datagram protocol.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol.connection_lost" func="yes">
			<Overload retVal="" descr="Called when the connection is lost or closed.&#10;&#10;The argument is an exception object or None (the latter&#10;meaning a regular EOF is received or the connection was&#10;aborted or closed).">
				<Param name="self" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol.connection_made" func="yes">
			<Overload retVal="" descr="Called when a connection is made.&#10;&#10;The argument is the transport representing the pipe connection.&#10;To receive data, wait for data_received() calls.&#10;When the connection is closed, connection_lost() is called.">
				<Param name="self" />
				<Param name="transport" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol.datagram_received" func="yes">
			<Overload retVal="" descr="Called when some datagram is received.">
				<Param name="self" />
				<Param name="data" />
				<Param name="addr" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol.error_received" func="yes">
			<Overload retVal="" descr="Called when a send or receive operation raises an OSError.&#10;&#10;(Other than BlockingIOError or InterruptedError.)">
				<Param name="self" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol.pause_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer goes over the high-water mark.&#10;&#10;Pause and resume calls are paired -- pause_writing() is called&#10;once when the buffer goes strictly over the high-water mark&#10;(even if subsequent writes increases the buffer size even&#10;more), and eventually resume_writing() is called once when the&#10;buffer size reaches the low-water mark.&#10;&#10;Note that if the buffer size equals the high-water mark,&#10;pause_writing() is not called -- it must go strictly over.&#10;Conversely, resume_writing() is called when the buffer size is&#10;equal or lower than the low-water mark.  These end conditions&#10;are important to ensure that things go as expected when either&#10;mark is zero.&#10;&#10;NOTE: This is the only Protocol callback that is not called&#10;through EventLoop.call_soon() -- if it were, it would have no&#10;effect when it's most needed (when the app keeps writing&#10;without yielding until pause_writing() is called).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramProtocol.resume_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer drains below the low-water mark.&#10;&#10;See pause_writing() for details.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport" func="yes">
			<Overload retVal="" descr="Interface for datagram (UDP) transports.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.abort" func="yes">
			<Overload retVal="" descr="Close the transport immediately.&#10;&#10;Buffered data will be lost.  No more data will be received.&#10;The protocol's connection_lost() method will (eventually) be&#10;called with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.close" func="yes">
			<Overload retVal="" descr="Close the transport.&#10;&#10;Buffered data will be flushed asynchronously.  No more data&#10;will be received.  After all buffered data is flushed, the&#10;protocol's connection_lost() method will (eventually) called&#10;with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.get_extra_info" func="yes">
			<Overload retVal="" descr="Get optional transport information.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.get_protocol" func="yes">
			<Overload retVal="" descr="Return the current protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.is_closing" func="yes">
			<Overload retVal="" descr="Return True if the transport is closing or closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.sendto" func="yes">
			<Overload retVal="" descr="Send data to the transport.&#10;&#10;This does not block; it buffers the data and arranges for it&#10;to be sent out asynchronously.&#10;addr is target socket address.&#10;If addr is None use target address pointed on transport creation.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[addr=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DatagramTransport.set_protocol" func="yes">
			<Overload retVal="" descr="Set a new protocol.">
				<Param name="self" />
				<Param name="protocol" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DefaultEventLoopPolicy" func="yes">
			<Overload retVal="" descr="Default policy implementation for accessing the event loop.&#10;&#10;In this policy, each thread has its own event loop.  However, we&#10;only automatically create an event loop by default for the main&#10;thread; other threads by default have no event loop.&#10;&#10;Other policies may have different rules (e.g. a single global&#10;event loop, or automatically creating an event loop per thread, or&#10;using some other notion of context to which an event loop is&#10;associated).">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DefaultEventLoopPolicy.get_child_watcher" func="yes">
			<Overload retVal="" descr="Get the watcher for child processes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DefaultEventLoopPolicy.get_event_loop" func="yes">
			<Overload retVal="" descr="Get the event loop.&#10;&#10;This may be None or an instance of EventLoop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DefaultEventLoopPolicy.new_event_loop" func="yes">
			<Overload retVal="" descr="Create a new event loop.&#10;&#10;You must call set_event_loop() to make this the current event&#10;loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DefaultEventLoopPolicy.set_child_watcher" func="yes">
			<Overload retVal="" descr="Set the watcher for child processes.">
				<Param name="self" />
				<Param name="watcher" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.DefaultEventLoopPolicy.set_event_loop" func="yes">
			<Overload retVal="" descr="Set the event loop.">
				<Param name="self" />
				<Param name="loop" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Event" func="yes">
			<Overload retVal="" descr="Asynchronous equivalent to threading.Event.&#10;&#10;Class implementing event objects. An event manages a flag that can be set&#10;to true with the set() method and reset to false with the clear() method.&#10;The wait() method blocks until the flag is true. The flag is initially&#10;false.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Event.clear" func="yes">
			<Overload retVal="" descr="Reset the internal flag to false. Subsequently, coroutines calling&#10;wait() will block until set() is called to set the internal flag&#10;to true again.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Event.is_set" func="yes">
			<Overload retVal="" descr="Return True if and only if the internal flag is true.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Event.set" func="yes">
			<Overload retVal="" descr="Set the internal flag to true. All coroutines waiting for it to&#10;become true are awakened. Coroutine that call wait() once the flag is&#10;true will not block at all.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Event.wait" func="yes">
			<Overload retVal="" descr="Block until the internal flag is true.&#10;&#10;If the internal flag is true on entry, return True&#10;immediately.  Otherwise, block until another coroutine calls&#10;set() to set the flag to true, then return True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.FIRST_COMPLETED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.FIRST_EXCEPTION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future" func="yes">
			<Overload retVal="" descr="This class is *almost* compatible with concurrent.futures.Future.&#10;&#10;Differences:&#10;&#10;- result() and exception() do not take a timeout argument and&#10;  raise an exception when the future isn't done yet.&#10;&#10;- Callbacks registered with add_done_callback() are always called&#10;  via the event loop's call_soon_threadsafe().&#10;&#10;- This class is not compatible with the wait() and as_completed()&#10;  methods in the concurrent.futures package.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.add_done_callback" func="yes">
			<Overload retVal="" descr="Add a callback to be run when the future becomes done.&#10;&#10;The callback is called with a single argument - the future object. If&#10;the future is already done when this is called, the callback is&#10;scheduled with call_soon.">
				<Param name="self" />
				<Param name="fn" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.cancel" func="yes">
			<Overload retVal="" descr="Cancel the future and schedule callbacks.&#10;&#10;If the future is already done or cancelled, return False.  Otherwise,&#10;change the future's state to cancelled, schedule the callbacks and&#10;return True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.cancelled" func="yes">
			<Overload retVal="" descr="Return True if the future was cancelled.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.done" func="yes">
			<Overload retVal="" descr="Return True if the future is done.&#10;&#10;Done means either that a result / exception are available, or that the&#10;future was cancelled.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.exception" func="yes">
			<Overload retVal="" descr="Return the exception that was set on this future.&#10;&#10;The exception (or None if no exception was set) is returned only if&#10;the future is done.  If the future has been cancelled, raises&#10;CancelledError.  If the future isn't done yet, raises&#10;InvalidStateError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.remove_done_callback" func="yes">
			<Overload retVal="" descr='Remove all instances of a callback from the "call when done" list.&#10;&#10;Returns the number of callbacks removed.'>
				<Param name="self" />
				<Param name="fn" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.result" func="yes">
			<Overload retVal="" descr="Return the result this future represents.&#10;&#10;If the future has been cancelled, raises CancelledError.  If the&#10;future's result isn't yet available, raises InvalidStateError.  If&#10;the future is done and has an exception set, this exception is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.set_exception" func="yes">
			<Overload retVal="" descr="Mark the future done and set an exception.&#10;&#10;If the future is already done when this method is called, raises&#10;InvalidStateError.">
				<Param name="self" />
				<Param name="exception" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Future.set_result" func="yes">
			<Overload retVal="" descr="Mark the future done and set its result.&#10;&#10;If the future is already done when this method is called, raises&#10;InvalidStateError.">
				<Param name="self" />
				<Param name="res" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Handle" func="yes">
			<Overload retVal="" descr="Object returned by callback registration methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Handle.cancel" />
		<KeyWord name="asyncio.IncompleteReadError" func="yes">
			<Overload retVal="" descr="Incomplete read error. Attributes:&#10;&#10;- partial: read bytes string before the end of stream was reached&#10;- expected: total number of expected bytes (or None if unknown)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IncompleteReadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IncompleteReadError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.InvalidStateError" func="yes">
			<Overload retVal="" descr="The operation is not allowed in this state.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.InvalidStateError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.InvalidStateError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IocpProactor" func="yes">
			<Overload retVal="" descr="Proactor implementation using IOCP.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IocpProactor.accept" />
		<KeyWord name="asyncio.IocpProactor.accept_pipe" />
		<KeyWord name="asyncio.IocpProactor.close" />
		<KeyWord name="asyncio.IocpProactor.connect" />
		<KeyWord name="asyncio.IocpProactor.connect_pipe" />
		<KeyWord name="asyncio.IocpProactor.recv" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="conn" />
				<Param name="nbytes" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IocpProactor.select" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IocpProactor.send" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="conn" />
				<Param name="buf" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.IocpProactor.set_loop" />
		<KeyWord name="asyncio.IocpProactor.wait_for_handle" func="yes">
			<Overload retVal="" descr="Wait for a handle.&#10;&#10;Return a Future object. The result of the future is True if the wait&#10;completed, or False if the wait did not complete (on timeout).">
				<Param name="self" />
				<Param name="handle" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue" func="yes">
			<Overload retVal="" descr="A subclass of Queue that retrieves most recently added entries first.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.empty" func="yes">
			<Overload retVal="" descr="Return True if the queue is empty, False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.full" func="yes">
			<Overload retVal="" descr="Return True if there are maxsize items in the queue.&#10;&#10;Note: if the Queue was initialized with maxsize=0 (the default),&#10;then full() is never True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.get" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;If queue is empty, wait until an item is available.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.get_nowait" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;Return an item if one is immediately available, else raise QueueEmpty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.join" func="yes">
			<Overload retVal="" descr="Block until all items in the queue have been gotten and processed.&#10;&#10;The count of unfinished tasks goes up whenever an item is added to the&#10;queue. The count goes down whenever a consumer calls task_done() to&#10;indicate that the item was retrieved and all work on it is complete.&#10;When the count of unfinished tasks drops to zero, join() unblocks.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.maxsize" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.put" func="yes">
			<Overload retVal="" descr="Put an item into the queue.&#10;&#10;Put an item into the queue. If the queue is full, wait until a free&#10;slot is available before adding item.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.put_nowait" func="yes">
			<Overload retVal="" descr="Put an item into the queue without blocking.&#10;&#10;If no free slot is immediately available, raise QueueFull.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.qsize" func="yes">
			<Overload retVal="" descr="Number of items in the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LifoQueue.task_done" func="yes">
			<Overload retVal="" descr="Indicate that a formerly enqueued task is complete.&#10;&#10;Used by queue consumers. For each get() used to fetch a task,&#10;a subsequent call to task_done() tells the queue that the processing&#10;on the task is complete.&#10;&#10;If a join() is currently blocking, it will resume when all items have&#10;been processed (meaning that a task_done() call was received for every&#10;item that had been put() into the queue).&#10;&#10;Raises ValueError if called more times than there were items placed in&#10;the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LimitOverrunError" func="yes">
			<Overload retVal="" descr="Reached the buffer limit while looking for a separator.&#10;&#10;Attributes:&#10;- consumed: total number of to be consumed bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LimitOverrunError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.LimitOverrunError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Lock" func="yes">
			<Overload retVal="" descr="Primitive lock objects.&#10;&#10;A primitive lock is a synchronization primitive that is not owned&#10;by a particular coroutine when locked.  A primitive lock is in one&#10;of two states, 'locked' or 'unlocked'.&#10;&#10;It is created in the unlocked state.  It has two basic methods,&#10;acquire() and release().  When the state is unlocked, acquire()&#10;changes the state to locked and returns immediately.  When the&#10;state is locked, acquire() blocks until a call to release() in&#10;another coroutine changes it to unlocked, then the acquire() call&#10;resets it to locked and returns.  The release() method should only&#10;be called in the locked state; it changes the state to unlocked&#10;and returns immediately.  If an attempt is made to release an&#10;unlocked lock, a RuntimeError will be raised.&#10;&#10;When more than one coroutine is blocked in acquire() waiting for&#10;the state to turn to unlocked, only one coroutine proceeds when a&#10;release() call resets the state to unlocked; first coroutine which&#10;is blocked in acquire() is being processed.&#10;&#10;acquire() is a coroutine and should be called with 'yield from'.&#10;&#10;Locks also support the context management protocol.  '(yield from lock)'&#10;should be used as the context manager expression.&#10;&#10;Usage:&#10;&#10;    lock = Lock()&#10;    ...&#10;    yield from lock&#10;    try:&#10;        ...&#10;    finally:&#10;        lock.release()&#10;&#10;Context manager usage:&#10;&#10;    lock = Lock()&#10;    ...&#10;    with (yield from lock):&#10;         ...&#10;&#10;Lock objects can be tested for locking state:&#10;&#10;    if not lock.locked():&#10;       yield from lock&#10;    else:&#10;       # lock is acquired&#10;       ...">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Lock.acquire" func="yes">
			<Overload retVal="" descr="Acquire a lock.&#10;&#10;This method blocks until the lock is unlocked, then sets it to&#10;locked and returns True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Lock.locked" func="yes">
			<Overload retVal="" descr="Return True if lock is acquired.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Lock.release" func="yes">
			<Overload retVal="" descr="Release a lock.&#10;&#10;When the lock is locked, reset it to unlocked, and return.&#10;If any other coroutines are blocked waiting for the lock to become&#10;unlocked, allow exactly one of them to proceed.&#10;&#10;When invoked on an unlocked lock, a RuntimeError is raised.&#10;&#10;There is no return value.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue" func="yes">
			<Overload retVal="" descr="A subclass of Queue; retrieves entries in priority order (lowest first).&#10;&#10;Entries are typically tuples of the form: (priority number, data).">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.empty" func="yes">
			<Overload retVal="" descr="Return True if the queue is empty, False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.full" func="yes">
			<Overload retVal="" descr="Return True if there are maxsize items in the queue.&#10;&#10;Note: if the Queue was initialized with maxsize=0 (the default),&#10;then full() is never True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.get" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;If queue is empty, wait until an item is available.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.get_nowait" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;Return an item if one is immediately available, else raise QueueEmpty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.join" func="yes">
			<Overload retVal="" descr="Block until all items in the queue have been gotten and processed.&#10;&#10;The count of unfinished tasks goes up whenever an item is added to the&#10;queue. The count goes down whenever a consumer calls task_done() to&#10;indicate that the item was retrieved and all work on it is complete.&#10;When the count of unfinished tasks drops to zero, join() unblocks.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.maxsize" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.put" func="yes">
			<Overload retVal="" descr="Put an item into the queue.&#10;&#10;Put an item into the queue. If the queue is full, wait until a free&#10;slot is available before adding item.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.put_nowait" func="yes">
			<Overload retVal="" descr="Put an item into the queue without blocking.&#10;&#10;If no free slot is immediately available, raise QueueFull.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.qsize" func="yes">
			<Overload retVal="" descr="Number of items in the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.PriorityQueue.task_done" func="yes">
			<Overload retVal="" descr="Indicate that a formerly enqueued task is complete.&#10;&#10;Used by queue consumers. For each get() used to fetch a task,&#10;a subsequent call to task_done() tells the queue that the processing&#10;on the task is complete.&#10;&#10;If a join() is currently blocking, it will resume when all items have&#10;been processed (meaning that a task_done() call was received for every&#10;item that had been put() into the queue).&#10;&#10;Raises ValueError if called more times than there were items placed in&#10;the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop" func="yes">
			<Overload retVal="" descr="Windows version of proactor event loop using IOCP.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.add_reader" />
		<KeyWord name="asyncio.ProactorEventLoop.add_signal_handler" />
		<KeyWord name="asyncio.ProactorEventLoop.add_writer" />
		<KeyWord name="asyncio.ProactorEventLoop.call_at" func="yes">
			<Overload retVal="" descr="Like call_later(), but uses an absolute time.&#10;&#10;Absolute time corresponds to the event loop's time() method.">
				<Param name="self" />
				<Param name="when" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.call_exception_handler" func="yes">
			<Overload retVal="" descr="Call the current event loop's exception handler.&#10;&#10;The context argument is a dict containing the following keys:&#10;&#10;- 'message': Error message;&#10;- 'exception' (optional): Exception object;&#10;- 'future' (optional): Future instance;&#10;- 'handle' (optional): Handle instance;&#10;- 'protocol' (optional): Protocol instance;&#10;- 'transport' (optional): Transport instance;&#10;- 'socket' (optional): Socket instance;&#10;- 'asyncgen' (optional): Asynchronous generator that caused&#10;                         the exception.&#10;&#10;New keys maybe introduced in the future.&#10;&#10;Note: do not overload this method in an event loop subclass.&#10;For custom exception handling, use the&#10;`set_exception_handler()` method.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.call_later" func="yes">
			<Overload retVal="" descr="Arrange for a callback to be called at a given time.&#10;&#10;Return a Handle: an opaque object with a cancel() method that&#10;can be used to cancel the call.&#10;&#10;The delay can be an int or float, expressed in seconds.  It is&#10;always relative to the current time.&#10;&#10;Each callback will be called exactly once.  If two callbacks&#10;are scheduled for exactly the same time, it undefined which&#10;will be called first.&#10;&#10;Any positional arguments after the callback will be passed to&#10;the callback when it is called.">
				<Param name="self" />
				<Param name="delay" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.call_soon" func="yes">
			<Overload retVal="" descr="Arrange for a callback to be called as soon as possible.&#10;&#10;This operates as a FIFO queue: callbacks are called in the&#10;order in which they are registered.  Each callback will be&#10;called exactly once.&#10;&#10;Any positional arguments after the callback will be passed to&#10;the callback when it is called.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.call_soon_threadsafe" func="yes">
			<Overload retVal="" descr="Like call_soon(), but thread-safe.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.close" func="yes">
			<Overload retVal="" descr="Close the event loop.&#10;&#10;This clears the queues and shuts down the executor,&#10;but does not wait for the executor to finish.&#10;&#10;The event loop must not be running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.connect_accepted_socket" func="yes">
			<Overload retVal="" descr="Handle an accepted connection.&#10;&#10;This is used by servers that accept connections outside of&#10;asyncio but that use asyncio to handle connections.&#10;&#10;This method is a coroutine.  When completed, the coroutine&#10;returns a (transport, protocol) pair.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.connect_read_pipe" func="yes">
			<Overload retVal="" descr="Register read pipe in event loop. Set the pipe to non-blocking mode.&#10;&#10;protocol_factory should instantiate object with Protocol interface.&#10;pipe is a file-like object.&#10;Return pair (transport, protocol), where transport supports the&#10;ReadTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.connect_write_pipe" func="yes">
			<Overload retVal="" descr="Register write pipe in event loop.&#10;&#10;protocol_factory should instantiate object with BaseProtocol interface.&#10;Pipe is file-like object already switched to nonblocking.&#10;Return pair (transport, protocol), where transport support&#10;WriteTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.create_connection" func="yes">
			<Overload retVal="" descr="Connect to a TCP server.&#10;&#10;Create a streaming transport connection to a given Internet host and&#10;port: socket family AF_INET or socket.AF_INET6 depending on host (or&#10;family if specified), socket type SOCK_STREAM. protocol_factory must be&#10;a callable returning a protocol instance.&#10;&#10;This method is a coroutine which will try to establish the connection&#10;in the background.  When successful, the coroutine returns a&#10;(transport, protocol) pair.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.create_datagram_endpoint" func="yes">
			<Overload retVal="" descr="Create datagram connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.create_future" func="yes">
			<Overload retVal="" descr="Create a Future object attached to the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.create_pipe_connection" />
		<KeyWord name="asyncio.ProactorEventLoop.create_server" func="yes">
			<Overload retVal="" descr="Create a TCP server.&#10;&#10;The host parameter can be a string, in that case the TCP server is bound&#10;to host and port.&#10;&#10;The host parameter can also be a sequence of strings and in that case&#10;the TCP server is bound to all hosts of the sequence. If a host&#10;appears multiple times (possibly indirectly e.g. when hostnames&#10;resolve to the same IP address), the server is only bound once to that&#10;host.&#10;&#10;Return a Server object which can be used to stop the service.&#10;&#10;This method is a coroutine.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.create_task" func="yes">
			<Overload retVal="" descr="Schedule a coroutine object.&#10;&#10;Return a task object.">
				<Param name="self" />
				<Param name="coro" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.create_unix_connection" />
		<KeyWord name="asyncio.ProactorEventLoop.create_unix_server" func="yes">
			<Overload retVal="" descr="A coroutine which creates a UNIX Domain Socket server.&#10;&#10;The return value is a Server object, which can be used to stop&#10;the service.&#10;&#10;path is a str, representing a file systsem path to bind the&#10;server socket to.&#10;&#10;sock can optionally be specified in order to use a preexisting&#10;socket object.&#10;&#10;backlog is the maximum number of queued connections passed to&#10;listen() (defaults to 100).&#10;&#10;ssl can be set to an SSLContext to enable SSL over the&#10;accepted connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.default_exception_handler" func="yes">
			<Overload retVal="" descr="Default exception handler.&#10;&#10;This is called when an exception occurs and no exception&#10;handler is set, and can be called by a custom exception&#10;handler that wants to defer to the default behavior.&#10;&#10;This default handler logs the error message and other&#10;context-dependent information.  In debug mode, a truncated&#10;stack trace is also appended showing where the given object&#10;(e.g. a handle or future or task) was created, if any.&#10;&#10;The context parameter has the same meaning as in&#10;`call_exception_handler()`.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.get_debug" />
		<KeyWord name="asyncio.ProactorEventLoop.get_exception_handler" func="yes">
			<Overload retVal="" descr="Return an exception handler, or None if the default one is in use.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.get_task_factory" func="yes">
			<Overload retVal="" descr="Return a task factory, or None if the default one is in use.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.getaddrinfo" />
		<KeyWord name="asyncio.ProactorEventLoop.getnameinfo" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sockaddr" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.is_closed" func="yes">
			<Overload retVal="" descr="Returns True if the event loop was closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.is_running" func="yes">
			<Overload retVal="" descr="Returns True if the event loop is running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.remove_reader" />
		<KeyWord name="asyncio.ProactorEventLoop.remove_signal_handler" />
		<KeyWord name="asyncio.ProactorEventLoop.remove_writer" />
		<KeyWord name="asyncio.ProactorEventLoop.run_forever" func="yes">
			<Overload retVal="" descr="Run until stop() is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.run_in_executor" />
		<KeyWord name="asyncio.ProactorEventLoop.run_until_complete" func="yes">
			<Overload retVal="" descr="Run until the Future is done.&#10;&#10;If the argument is a coroutine, it is wrapped in a Task.&#10;&#10;WARNING: It would be disastrous to call run_until_complete()&#10;with the same coroutine twice -- it would wrap it in two&#10;different Tasks and that can't be good.&#10;&#10;Return the Future's result, or raise its exception.">
				<Param name="self" />
				<Param name="future" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.set_debug" />
		<KeyWord name="asyncio.ProactorEventLoop.set_default_executor" />
		<KeyWord name="asyncio.ProactorEventLoop.set_exception_handler" func="yes">
			<Overload retVal="" descr="Set handler as the new event loop exception handler.&#10;&#10;If handler is None, the default exception handler will&#10;be set.&#10;&#10;If handler is a callable object, it should have a&#10;signature matching '(loop, context)', where 'loop'&#10;will be a reference to the active event loop, 'context'&#10;will be a dict object (see `call_exception_handler()`&#10;documentation for details about context).">
				<Param name="self" />
				<Param name="handler" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.set_task_factory" func="yes">
			<Overload retVal="" descr="Set a task factory that will be used by loop.create_task().&#10;&#10;If factory is None the default task factory will be set.&#10;&#10;If factory is a callable, it should have a signature matching&#10;'(loop, coro)', where 'loop' will be a reference to the active&#10;event loop, 'coro' will be a coroutine object.  The callable&#10;must return a Future.">
				<Param name="self" />
				<Param name="factory" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.shutdown_asyncgens" func="yes">
			<Overload retVal="" descr="Shutdown all active asynchronous generators.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.sock_accept" />
		<KeyWord name="asyncio.ProactorEventLoop.sock_connect" />
		<KeyWord name="asyncio.ProactorEventLoop.sock_recv" />
		<KeyWord name="asyncio.ProactorEventLoop.sock_sendall" />
		<KeyWord name="asyncio.ProactorEventLoop.start_serving_pipe" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.stop" func="yes">
			<Overload retVal="" descr="Stop running the event loop.&#10;&#10;Every callback already scheduled will still run.  This simply informs&#10;run_forever to stop looping after a complete iteration.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ProactorEventLoop.subprocess_exec" />
		<KeyWord name="asyncio.ProactorEventLoop.subprocess_shell" />
		<KeyWord name="asyncio.ProactorEventLoop.time" func="yes">
			<Overload retVal="" descr="Return the time according to the event loop's clock.&#10;&#10;This is a float expressed in seconds since an epoch, but the&#10;epoch, precision, accuracy and drift are unspecified and may&#10;differ per event loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol" func="yes">
			<Overload retVal="" descr="Interface for stream protocol.&#10;&#10;The user should implement this interface.  They can inherit from&#10;this class but don't need to.  The implementations here do&#10;nothing (they don't raise exceptions).&#10;&#10;When the user wants to requests a transport, they pass a protocol&#10;factory to a utility function (e.g., EventLoop.create_connection()).&#10;&#10;When the connection is made successfully, connection_made() is&#10;called with a suitable transport object.  Then data_received()&#10;will be called 0 or more times with data (bytes) received from the&#10;transport; finally, connection_lost() will be called exactly once&#10;with either an exception object or None as an argument.&#10;&#10;State machine of calls:&#10;&#10;  start -&gt; CM [-&gt; DR*] [-&gt; ER?] -&gt; CL -&gt; end&#10;&#10;* CM: connection_made()&#10;* DR: data_received()&#10;* ER: eof_received()&#10;* CL: connection_lost()">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol.connection_lost" func="yes">
			<Overload retVal="" descr="Called when the connection is lost or closed.&#10;&#10;The argument is an exception object or None (the latter&#10;meaning a regular EOF is received or the connection was&#10;aborted or closed).">
				<Param name="self" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol.connection_made" func="yes">
			<Overload retVal="" descr="Called when a connection is made.&#10;&#10;The argument is the transport representing the pipe connection.&#10;To receive data, wait for data_received() calls.&#10;When the connection is closed, connection_lost() is called.">
				<Param name="self" />
				<Param name="transport" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol.data_received" func="yes">
			<Overload retVal="" descr="Called when some data is received.&#10;&#10;The argument is a bytes object.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol.eof_received" func="yes">
			<Overload retVal="" descr="Called when the other end calls write_eof() or equivalent.&#10;&#10;If this returns a false value (including None), the transport&#10;will close itself.  If it returns a true value, closing the&#10;transport is up to the protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol.pause_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer goes over the high-water mark.&#10;&#10;Pause and resume calls are paired -- pause_writing() is called&#10;once when the buffer goes strictly over the high-water mark&#10;(even if subsequent writes increases the buffer size even&#10;more), and eventually resume_writing() is called once when the&#10;buffer size reaches the low-water mark.&#10;&#10;Note that if the buffer size equals the high-water mark,&#10;pause_writing() is not called -- it must go strictly over.&#10;Conversely, resume_writing() is called when the buffer size is&#10;equal or lower than the low-water mark.  These end conditions&#10;are important to ensure that things go as expected when either&#10;mark is zero.&#10;&#10;NOTE: This is the only Protocol callback that is not called&#10;through EventLoop.call_soon() -- if it were, it would have no&#10;effect when it's most needed (when the app keeps writing&#10;without yielding until pause_writing() is called).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Protocol.resume_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer drains below the low-water mark.&#10;&#10;See pause_writing() for details.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue" func="yes">
			<Overload retVal="" descr="A queue, useful for coordinating producer and consumer coroutines.&#10;&#10;If maxsize is less than or equal to zero, the queue size is infinite. If it&#10;is an integer greater than 0, then &quot;yield from put()&quot; will block when the&#10;queue reaches maxsize, until an item is removed by get().&#10;&#10;Unlike the standard library Queue, you can reliably know this Queue's size&#10;with qsize(), since your single-threaded asyncio application won't be&#10;interrupted between calling qsize() and doing an operation on the Queue.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.empty" func="yes">
			<Overload retVal="" descr="Return True if the queue is empty, False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.full" func="yes">
			<Overload retVal="" descr="Return True if there are maxsize items in the queue.&#10;&#10;Note: if the Queue was initialized with maxsize=0 (the default),&#10;then full() is never True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.get" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;If queue is empty, wait until an item is available.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.get_nowait" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;Return an item if one is immediately available, else raise QueueEmpty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.join" func="yes">
			<Overload retVal="" descr="Block until all items in the queue have been gotten and processed.&#10;&#10;The count of unfinished tasks goes up whenever an item is added to the&#10;queue. The count goes down whenever a consumer calls task_done() to&#10;indicate that the item was retrieved and all work on it is complete.&#10;When the count of unfinished tasks drops to zero, join() unblocks.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.maxsize" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.put" func="yes">
			<Overload retVal="" descr="Put an item into the queue.&#10;&#10;Put an item into the queue. If the queue is full, wait until a free&#10;slot is available before adding item.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.put_nowait" func="yes">
			<Overload retVal="" descr="Put an item into the queue without blocking.&#10;&#10;If no free slot is immediately available, raise QueueFull.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.qsize" func="yes">
			<Overload retVal="" descr="Number of items in the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Queue.task_done" func="yes">
			<Overload retVal="" descr="Indicate that a formerly enqueued task is complete.&#10;&#10;Used by queue consumers. For each get() used to fetch a task,&#10;a subsequent call to task_done() tells the queue that the processing&#10;on the task is complete.&#10;&#10;If a join() is currently blocking, it will resume when all items have&#10;been processed (meaning that a task_done() call was received for every&#10;item that had been put() into the queue).&#10;&#10;Raises ValueError if called more times than there were items placed in&#10;the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.QueueEmpty" func="yes">
			<Overload retVal="" descr="Exception raised when Queue.get_nowait() is called on a Queue object&#10;which is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.QueueEmpty.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.QueueEmpty.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.QueueFull" func="yes">
			<Overload retVal="" descr="Exception raised when the Queue.put_nowait() method is called on a Queue&#10;object which is full.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.QueueFull.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.QueueFull.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport" func="yes">
			<Overload retVal="" descr="Interface for read-only transports.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.close" func="yes">
			<Overload retVal="" descr="Close the transport.&#10;&#10;Buffered data will be flushed asynchronously.  No more data&#10;will be received.  After all buffered data is flushed, the&#10;protocol's connection_lost() method will (eventually) called&#10;with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.get_extra_info" func="yes">
			<Overload retVal="" descr="Get optional transport information.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.get_protocol" func="yes">
			<Overload retVal="" descr="Return the current protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.is_closing" func="yes">
			<Overload retVal="" descr="Return True if the transport is closing or closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.pause_reading" func="yes">
			<Overload retVal="" descr="Pause the receiving end.&#10;&#10;No data will be passed to the protocol's data_received()&#10;method until resume_reading() is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.resume_reading" func="yes">
			<Overload retVal="" descr="Resume the receiving end.&#10;&#10;Data received will once again be passed to the protocol's&#10;data_received() method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ReadTransport.set_protocol" func="yes">
			<Overload retVal="" descr="Set a new protocol.">
				<Param name="self" />
				<Param name="protocol" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop" func="yes">
			<Overload retVal="" descr="Windows version of selector event loop.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.add_reader" func="yes">
			<Overload retVal="" descr="Add a reader callback.">
				<Param name="self" />
				<Param name="fd" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.add_signal_handler" />
		<KeyWord name="asyncio.SelectorEventLoop.add_writer" func="yes">
			<Overload retVal="" descr="Add a writer callback..">
				<Param name="self" />
				<Param name="fd" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.call_at" func="yes">
			<Overload retVal="" descr="Like call_later(), but uses an absolute time.&#10;&#10;Absolute time corresponds to the event loop's time() method.">
				<Param name="self" />
				<Param name="when" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.call_exception_handler" func="yes">
			<Overload retVal="" descr="Call the current event loop's exception handler.&#10;&#10;The context argument is a dict containing the following keys:&#10;&#10;- 'message': Error message;&#10;- 'exception' (optional): Exception object;&#10;- 'future' (optional): Future instance;&#10;- 'handle' (optional): Handle instance;&#10;- 'protocol' (optional): Protocol instance;&#10;- 'transport' (optional): Transport instance;&#10;- 'socket' (optional): Socket instance;&#10;- 'asyncgen' (optional): Asynchronous generator that caused&#10;                         the exception.&#10;&#10;New keys maybe introduced in the future.&#10;&#10;Note: do not overload this method in an event loop subclass.&#10;For custom exception handling, use the&#10;`set_exception_handler()` method.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.call_later" func="yes">
			<Overload retVal="" descr="Arrange for a callback to be called at a given time.&#10;&#10;Return a Handle: an opaque object with a cancel() method that&#10;can be used to cancel the call.&#10;&#10;The delay can be an int or float, expressed in seconds.  It is&#10;always relative to the current time.&#10;&#10;Each callback will be called exactly once.  If two callbacks&#10;are scheduled for exactly the same time, it undefined which&#10;will be called first.&#10;&#10;Any positional arguments after the callback will be passed to&#10;the callback when it is called.">
				<Param name="self" />
				<Param name="delay" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.call_soon" func="yes">
			<Overload retVal="" descr="Arrange for a callback to be called as soon as possible.&#10;&#10;This operates as a FIFO queue: callbacks are called in the&#10;order in which they are registered.  Each callback will be&#10;called exactly once.&#10;&#10;Any positional arguments after the callback will be passed to&#10;the callback when it is called.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.call_soon_threadsafe" func="yes">
			<Overload retVal="" descr="Like call_soon(), but thread-safe.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.close" func="yes">
			<Overload retVal="" descr="Close the event loop.&#10;&#10;This clears the queues and shuts down the executor,&#10;but does not wait for the executor to finish.&#10;&#10;The event loop must not be running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.connect_accepted_socket" func="yes">
			<Overload retVal="" descr="Handle an accepted connection.&#10;&#10;This is used by servers that accept connections outside of&#10;asyncio but that use asyncio to handle connections.&#10;&#10;This method is a coroutine.  When completed, the coroutine&#10;returns a (transport, protocol) pair.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.connect_read_pipe" func="yes">
			<Overload retVal="" descr="Register read pipe in event loop. Set the pipe to non-blocking mode.&#10;&#10;protocol_factory should instantiate object with Protocol interface.&#10;pipe is a file-like object.&#10;Return pair (transport, protocol), where transport supports the&#10;ReadTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.connect_write_pipe" func="yes">
			<Overload retVal="" descr="Register write pipe in event loop.&#10;&#10;protocol_factory should instantiate object with BaseProtocol interface.&#10;Pipe is file-like object already switched to nonblocking.&#10;Return pair (transport, protocol), where transport support&#10;WriteTransport interface.">
				<Param name="self" />
				<Param name="protocol_factory" />
				<Param name="pipe" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.create_connection" func="yes">
			<Overload retVal="" descr="Connect to a TCP server.&#10;&#10;Create a streaming transport connection to a given Internet host and&#10;port: socket family AF_INET or socket.AF_INET6 depending on host (or&#10;family if specified), socket type SOCK_STREAM. protocol_factory must be&#10;a callable returning a protocol instance.&#10;&#10;This method is a coroutine which will try to establish the connection&#10;in the background.  When successful, the coroutine returns a&#10;(transport, protocol) pair.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.create_datagram_endpoint" func="yes">
			<Overload retVal="" descr="Create datagram connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.create_future" func="yes">
			<Overload retVal="" descr="Create a Future object attached to the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.create_server" func="yes">
			<Overload retVal="" descr="Create a TCP server.&#10;&#10;The host parameter can be a string, in that case the TCP server is bound&#10;to host and port.&#10;&#10;The host parameter can also be a sequence of strings and in that case&#10;the TCP server is bound to all hosts of the sequence. If a host&#10;appears multiple times (possibly indirectly e.g. when hostnames&#10;resolve to the same IP address), the server is only bound once to that&#10;host.&#10;&#10;Return a Server object which can be used to stop the service.&#10;&#10;This method is a coroutine.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.create_task" func="yes">
			<Overload retVal="" descr="Schedule a coroutine object.&#10;&#10;Return a task object.">
				<Param name="self" />
				<Param name="coro" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.create_unix_connection" />
		<KeyWord name="asyncio.SelectorEventLoop.create_unix_server" func="yes">
			<Overload retVal="" descr="A coroutine which creates a UNIX Domain Socket server.&#10;&#10;The return value is a Server object, which can be used to stop&#10;the service.&#10;&#10;path is a str, representing a file systsem path to bind the&#10;server socket to.&#10;&#10;sock can optionally be specified in order to use a preexisting&#10;socket object.&#10;&#10;backlog is the maximum number of queued connections passed to&#10;listen() (defaults to 100).&#10;&#10;ssl can be set to an SSLContext to enable SSL over the&#10;accepted connections.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.default_exception_handler" func="yes">
			<Overload retVal="" descr="Default exception handler.&#10;&#10;This is called when an exception occurs and no exception&#10;handler is set, and can be called by a custom exception&#10;handler that wants to defer to the default behavior.&#10;&#10;This default handler logs the error message and other&#10;context-dependent information.  In debug mode, a truncated&#10;stack trace is also appended showing where the given object&#10;(e.g. a handle or future or task) was created, if any.&#10;&#10;The context parameter has the same meaning as in&#10;`call_exception_handler()`.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.get_debug" />
		<KeyWord name="asyncio.SelectorEventLoop.get_exception_handler" func="yes">
			<Overload retVal="" descr="Return an exception handler, or None if the default one is in use.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.get_task_factory" func="yes">
			<Overload retVal="" descr="Return a task factory, or None if the default one is in use.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.getaddrinfo" />
		<KeyWord name="asyncio.SelectorEventLoop.getnameinfo" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sockaddr" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.is_closed" func="yes">
			<Overload retVal="" descr="Returns True if the event loop was closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.is_running" func="yes">
			<Overload retVal="" descr="Returns True if the event loop is running.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.remove_reader" func="yes">
			<Overload retVal="" descr="Remove a reader callback.">
				<Param name="self" />
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.remove_signal_handler" />
		<KeyWord name="asyncio.SelectorEventLoop.remove_writer" func="yes">
			<Overload retVal="" descr="Remove a writer callback.">
				<Param name="self" />
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.run_forever" func="yes">
			<Overload retVal="" descr="Run until stop() is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.run_in_executor" />
		<KeyWord name="asyncio.SelectorEventLoop.run_until_complete" func="yes">
			<Overload retVal="" descr="Run until the Future is done.&#10;&#10;If the argument is a coroutine, it is wrapped in a Task.&#10;&#10;WARNING: It would be disastrous to call run_until_complete()&#10;with the same coroutine twice -- it would wrap it in two&#10;different Tasks and that can't be good.&#10;&#10;Return the Future's result, or raise its exception.">
				<Param name="self" />
				<Param name="future" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.set_debug" />
		<KeyWord name="asyncio.SelectorEventLoop.set_default_executor" />
		<KeyWord name="asyncio.SelectorEventLoop.set_exception_handler" func="yes">
			<Overload retVal="" descr="Set handler as the new event loop exception handler.&#10;&#10;If handler is None, the default exception handler will&#10;be set.&#10;&#10;If handler is a callable object, it should have a&#10;signature matching '(loop, context)', where 'loop'&#10;will be a reference to the active event loop, 'context'&#10;will be a dict object (see `call_exception_handler()`&#10;documentation for details about context).">
				<Param name="self" />
				<Param name="handler" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.set_task_factory" func="yes">
			<Overload retVal="" descr="Set a task factory that will be used by loop.create_task().&#10;&#10;If factory is None the default task factory will be set.&#10;&#10;If factory is a callable, it should have a signature matching&#10;'(loop, coro)', where 'loop' will be a reference to the active&#10;event loop, 'coro' will be a coroutine object.  The callable&#10;must return a Future.">
				<Param name="self" />
				<Param name="factory" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.shutdown_asyncgens" func="yes">
			<Overload retVal="" descr="Shutdown all active asynchronous generators.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.sock_accept" func="yes">
			<Overload retVal="" descr="Accept a connection.&#10;&#10;The socket must be bound to an address and listening for connections.&#10;The return value is a pair (conn, address) where conn is a new socket&#10;object usable to send and receive data on the connection, and address&#10;is the address bound to the socket on the other end of the connection.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="sock" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.sock_connect" func="yes">
			<Overload retVal="" descr="Connect to a remote socket at address.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="sock" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.sock_recv" func="yes">
			<Overload retVal="" descr="Receive data from the socket.&#10;&#10;The return value is a bytes object representing the data received.&#10;The maximum amount of data to be received at once is specified by&#10;nbytes.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="sock" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.sock_sendall" func="yes">
			<Overload retVal="" descr="Send data to the socket.&#10;&#10;The socket must be connected to a remote socket. This method continues&#10;to send data from data until either all data has been sent or an&#10;error occurs. None is returned on success. On error, an exception is&#10;raised, and there is no way to determine how much data, if any, was&#10;successfully processed by the receiving end of the connection.&#10;&#10;This method is a coroutine.">
				<Param name="self" />
				<Param name="sock" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.stop" func="yes">
			<Overload retVal="" descr="Stop running the event loop.&#10;&#10;Every callback already scheduled will still run.  This simply informs&#10;run_forever to stop looping after a complete iteration.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SelectorEventLoop.subprocess_exec" />
		<KeyWord name="asyncio.SelectorEventLoop.subprocess_shell" />
		<KeyWord name="asyncio.SelectorEventLoop.time" func="yes">
			<Overload retVal="" descr="Return the time according to the event loop's clock.&#10;&#10;This is a float expressed in seconds since an epoch, but the&#10;epoch, precision, accuracy and drift are unspecified and may&#10;differ per event loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Semaphore" func="yes">
			<Overload retVal="" descr="A Semaphore implementation.&#10;&#10;A semaphore manages an internal counter which is decremented by each&#10;acquire() call and incremented by each release() call. The counter&#10;can never go below zero; when acquire() finds that it is zero, it blocks,&#10;waiting until some other thread calls release().&#10;&#10;Semaphores also support the context management protocol.&#10;&#10;The optional argument gives the initial value for the internal&#10;counter; it defaults to 1. If the value given is less than 0,&#10;ValueError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Semaphore.acquire" func="yes">
			<Overload retVal="" descr="Acquire a semaphore.&#10;&#10;If the internal counter is larger than zero on entry,&#10;decrement it by one and return True immediately.  If it is&#10;zero on entry, block, waiting until some other coroutine has&#10;called release() to make it larger than 0, and then return&#10;True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Semaphore.locked" func="yes">
			<Overload retVal="" descr="Returns True if semaphore can not be acquired immediately.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Semaphore.release" func="yes">
			<Overload retVal="" descr="Release a semaphore, incrementing the internal counter by one.&#10;When it was zero on entry and another coroutine is waiting for it to&#10;become larger than zero again, wake up that coroutine.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReader" />
		<KeyWord name="asyncio.StreamReader.at_eof" func="yes">
			<Overload retVal="" descr="Return True if the buffer is empty and 'feed_eof' was called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReader.exception" />
		<KeyWord name="asyncio.StreamReader.feed_data" />
		<KeyWord name="asyncio.StreamReader.feed_eof" />
		<KeyWord name="asyncio.StreamReader.read" func="yes">
			<Overload retVal="" descr="Read up to `n` bytes from the stream.&#10;&#10;If n is not provided, or set to -1, read until EOF and return all read&#10;bytes. If the EOF was received and the internal buffer is empty, return&#10;an empty bytes object.&#10;&#10;If n is zero, return empty bytes object immediately.&#10;&#10;If n is positive, this function try to read `n` bytes, and may return&#10;less or equal bytes than requested, but at least one byte. If EOF was&#10;received before any byte is read, this function returns empty byte&#10;object.&#10;&#10;Returned value is not limited with limit, configured at stream&#10;creation.&#10;&#10;If stream was paused, this function will automatically resume it if&#10;needed.">
				<Param name="self" />
				<Param name="[n=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReader.readexactly" func="yes">
			<Overload retVal="" descr="Read exactly `n` bytes.&#10;&#10;Raise an IncompleteReadError if EOF is reached before `n` bytes can be&#10;read. The IncompleteReadError.partial attribute of the exception will&#10;contain the partial read bytes.&#10;&#10;if n is zero, return empty bytes object.&#10;&#10;Returned value is not limited with limit, configured at stream&#10;creation.&#10;&#10;If stream was paused, this function will automatically resume it if&#10;needed.">
				<Param name="self" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReader.readline" func="yes">
			<Overload retVal="" descr="Read chunk of data from the stream until newline (b'&#10;') is found.&#10;&#10;        On success, return chunk that ends with newline. If only partial&#10;        line can be read due to EOF, return incomplete line without&#10;        terminating newline. When EOF was reached while no bytes read, empty&#10;        bytes object is returned.&#10;&#10;        If limit is reached, ValueError will be raised. In that case, if&#10;        newline was found, complete line including newline will be removed&#10;        from internal buffer. Else, internal buffer will be cleared. Limit is&#10;        compared against part of the line without newline.&#10;&#10;        If stream was paused, this function will automatically resume it if&#10;        needed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReader.readuntil" func="yes">
			<Overload retVal="" descr="Read data from the stream until ``separator`` is found.&#10;&#10;On success, the data and separator will be removed from the&#10;internal buffer (consumed). Returned data will include the&#10;separator at the end.&#10;&#10;Configured stream limit is used to check result. Limit sets the&#10;maximal length of data that can be returned, not counting the&#10;separator.&#10;&#10;If an EOF occurs and the complete separator is still not found,&#10;an IncompleteReadError exception will be raised, and the internal&#10;buffer will be reset.  The IncompleteReadError.partial attribute&#10;may contain the separator partially.&#10;&#10;If the data cannot be read because of over limit, a&#10;LimitOverrunError exception  will be raised, and the data&#10;will be left in the internal buffer, so it can be read again.">
				<Param name="self" />
				<Param name="[separator=b'\n']" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReader.set_exception" />
		<KeyWord name="asyncio.StreamReader.set_transport" />
		<KeyWord name="asyncio.StreamReaderProtocol" func="yes">
			<Overload retVal="" descr="Helper class to adapt between Protocol and StreamReader.&#10;&#10;(This is a helper class instead of making StreamReader itself a&#10;Protocol subclass, because the StreamReader has other potential&#10;uses, and to prevent the user of the StreamReader to accidentally&#10;call inappropriate methods of the protocol.)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReaderProtocol.connection_lost" func="yes">
			<Overload retVal="" descr="Called when the connection is lost or closed.&#10;&#10;The argument is an exception object or None (the latter&#10;meaning a regular EOF is received or the connection was&#10;aborted or closed).">
				<Param name="self" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReaderProtocol.connection_made" func="yes">
			<Overload retVal="" descr="Called when a connection is made.&#10;&#10;The argument is the transport representing the pipe connection.&#10;To receive data, wait for data_received() calls.&#10;When the connection is closed, connection_lost() is called.">
				<Param name="self" />
				<Param name="transport" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReaderProtocol.data_received" func="yes">
			<Overload retVal="" descr="Called when some data is received.&#10;&#10;The argument is a bytes object.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReaderProtocol.eof_received" func="yes">
			<Overload retVal="" descr="Called when the other end calls write_eof() or equivalent.&#10;&#10;If this returns a false value (including None), the transport&#10;will close itself.  If it returns a true value, closing the&#10;transport is up to the protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReaderProtocol.pause_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer goes over the high-water mark.&#10;&#10;Pause and resume calls are paired -- pause_writing() is called&#10;once when the buffer goes strictly over the high-water mark&#10;(even if subsequent writes increases the buffer size even&#10;more), and eventually resume_writing() is called once when the&#10;buffer size reaches the low-water mark.&#10;&#10;Note that if the buffer size equals the high-water mark,&#10;pause_writing() is not called -- it must go strictly over.&#10;Conversely, resume_writing() is called when the buffer size is&#10;equal or lower than the low-water mark.  These end conditions&#10;are important to ensure that things go as expected when either&#10;mark is zero.&#10;&#10;NOTE: This is the only Protocol callback that is not called&#10;through EventLoop.call_soon() -- if it were, it would have no&#10;effect when it's most needed (when the app keeps writing&#10;without yielding until pause_writing() is called).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamReaderProtocol.resume_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer drains below the low-water mark.&#10;&#10;See pause_writing() for details.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamWriter" func="yes">
			<Overload retVal="" descr="Wraps a Transport.&#10;&#10;This exposes write(), writelines(), [can_]write_eof(),&#10;get_extra_info() and close().  It adds drain() which returns an&#10;optional Future on which you can wait for flow control.  It also&#10;adds a transport property which references the Transport&#10;directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamWriter.can_write_eof" />
		<KeyWord name="asyncio.StreamWriter.close" />
		<KeyWord name="asyncio.StreamWriter.drain" func="yes">
			<Overload retVal="" descr="Flush the write buffer.&#10;&#10;The intended use is to write&#10;&#10;  w.write(data)&#10;  yield from w.drain()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamWriter.get_extra_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamWriter.transport" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.StreamWriter.write" />
		<KeyWord name="asyncio.StreamWriter.write_eof" />
		<KeyWord name="asyncio.StreamWriter.writelines" />
		<KeyWord name="asyncio.SubprocessProtocol" func="yes">
			<Overload retVal="" descr="Interface for protocol for subprocess calls.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.connection_lost" func="yes">
			<Overload retVal="" descr="Called when the connection is lost or closed.&#10;&#10;The argument is an exception object or None (the latter&#10;meaning a regular EOF is received or the connection was&#10;aborted or closed).">
				<Param name="self" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.connection_made" func="yes">
			<Overload retVal="" descr="Called when a connection is made.&#10;&#10;The argument is the transport representing the pipe connection.&#10;To receive data, wait for data_received() calls.&#10;When the connection is closed, connection_lost() is called.">
				<Param name="self" />
				<Param name="transport" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.pause_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer goes over the high-water mark.&#10;&#10;Pause and resume calls are paired -- pause_writing() is called&#10;once when the buffer goes strictly over the high-water mark&#10;(even if subsequent writes increases the buffer size even&#10;more), and eventually resume_writing() is called once when the&#10;buffer size reaches the low-water mark.&#10;&#10;Note that if the buffer size equals the high-water mark,&#10;pause_writing() is not called -- it must go strictly over.&#10;Conversely, resume_writing() is called when the buffer size is&#10;equal or lower than the low-water mark.  These end conditions&#10;are important to ensure that things go as expected when either&#10;mark is zero.&#10;&#10;NOTE: This is the only Protocol callback that is not called&#10;through EventLoop.call_soon() -- if it were, it would have no&#10;effect when it's most needed (when the app keeps writing&#10;without yielding until pause_writing() is called).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.pipe_connection_lost" func="yes">
			<Overload retVal="" descr="Called when a file descriptor associated with the child process is&#10;closed.&#10;&#10;fd is the int file descriptor that was closed.">
				<Param name="self" />
				<Param name="fd" />
				<Param name="exc" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.pipe_data_received" func="yes">
			<Overload retVal="" descr="Called when the subprocess writes data into stdout/stderr pipe.&#10;&#10;fd is int file descriptor.&#10;data is bytes object.">
				<Param name="self" />
				<Param name="fd" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.process_exited" func="yes">
			<Overload retVal="" descr="Called when subprocess has exited.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessProtocol.resume_writing" func="yes">
			<Overload retVal="" descr="Called when the transport's buffer drains below the low-water mark.&#10;&#10;See pause_writing() for details.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport" func="yes">
			<Overload retVal="" descr="Base class for transports.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.close" func="yes">
			<Overload retVal="" descr="Close the transport.&#10;&#10;Buffered data will be flushed asynchronously.  No more data&#10;will be received.  After all buffered data is flushed, the&#10;protocol's connection_lost() method will (eventually) called&#10;with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.get_extra_info" func="yes">
			<Overload retVal="" descr="Get optional transport information.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.get_pid" func="yes">
			<Overload retVal="" descr="Get subprocess id.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.get_pipe_transport" func="yes">
			<Overload retVal="" descr="Get transport for pipe with number fd.">
				<Param name="self" />
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.get_protocol" func="yes">
			<Overload retVal="" descr="Return the current protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.get_returncode" func="yes">
			<Overload retVal="" descr="Get subprocess returncode.&#10;&#10;See also&#10;http://docs.python.org/3/library/subprocess#subprocess.Popen.returncode">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.is_closing" func="yes">
			<Overload retVal="" descr="Return True if the transport is closing or closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.kill" func="yes">
			<Overload retVal="" descr="Kill the subprocess.&#10;&#10;On Posix OSs the function sends SIGKILL to the subprocess.&#10;On Windows kill() is an alias for terminate().&#10;&#10;See also:&#10;http://docs.python.org/3/library/subprocess#subprocess.Popen.kill">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.send_signal" func="yes">
			<Overload retVal="" descr="Send signal to subprocess.&#10;&#10;See also:&#10;docs.python.org/3/library/subprocess#subprocess.Popen.send_signal">
				<Param name="self" />
				<Param name="signal" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.set_protocol" func="yes">
			<Overload retVal="" descr="Set a new protocol.">
				<Param name="self" />
				<Param name="protocol" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.SubprocessTransport.terminate" func="yes">
			<Overload retVal="" descr="Stop the subprocess.&#10;&#10;Alias for close() method.&#10;&#10;On Posix OSs the method sends SIGTERM to the subprocess.&#10;On Windows the Win32 API function TerminateProcess()&#10; is called to stop the subprocess.&#10;&#10;See also:&#10;http://docs.python.org/3/library/subprocess#subprocess.Popen.terminate">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task" func="yes">
			<Overload retVal="" descr="A coroutine wrapped in a Future.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.add_done_callback" func="yes">
			<Overload retVal="" descr="Add a callback to be run when the future becomes done.&#10;&#10;The callback is called with a single argument - the future object. If&#10;the future is already done when this is called, the callback is&#10;scheduled with call_soon.">
				<Param name="self" />
				<Param name="fn" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.all_tasks" func="yes">
			<Overload retVal="" descr="Return a set of all tasks for an event loop.&#10;&#10;By default all tasks for the current event loop are returned.">
				<Param name="type" />
				<Param name="[loop=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.cancel" func="yes">
			<Overload retVal="" descr="Request that this task cancel itself.&#10;&#10;This arranges for a CancelledError to be thrown into the&#10;wrapped coroutine on the next cycle through the event loop.&#10;The coroutine then has a chance to clean up or even deny&#10;the request using try/except/finally.&#10;&#10;Unlike Future.cancel, this does not guarantee that the&#10;task will be cancelled: the exception might be caught and&#10;acted upon, delaying cancellation of the task or preventing&#10;cancellation completely.  The task may also return a value or&#10;raise a different exception.&#10;&#10;Immediately after this method is called, Task.cancelled() will&#10;not return True (unless the task was already cancelled).  A&#10;task will be marked as cancelled when the wrapped coroutine&#10;terminates with a CancelledError exception (even if cancel()&#10;was not called).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.cancelled" func="yes">
			<Overload retVal="" descr="Return True if the future was cancelled.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.current_task" func="yes">
			<Overload retVal="" descr="Return the currently running task in an event loop or None.&#10;&#10;By default the current task for the current event loop is returned.&#10;&#10;None is returned when called not in the context of a Task.">
				<Param name="type" />
				<Param name="[loop=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.done" func="yes">
			<Overload retVal="" descr="Return True if the future is done.&#10;&#10;Done means either that a result / exception are available, or that the&#10;future was cancelled.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.exception" func="yes">
			<Overload retVal="" descr="Return the exception that was set on this future.&#10;&#10;The exception (or None if no exception was set) is returned only if&#10;the future is done.  If the future has been cancelled, raises&#10;CancelledError.  If the future isn't done yet, raises&#10;InvalidStateError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.get_stack" func="yes">
			<Overload retVal="" descr="Return the list of stack frames for this task's coroutine.&#10;&#10;If the coroutine is not done, this returns the stack where it is&#10;suspended.  If the coroutine has completed successfully or was&#10;cancelled, this returns an empty list.  If the coroutine was&#10;terminated by an exception, this returns the list of traceback&#10;frames.&#10;&#10;The frames are always ordered from oldest to newest.&#10;&#10;The optional limit gives the maximum number of frames to&#10;return; by default all available frames are returned.  Its&#10;meaning differs depending on whether a stack or a traceback is&#10;returned: the newest frames of a stack are returned, but the&#10;oldest frames of a traceback are returned.  (This matches the&#10;behavior of the traceback module.)&#10;&#10;For reasons beyond our control, only one stack frame is&#10;returned for a suspended coroutine.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.print_stack" func="yes">
			<Overload retVal="" descr="Print the stack or traceback for this task's coroutine.&#10;&#10;This produces output similar to that of the traceback module,&#10;for the frames retrieved by get_stack().  The limit argument&#10;is passed to get_stack().  The file argument is an I/O stream&#10;to which the output is written; by default output is written&#10;to sys.stderr.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.remove_done_callback" func="yes">
			<Overload retVal="" descr='Remove all instances of a callback from the "call when done" list.&#10;&#10;Returns the number of callbacks removed.'>
				<Param name="self" />
				<Param name="fn" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.result" func="yes">
			<Overload retVal="" descr="Return the result this future represents.&#10;&#10;If the future has been cancelled, raises CancelledError.  If the&#10;future's result isn't yet available, raises InvalidStateError.  If&#10;the future is done and has an exception set, this exception is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.set_exception" func="yes">
			<Overload retVal="" descr="Mark the future done and set an exception.&#10;&#10;If the future is already done when this method is called, raises&#10;InvalidStateError.">
				<Param name="self" />
				<Param name="exception" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Task.set_result" func="yes">
			<Overload retVal="" descr="Mark the future done and set its result.&#10;&#10;If the future is already done when this method is called, raises&#10;InvalidStateError.">
				<Param name="self" />
				<Param name="res" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.TimeoutError" func="yes">
			<Overload retVal="" descr="The operation exceeded the given deadline.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.TimeoutError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.TimeoutError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.TimerHandle" func="yes">
			<Overload retVal="" descr="Object returned by timed callback registration methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.TimerHandle.cancel" />
		<KeyWord name="asyncio.Transport" func="yes">
			<Overload retVal="" descr="Interface representing a bidirectional transport.&#10;&#10;There may be several implementations, but typically, the user does&#10;not implement new transports; rather, the platform provides some&#10;useful transports that are implemented using the platform's best&#10;practices.&#10;&#10;The user never instantiates a transport directly; they call a&#10;utility function, passing it a protocol factory and other&#10;information necessary to create the transport and protocol.  (E.g.&#10;EventLoop.create_connection() or EventLoop.create_server().)&#10;&#10;The utility function will asynchronously create a transport and a&#10;protocol and hook them up by calling the protocol's&#10;connection_made() method, passing it the transport.&#10;&#10;The implementation here raises NotImplemented for every method&#10;except writelines(), which calls write() in a loop.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.abort" func="yes">
			<Overload retVal="" descr="Close the transport immediately.&#10;&#10;Buffered data will be lost.  No more data will be received.&#10;The protocol's connection_lost() method will (eventually) be&#10;called with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.can_write_eof" func="yes">
			<Overload retVal="" descr="Return True if this transport supports write_eof(), False if not.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.close" func="yes">
			<Overload retVal="" descr="Close the transport.&#10;&#10;Buffered data will be flushed asynchronously.  No more data&#10;will be received.  After all buffered data is flushed, the&#10;protocol's connection_lost() method will (eventually) called&#10;with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.get_extra_info" func="yes">
			<Overload retVal="" descr="Get optional transport information.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.get_protocol" func="yes">
			<Overload retVal="" descr="Return the current protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.get_write_buffer_size" func="yes">
			<Overload retVal="" descr="Return the current size of the write buffer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.is_closing" func="yes">
			<Overload retVal="" descr="Return True if the transport is closing or closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.pause_reading" func="yes">
			<Overload retVal="" descr="Pause the receiving end.&#10;&#10;No data will be passed to the protocol's data_received()&#10;method until resume_reading() is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.resume_reading" func="yes">
			<Overload retVal="" descr="Resume the receiving end.&#10;&#10;Data received will once again be passed to the protocol's&#10;data_received() method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.set_protocol" func="yes">
			<Overload retVal="" descr="Set a new protocol.">
				<Param name="self" />
				<Param name="protocol" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.set_write_buffer_limits" func="yes">
			<Overload retVal="" descr="Set the high- and low-water limits for write flow control.&#10;&#10;These two values control when to call the protocol's&#10;pause_writing() and resume_writing() methods.  If specified,&#10;the low-water limit must be less than or equal to the&#10;high-water limit.  Neither value can be negative.&#10;&#10;The defaults are implementation-specific.  If only the&#10;high-water limit is given, the low-water limit defaults to an&#10;implementation-specific value less than or equal to the&#10;high-water limit.  Setting high to zero forces low to zero as&#10;well, and causes pause_writing() to be called whenever the&#10;buffer becomes non-empty.  Setting low to zero causes&#10;resume_writing() to be called only once the buffer is empty.&#10;Use of zero for either limit is generally sub-optimal as it&#10;reduces opportunities for doing I/O and computation&#10;concurrently.">
				<Param name="self" />
				<Param name="[high=None" />
				<Param name="[low=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.write" func="yes">
			<Overload retVal="" descr="Write some data bytes to the transport.&#10;&#10;This does not block; it buffers the data and arranges for it&#10;to be sent out asynchronously.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.write_eof" func="yes">
			<Overload retVal="" descr="Close the write end after flushing buffered data.&#10;&#10;(This is like typing ^D into a UNIX program reading from stdin.)&#10;&#10;Data may still be received.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.Transport.writelines" func="yes">
			<Overload retVal="" descr="Write a list (or any iterable) of data bytes to the transport.&#10;&#10;The default implementation concatenates the arguments and&#10;calls write() on the result.">
				<Param name="self" />
				<Param name="list_of_data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport" func="yes">
			<Overload retVal="" descr="Interface for write-only transports.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.abort" func="yes">
			<Overload retVal="" descr="Close the transport immediately.&#10;&#10;Buffered data will be lost.  No more data will be received.&#10;The protocol's connection_lost() method will (eventually) be&#10;called with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.can_write_eof" func="yes">
			<Overload retVal="" descr="Return True if this transport supports write_eof(), False if not.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.close" func="yes">
			<Overload retVal="" descr="Close the transport.&#10;&#10;Buffered data will be flushed asynchronously.  No more data&#10;will be received.  After all buffered data is flushed, the&#10;protocol's connection_lost() method will (eventually) called&#10;with None as its argument.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.get_extra_info" func="yes">
			<Overload retVal="" descr="Get optional transport information.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.get_protocol" func="yes">
			<Overload retVal="" descr="Return the current protocol.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.get_write_buffer_size" func="yes">
			<Overload retVal="" descr="Return the current size of the write buffer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.is_closing" func="yes">
			<Overload retVal="" descr="Return True if the transport is closing or closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.set_protocol" func="yes">
			<Overload retVal="" descr="Set a new protocol.">
				<Param name="self" />
				<Param name="protocol" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.set_write_buffer_limits" func="yes">
			<Overload retVal="" descr="Set the high- and low-water limits for write flow control.&#10;&#10;These two values control when to call the protocol's&#10;pause_writing() and resume_writing() methods.  If specified,&#10;the low-water limit must be less than or equal to the&#10;high-water limit.  Neither value can be negative.&#10;&#10;The defaults are implementation-specific.  If only the&#10;high-water limit is given, the low-water limit defaults to an&#10;implementation-specific value less than or equal to the&#10;high-water limit.  Setting high to zero forces low to zero as&#10;well, and causes pause_writing() to be called whenever the&#10;buffer becomes non-empty.  Setting low to zero causes&#10;resume_writing() to be called only once the buffer is empty.&#10;Use of zero for either limit is generally sub-optimal as it&#10;reduces opportunities for doing I/O and computation&#10;concurrently.">
				<Param name="self" />
				<Param name="[high=None" />
				<Param name="[low=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.write" func="yes">
			<Overload retVal="" descr="Write some data bytes to the transport.&#10;&#10;This does not block; it buffers the data and arranges for it&#10;to be sent out asynchronously.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.write_eof" func="yes">
			<Overload retVal="" descr="Close the write end after flushing buffered data.&#10;&#10;(This is like typing ^D into a UNIX program reading from stdin.)&#10;&#10;Data may still be received.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.WriteTransport.writelines" func="yes">
			<Overload retVal="" descr="Write a list (or any iterable) of data bytes to the transport.&#10;&#10;The default implementation concatenates the arguments and&#10;calls write() on the result.">
				<Param name="self" />
				<Param name="list_of_data" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.as_completed" func="yes">
			<Overload retVal="" descr="Return an iterator whose values are coroutines.&#10;&#10;When waiting for the yielded coroutines you'll get the results (or&#10;exceptions!) of the original Futures (or coroutines), in the order&#10;in which and as soon as they complete.&#10;&#10;This differs from PEP 3148; the proper way to use this is:&#10;&#10;    for f in as_completed(fs):&#10;        result = yield from f  # The 'yield from' may raise.&#10;        # Use result.&#10;&#10;If a timeout is specified, the 'yield from' will raise&#10;TimeoutError when the timeout occurs before all Futures are done.&#10;&#10;Note: The futures 'f' are not necessarily members of fs.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.async" func="yes">
			<Overload retVal="" descr="Wrap a coroutine in a future.&#10;&#10;If the argument is a Future, it is returned directly.&#10;&#10;This function is deprecated in 3.5. Use asyncio.ensure_future() instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.coroutine" func="yes">
			<Overload retVal="" descr="Decorator to mark coroutines.&#10;&#10;If the coroutine is not yielded from before it is destroyed,&#10;an error message is logged.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.create_subprocess_exec" />
		<KeyWord name="asyncio.create_subprocess_shell" func="yes">
			<Overload retVal="" descr=>
				<Param name="cmd" />
				<Param name="[stdin=None" />
				<Param name="[stdout=None" />
				<Param name="[stderr=None" />
				<Param name="[loop=None" />
				<Param name="[limit=65536" />
				<Param name="[**]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.ensure_future" func="yes">
			<Overload retVal="" descr="Wrap a coroutine or an awaitable in a future.&#10;&#10;If the argument is a Future, it is returned directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.gather" func="yes">
			<Overload retVal="" descr="Return a future aggregating results from the given coroutines&#10;or futures.&#10;&#10;Coroutines will be wrapped in a future and scheduled in the event&#10;loop. They will not necessarily be scheduled in the same order as&#10;passed in.&#10;&#10;All futures must share the same event loop.  If all the tasks are&#10;done successfully, the returned future's result is the list of&#10;results (in the order of the original sequence, not necessarily&#10;the order of results arrival).  If *return_exceptions* is True,&#10;exceptions in the tasks are treated the same as successful&#10;results, and gathered in the result list; otherwise, the first&#10;raised exception will be immediately propagated to the returned&#10;future.&#10;&#10;Cancellation: if the outer Future is cancelled, all children (that&#10;have not completed yet) are also cancelled.  If any child is&#10;cancelled, this is treated as if it raised CancelledError --&#10;the outer Future is *not* cancelled in this case.  (This is to&#10;prevent the cancellation of one child to cause other children to&#10;be cancelled.)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.get_child_watcher" func="yes">
			<Overload retVal="" descr="Equivalent to calling get_event_loop_policy().get_child_watcher().">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.get_event_loop" func="yes">
			<Overload retVal="" descr="Return an asyncio event loop.&#10;&#10;When called from a coroutine or a callback (e.g. scheduled with call_soon&#10;or similar API), this function will always return the running event loop.&#10;&#10;If there is no running event loop set, the function will return&#10;the result of `get_event_loop_policy().get_event_loop()` call.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.get_event_loop_policy" func="yes">
			<Overload retVal="" descr="Get the current event loop policy.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.iscoroutine" func="yes">
			<Overload retVal="" descr="Return True if obj is a coroutine object.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.iscoroutinefunction" func="yes">
			<Overload retVal="" descr="Return True if func is a decorated coroutine function.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.isfuture" func="yes">
			<Overload retVal="" descr="Check for a Future.&#10;&#10;This returns True when obj is a Future instance or is advertising&#10;itself as duck-type compatible by setting _asyncio_future_blocking.&#10;See comment in Future for more details.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.new_event_loop" func="yes">
			<Overload retVal="" descr="Equivalent to calling get_event_loop_policy().new_event_loop().">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.open_connection" func="yes">
			<Overload retVal="" descr="A wrapper for create_connection() returning a (reader, writer) pair.&#10;&#10;The reader returned is a StreamReader instance; the writer is a&#10;StreamWriter instance.&#10;&#10;The arguments are all the usual arguments to create_connection()&#10;except protocol_factory; most common are positional host and port,&#10;with various optional keyword arguments following.&#10;&#10;Additional optional keyword arguments are loop (to set the event loop&#10;instance to use) and limit (to set the buffer limit passed to the&#10;StreamReader).&#10;&#10;(If you want to customize the StreamReader and/or&#10;StreamReaderProtocol classes, just copy the code -- there's&#10;really nothing special here except some convenience.)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.run_coroutine_threadsafe" func="yes">
			<Overload retVal="" descr="Submit a coroutine object to a given event loop.&#10;&#10;Return a concurrent.futures.Future to access the result.">
				<Param name="coro" />
				<Param name="loop" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.set_child_watcher" func="yes">
			<Overload retVal="" descr="Equivalent to calling&#10;get_event_loop_policy().set_child_watcher(watcher).">
				<Param name="watcher" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.set_event_loop" func="yes">
			<Overload retVal="" descr="Equivalent to calling get_event_loop_policy().set_event_loop(loop).">
				<Param name="loop" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.set_event_loop_policy" func="yes">
			<Overload retVal="" descr="Set the current event loop policy.&#10;&#10;If policy is None, the default policy is restored.">
				<Param name="policy" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.shield" func="yes">
			<Overload retVal="" descr="Wait for a future, shielding it from cancellation.&#10;&#10;The statement&#10;&#10;    res = yield from shield(something())&#10;&#10;is exactly equivalent to the statement&#10;&#10;    res = yield from something()&#10;&#10;*except* that if the coroutine containing it is cancelled, the&#10;task running in something() is not cancelled.  From the POV of&#10;something(), the cancellation did not happen.  But its caller is&#10;still cancelled, so the yield-from expression still raises&#10;CancelledError.  Note: If something() is cancelled by other means&#10;this will still cancel shield().&#10;&#10;If you want to completely ignore cancellation (not recommended)&#10;you can combine shield() with a try/except clause, as follows:&#10;&#10;    try:&#10;        res = yield from shield(something())&#10;    except CancelledError:&#10;        res = None">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.sleep" func="yes">
			<Overload retVal="" descr="Coroutine that completes after a given time (in seconds).">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.start_server" func="yes">
			<Overload retVal="" descr="Start a socket server, call back for each client connected.&#10;&#10;The first parameter, `client_connected_cb`, takes two parameters:&#10;client_reader, client_writer.  client_reader is a StreamReader&#10;object, while client_writer is a StreamWriter object.  This&#10;parameter can either be a plain callback function or a coroutine;&#10;if it is a coroutine, it will be automatically converted into a&#10;Task.&#10;&#10;The rest of the arguments are all the usual arguments to&#10;loop.create_server() except protocol_factory; most common are&#10;positional host and port, with various optional keyword arguments&#10;following.  The return value is the same as loop.create_server().&#10;&#10;Additional optional keyword arguments are loop (to set the event loop&#10;instance to use) and limit (to set the buffer limit passed to the&#10;StreamReader).&#10;&#10;The return value is the same as loop.create_server(), i.e. a&#10;Server object which can be used to stop the service.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.wait" func="yes">
			<Overload retVal="" descr="Wait for the Futures and coroutines given by fs to complete.&#10;&#10;The sequence futures must not be empty.&#10;&#10;Coroutines will be wrapped in Tasks.&#10;&#10;Returns two sets of Future: (done, pending).&#10;&#10;Usage:&#10;&#10;    done, pending = yield from asyncio.wait(fs)&#10;&#10;Note: This does not raise TimeoutError! Futures that aren't done&#10;when the timeout occurs are returned in the second set.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.wait_for" func="yes">
			<Overload retVal="" descr="Wait for the single Future or coroutine to complete, with timeout.&#10;&#10;Coroutine will be wrapped in Task.&#10;&#10;Returns result of the Future or coroutine.  When a timeout occurs,&#10;it cancels the task and raises TimeoutError.  To avoid the task&#10;cancellation, wrap it in shield().&#10;&#10;If the wait is cancelled, the task is also cancelled.&#10;&#10;This function is a coroutine.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncio.wrap_future" func="yes">
			<Overload retVal="" descr="Wrap concurrent.futures.Future object.">
			</Overload>
		</KeyWord>
        		<KeyWord name="asyncore" func="yes">
			<Overload retVal="" descr="Basic infrastructure for asynchronous socket service clients and servers.&#10;&#10;There are only two ways to have a program on a single processor do &quot;more&#10;than one thing at a time&quot;.  Multi-threaded programming is the simplest and&#10;most popular way to do it, but there is another very different technique,&#10;that lets you have nearly all the advantages of multi-threading, without&#10;actually using multiple threads. it's really only practical if your program&#10;is largely I/O bound. If your program is CPU bound, then pre-emptive&#10;scheduled threads are probably what you really need. Network servers are&#10;rarely CPU-bound, however.&#10;&#10;If your operating system supports the select() system call in its I/O&#10;library (and nearly all do), then you can use it to juggle multiple&#10;communication channels at once; doing other work while your I/O is taking&#10;place in the &quot;background.&quot;  Although this strategy can seem strange and&#10;complex, especially at first, it is in many ways easier to understand and&#10;control than multi-threaded programming. The module documented here solves&#10;many of the difficult problems for you, making the task of building&#10;sophisticated high-performance network servers and clients a snap.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EAGAIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EALREADY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EBADF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ECONNABORTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ECONNRESET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EINPROGRESS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EINVAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EISCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ENOTCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EPIPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ESHUTDOWN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.EWOULDBLOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ExitNow" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ExitNow.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.ExitNow.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.close_all" func="yes">
			<Overload retVal="" descr=>
				<Param name="[map=None" />
				<Param name="[ignore_all=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.compact_traceback" />
		<KeyWord name="asyncore.dispatcher" />
		<KeyWord name="asyncore.dispatcher.accept" />
		<KeyWord name="asyncore.dispatcher.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher.bind" />
		<KeyWord name="asyncore.dispatcher.close" />
		<KeyWord name="asyncore.dispatcher.connect" />
		<KeyWord name="asyncore.dispatcher.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher.handle_accept" />
		<KeyWord name="asyncore.dispatcher.handle_accepted" />
		<KeyWord name="asyncore.dispatcher.handle_close" />
		<KeyWord name="asyncore.dispatcher.handle_connect" />
		<KeyWord name="asyncore.dispatcher.handle_connect_event" />
		<KeyWord name="asyncore.dispatcher.handle_error" />
		<KeyWord name="asyncore.dispatcher.handle_expt" />
		<KeyWord name="asyncore.dispatcher.handle_expt_event" />
		<KeyWord name="asyncore.dispatcher.handle_read" />
		<KeyWord name="asyncore.dispatcher.handle_read_event" />
		<KeyWord name="asyncore.dispatcher.handle_write" />
		<KeyWord name="asyncore.dispatcher.handle_write_event" />
		<KeyWord name="asyncore.dispatcher.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher.listen" />
		<KeyWord name="asyncore.dispatcher.log" />
		<KeyWord name="asyncore.dispatcher.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher.readable" />
		<KeyWord name="asyncore.dispatcher.recv" />
		<KeyWord name="asyncore.dispatcher.send" />
		<KeyWord name="asyncore.dispatcher.set_reuse_addr" />
		<KeyWord name="asyncore.dispatcher.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher.writable" />
		<KeyWord name="asyncore.dispatcher_with_send" />
		<KeyWord name="asyncore.dispatcher_with_send.accept" />
		<KeyWord name="asyncore.dispatcher_with_send.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send.bind" />
		<KeyWord name="asyncore.dispatcher_with_send.close" />
		<KeyWord name="asyncore.dispatcher_with_send.connect" />
		<KeyWord name="asyncore.dispatcher_with_send.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send.handle_accept" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_accepted" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_close" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_connect" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_connect_event" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_error" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_expt" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_expt_event" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_read" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_read_event" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_write" />
		<KeyWord name="asyncore.dispatcher_with_send.handle_write_event" />
		<KeyWord name="asyncore.dispatcher_with_send.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send.initiate_send" />
		<KeyWord name="asyncore.dispatcher_with_send.listen" />
		<KeyWord name="asyncore.dispatcher_with_send.log" />
		<KeyWord name="asyncore.dispatcher_with_send.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send.readable" />
		<KeyWord name="asyncore.dispatcher_with_send.recv" />
		<KeyWord name="asyncore.dispatcher_with_send.send" />
		<KeyWord name="asyncore.dispatcher_with_send.set_reuse_addr" />
		<KeyWord name="asyncore.dispatcher_with_send.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.dispatcher_with_send.writable" />
		<KeyWord name="asyncore.errorcode" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.loop" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=30.0" />
				<Param name="[use_poll=False" />
				<Param name="[map=None" />
				<Param name="[count=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.poll" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=0.0" />
				<Param name="[map=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.poll2" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=0.0" />
				<Param name="[map=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.poll3" func="yes">
			<Overload retVal="" descr=>
				<Param name="[timeout=0.0" />
				<Param name="[map=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="asyncore.read" />
		<KeyWord name="asyncore.readwrite" />
		<KeyWord name="asyncore.write" />
        		<KeyWord name="at_eof" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="athrow" func="yes">
			<Overload retVal="" descr="Function of types.AsyncGeneratorType">
			</Overload>
		</KeyWord>
		<KeyWord name="atof" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="atoi" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="attach" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="attr_matches" func="yes">
			<Overload retVal="" descr="Function of rlcompleter.Completer">
			</Overload>
		</KeyWord>
		<KeyWord name="auth" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP_TLS">
			</Overload>
		</KeyWord>
		<KeyWord name="auth_cram_md5" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="auth_login" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="auth_plain" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="authenticate" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="authenticators" func="yes">
			<Overload retVal="" descr="Function of netrc.netrc">
			</Overload>
		</KeyWord>
		<KeyWord name="autocomplete" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="autorange" func="yes">
			<Overload retVal="" descr="Function of timeit.Timer">
			</Overload>
		</KeyWord>
		<KeyWord name="b16decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b16encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b2a_qp" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="b32decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b32encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b64decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b64encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b85decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="b85encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="backslashreplace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="bar" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="base64" func="yes">
			<Overload retVal="" descr="Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.MAXBINSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.MAXLINESIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.a85decode" func="yes">
			<Overload retVal="" descr="Decode the Ascii85 encoded bytes-like object or ASCII string b.&#10;&#10;foldspaces is a flag that specifies whether the 'y' short sequence should be&#10;accepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is&#10;not supported by the &quot;standard&quot; Adobe encoding.&#10;&#10;adobe controls whether the input sequence is in Adobe Ascii85 format (i.e.&#10;is framed with &lt;~ and ~&gt;).&#10;&#10;ignorechars should be a byte string containing characters to ignore from the&#10;input. This should only contain whitespace characters, and by default&#10;contains all whitespace characters in ASCII.&#10;&#10;The result is returned as a bytes object.">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.a85encode" func="yes">
			<Overload retVal="" descr="Encode bytes-like object b using Ascii85 and return a bytes object.&#10;&#10;foldspaces is an optional flag that uses the special short sequence 'y'&#10;instead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This&#10;feature is not supported by the &quot;standard&quot; Adobe encoding.&#10;&#10;wrapcol controls whether the output should have newline (b'\n') characters&#10;added to it. If this is non-zero, each output line will be at most this&#10;many characters long.&#10;&#10;pad controls whether the input is padded to a multiple of 4 before&#10;encoding. Note that the btoa implementation always pads.&#10;&#10;adobe controls whether the encoded byte sequence is framed with &lt;~ and ~&gt;,&#10;which is used by the Adobe implementation.">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b16decode" func="yes">
			<Overload retVal="" descr="Decode the Base16 encoded bytes-like object or ASCII string s.&#10;&#10;Optional casefold is a flag specifying whether a lowercase alphabet is&#10;acceptable as input.  For security purposes, the default is False.&#10;&#10;The result is returned as a bytes object.  A binascii.Error is raised if&#10;s is incorrectly padded or if there are non-alphabet characters present&#10;in the input.">
				<Param name="s" />
				<Param name="[casefold=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b16encode" func="yes">
			<Overload retVal="" descr="Encode the bytes-like object s using Base16 and return a bytes object.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b32decode" func="yes">
			<Overload retVal="" descr="Decode the Base32 encoded bytes-like object or ASCII string s.&#10;&#10;Optional casefold is a flag specifying whether a lowercase alphabet is&#10;acceptable as input.  For security purposes, the default is False.&#10;&#10;RFC 3548 allows for optional mapping of the digit 0 (zero) to the&#10;letter O (oh), and for optional mapping of the digit 1 (one) to&#10;either the letter I (eye) or letter L (el).  The optional argument&#10;map01 when not None, specifies which letter the digit 1 should be&#10;mapped to (when map01 is not None, the digit 0 is always mapped to&#10;the letter O).  For security purposes the default is None, so that&#10;0 and 1 are not allowed in the input.&#10;&#10;The result is returned as a bytes object.  A binascii.Error is raised if&#10;the input is incorrectly padded or if there are non-alphabet&#10;characters present in the input.">
				<Param name="s" />
				<Param name="[casefold=False" />
				<Param name="[map01=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b32encode" func="yes">
			<Overload retVal="" descr="Encode the bytes-like object s using Base32 and return a bytes object.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b64decode" func="yes">
			<Overload retVal="" descr="Decode the Base64 encoded bytes-like object or ASCII string s.&#10;&#10;Optional altchars must be a bytes-like object or ASCII string of length 2&#10;which specifies the alternative alphabet used instead of the '+' and '/'&#10;characters.&#10;&#10;The result is returned as a bytes object.  A binascii.Error is raised if&#10;s is incorrectly padded.&#10;&#10;If validate is False (the default), characters that are neither in the&#10;normal base-64 alphabet nor the alternative alphabet are discarded prior&#10;to the padding check.  If validate is True, these non-alphabet characters&#10;in the input result in a binascii.Error.">
				<Param name="s" />
				<Param name="[altchars=None" />
				<Param name="[validate=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b64encode" func="yes">
			<Overload retVal="" descr="Encode the bytes-like object s using Base64 and return a bytes object.&#10;&#10;Optional altchars should be a byte string of length 2 which specifies an&#10;alternative alphabet for the '+' and '/' characters.  This allows an&#10;application to e.g. generate url or filesystem safe Base64 strings.">
				<Param name="s" />
				<Param name="[altchars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b85decode" func="yes">
			<Overload retVal="" descr="Decode the base85-encoded bytes-like object or ASCII string b&#10;&#10;The result is returned as a bytes object.">
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.b85encode" func="yes">
			<Overload retVal="" descr="Encode bytes-like object b in base85 format and return a bytes object.&#10;&#10;If pad is true, the input is padded with b'\0' so its length is a multiple of&#10;4 bytes before encoding.">
				<Param name="b" />
				<Param name="[pad=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.bytes_types" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.decode" func="yes">
			<Overload retVal="" descr="Decode a file; input and output are binary files.">
				<Param name="input" />
				<Param name="output" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.decodebytes" func="yes">
			<Overload retVal="" descr="Decode a bytestring of base-64 data into a bytes object.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.decodestring" func="yes">
			<Overload retVal="" descr="Legacy alias of decodebytes().">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.encode" func="yes">
			<Overload retVal="" descr="Encode a file; input and output are binary files.">
				<Param name="input" />
				<Param name="output" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.encodebytes" func="yes">
			<Overload retVal="" descr="Encode a bytestring into a bytes object containing multiple lines&#10;of base-64 data.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.encodestring" func="yes">
			<Overload retVal="" descr="Legacy alias of encodebytes().">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.main" func="yes">
			<Overload retVal="" descr="Small main program">
			</Overload>
		</KeyWord>
		<KeyWord name="base64.standard_b64decode" func="yes">
			<Overload retVal="" descr="Decode bytes encoded with the standard Base64 alphabet.&#10;&#10;Argument s is a bytes-like object or ASCII string to decode.  The result&#10;is returned as a bytes object.  A binascii.Error is raised if the input&#10;is incorrectly padded.  Characters that are not in the standard alphabet&#10;are discarded prior to the padding check.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.standard_b64encode" func="yes">
			<Overload retVal="" descr="Encode bytes-like object s using the standard Base64 alphabet.&#10;&#10;The result is returned as a bytes object.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.test" />
		<KeyWord name="base64.urlsafe_b64decode" func="yes">
			<Overload retVal="" descr="Decode bytes using the URL- and filesystem-safe Base64 alphabet.&#10;&#10;Argument s is a bytes-like object or ASCII string to decode.  The result&#10;is returned as a bytes object.  A binascii.Error is raised if the input&#10;is incorrectly padded.  Characters that are not in the URL-safe base-64&#10;alphabet, and are not a plus '+' or slash '/', are discarded prior to the&#10;padding check.&#10;&#10;The alphabet uses '-' instead of '+' and '_' instead of '/'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="base64.urlsafe_b64encode" func="yes">
			<Overload retVal="" descr="Encode bytes using the URL- and filesystem-safe Base64 alphabet.&#10;&#10;Argument s is a bytes-like object to encode.  The result is returned as a&#10;bytes object.  The alphabet uses '-' instead of '+' and '_' instead of&#10;'/'.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="basename" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="basicConfig" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb" func="yes">
			<Overload retVal="" descr="Debugger basics">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb" func="yes">
			<Overload retVal="" descr="Generic Python debugger base class.&#10;&#10;This class takes care of details of the trace facility;&#10;a derived class should implement user interaction.&#10;The standard debugger class (pdb.Pdb) is an example.">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.break_anywhere" />
		<KeyWord name="bdb.Bdb.break_here" />
		<KeyWord name="bdb.Bdb.canonic" />
		<KeyWord name="bdb.Bdb.clear_all_breaks" />
		<KeyWord name="bdb.Bdb.clear_all_file_breaks" />
		<KeyWord name="bdb.Bdb.clear_bpbynumber" />
		<KeyWord name="bdb.Bdb.clear_break" />
		<KeyWord name="bdb.Bdb.dispatch_call" />
		<KeyWord name="bdb.Bdb.dispatch_exception" />
		<KeyWord name="bdb.Bdb.dispatch_line" />
		<KeyWord name="bdb.Bdb.dispatch_return" />
		<KeyWord name="bdb.Bdb.do_clear" />
		<KeyWord name="bdb.Bdb.format_stack_entry" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="frame_lineno" />
				<Param name="[lprefix=: ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.get_all_breaks" />
		<KeyWord name="bdb.Bdb.get_bpbynumber" />
		<KeyWord name="bdb.Bdb.get_break" />
		<KeyWord name="bdb.Bdb.get_breaks" />
		<KeyWord name="bdb.Bdb.get_file_breaks" />
		<KeyWord name="bdb.Bdb.get_stack" />
		<KeyWord name="bdb.Bdb.is_skipped_module" />
		<KeyWord name="bdb.Bdb.reset" />
		<KeyWord name="bdb.Bdb.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.runctx" />
		<KeyWord name="bdb.Bdb.runeval" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="expr" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.set_break" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[temporary=False" />
				<Param name="[cond=None" />
				<Param name="[funcname=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.set_continue" />
		<KeyWord name="bdb.Bdb.set_next" func="yes">
			<Overload retVal="" descr="Stop on the next line in or below the given frame.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.set_quit" />
		<KeyWord name="bdb.Bdb.set_return" func="yes">
			<Overload retVal="" descr="Stop when returning from the given frame.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.set_step" func="yes">
			<Overload retVal="" descr="Stop after one line of code.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.set_trace" func="yes">
			<Overload retVal="" descr="Start debugging from `frame`.&#10;&#10;If frame is not specified, debugging starts from caller's frame.">
				<Param name="self" />
				<Param name="[frame=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.set_until" func="yes">
			<Overload retVal="" descr="Stop when the line with the line no greater than the current one is&#10;reached or when returning from current frame">
				<Param name="self" />
				<Param name="frame" />
				<Param name="[lineno=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.stop_here" />
		<KeyWord name="bdb.Bdb.trace_dispatch" />
		<KeyWord name="bdb.Bdb.user_call" func="yes">
			<Overload retVal="" descr="This method is called when there is the remote possibility&#10;that we ever need to stop in this function.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="argument_list" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.user_exception" func="yes">
			<Overload retVal="" descr="This method is called if an exception occurs,&#10;but only if we are to stop at or just below this level.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="exc_info" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.user_line" func="yes">
			<Overload retVal="" descr="This method is called when we stop or break at this line.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Bdb.user_return" func="yes">
			<Overload retVal="" descr="This method is called when a return trap is set here.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="return_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.BdbQuit" func="yes">
			<Overload retVal="" descr="Exception to give up completely.">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.BdbQuit.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.BdbQuit.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Breakpoint" func="yes">
			<Overload retVal="" descr="Breakpoint class.&#10;&#10;Implements temporary breakpoints, ignore counts, disabling and&#10;(re)-enabling, and conditionals.&#10;&#10;Breakpoints are indexed by number through bpbynumber and by&#10;the file,line tuple using bplist.  The former points to a&#10;single instance of class Breakpoint.  The latter points to a&#10;list of such instances since there may be more than one&#10;breakpoint per line.">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Breakpoint.bpbynumber" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Breakpoint.bpformat" />
		<KeyWord name="bdb.Breakpoint.bpprint" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[out=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Breakpoint.deleteMe" />
		<KeyWord name="bdb.Breakpoint.disable" />
		<KeyWord name="bdb.Breakpoint.enable" />
		<KeyWord name="bdb.Breakpoint.next" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.CO_GENERATOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb" func="yes">
			<Overload retVal="" descr="Generic Python debugger base class.&#10;&#10;This class takes care of details of the trace facility;&#10;a derived class should implement user interaction.&#10;The standard debugger class (pdb.Pdb) is an example.">
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.break_anywhere" />
		<KeyWord name="bdb.Tdb.break_here" />
		<KeyWord name="bdb.Tdb.canonic" />
		<KeyWord name="bdb.Tdb.clear_all_breaks" />
		<KeyWord name="bdb.Tdb.clear_all_file_breaks" />
		<KeyWord name="bdb.Tdb.clear_bpbynumber" />
		<KeyWord name="bdb.Tdb.clear_break" />
		<KeyWord name="bdb.Tdb.dispatch_call" />
		<KeyWord name="bdb.Tdb.dispatch_exception" />
		<KeyWord name="bdb.Tdb.dispatch_line" />
		<KeyWord name="bdb.Tdb.dispatch_return" />
		<KeyWord name="bdb.Tdb.do_clear" />
		<KeyWord name="bdb.Tdb.format_stack_entry" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="frame_lineno" />
				<Param name="[lprefix=: ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.get_all_breaks" />
		<KeyWord name="bdb.Tdb.get_bpbynumber" />
		<KeyWord name="bdb.Tdb.get_break" />
		<KeyWord name="bdb.Tdb.get_breaks" />
		<KeyWord name="bdb.Tdb.get_file_breaks" />
		<KeyWord name="bdb.Tdb.get_stack" />
		<KeyWord name="bdb.Tdb.is_skipped_module" />
		<KeyWord name="bdb.Tdb.reset" />
		<KeyWord name="bdb.Tdb.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.runctx" />
		<KeyWord name="bdb.Tdb.runeval" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="expr" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.set_break" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[temporary=False" />
				<Param name="[cond=None" />
				<Param name="[funcname=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.set_continue" />
		<KeyWord name="bdb.Tdb.set_next" func="yes">
			<Overload retVal="" descr="Stop on the next line in or below the given frame.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.set_quit" />
		<KeyWord name="bdb.Tdb.set_return" func="yes">
			<Overload retVal="" descr="Stop when returning from the given frame.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.set_step" func="yes">
			<Overload retVal="" descr="Stop after one line of code.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.set_trace" func="yes">
			<Overload retVal="" descr="Start debugging from `frame`.&#10;&#10;If frame is not specified, debugging starts from caller's frame.">
				<Param name="self" />
				<Param name="[frame=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.set_until" func="yes">
			<Overload retVal="" descr="Stop when the line with the line no greater than the current one is&#10;reached or when returning from current frame">
				<Param name="self" />
				<Param name="frame" />
				<Param name="[lineno=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.stop_here" />
		<KeyWord name="bdb.Tdb.trace_dispatch" />
		<KeyWord name="bdb.Tdb.user_call" func="yes">
			<Overload retVal="" descr="This method is called when there is the remote possibility&#10;that we ever need to stop in this function.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="args" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.user_exception" func="yes">
			<Overload retVal="" descr="This method is called if an exception occurs,&#10;but only if we are to stop at or just below this level.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="exc_stuff" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.user_line" func="yes">
			<Overload retVal="" descr="This method is called when we stop or break at this line.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.Tdb.user_return" func="yes">
			<Overload retVal="" descr="This method is called when a return trap is set here.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="retval" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.bar" />
		<KeyWord name="bdb.checkfuncname" func="yes">
			<Overload retVal="" descr="Check whether we should break here because of `b.funcname`.">
				<Param name="b" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.effective" func="yes">
			<Overload retVal="" descr="Determine which breakpoint for this file:line is to be acted upon.&#10;&#10;Called only if we know there is a bpt at this&#10;location.  Returns breakpoint that was triggered and a flag&#10;that indicates if it is ok to delete a temporary bp.">
				<Param name="file" />
				<Param name="line" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="bdb.foo" />
		<KeyWord name="bdb.set_trace" />
		<KeyWord name="bdb.test" />
        		<KeyWord name="before_get" func="yes">
			<Overload retVal="" descr="Function of configparser.BasicInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="before_read" func="yes">
			<Overload retVal="" descr="Function of configparser.BasicInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="before_set" func="yes">
			<Overload retVal="" descr="Function of configparser.BasicInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="before_write" func="yes">
			<Overload retVal="" descr="Function of configparser.BasicInterpolation">
			</Overload>
		</KeyWord>
		<KeyWord name="best_match" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.AvailableDistributions">
			</Overload>
		</KeyWord>
		<KeyWord name="betavariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="bidirectional" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="bigsection" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="bin" func="yes">
			<Overload retVal="" descr="Return the binary representation of an integer.&#10;&#10;&gt;&gt;&gt; bin(2796202)&#10;'0b1010101010101010101010'">
				<Param name="number" />
			</Overload>
		</KeyWord>
		<KeyWord name="bind" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="bind_partial" func="yes">
			<Overload retVal="" descr="Function of inspect.Signature">
			</Overload>
		</KeyWord>
		<KeyWord name="bind_textdomain_codeset" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="bindtextdomain" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex" func="yes">
			<Overload retVal="" descr="Macintosh binhex compression/decompression.&#10;&#10;easy interface:&#10;binhex(inputfilename, outputfilename)&#10;hexbin(inputfilename, outputfilename)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.BinHex" />
		<KeyWord name="binhex.BinHex.close" />
		<KeyWord name="binhex.BinHex.close_data" />
		<KeyWord name="binhex.BinHex.write" />
		<KeyWord name="binhex.BinHex.write_rsrc" />
		<KeyWord name="binhex.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.FInfo" />
		<KeyWord name="binhex.HexBin" />
		<KeyWord name="binhex.HexBin.close" />
		<KeyWord name="binhex.HexBin.close_data" />
		<KeyWord name="binhex.HexBin.read" />
		<KeyWord name="binhex.HexBin.read_rsrc" />
		<KeyWord name="binhex.LINELEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.REASONABLY_LARGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.RUNCHAR" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.binhex" func="yes">
			<Overload retVal="" descr="binhex(infilename, outfilename): create binhex-encoded copy of a file">
				<Param name="inp" />
				<Param name="out" />
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.getfileinfo" />
		<KeyWord name="binhex.hexbin" func="yes">
			<Overload retVal="" descr="hexbin(infilename, outfilename) - Decode binhexed file">
				<Param name="inp" />
				<Param name="out" />
			</Overload>
		</KeyWord>
		<KeyWord name="binhex.openrsrc" />
		<KeyWord name="binhex.openrsrc.close" />
		<KeyWord name="binhex.openrsrc.read" />
		<KeyWord name="binhex.openrsrc.write" />
		<KeyWord name="bisect" func="yes">
			<Overload retVal="" descr="Bisection algorithms.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.bisect" func="yes">
			<Overload retVal="" descr="Alias for bisect_right().">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.bisect_left" func="yes">
			<Overload retVal="" descr="bisect_left(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt; x, and all e in&#10;a[i:] have e &gt;= x.  So if x already appears in the list, i points just&#10;before the leftmost x already there.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.bisect_right" func="yes">
			<Overload retVal="" descr="bisect_right(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt;= x, and all e in&#10;a[i:] have e &gt; x.  So if x already appears in the list, i points just&#10;beyond the rightmost x already there&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.insort" func="yes">
			<Overload retVal="" descr="Alias for insort_right().">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.insort_left" func="yes">
			<Overload retVal="" descr="insort_left(a, x[, lo[, hi]])&#10;&#10;Insert item x in list a, and keep it sorted assuming a is sorted.&#10;&#10;If x is already in a, insert it to the left of the leftmost x.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect.insort_right" func="yes">
			<Overload retVal="" descr="insort_right(a, x[, lo[, hi]])&#10;&#10;Insert item x in list a, and keep it sorted assuming a is sorted.&#10;&#10;If x is already in a, insert it to the right of the rightmost x.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect_left" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="bisect_right" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="bitmap" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="blake2b" func="yes">
			<Overload retVal="" descr="Function of hashlib.blake2b">
			</Overload>
		</KeyWord>
		<KeyWord name="blake2s" func="yes">
			<Overload retVal="" descr="Function of hashlib.blake2s">
			</Overload>
		</KeyWord>
		<KeyWord name="bltn_open" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="body" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="bold" func="yes">
			<Overload retVal="" descr="Function of pydoc.TextDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="bool" func="yes">
			<Overload retVal="" descr="bool(x) -&gt; bool&#10;&#10;Returns True when the argument x is true, False otherwise.&#10;The builtins True and False are the only two instances of the class bool.&#10;The class bool is a subclass of the class int, and cannot be subclassed.">
			</Overload>
		</KeyWord>
		<KeyWord name="bootstrap" func="yes">
			<Overload retVal="" descr="Function of ensurepip">
			</Overload>
		</KeyWord>
		<KeyWord name="bp_commands" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="bpformat" func="yes">
			<Overload retVal="" descr="Function of bdb.Breakpoint">
			</Overload>
		</KeyWord>
		<KeyWord name="bpprint" func="yes">
			<Overload retVal="" descr="Function of bdb.Breakpoint">
			</Overload>
		</KeyWord>
		<KeyWord name="break" />
		<KeyWord name="break_anywhere" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="break_here" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="browse" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="build" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.MemoizedZipManifests">
			</Overload>
		</KeyWord>
		<KeyWord name="byref" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="bytearray" func="yes">
			<Overload retVal="" descr="bytearray(iterable_of_ints) -&gt; bytearray&#10;bytearray(string, encoding[, errors]) -&gt; bytearray&#10;bytearray(bytes_or_buffer) -&gt; mutable copy of bytes_or_buffer&#10;bytearray(int) -&gt; bytes array of size given by the parameter initialized with null bytes&#10;bytearray() -&gt; empty bytes array&#10;&#10;Construct a mutable bytearray object from:&#10;  - an iterable yielding integers in range(256)&#10;  - a text string encoded using the specified encoding&#10;  - a bytes or a buffer object&#10;  - any object implementing the buffer API.&#10;  - an integer">
			</Overload>
		</KeyWord>
		<KeyWord name="bytes" func="yes">
			<Overload retVal="" descr="bytes(iterable_of_ints) -&gt; bytes&#10;bytes(string, encoding[, errors]) -&gt; bytes&#10;bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer&#10;bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes&#10;bytes() -&gt; empty bytes object&#10;&#10;Construct an immutable array of bytes from:&#10;  - an iterable yielding integers in range(256)&#10;  - a text string encoded using the specified encoding&#10;  - any object implementing the buffer API.&#10;  - an integer">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2" func="yes">
			<Overload retVal="" descr="Interface to the libbzip2 compression library.&#10;&#10;This module provides a file interface, classes for incremental&#10;(de)compression, and functions for one-shot (de)compression.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Compressor" func="yes">
			<Overload retVal="" descr="Create a compressor object for compressing data incrementally.&#10;&#10;  compresslevel&#10;    Compression level, as a number between 1 and 9.&#10;&#10;For one-shot compression, use the compress() function instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Compressor.compress" func="yes">
			<Overload retVal="" descr="Provide data to the compressor object.&#10;&#10;Returns a chunk of compressed data if possible, or b'' otherwise.&#10;&#10;When you have finished providing data to the compressor, call the&#10;flush() method to finish the compression process.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Compressor.flush" func="yes">
			<Overload retVal="" descr="Finish the compression process.&#10;&#10;Returns the compressed data left in internal buffers.&#10;&#10;The compressor object may not be used after this method is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor" func="yes">
			<Overload retVal="" descr="Create a decompressor object for decompressing data incrementally.&#10;&#10;For one-shot decompression, use the decompress() function instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor.decompress" func="yes">
			<Overload retVal="" descr="Decompress *data*, returning uncompressed data as bytes.&#10;&#10;If *max_length* is nonnegative, returns at most *max_length* bytes of&#10;decompressed data. If this limit is reached and further output can be&#10;produced, *self.needs_input* will be set to ``False``. In this case, the next&#10;call to *decompress()* may provide *data* as b'' to obtain more of the output.&#10;&#10;If all of the input data was decompressed and returned (either because this&#10;was less than *max_length* bytes, or because *max_length* was negative),&#10;*self.needs_input* will be set to True.&#10;&#10;Attempting to decompress data after the end of stream is reached raises an&#10;EOFError.  Any data found after the end of the stream is ignored and saved in&#10;the unused_data attribute.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[max_length=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor.eof" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor.needs_input" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2Decompressor.unused_data" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.BZ2File" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.RLock" func="yes">
			<Overload retVal="" descr="Factory function that returns a new reentrant lock.&#10;&#10;A reentrant lock must be released by the thread that acquired it. Once a&#10;thread has acquired a reentrant lock, the same thread may acquire it again&#10;without blocking; the thread must release it once for each time it has&#10;acquired it.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.compress" func="yes">
			<Overload retVal="" descr="Compress a block of data.&#10;&#10;compresslevel, if given, must be a number between 1 and 9.&#10;&#10;For incremental compression, use a BZ2Compressor object instead.">
				<Param name="data" />
				<Param name="[compresslevel=9]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.decompress" func="yes">
			<Overload retVal="" descr="Decompress a block of data.&#10;&#10;For incremental decompression, use a BZ2Decompressor object instead.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2.open" func="yes">
			<Overload retVal="" descr='Open a bzip2-compressed file in binary or text mode.&#10;&#10;The filename argument can be an actual filename (a str, bytes, or&#10;PathLike object), or an existing file object to read from or write&#10;to.&#10;&#10;The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or&#10;"ab" for binary mode, or "rt", "wt", "xt" or "at" for text mode.&#10;The default mode is "rb", and the default compresslevel is 9.&#10;&#10;For binary mode, this function is equivalent to the BZ2File&#10;constructor: BZ2File(filename, mode, compresslevel). In this case,&#10;the encoding, errors and newline arguments must not be provided.&#10;&#10;For text mode, a BZ2File object is created, and wrapped in an&#10;io.TextIOWrapper instance with the specified encoding, error&#10;handling behavior, and line ending(s).'>
				<Param name="filename" />
				<Param name="[mode=rb" />
				<Param name="[compresslevel=9" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="bz2open" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="c2py" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile" func="yes">
			<Overload retVal="" descr="Python interface for the 'lsprof' profiler.&#10;Compatible with the 'profile' module.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile" func="yes">
			<Overload retVal="" descr="Profile(custom_timer=None, time_unit=None, subcalls=True, builtins=True)&#10;&#10;Builds a profiler object using the specified timer function.&#10;The default timer is a fast built-in one based on real time.&#10;For custom timer functions returning integers, time_unit can&#10;be a float specifying a scale (i.e. how long each integer unit&#10;is, in seconds).">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.clear" func="yes">
			<Overload retVal="" descr="clear()&#10;&#10;Clear all profiling information collected so far.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.create_stats" />
		<KeyWord name="cProfile.Profile.disable" func="yes">
			<Overload retVal="" descr="disable()&#10;&#10;Stop collecting profiling information.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.dump_stats" />
		<KeyWord name="cProfile.Profile.enable" func="yes">
			<Overload retVal="" descr="enable(subcalls=True, builtins=True)&#10;&#10;Start collecting profiling information.&#10;If 'subcalls' is True, also records for each function&#10;statistics separated according to its current caller.&#10;If 'builtins' is True, records the time spent in&#10;built-in functions separately from their caller.">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.getstats" func="yes">
			<Overload retVal="" descr="getstats() -&gt; list of profiler_entry objects&#10;&#10;Return all information collected by the profiler.&#10;Each profiler_entry is a tuple-like object with the&#10;following attributes:&#10;&#10;    code          code object&#10;    callcount     how many times this was called&#10;    reccallcount  how many times called recursively&#10;    totaltime     total time in this entry&#10;    inlinetime    inline time in this entry (not in subcalls)&#10;    calls         details of the calls&#10;&#10;The calls attribute is either None or a list of&#10;profiler_subentry objects:&#10;&#10;    code          called code object&#10;    callcount     how many times this is called&#10;    reccallcount  how many times this is called recursively&#10;    totaltime     total time spent in this call&#10;    inlinetime    inline time (not in further subcalls)">
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.print_stats" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[sort=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.run" />
		<KeyWord name="cProfile.Profile.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.Profile.runctx" />
		<KeyWord name="cProfile.Profile.snapshot_stats" />
		<KeyWord name="cProfile.label" />
		<KeyWord name="cProfile.main" />
		<KeyWord name="cProfile.run" func="yes">
			<Overload retVal="" descr='Run statement under profiler optionally saving results in filename&#10;&#10;This function takes a single argument that can be passed to the&#10;"exec" statement, and an optional file name.  In all cases this&#10;routine attempts to "exec" its first argument and gather profiling&#10;statistics from the execution. If no file name is present, then this&#10;function automatically prints a simple profiling report, sorted by the&#10;standard name string (file/line/function-name) that is presented in&#10;each line.'>
				<Param name="statement" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cProfile.runctx" func="yes">
			<Overload retVal="" descr="Run statement under profiler, supplying your own globals and locals,&#10;optionally saving results in filename.&#10;&#10;statement and filename have the same semantics as profile.run">
				<Param name="statement" />
				<Param name="globals" />
				<Param name="locals" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="c_buffer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="cache_from_source" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="calc_callees" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="calc_chksums" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="calcsize" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar" func="yes">
			<Overload retVal="" descr="Calendar printing functions&#10;&#10;Note when comparing these calendars to the ones printed by cal(1): By&#10;default, these calendars have Monday as the first day of the week, and&#10;Sunday as the last (the European convention). Use setfirstweekday() to&#10;set the first day of the week (0=Monday, 6=Sunday).">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar" func="yes">
			<Overload retVal="" descr="Base calendar class. This class doesn't do any formatting. It simply&#10;provides data to subclasses.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.getfirstweekday" />
		<KeyWord name="calendar.Calendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return an iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.setfirstweekday" />
		<KeyWord name="calendar.Calendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.Calendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.EPOCH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.FRIDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.February" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar" func="yes">
			<Overload retVal="" descr="This calendar returns complete HTML pages.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.cssclasses" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatday" func="yes">
			<Overload retVal="" descr="Return a day as a table cell.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a formatted month as a table.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr="Return a month name as a table row.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Return a complete week as a table row.">
				<Param name="self" />
				<Param name="theweek" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatweekday" func="yes">
			<Overload retVal="" descr="Return a weekday name as a table header.">
				<Param name="self" />
				<Param name="day" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week as a table row.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Return a formatted year as a table of tables.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.formatyearpage" func="yes">
			<Overload retVal="" descr="Return a formatted year as a complete HTML page.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3" />
				<Param name="[css=calendar.css" />
				<Param name="[encoding=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.getfirstweekday" />
		<KeyWord name="calendar.HTMLCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return an iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.setfirstweekday" />
		<KeyWord name="calendar.HTMLCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.HTMLCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalMonthError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalMonthError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalMonthError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalWeekdayError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalWeekdayError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.IllegalWeekdayError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.January" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar" func="yes">
			<Overload retVal="" descr="This class can be passed a locale name in the constructor and will return&#10;month and weekday names in the specified locale. If this locale includes&#10;an encoding all strings containing month and weekday names will be returned&#10;as unicode.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.cssclasses" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatday" func="yes">
			<Overload retVal="" descr="Return a day as a table cell.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a formatted month as a table.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr="Return a month name as a table row.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Return a complete week as a table row.">
				<Param name="self" />
				<Param name="theweek" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatweekday" func="yes">
			<Overload retVal="" descr="Return a weekday name as a table header.">
				<Param name="self" />
				<Param name="day" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week as a table row.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Return a formatted year as a table of tables.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.formatyearpage" func="yes">
			<Overload retVal="" descr="Return a formatted year as a complete HTML page.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[width=3" />
				<Param name="[css=calendar.css" />
				<Param name="[encoding=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.getfirstweekday" />
		<KeyWord name="calendar.LocaleHTMLCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return an iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.setfirstweekday" />
		<KeyWord name="calendar.LocaleHTMLCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleHTMLCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar" func="yes">
			<Overload retVal="" descr="This class can be passed a locale name in the constructor and will return&#10;month and weekday names in the specified locale. If this locale includes&#10;an encoding all strings containing month and weekday names will be returned&#10;as unicode.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatday" func="yes">
			<Overload retVal="" descr="Returns a formatted day.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a month's calendar string (multi-line).">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr="Return a formatted month name.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="width" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Returns a single week in a string (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatweekday" func="yes">
			<Overload retVal="" descr="Returns a formatted week day name.">
				<Param name="self" />
				<Param name="day" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week.">
				<Param name="self" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Returns a year's calendar as a multi-line string.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=2" />
				<Param name="[l=1" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.getfirstweekday" />
		<KeyWord name="calendar.LocaleTextCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return an iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.prmonth" func="yes">
			<Overload retVal="" descr="Print a month's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.prweek" func="yes">
			<Overload retVal="" descr="Print a single week (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.pryear" func="yes">
			<Overload retVal="" descr="Print a year's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=0" />
				<Param name="[l=0" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.setfirstweekday" />
		<KeyWord name="calendar.LocaleTextCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.LocaleTextCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.SATURDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.SUNDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.THURSDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TUESDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar" func="yes">
			<Overload retVal="" descr="Subclass of Calendar that outputs a calendar as a simple plain text&#10;similar to the UNIX program cal.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.firstweekday" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatday" func="yes">
			<Overload retVal="" descr="Returns a formatted day.">
				<Param name="self" />
				<Param name="day" />
				<Param name="weekday" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatmonth" func="yes">
			<Overload retVal="" descr="Return a month's calendar string (multi-line).">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatmonthname" func="yes">
			<Overload retVal="" descr="Return a formatted month name.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="width" />
				<Param name="[withyear=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatweek" func="yes">
			<Overload retVal="" descr="Returns a single week in a string (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatweekday" func="yes">
			<Overload retVal="" descr="Returns a formatted week day name.">
				<Param name="self" />
				<Param name="day" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatweekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week.">
				<Param name="self" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.formatyear" func="yes">
			<Overload retVal="" descr="Returns a year's calendar as a multi-line string.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=2" />
				<Param name="[l=1" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.getfirstweekday" />
		<KeyWord name="calendar.TextCalendar.itermonthdates" func="yes">
			<Overload retVal="" descr="Return an iterator for one month. The iterator will yield datetime.date&#10;values and will always iterate through complete weeks, so it will yield&#10;dates outside the specified month.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.itermonthdays" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield day numbers. For days outside&#10;the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.itermonthdays2" func="yes">
			<Overload retVal="" descr="Like itermonthdates(), but will yield (day number, weekday number)&#10;tuples. For days outside the specified month the day number is 0.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.iterweekdays" func="yes">
			<Overload retVal="" descr="Return an iterator for one week of weekday numbers starting with the&#10;configured first one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.monthdatescalendar" func="yes">
			<Overload retVal="" descr="Return a matrix (list of lists) representing a month's calendar.&#10;Each row represents a week; week entries are datetime.date values.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.monthdays2calendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; week entries are&#10;(day number, weekday number) tuples. Day numbers outside this month&#10;are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.monthdayscalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.prmonth" func="yes">
			<Overload retVal="" descr="Print a month's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.prweek" func="yes">
			<Overload retVal="" descr="Print a single week (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.pryear" func="yes">
			<Overload retVal="" descr="Print a year's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=0" />
				<Param name="[l=0" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.setfirstweekday" />
		<KeyWord name="calendar.TextCalendar.yeardatescalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting. The return&#10;value is a list of month rows. Each month row contains up to width months.&#10;Each month contains between 4 and 6 weeks and each week contains 1-7&#10;days. Days are datetime.date objects.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.yeardays2calendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are&#10;(day number, weekday number) tuples. Day numbers outside this month are&#10;zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.TextCalendar.yeardayscalendar" func="yes">
			<Overload retVal="" descr="Return the data for the specified year ready for formatting (similar to&#10;yeardatescalendar()). Entries in the week lists are day numbers.&#10;Day numbers outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="[width=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.WEDNESDAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.c" func="yes">
			<Overload retVal="" descr="(TextCalendar)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.calendar" func="yes">
			<Overload retVal="" descr="Returns a year's calendar as a multi-line string.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=2" />
				<Param name="[l=1" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.day_abbr" func="yes">
			<Overload retVal="" descr="(_localized_day)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.day_name" func="yes">
			<Overload retVal="" descr="(_localized_day)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.different_locale" />
		<KeyWord name="calendar.error" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.firstweekday" />
		<KeyWord name="calendar.format" func="yes">
			<Overload retVal="" descr="Prints multi-column formatting for year calendars">
				<Param name="cols" />
				<Param name="[colwidth=20" />
				<Param name="[spacing=6]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.formatstring" func="yes">
			<Overload retVal="" descr="Returns a string formatted from n strings, centered within n columns.">
				<Param name="cols" />
				<Param name="[colwidth=20" />
				<Param name="[spacing=6]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.isleap" func="yes">
			<Overload retVal="" descr="Return True for leap years, False for non-leap years.">
				<Param name="year" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.leapdays" func="yes">
			<Overload retVal="" descr="Return number of leap years in range [y1, y2).&#10;Assume y1 &lt;= y2.">
				<Param name="y1" />
				<Param name="y2" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.main" />
		<KeyWord name="calendar.mdays" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.month" func="yes">
			<Overload retVal="" descr="Return a month's calendar string (multi-line).">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.month_abbr" func="yes">
			<Overload retVal="" descr="(_localized_month)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.month_name" func="yes">
			<Overload retVal="" descr="(_localized_month)">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.monthcalendar" func="yes">
			<Overload retVal="" descr="Return a matrix representing a month's calendar.&#10;Each row represents a week; days outside this month are zero.">
				<Param name="self" />
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.monthrange" func="yes">
			<Overload retVal="" descr="Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for&#10;year, month.">
				<Param name="year" />
				<Param name="month" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.prcal" func="yes">
			<Overload retVal="" descr="Print a year's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="[w=0" />
				<Param name="[l=0" />
				<Param name="[c=6" />
				<Param name="[m=3]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.prmonth" func="yes">
			<Overload retVal="" descr="Print a month's calendar.">
				<Param name="self" />
				<Param name="theyear" />
				<Param name="themonth" />
				<Param name="[w=0" />
				<Param name="[l=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.prweek" func="yes">
			<Overload retVal="" descr="Print a single week (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.repeat" func="yes">
			<Overload retVal="" descr="repeat(object [,times]) -&gt; create an iterator which returns the object&#10;for the specified number of times.  If not specified, returns the object&#10;endlessly.">
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.setfirstweekday" />
		<KeyWord name="calendar.timegm" func="yes">
			<Overload retVal="" descr="Unrelated but handy function to calculate Unix timestamp from GMT.">
				<Param name="tuple" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.week" func="yes">
			<Overload retVal="" descr="Returns a single week in a string (no newline).">
				<Param name="self" />
				<Param name="theweek" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.weekday" func="yes">
			<Overload retVal="" descr="Return weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12),&#10;day (1-31).">
				<Param name="year" />
				<Param name="month" />
				<Param name="day" />
			</Overload>
		</KeyWord>
		<KeyWord name="calendar.weekheader" func="yes">
			<Overload retVal="" descr="Return a header for a week.">
				<Param name="self" />
				<Param name="width" />
			</Overload>
		</KeyWord>
		<KeyWord name="calibrate" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="call" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="callHandlers" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="call_at" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="call_exception_handler" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="call_later" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="call_soon" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="call_soon_threadsafe" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="callable" func="yes">
			<Overload retVal="" descr="Return whether the object is callable (i.e., some kind of function).&#10;&#10;Note that classes are callable, as are instances of classes with a&#10;__call__() method.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="can_add" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.AvailableDistributions">
			</Overload>
		</KeyWord>
		<KeyWord name="can_write_eof" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="cancel" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="cancelled" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="canonic" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="canonical" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="capa" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="capabilities" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="capability" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; str&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="captureWarnings" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="capwords" func="yes">
			<Overload retVal="" descr="Function of string">
			</Overload>
		</KeyWord>
		<KeyWord name="casefold" func="yes">
			<Overload retVal="" descr="S.casefold() -&gt; str&#10;&#10;Return a version of S suitable for caseless comparisons.">
			</Overload>
		</KeyWord>
		<KeyWord name="cast" func="yes">
			<Overload retVal="" descr="Cast a memoryview to a new format or shape.">
			</Overload>
		</KeyWord>
		<KeyWord name="category" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="ccc" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP_TLS">
			</Overload>
		</KeyWord>
		<KeyWord name="center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; str&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="cert_store_stats" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="cert_time_to_seconds" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi" func="yes">
			<Overload retVal="" descr="Support module for CGI (Common Gateway Interface) scripts.&#10;&#10;This module defines a number of utilities for use by CGI scripts&#10;written in Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO" func="yes">
			<Overload retVal="" descr="Buffered I/O implementation using an in-memory bytes buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.close" func="yes">
			<Overload retVal="" descr="Disable all I/O operations.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.flush" func="yes">
			<Overload retVal="" descr="Does nothing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.getbuffer" func="yes">
			<Overload retVal="" descr="Get a read-write view over the contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.isatty" func="yes">
			<Overload retVal="" descr="Always returns False.&#10;&#10;BytesIO objects are not connected to a TTY-like device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.read1" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.readinto" func="yes">
			<Overload retVal="" descr="Read bytes into buffer.&#10;&#10;Returns number of bytes read (0 for EOF), or None if the object&#10;is set not to block and has no data to read.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.readinto1" />
		<KeyWord name="cgi.BytesIO.readline" func="yes">
			<Overload retVal="" descr="Next line from the file, as a bytes object.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.readlines" func="yes">
			<Overload retVal="" descr="List of bytes objects, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to byte offset pos relative to position indicated by whence:&#10;     0  Start of stream (the default).  pos should be &gt;= 0;&#10;     1  Current position - pos may be negative;&#10;     2  End of stream - pos usually negative.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.tell" func="yes">
			<Overload retVal="" descr="Current file position, an integer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is unchanged.  Returns the new size.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.write" func="yes">
			<Overload retVal="" descr="Write bytes to file.&#10;&#10;Return the number of bytes written.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.BytesIO.writelines" func="yes">
			<Overload retVal="" descr="Write lines to the file.&#10;&#10;Note that newlines are not added.  lines can be any iterable object&#10;producing bytes-like objects. This is equivalent to calling write() for&#10;each element.">
				<Param name="self" />
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FeedParser" func="yes">
			<Overload retVal="" descr="A feed-style parser of email.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FeedParser.close" func="yes">
			<Overload retVal="" descr="Parse all remaining data and return the root message object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FeedParser.feed" func="yes">
			<Overload retVal="" descr="Push more data into the parser.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage" func="yes">
			<Overload retVal="" descr="Store a sequence of fields, reading multipart/form-data.&#10;&#10;This class provides naming, typing, files stored on disk, and&#10;more.  At the top level, it is accessible like a dictionary, whose&#10;keys are the field names.  (Note: None can occur as a field name.)&#10;The items are either a Python list (if there's multiple values) or&#10;another FieldStorage or MiniFieldStorage object.  If it's a single&#10;object, it has the following attributes:&#10;&#10;name: the field name, if specified; otherwise None&#10;&#10;filename: the filename, if specified; otherwise None; this is the&#10;    client side filename, *not* the file name on which it is&#10;    stored (that's a temporary file you don't deal with)&#10;&#10;value: the value as a *string*; for file uploads, this&#10;    transparently reads the file every time you request the value&#10;    and returns *bytes*&#10;&#10;file: the file(-like) object from which you can read the data *as&#10;    bytes* ; None if the data is stored a simple string&#10;&#10;type: the content-type, or None if not specified&#10;&#10;type_options: dictionary of options specified on the content-type&#10;    line&#10;&#10;disposition: content-disposition, or None if not specified&#10;&#10;disposition_options: dictionary of corresponding options&#10;&#10;headers: a dictionary(-like) object (sometimes email.message.Message or a&#10;    subclass thereof) containing *all* headers&#10;&#10;The class is subclassable, mostly for the purpose of overriding&#10;the make_file() method, which is called internally to come up with&#10;a file open for reading and writing.  This makes it possible to&#10;override the default choice of storing all files in a temporary&#10;directory and unlinking them as soon as they have been opened.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.bufsize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.getfirst" func="yes">
			<Overload retVal="" descr="Return the first value received.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.getlist" func="yes">
			<Overload retVal="" descr="Return list of received values.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.getvalue" func="yes">
			<Overload retVal="" descr="Dictionary style get() method, including 'value' lookup.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.keys" func="yes">
			<Overload retVal="" descr="Dictionary style keys() method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.make_file" func="yes">
			<Overload retVal="" descr="Overridable: return a readable &amp; writable file.&#10;&#10;The file will be used as follows:&#10;- data is written to it&#10;- seek(0)&#10;- data is read from it&#10;&#10;The file is opened in binary mode for files, in text mode&#10;for other fields&#10;&#10;This version opens a temporary file for reading and writing,&#10;and immediately deletes (unlinks) it.  The trick (on Unix!) is&#10;that the file can still be used, but it can't be opened by&#10;another process, and it will automatically be deleted when it&#10;is closed or when the current process terminates.&#10;&#10;If you want a more permanent file, you derive a class which&#10;overrides this method.  If you want a visible temporary file&#10;that is nevertheless automatically deleted when the script&#10;terminates, try defining a __del__ method in a derived class&#10;which unlinks the temporary files you have created.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_binary" func="yes">
			<Overload retVal="" descr="Internal: read binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_lines" func="yes">
			<Overload retVal="" descr="Internal: read lines until EOF or outerboundary.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_lines_to_eof" func="yes">
			<Overload retVal="" descr="Internal: read lines until EOF.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_lines_to_outerboundary" func="yes">
			<Overload retVal="" descr="Internal: read lines until outerboundary.&#10;Data is read as bytes: boundaries and line ends must be converted&#10;to bytes for comparisons.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_multi" func="yes">
			<Overload retVal="" descr="Internal: read a part that is itself multipart.">
				<Param name="self" />
				<Param name="environ" />
				<Param name="keep_blank_values" />
				<Param name="strict_parsing" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_single" func="yes">
			<Overload retVal="" descr="Internal: read an atomic part.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.read_urlencoded" func="yes">
			<Overload retVal="" descr="Internal: read data in query string format.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.FieldStorage.skip_lines" func="yes">
			<Overload retVal="" descr="Internal: skip lines until outer boundary if defined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Mapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message" func="yes">
			<Overload retVal="" descr="Basic message object.&#10;&#10;A message object is defined as something that has a bunch of RFC 2822&#10;headers and a payload.  It may optionally have an envelope header&#10;(a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a&#10;multipart or a message/rfc822), then the payload is a list of Message&#10;objects, otherwise it is a string.&#10;&#10;Message objects implement part of the `mapping' interface, which assumes&#10;there is exactly one occurrence of the header per message.  Some headers&#10;do in fact appear multiple times (e.g. Received) and for those headers,&#10;you must use the explicit API to set or get all the headers.  Not all of&#10;the mapping methods are implemented.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fu?baller.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fu?baller.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.get_unixfrom" />
		<KeyWord name="cgi.Message.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.set_unixfrom" />
		<KeyWord name="cgi.Message.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.Message.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.MiniFieldStorage" func="yes">
			<Overload retVal="" descr="Like FieldStorage, for use when no file uploads are possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO" func="yes">
			<Overload retVal="" descr="Text I/O implementation using an in-memory buffer.&#10;&#10;The initial_value argument sets the value of object.  The newline&#10;argument is like the one of TextIOWrapper's constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.close" func="yes">
			<Overload retVal="" descr="Close the IO object.&#10;&#10;Attempting any further operation after the object is closed&#10;will raise a ValueError.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.encoding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.line_buffering" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.read" func="yes">
			<Overload retVal="" descr="Read at most size characters, returned as a string.&#10;&#10;If the argument is negative or omitted, read until EOF&#10;is reached. Return an empty string at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to character offset pos relative to position indicated by whence:&#10;    0  Start of stream (the default).  pos should be &gt;= 0;&#10;    1  Current position - pos must be 0;&#10;    2  End of stream - pos must be 0.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.tell" func="yes">
			<Overload retVal="" descr="Tell the current file position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate size to pos.&#10;&#10;The pos argument defaults to the current file position, as&#10;returned by tell().  The current file position is unchanged.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.write" func="yes">
			<Overload retVal="" descr="Write string to file.&#10;&#10;Returns the number of characters written, which is always equal to&#10;the length of the string.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.StringIO.writelines" />
		<KeyWord name="cgi.TextIOWrapper" func="yes">
			<Overload retVal="" descr="Character and line based layer over a BufferedIOBase object, buffer.&#10;&#10;encoding gives the name of the encoding that the stream will be&#10;decoded or encoded with. It defaults to locale.getpreferredencoding(False).&#10;&#10;errors determines the strictness of encoding and decoding (see&#10;help(codecs.Codec) or the documentation for codecs.register) and&#10;defaults to &quot;strict&quot;.&#10;&#10;newline controls how line endings are handled. It can be None, '',&#10;'\n', '\r', and '\r\n'.  It works as follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If line_buffering is True, a call to flush is implied when a call to&#10;write contains a newline character.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.buffer" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.line_buffering" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.read" func="yes">
			<Overload retVal="" descr="Read at most n characters from stream.&#10;&#10;Read from underlying buffer until we have n characters or we hit EOF.&#10;If n is negative or omitted, read until EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="cookie" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.write" func="yes">
			<Overload retVal="" descr="Write string to stream.&#10;Returns the number of characters written (which is always equal to&#10;the length of the string).">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.TextIOWrapper.writelines" />
		<KeyWord name="cgi.closelog" func="yes">
			<Overload retVal="" descr="Close the log file.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.dolog" func="yes">
			<Overload retVal="" descr="Write a log message to the log file.  See initlog() for docs.">
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.escape" func="yes">
			<Overload retVal="" descr="Deprecated API.">
				<Param name="s" />
				<Param name="[quote=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.initlog" func="yes">
			<Overload retVal="" descr="Write a log message, if there is a log file.&#10;&#10;Even though this function is called initlog(), you should always&#10;use log(); log is a variable that is set either to initlog&#10;(initially), to dolog (once the log file has been opened), or to&#10;nolog (when logging is disabled).&#10;&#10;The first argument is a format string; the remaining arguments (if&#10;any) are arguments to the % operator, so e.g.&#10;    log(&quot;%s: %s&quot;, &quot;a&quot;, &quot;b&quot;)&#10;will write &quot;a: b&quot; to the log file, followed by a newline.&#10;&#10;If the global logfp is not None, it should be a file object to&#10;which log data is written.&#10;&#10;If the global logfp is None, the global logfile may be a string&#10;giving a filename to open, in append mode.  This file should be&#10;world writable!!!  If the file can't be opened, logging is&#10;silently disabled (since there is no safe place where we could&#10;send an error message).">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.log" func="yes">
			<Overload retVal="" descr="Write a log message, if there is a log file.&#10;&#10;Even though this function is called initlog(), you should always&#10;use log(); log is a variable that is set either to initlog&#10;(initially), to dolog (once the log file has been opened), or to&#10;nolog (when logging is disabled).&#10;&#10;The first argument is a format string; the remaining arguments (if&#10;any) are arguments to the % operator, so e.g.&#10;    log(&quot;%s: %s&quot;, &quot;a&quot;, &quot;b&quot;)&#10;will write &quot;a: b&quot; to the log file, followed by a newline.&#10;&#10;If the global logfp is not None, it should be a file object to&#10;which log data is written.&#10;&#10;If the global logfp is None, the global logfile may be a string&#10;giving a filename to open, in append mode.  This file should be&#10;world writable!!!  If the file can't be opened, logging is&#10;silently disabled (since there is no safe place where we could&#10;send an error message).">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.nolog" func="yes">
			<Overload retVal="" descr="Dummy function, assigned to log when logging is disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse" func="yes">
			<Overload retVal="" descr="Parse a query in the environment or from a file (default stdin)&#10;&#10;Arguments, all optional:&#10;&#10;fp              : file pointer; default: sys.stdin.buffer&#10;&#10;environ         : environment dictionary; default: os.environ&#10;&#10;keep_blank_values: flag indicating whether blank values in&#10;    percent-encoded forms should be treated as blank strings.&#10;    A true value indicates that blanks should be retained as&#10;    blank strings.  The default false value indicates that&#10;    blank values are to be ignored and treated as if they were&#10;    not included.&#10;&#10;strict_parsing: flag indicating what to do with parsing errors.&#10;    If false (the default), errors are silently ignored.&#10;    If true, errors raise a ValueError exception.">
				<Param name="[fp=None" />
				<Param name="[environ=environ({'ACLOCAL_PATH': 'C:\\Program Files\\Git\\mingw64\\share\\aclocal;C:\\Program Files\\Git\\usr\\share\\aclocal', 'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\aleks_000\\AppData\\Roaming', 'CLASSPATH': '%DERBY_HOME%\\lib\\derby.jar;%DERBY_HOME%\\lib\\derbytools.jar;%DERBY_HOME%/lib/derbyoptionaltools.jar', 'COMMONPROGRAMFILES': 'C:\\Program Files (x86)\\Common Files', 'COMPUTERNAME': 'ZYGMUNT', 'COMSPEC': 'C:\\Windows\\system32\\cmd.exe', 'COMMONPROGRAMFILES(X86)': 'C:\\Program Files (x86)\\Common Files', 'COMMONPROGRAMW6432': 'C:\\Program Files\\Common Files', 'DISPLAY': 'needs-to-be-defined', 'DOCKER_TOOLBOX_INSTALL_PATH': 'C:\\Program Files\\Docker Toolbox', 'ESET_OPTIONS': '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ', 'EXEPATH': 'C:\\Program Files\\Git', 'FP_NO_HOST_CHECK': 'NO', 'HOME': 'C:\\Users\\aleks_000', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\Users\\aleks_000', 'HOSTNAME': 'zygmunt', 'INFOPATH': 'C:\\Program Files\\Git\\usr\\local\\info;C:\\Program Files\\Git\\usr\\share\\info;C:\\Program Files\\Git\\usr\\info;C:\\Program Files\\Git\\share\\info', 'JAVA_HOME': 'C:\\Program Files\\Java\\jdk1.8.0_92', 'LANG': 'ru_RU.UTF-8', 'LOCALAPPDATA': 'C:\\Users\\aleks_000\\AppData\\Local', 'LOGONSERVER': '\\\\MicrosoftAccount', 'MANPATH': 'C:\\Program Files\\Git\\mingw64\\share\\man;C:\\Program Files\\Git\\usr\\local\\man;C:\\Program Files\\Git\\usr\\share\\man;C:\\Program Files\\Git\\usr\\man;C:\\Program Files\\Git\\share\\man', 'MSYSTEM': 'MINGW64', 'NUMBER_OF_PROCESSORS': '4', 'OS': 'Windows_NT', 'PATH': 'C:\\Users\\aleks_000\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\local\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\aleks_000\\bin;C:\\Program Files (x86)\\Python36-32\\Scripts;C:\\Program Files (x86)\\Python36-32;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Broadcom\\Broadcom 802.11 Network Adapter;C:\\Program Files (x86)\\Intel\\iCLS Client;C:\\Program Files\\Intel\\iCLS Client;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files (x86)\\Acer\\abFiles;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files\\WIDCOMM\\Bluetooth Software;C:\\Program Files\\WIDCOMM\\Bluetooth Software\\syswow64;C:\\Program Files (x86)\\Skype\\Phone;C:\\bin;C:\\Program Files\\Java\\jdk1.8.0_92\\bin;C:\\Program Files\\Graphviz;%DERBY_HOME%\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\Docker Toolbox;C:\\Program Files (x86)\\NPP;C:\\Program Files (x86)\\Selenium;C:\\Program Files\\Git\\usr\\bin\\vendor_perl;C:\\Program Files\\Git\\usr\\bin\\core_perl', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW', 'PKG_CONFIG_PATH': 'C:\\Program Files\\Git\\mingw64\\lib\\pkgconfig;C:\\Program Files\\Git\\mingw64\\share\\pkgconfig', 'PLINK_PROTOCOL': 'ssh', 'PRINTER': 'Send To OneNote 2013', 'PROCESSOR_ARCHITECTURE': 'x86', 'PROCESSOR_ARCHITEW6432': 'AMD64', 'PROCESSOR_IDENTIFIER': 'Intel64 Family 6 Model 69 Stepping 1, GenuineIntel', 'PROCESSOR_LEVEL': '6', 'PROCESSOR_REVISION': '4501', 'PROGRAMFILES': 'C:\\Program Files (x86)', 'PS1': '\\[\\033]0;$TITLEPREFIX:${PWD//[^[:ascii:]]/?}\\007\\]\\n\\[\\033[32m\\]\\u@\\h \\[\\033[35m\\]$MSYSTEM \\[\\033[33m\\]\\w\\[\\033[36m\\]`__git_ps1`\\[\\033[0m\\]\\n$ ', 'PSMODULEPATH': 'C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\', 'PUBLIC': 'C:\\Users\\Public', 'PWD': 'C:/Temp/python tdd', 'PYTHONIOENCODING': 'utf-8', 'PROGRAMDATA': 'C:\\ProgramData', 'PROGRAMFILES(X86)': 'C:\\Program Files (x86)', 'PROGRAMW6432': 'C:\\Program Files', 'SESSIONNAME': 'Console', 'SHELL': 'C:\\Program Files\\Git\\usr\\bin\\bash', 'SHLVL': '1', 'SSH_ASKPASS': 'C:/Program Files/Git/mingw64/libexec/git-core/git-gui--askpass', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\Windows', 'TEMP': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'TERM': 'xterm', 'TMP': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'TMPDIR': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'USERDOMAIN': 'ZYGMUNT', 'USERDOMAIN_ROAMINGPROFILE': 'ZYGMUNT', 'USERNAME': 'aleks_000', 'USERPROFILE': 'C:\\Users\\aleks_000', 'VBOX_MSI_INSTALL_PATH': 'C:\\Program Files\\Oracle\\VirtualBox\\', 'WINDIR': 'C:\\Windows', '_': 'C:/Program Files (x86)/Python36-32/python'})" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_header" func="yes">
			<Overload retVal="" descr="Parse a Content-type like header.&#10;&#10;Return the main content-type and a dictionary of options.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_multipart" func="yes">
			<Overload retVal="" descr="Parse multipart input.&#10;&#10;Arguments:&#10;fp   : input file&#10;pdict: dictionary containing other parameters of content-type header&#10;&#10;Returns a dictionary just like parse_qs(): keys are the field names, each&#10;value is a list of values for that field.  This is easy to use but not&#10;much good if you are expecting megabytes to be uploaded -- in that case,&#10;use the FieldStorage class instead which is much more flexible.  Note&#10;that content-type is the raw, unparsed contents of the content-type&#10;header.&#10;&#10;XXX This does not parse nested multipart parts -- use FieldStorage for&#10;that.&#10;&#10;XXX This should really be subsumed by FieldStorage altogether -- no&#10;point in having two implementations of the same parsing algorithm.&#10;Also, FieldStorage protects itself better against certain DoS attacks&#10;by limiting the size of the data read in one chunk.  The API here&#10;does not support that kind of protection.  This also affects parse()&#10;since it can call parse_multipart().">
				<Param name="fp" />
				<Param name="pdict" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_qs" func="yes">
			<Overload retVal="" descr="Parse a query given as a string argument.">
				<Param name="qs" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.parse_qsl" func="yes">
			<Overload retVal="" descr="Parse a query given as a string argument.">
				<Param name="qs" />
				<Param name="[keep_blank_values=0" />
				<Param name="[strict_parsing=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_arguments" />
		<KeyWord name="cgi.print_directory" func="yes">
			<Overload retVal="" descr="Dump the current directory as HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_environ" func="yes">
			<Overload retVal="" descr="Dump the shell environment as HTML.">
				<Param name="[environ=environ({'ACLOCAL_PATH': 'C:\\Program Files\\Git\\mingw64\\share\\aclocal;C:\\Program Files\\Git\\usr\\share\\aclocal', 'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\aleks_000\\AppData\\Roaming', 'CLASSPATH': '%DERBY_HOME%\\lib\\derby.jar;%DERBY_HOME%\\lib\\derbytools.jar;%DERBY_HOME%/lib/derbyoptionaltools.jar', 'COMMONPROGRAMFILES': 'C:\\Program Files (x86)\\Common Files', 'COMPUTERNAME': 'ZYGMUNT', 'COMSPEC': 'C:\\Windows\\system32\\cmd.exe', 'COMMONPROGRAMFILES(X86)': 'C:\\Program Files (x86)\\Common Files', 'COMMONPROGRAMW6432': 'C:\\Program Files\\Common Files', 'DISPLAY': 'needs-to-be-defined', 'DOCKER_TOOLBOX_INSTALL_PATH': 'C:\\Program Files\\Docker Toolbox', 'ESET_OPTIONS': '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ', 'EXEPATH': 'C:\\Program Files\\Git', 'FP_NO_HOST_CHECK': 'NO', 'HOME': 'C:\\Users\\aleks_000', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\Users\\aleks_000', 'HOSTNAME': 'zygmunt', 'INFOPATH': 'C:\\Program Files\\Git\\usr\\local\\info;C:\\Program Files\\Git\\usr\\share\\info;C:\\Program Files\\Git\\usr\\info;C:\\Program Files\\Git\\share\\info', 'JAVA_HOME': 'C:\\Program Files\\Java\\jdk1.8.0_92', 'LANG': 'ru_RU.UTF-8', 'LOCALAPPDATA': 'C:\\Users\\aleks_000\\AppData\\Local', 'LOGONSERVER': '\\\\MicrosoftAccount', 'MANPATH': 'C:\\Program Files\\Git\\mingw64\\share\\man;C:\\Program Files\\Git\\usr\\local\\man;C:\\Program Files\\Git\\usr\\share\\man;C:\\Program Files\\Git\\usr\\man;C:\\Program Files\\Git\\share\\man', 'MSYSTEM': 'MINGW64', 'NUMBER_OF_PROCESSORS': '4', 'OS': 'Windows_NT', 'PATH': 'C:\\Users\\aleks_000\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\local\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\aleks_000\\bin;C:\\Program Files (x86)\\Python36-32\\Scripts;C:\\Program Files (x86)\\Python36-32;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Broadcom\\Broadcom 802.11 Network Adapter;C:\\Program Files (x86)\\Intel\\iCLS Client;C:\\Program Files\\Intel\\iCLS Client;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files (x86)\\Acer\\abFiles;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files\\WIDCOMM\\Bluetooth Software;C:\\Program Files\\WIDCOMM\\Bluetooth Software\\syswow64;C:\\Program Files (x86)\\Skype\\Phone;C:\\bin;C:\\Program Files\\Java\\jdk1.8.0_92\\bin;C:\\Program Files\\Graphviz;%DERBY_HOME%\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\Docker Toolbox;C:\\Program Files (x86)\\NPP;C:\\Program Files (x86)\\Selenium;C:\\Program Files\\Git\\usr\\bin\\vendor_perl;C:\\Program Files\\Git\\usr\\bin\\core_perl', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW', 'PKG_CONFIG_PATH': 'C:\\Program Files\\Git\\mingw64\\lib\\pkgconfig;C:\\Program Files\\Git\\mingw64\\share\\pkgconfig', 'PLINK_PROTOCOL': 'ssh', 'PRINTER': 'Send To OneNote 2013', 'PROCESSOR_ARCHITECTURE': 'x86', 'PROCESSOR_ARCHITEW6432': 'AMD64', 'PROCESSOR_IDENTIFIER': 'Intel64 Family 6 Model 69 Stepping 1, GenuineIntel', 'PROCESSOR_LEVEL': '6', 'PROCESSOR_REVISION': '4501', 'PROGRAMFILES': 'C:\\Program Files (x86)', 'PS1': '\\[\\033]0;$TITLEPREFIX:${PWD//[^[:ascii:]]/?}\\007\\]\\n\\[\\033[32m\\]\\u@\\h \\[\\033[35m\\]$MSYSTEM \\[\\033[33m\\]\\w\\[\\033[36m\\]`__git_ps1`\\[\\033[0m\\]\\n$ ', 'PSMODULEPATH': 'C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\', 'PUBLIC': 'C:\\Users\\Public', 'PWD': 'C:/Temp/python tdd', 'PYTHONIOENCODING': 'utf-8', 'PROGRAMDATA': 'C:\\ProgramData', 'PROGRAMFILES(X86)': 'C:\\Program Files (x86)', 'PROGRAMW6432': 'C:\\Program Files', 'SESSIONNAME': 'Console', 'SHELL': 'C:\\Program Files\\Git\\usr\\bin\\bash', 'SHLVL': '1', 'SSH_ASKPASS': 'C:/Program Files/Git/mingw64/libexec/git-core/git-gui--askpass', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\Windows', 'TEMP': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'TERM': 'xterm', 'TMP': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'TMPDIR': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'USERDOMAIN': 'ZYGMUNT', 'USERDOMAIN_ROAMINGPROFILE': 'ZYGMUNT', 'USERNAME': 'aleks_000', 'USERPROFILE': 'C:\\Users\\aleks_000', 'VBOX_MSI_INSTALL_PATH': 'C:\\Program Files\\Oracle\\VirtualBox\\', 'WINDIR': 'C:\\Windows', '_': 'C:/Program Files (x86)/Python36-32/python'})]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_environ_usage" func="yes">
			<Overload retVal="" descr="Dump a list of environment variables used by CGI as HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_exception" func="yes">
			<Overload retVal="" descr=>
				<Param name="[type=None" />
				<Param name="[value=None" />
				<Param name="[tb=None" />
				<Param name="[limit=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.print_form" func="yes">
			<Overload retVal="" descr="Dump the contents of a form as HTML.">
				<Param name="form" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.test" func="yes">
			<Overload retVal="" descr="Robust test CGI script, usable as main program.&#10;&#10;Write minimal HTTP headers and dump all information provided to&#10;the script in HTML form.">
				<Param name="[environ=environ({'ACLOCAL_PATH': 'C:\\Program Files\\Git\\mingw64\\share\\aclocal;C:\\Program Files\\Git\\usr\\share\\aclocal', 'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\aleks_000\\AppData\\Roaming', 'CLASSPATH': '%DERBY_HOME%\\lib\\derby.jar;%DERBY_HOME%\\lib\\derbytools.jar;%DERBY_HOME%/lib/derbyoptionaltools.jar', 'COMMONPROGRAMFILES': 'C:\\Program Files (x86)\\Common Files', 'COMPUTERNAME': 'ZYGMUNT', 'COMSPEC': 'C:\\Windows\\system32\\cmd.exe', 'COMMONPROGRAMFILES(X86)': 'C:\\Program Files (x86)\\Common Files', 'COMMONPROGRAMW6432': 'C:\\Program Files\\Common Files', 'DISPLAY': 'needs-to-be-defined', 'DOCKER_TOOLBOX_INSTALL_PATH': 'C:\\Program Files\\Docker Toolbox', 'ESET_OPTIONS': '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ', 'EXEPATH': 'C:\\Program Files\\Git', 'FP_NO_HOST_CHECK': 'NO', 'HOME': 'C:\\Users\\aleks_000', 'HOMEDRIVE': 'C:', 'HOMEPATH': '\\Users\\aleks_000', 'HOSTNAME': 'zygmunt', 'INFOPATH': 'C:\\Program Files\\Git\\usr\\local\\info;C:\\Program Files\\Git\\usr\\share\\info;C:\\Program Files\\Git\\usr\\info;C:\\Program Files\\Git\\share\\info', 'JAVA_HOME': 'C:\\Program Files\\Java\\jdk1.8.0_92', 'LANG': 'ru_RU.UTF-8', 'LOCALAPPDATA': 'C:\\Users\\aleks_000\\AppData\\Local', 'LOGONSERVER': '\\\\MicrosoftAccount', 'MANPATH': 'C:\\Program Files\\Git\\mingw64\\share\\man;C:\\Program Files\\Git\\usr\\local\\man;C:\\Program Files\\Git\\usr\\share\\man;C:\\Program Files\\Git\\usr\\man;C:\\Program Files\\Git\\share\\man', 'MSYSTEM': 'MINGW64', 'NUMBER_OF_PROCESSORS': '4', 'OS': 'Windows_NT', 'PATH': 'C:\\Users\\aleks_000\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\local\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\aleks_000\\bin;C:\\Program Files (x86)\\Python36-32\\Scripts;C:\\Program Files (x86)\\Python36-32;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Program Files\\Broadcom\\Broadcom 802.11 Network Adapter;C:\\Program Files (x86)\\Intel\\iCLS Client;C:\\Program Files\\Intel\\iCLS Client;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files (x86)\\Acer\\abFiles;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL;C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\IPT;C:\\Program Files\\WIDCOMM\\Bluetooth Software;C:\\Program Files\\WIDCOMM\\Bluetooth Software\\syswow64;C:\\Program Files (x86)\\Skype\\Phone;C:\\bin;C:\\Program Files\\Java\\jdk1.8.0_92\\bin;C:\\Program Files\\Graphviz;%DERBY_HOME%\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\Docker Toolbox;C:\\Program Files (x86)\\NPP;C:\\Program Files (x86)\\Selenium;C:\\Program Files\\Git\\usr\\bin\\vendor_perl;C:\\Program Files\\Git\\usr\\bin\\core_perl', 'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW', 'PKG_CONFIG_PATH': 'C:\\Program Files\\Git\\mingw64\\lib\\pkgconfig;C:\\Program Files\\Git\\mingw64\\share\\pkgconfig', 'PLINK_PROTOCOL': 'ssh', 'PRINTER': 'Send To OneNote 2013', 'PROCESSOR_ARCHITECTURE': 'x86', 'PROCESSOR_ARCHITEW6432': 'AMD64', 'PROCESSOR_IDENTIFIER': 'Intel64 Family 6 Model 69 Stepping 1, GenuineIntel', 'PROCESSOR_LEVEL': '6', 'PROCESSOR_REVISION': '4501', 'PROGRAMFILES': 'C:\\Program Files (x86)', 'PS1': '\\[\\033]0;$TITLEPREFIX:${PWD//[^[:ascii:]]/?}\\007\\]\\n\\[\\033[32m\\]\\u@\\h \\[\\033[35m\\]$MSYSTEM \\[\\033[33m\\]\\w\\[\\033[36m\\]`__git_ps1`\\[\\033[0m\\]\\n$ ', 'PSMODULEPATH': 'C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\', 'PUBLIC': 'C:\\Users\\Public', 'PWD': 'C:/Temp/python tdd', 'PYTHONIOENCODING': 'utf-8', 'PROGRAMDATA': 'C:\\ProgramData', 'PROGRAMFILES(X86)': 'C:\\Program Files (x86)', 'PROGRAMW6432': 'C:\\Program Files', 'SESSIONNAME': 'Console', 'SHELL': 'C:\\Program Files\\Git\\usr\\bin\\bash', 'SHLVL': '1', 'SSH_ASKPASS': 'C:/Program Files/Git/mingw64/libexec/git-core/git-gui--askpass', 'SYSTEMDRIVE': 'C:', 'SYSTEMROOT': 'C:\\Windows', 'TEMP': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'TERM': 'xterm', 'TMP': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'TMPDIR': 'C:\\Users\\ALEKS_~1\\AppData\\Local\\Temp', 'USERDOMAIN': 'ZYGMUNT', 'USERDOMAIN_ROAMINGPROFILE': 'ZYGMUNT', 'USERNAME': 'aleks_000', 'USERPROFILE': 'C:\\Users\\aleks_000', 'VBOX_MSI_INSTALL_PATH': 'C:\\Program Files\\Oracle\\VirtualBox\\', 'WINDIR': 'C:\\Windows', '_': 'C:/Program Files (x86)/Python36-32/python'})]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgi.valid_boundary" />
		<KeyWord name="cgi.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb" func="yes">
			<Overload retVal="" descr="More comprehensive traceback formatting for Python scripts.&#10;&#10;To enable this module, do:&#10;&#10;    import cgitb; cgitb.enable()&#10;&#10;at the top of your script.  The optional arguments to enable() are:&#10;&#10;    display     - if true, tracebacks are displayed in the web browser&#10;    logdir      - if set, tracebacks are written to files in this directory&#10;    context     - number of lines of source code to show for each stack frame&#10;    format      - 'text' or 'html' controls the output format&#10;&#10;By default, tracebacks are displayed but not saved, the context is 5 lines&#10;and the output format is 'html' (for backwards compatibility with the&#10;original use of this module)&#10;&#10;Alternatively, if you have caught an exception and want cgitb to display it&#10;for you, call cgitb.handler().  The optional argument to handler() is a&#10;3-item tuple (etype, evalue, etb) just like the value of sys.exc_info().&#10;The default handler displays output as HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.Hook" func="yes">
			<Overload retVal="" descr="A hook to replace sys.excepthook that shows tracebacks in HTML.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.Hook.handle" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[info=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.enable" func="yes">
			<Overload retVal="" descr="Install an exception handler that formats tracebacks as HTML.&#10;&#10;The optional argument 'display' can be set to 0 to suppress sending the&#10;traceback to the browser, and 'logdir' can be set to a directory to cause&#10;tracebacks to be written to files there.">
				<Param name="[display=1" />
				<Param name="[logdir=None" />
				<Param name="[context=5" />
				<Param name="[format=html]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.grey" />
		<KeyWord name="cgitb.handler" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[info=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.html" func="yes">
			<Overload retVal="" descr="Return a nice HTML document describing a given traceback.">
				<Param name="einfo" />
				<Param name="[context=5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.lookup" func="yes">
			<Overload retVal="" descr="Find the value for a given name in the given environment.">
				<Param name="name" />
				<Param name="frame" />
				<Param name="locals" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.reset" func="yes">
			<Overload retVal="" descr="Return a string that resets the CGI and browser to a known state.">
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.scanvars" func="yes">
			<Overload retVal="" descr="Scan one logical line of Python and look up values of variables used.">
				<Param name="reader" />
				<Param name="frame" />
				<Param name="locals" />
			</Overload>
		</KeyWord>
		<KeyWord name="cgitb.small" />
		<KeyWord name="cgitb.strong" />
		<KeyWord name="cgitb.text" func="yes">
			<Overload retVal="" descr="Return a plain text document describing a given traceback.">
				<Param name="einfo" />
				<Param name="[context=5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="chain" func="yes">
			<Overload retVal="" descr="Function of statistics.chain">
			</Overload>
		</KeyWord>
		<KeyWord name="change_sequence" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="charmap_build" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="charmap_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="charmap_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="charset" func="yes">
			<Overload retVal="" descr="Function of gettext.GNUTranslations">
			</Overload>
		</KeyWord>
		<KeyWord name="chdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="check" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="check_builtin" func="yes">
			<Overload retVal="" descr="Function of optparse">
			</Overload>
		</KeyWord>
		<KeyWord name="check_call" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="check_choice" func="yes">
			<Overload retVal="" descr="Function of optparse">
			</Overload>
		</KeyWord>
		<KeyWord name="check_default" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="check_enableusersite" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="check_isolated" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="check_output" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="check_returncode" func="yes">
			<Overload retVal="" descr="Function of subprocess.CompletedProcess">
			</Overload>
		</KeyWord>
		<KeyWord name="check_unused_args" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="check_value" func="yes">
			<Overload retVal="" descr="Function of optparse.Option">
			</Overload>
		</KeyWord>
		<KeyWord name="check_values" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="check_version_conflict" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="checkbox" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="checkcache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="checkfuncname" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="checkgroup" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Pattern">
			</Overload>
		</KeyWord>
		<KeyWord name="checkline" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="checklookbehindgroup" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Pattern">
			</Overload>
		</KeyWord>
		<KeyWord name="chmod" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="choice" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="choices" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="chown" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="chr" func="yes">
			<Overload retVal="" descr="Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff.">
				<Param name="i" />
			</Overload>
		</KeyWord>
		<KeyWord name="chunk" func="yes">
			<Overload retVal="" descr="Simple class to read IFF chunks.&#10;&#10;An IFF chunk (used in formats such as AIFF, TIFF, RMFF (RealMedia File&#10;Format)) has the following structure:&#10;&#10;+----------------+&#10;| ID (4 bytes)   |&#10;+----------------+&#10;| size (4 bytes) |&#10;+----------------+&#10;| data           |&#10;| ...            |&#10;+----------------+&#10;&#10;The ID is a 4-byte string which identifies the type of chunk.&#10;&#10;The size field (a 32-bit value, encoded using big-endian byte order)&#10;gives the size of the whole chunk, including the 8-byte header.&#10;&#10;Usually an IFF-type file consists of one or more chunks.  The proposed&#10;usage of the Chunk class defined here is to instantiate an instance at&#10;the start of each chunk and read from the instance until it reaches&#10;the end, after which a new instance can be instantiated.  At the end&#10;of the file, creating a new instance will fail with an EOFError&#10;exception.&#10;&#10;Usage:&#10;while True:&#10;    try:&#10;        chunk = Chunk(file)&#10;    except EOFError:&#10;        break&#10;    chunktype = chunk.getname()&#10;    while True:&#10;        data = chunk.read(nbytes)&#10;        if not data:&#10;            pass&#10;        # do something with data&#10;&#10;The interface is file-like.  The implemented methods are:&#10;read, close, seek, tell, isatty.&#10;Extra methods are: skip() (called by close, skips to the end of the chunk),&#10;getname() (returns the name (ID) of the chunk)&#10;&#10;The __init__ method has one required argument, a file-like object&#10;(including a chunk instance), and one optional argument, a flag which&#10;specifies whether or not chunks are aligned on 2-byte boundaries.  The&#10;default is 1, i.e. aligned.">
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk" />
		<KeyWord name="chunk.Chunk.close" />
		<KeyWord name="chunk.Chunk.getname" func="yes">
			<Overload retVal="" descr="Return the name (ID) of the current chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk.getsize" func="yes">
			<Overload retVal="" descr="Return the size of the current chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk.isatty" />
		<KeyWord name="chunk.Chunk.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes from the chunk.&#10;If size is omitted or negative, read until the end&#10;of the chunk.">
				<Param name="self" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk.seek" func="yes">
			<Overload retVal="" descr="Seek to specified position into the chunk.&#10;Default position is 0 (start of chunk).&#10;If the file is not seekable, this will result in an error.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk.skip" func="yes">
			<Overload retVal="" descr="Skip the rest of the chunk.&#10;If you are not interested in the contents of the chunk,&#10;this method should be called so that the file points to&#10;the start of the next chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="chunk.Chunk.tell" />
		<KeyWord name="cipher" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="class" />
		<KeyWord name="classify_class_attrs" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="classlink" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="classmethod" func="yes">
			<Overload retVal="" descr="classmethod(function) -&gt; method&#10;&#10;Convert a function to be a class method.&#10;&#10;A class method receives the class as implicit first argument,&#10;just like an instance method receives the instance.&#10;To declare a class method, use this idiom:&#10;&#10;  class C:&#10;      @classmethod&#10;      def f(cls, arg1, arg2, ...):&#10;          ...&#10;&#10;It can be called either on the class (e.g. C.f()) or on an instance&#10;(e.g. C().f()).  The instance is ignored except for its class.&#10;If a class method is called for a derived class, the derived class&#10;object is passed as the implied first argument.&#10;&#10;Class methods are different than C++ or Java static methods.&#10;If you want those, see the staticmethod builtin.">
			</Overload>
		</KeyWord>
		<KeyWord name="classname" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="clean" func="yes">
			<Overload retVal="" descr="Function of mailbox.Maildir">
			</Overload>
		</KeyWord>
		<KeyWord name="cleandoc" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="cleanup" func="yes">
			<Overload retVal="" descr="Function of tempfile.TemporaryDirectory">
			</Overload>
		</KeyWord>
		<KeyWord name="cleanup_resources" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="clear" func="yes">
			<Overload retVal="" descr="Remove all elements from this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_all_breaks" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_all_file_breaks" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_bpbynumber" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_break" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_cache" func="yes">
			<Overload retVal="" descr="Function of filecmp">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_directory" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_extension_cache" func="yes">
			<Overload retVal="" descr="Function of copyreg">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_flags" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_frames" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_memo" func="yes">
			<Overload retVal="" descr="Function of pickle.Pickler">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_traces" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="clear_traps" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="clearcache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="cli" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="clone" func="yes">
			<Overload retVal="" descr="Function of pipes.Template">
			</Overload>
		</KeyWord>
		<KeyWord name="close" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="close_all" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="close_data" func="yes">
			<Overload retVal="" descr="Function of binhex.BinHex">
			</Overload>
		</KeyWord>
		<KeyWord name="close_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="close_when_done" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="closegroup" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Pattern">
			</Overload>
		</KeyWord>
		<KeyWord name="closelog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="closerange" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd" func="yes">
			<Overload retVal="" descr="A generic class to build line-oriented command interpreters.&#10;&#10;Interpreters constructed with this class obey the following conventions:&#10;&#10;1. End of file on input is processed as the command 'EOF'.&#10;2. A command is parsed out of each line by collecting the prefix composed&#10;   of characters in the identchars member.&#10;3. A command `foo' is dispatched to a method 'do_foo()'; the do_ method&#10;   is passed a single argument consisting of the remainder of the line.&#10;4. Typing an empty line repeats the last command.  (Actually, it calls the&#10;   method `emptyline', which may be overridden in a subclass.)&#10;5. There is a predefined `help' method.  Given an argument `topic', it&#10;   calls the command `help_topic'.  With no arguments, it lists all topics&#10;   with defined help_ functions, broken into up to three topics; documented&#10;   commands, miscellaneous help topics, and undocumented commands.&#10;6. The command '?' is a synonym for `help'.  The command '!' is a synonym&#10;   for `shell', if a do_shell method exists.&#10;7. If completion is enabled, completing commands will be done automatically,&#10;   and completing of commands args is done by calling complete_foo() with&#10;   arguments text, line, begidx, endidx.  text is string we are matching&#10;   against, all returned matches must begin with it.  line is the current&#10;   input line (lstripped), begidx and endidx are the beginning and end&#10;   indexes of the text being matched, which could be used to provide&#10;   different completion depending upon which position the argument is in.&#10;&#10;The `default' method may be overridden to intercept commands for which there&#10;is no do_ method.&#10;&#10;The `completedefault' method may be overridden to intercept completions for&#10;commands that have no complete_ method.&#10;&#10;The data member `self.ruler' sets the character used to draw separator lines&#10;in the help messages.  If empty, no ruler line is drawn.  It defaults to &quot;=&quot;.&#10;&#10;If the value of `self.intro' is nonempty when the cmdloop method is called,&#10;it is printed out on interpreter startup.  This value may be overridden&#10;via an optional argument to the cmdloop() method.&#10;&#10;The data members `self.doc_header', `self.misc_header', and&#10;`self.undoc_header' set the headers used for the help function's&#10;listings of documented functions, miscellaneous topics, and undocumented&#10;functions respectively.">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd" func="yes">
			<Overload retVal="" descr="A simple framework for writing line-oriented command interpreters.&#10;&#10;These are often useful for test harnesses, administrative tools, and&#10;prototypes that will later be wrapped in a more sophisticated interface.&#10;&#10;A Cmd instance or subclass instance is a line-oriented interpreter&#10;framework.  There is no good reason to instantiate Cmd itself; rather,&#10;it's useful as a superclass of an interpreter class you define yourself&#10;in order to inherit Cmd's methods and encapsulate action methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.cmdloop" func="yes">
			<Overload retVal="" descr="Repeatedly issue a prompt, accept input, parse an initial prefix&#10;off the received input, and dispatch to action methods, passing them&#10;the remainder of the line as argument.">
				<Param name="self" />
				<Param name="[intro=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.columnize" func="yes">
			<Overload retVal="" descr="Display a list of strings as a compact set of columns.&#10;&#10;Each column is only as wide as necessary.&#10;Columns are separated by two spaces (one was not legible enough).">
				<Param name="self" />
				<Param name="list" />
				<Param name="[displaywidth=80]" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.complete" func="yes">
			<Overload retVal="" descr="Return the next possible completion for 'text'.&#10;&#10;If a command has not been entered, then complete against command list.&#10;Otherwise try to call complete_&lt;command&gt; to get list of completions.">
				<Param name="self" />
				<Param name="text" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.complete_help" />
		<KeyWord name="cmd.Cmd.completedefault" func="yes">
			<Overload retVal="" descr="Method called to complete an input line when no command-specific&#10;complete_*() method is available.&#10;&#10;By default, it returns an empty list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.completenames" />
		<KeyWord name="cmd.Cmd.default" func="yes">
			<Overload retVal="" descr="Called on an input line when the command prefix is not recognized.&#10;&#10;If this method is not overridden, it prints an error message and&#10;returns.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.do_help" func="yes">
			<Overload retVal="" descr='List available commands with "help" or detailed help with "help cmd".'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.doc_header" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.emptyline" func="yes">
			<Overload retVal="" descr="Called when an empty line is entered in response to the prompt.&#10;&#10;If this method is not overridden, it repeats the last nonempty&#10;command entered.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.get_names" />
		<KeyWord name="cmd.Cmd.identchars" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.misc_header" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.nohelp" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.onecmd" func="yes">
			<Overload retVal="" descr="Interpret the argument as though it had been typed in response&#10;to the prompt.&#10;&#10;This may be overridden, but should not normally need to be;&#10;see the precmd() and postcmd() methods for useful execution hooks.&#10;The return value is a flag indicating whether interpretation of&#10;commands by the interpreter should stop.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.parseline" func="yes">
			<Overload retVal="" descr="Parse the line into a command name and a string containing&#10;the arguments.  Returns a tuple containing (command, args, line).&#10;'command' and 'args' may be None if the line couldn't be parsed.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.postcmd" func="yes">
			<Overload retVal="" descr="Hook method executed just after a command dispatch is finished.">
				<Param name="self" />
				<Param name="stop" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.postloop" func="yes">
			<Overload retVal="" descr="Hook method executed once when the cmdloop() method is about to&#10;return.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.precmd" func="yes">
			<Overload retVal="" descr="Hook method executed just before the command line is&#10;interpreted, but after the input prompt is generated and issued.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.preloop" func="yes">
			<Overload retVal="" descr="Hook method executed once when the cmdloop() method is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.print_topics" />
		<KeyWord name="cmd.Cmd.prompt" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.ruler" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.undoc_header" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.Cmd.use_rawinput" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.IDENTCHARS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmd.PROMPT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="cmdloop" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="cmp" func="yes">
			<Overload retVal="" descr="Function of filecmp">
			</Overload>
		</KeyWord>
		<KeyWord name="cmp_to_key" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="cmpfiles" func="yes">
			<Overload retVal="" descr="Function of filecmp">
			</Overload>
		</KeyWord>
		<KeyWord name="code" func="yes">
			<Overload retVal="" descr="Utilities needed to emulate Python's interactive interpreter.">
			</Overload>
		</KeyWord>
		<KeyWord name="code.CommandCompiler" func="yes">
			<Overload retVal="" descr="Instances of this class have __call__ methods identical in&#10;signature to compile_command; the difference is that if the&#10;instance compiles program text containing a __future__ statement,&#10;the instance 'remembers' and compiles all subsequent program texts&#10;with the statement in force.">
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole" func="yes">
			<Overload retVal="" descr="Closely emulate the behavior of the interactive Python interpreter.&#10;&#10;This class builds on InteractiveInterpreter and adds prompting&#10;using the familiar sys.ps1 and sys.ps2, and input buffering.">
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.interact" func="yes">
			<Overload retVal="" descr="Closely emulate the interactive Python console.&#10;&#10;The optional banner argument specifies the banner to print&#10;before the first interaction; by default it prints a banner&#10;similar to the one printed by the real Python interpreter,&#10;followed by the current class name in parentheses (so as not&#10;to confuse this with the real interpreter -- since it's so&#10;close!).&#10;&#10;The optional exitmsg argument specifies the exit message&#10;printed when exiting. Pass the empty string to suppress&#10;printing an exit message. If exitmsg is not given or None,&#10;a default message is printed.">
				<Param name="self" />
				<Param name="[banner=None" />
				<Param name="[exitmsg=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.push" func="yes">
			<Overload retVal="" descr="Push a line to the interpreter.&#10;&#10;The line should not have a trailing newline; it may have&#10;internal newlines.  The line is appended to a buffer and the&#10;interpreter's runsource() method is called with the&#10;concatenated contents of the buffer as source.  If this&#10;indicates that the command was executed or invalid, the buffer&#10;is reset; otherwise, the command is incomplete, and the buffer&#10;is left as it was after the line was appended.  The return&#10;value is 1 if more input is required, 0 if the line was dealt&#10;with in some way (this is the same as runsource()).">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.raw_input" func="yes">
			<Overload retVal="" descr="Write a prompt and read a line.&#10;&#10;The returned line does not include the trailing newline.&#10;When the user enters the EOF key sequence, EOFError is raised.&#10;&#10;The base implementation uses the built-in function&#10;input(); a subclass may replace this with a different&#10;implementation.">
				<Param name="self" />
				<Param name="[prompt]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.resetbuffer" func="yes">
			<Overload retVal="" descr="Reset the input buffer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.runcode" func="yes">
			<Overload retVal="" descr="Execute a code object.&#10;&#10;When an exception occurs, self.showtraceback() is called to&#10;display a traceback.  All exceptions are caught except&#10;SystemExit, which is reraised.&#10;&#10;A note about KeyboardInterrupt: this exception may occur&#10;elsewhere in this code, and may not always be caught.  The&#10;caller should be prepared to deal with it.">
				<Param name="self" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.runsource" func="yes">
			<Overload retVal="" descr="Compile and run some source in the interpreter.&#10;&#10;Arguments are as for compile_command().&#10;&#10;One several things can happen:&#10;&#10;1) The input is incorrect; compile_command() raised an&#10;exception (SyntaxError or OverflowError).  A syntax traceback&#10;will be printed by calling the showsyntaxerror() method.&#10;&#10;2) The input is incomplete, and more input is required;&#10;compile_command() returned None.  Nothing happens.&#10;&#10;3) The input is complete; compile_command() returned a code&#10;object.  The code is executed by calling self.runcode() (which&#10;also handles run-time exceptions, except for SystemExit).&#10;&#10;The return value is True in case 2, False in the other cases (unless&#10;an exception is raised).  The return value can be used to&#10;decide whether to use sys.ps1 or sys.ps2 to prompt the next&#10;line.">
				<Param name="self" />
				<Param name="source" />
				<Param name="[filename=<input>" />
				<Param name="[symbol=single]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.showsyntaxerror" func="yes">
			<Overload retVal="" descr="Display the syntax error that just occurred.&#10;&#10;This doesn't display a stack trace because there isn't one.&#10;&#10;If a filename is given, it is stuffed in the exception instead&#10;of what was there before (because Python's parser always uses&#10;&quot;&lt;string&gt;&quot; when reading from a string).&#10;&#10;The output is written by self.write(), below.">
				<Param name="self" />
				<Param name="[filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.showtraceback" func="yes">
			<Overload retVal="" descr="Display the exception that just occurred.&#10;&#10;We remove the first stack item because it is our own code.&#10;&#10;The output is written by self.write(), below.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveConsole.write" func="yes">
			<Overload retVal="" descr="Write a string.&#10;&#10;The base implementation writes to sys.stderr; a subclass may&#10;replace this with a different implementation.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter" func="yes">
			<Overload retVal="" descr="Base class for InteractiveConsole.&#10;&#10;This class deals with parsing and interpreter state (the user's&#10;namespace); it doesn't deal with input buffering or prompting or&#10;input file naming (the filename is always passed in explicitly).">
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter.runcode" func="yes">
			<Overload retVal="" descr="Execute a code object.&#10;&#10;When an exception occurs, self.showtraceback() is called to&#10;display a traceback.  All exceptions are caught except&#10;SystemExit, which is reraised.&#10;&#10;A note about KeyboardInterrupt: this exception may occur&#10;elsewhere in this code, and may not always be caught.  The&#10;caller should be prepared to deal with it.">
				<Param name="self" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter.runsource" func="yes">
			<Overload retVal="" descr="Compile and run some source in the interpreter.&#10;&#10;Arguments are as for compile_command().&#10;&#10;One several things can happen:&#10;&#10;1) The input is incorrect; compile_command() raised an&#10;exception (SyntaxError or OverflowError).  A syntax traceback&#10;will be printed by calling the showsyntaxerror() method.&#10;&#10;2) The input is incomplete, and more input is required;&#10;compile_command() returned None.  Nothing happens.&#10;&#10;3) The input is complete; compile_command() returned a code&#10;object.  The code is executed by calling self.runcode() (which&#10;also handles run-time exceptions, except for SystemExit).&#10;&#10;The return value is True in case 2, False in the other cases (unless&#10;an exception is raised).  The return value can be used to&#10;decide whether to use sys.ps1 or sys.ps2 to prompt the next&#10;line.">
				<Param name="self" />
				<Param name="source" />
				<Param name="[filename=<input>" />
				<Param name="[symbol=single]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter.showsyntaxerror" func="yes">
			<Overload retVal="" descr="Display the syntax error that just occurred.&#10;&#10;This doesn't display a stack trace because there isn't one.&#10;&#10;If a filename is given, it is stuffed in the exception instead&#10;of what was there before (because Python's parser always uses&#10;&quot;&lt;string&gt;&quot; when reading from a string).&#10;&#10;The output is written by self.write(), below.">
				<Param name="self" />
				<Param name="[filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter.showtraceback" func="yes">
			<Overload retVal="" descr="Display the exception that just occurred.&#10;&#10;We remove the first stack item because it is our own code.&#10;&#10;The output is written by self.write(), below.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.InteractiveInterpreter.write" func="yes">
			<Overload retVal="" descr="Write a string.&#10;&#10;The base implementation writes to sys.stderr; a subclass may&#10;replace this with a different implementation.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.compile_command" func="yes">
			<Overload retVal="" descr='Compile a command and determine whether it is incomplete.&#10;&#10;Arguments:&#10;&#10;source -- the source string; may contain \n characters&#10;filename -- optional filename from which source was read; default&#10;            "&lt;input&gt;"&#10;symbol -- optional grammar start symbol; "single" (default) or "eval"&#10;&#10;Return value / exceptions raised:&#10;&#10;- Return a code object if the command is complete and valid&#10;- Return None if the command is incomplete&#10;- Raise SyntaxError, ValueError or OverflowError if the command is a&#10;  syntax error (OverflowError and ValueError can be produced by&#10;  malformed literals).'>
				<Param name="source" />
				<Param name="[filename=<input>" />
				<Param name="[symbol=single]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code.interact" func="yes">
			<Overload retVal="" descr="Closely emulate the interactive Python interpreter.&#10;&#10;This is a backwards compatible interface to the InteractiveConsole&#10;class.  When readfunc is not specified, it attempts to import the&#10;readline module to enable GNU readline if it is available.&#10;&#10;Arguments (all optional, all default to None):&#10;&#10;banner -- passed to InteractiveConsole.interact()&#10;readfunc -- if not None, replaces InteractiveConsole.raw_input()&#10;local -- passed to InteractiveInterpreter.__init__()&#10;exitmsg -- passed to InteractiveConsole.interact()">
				<Param name="[banner=None" />
				<Param name="[readfunc=None" />
				<Param name="[local=None" />
				<Param name="[exitmsg=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="code_info" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="code_page_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="code_page_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs" func="yes">
			<Overload retVal="" descr="codecs -- Python Codec Registry, API and helpers.&#10;&#10;&#10;Written by Marc-Andre Lemburg (mal@lemburg.com).&#10;&#10;(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM32_BE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM32_LE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM64_BE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM64_LE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_BE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_LE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF16" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF16_BE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF16_LE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF32" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF32_BE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF32_LE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BOM_UTF8" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder" func="yes">
			<Overload retVal="" descr="This subclass of IncrementalDecoder can be used as the baseclass for an&#10;incremental decoder if the decoder must be able to handle incomplete&#10;byte sequences.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder.decode" func="yes">
			<Overload retVal="" descr="Decode input and returns the resulting object.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder.getstate" func="yes">
			<Overload retVal="" descr='Return the current state of the decoder.&#10;&#10;This must be a (buffered_input, additional_state_info) tuple.&#10;buffered_input must be a bytes object containing bytes that&#10;were passed to decode() that have not yet been converted.&#10;additional_state_info must be a non-negative integer&#10;representing the state of the decoder WITHOUT yet having&#10;processed the contents of buffered_input.  In the initial state&#10;and after reset(), getstate() must return (b"", 0).'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder.reset" func="yes">
			<Overload retVal="" descr="Reset the decoder to the initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalDecoder.setstate" func="yes">
			<Overload retVal="" descr='Set the current state of the decoder.&#10;&#10;state must have been returned by getstate().  The effect of&#10;setstate((b"", 0)) must be equivalent to reset().'>
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder" func="yes">
			<Overload retVal="" descr="This subclass of IncrementalEncoder can be used as the baseclass for an&#10;incremental encoder if the encoder must keep some of the output in a&#10;buffer between calls to encode().">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder.encode" func="yes">
			<Overload retVal="" descr="Encodes input and returns the resulting object.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder.getstate" func="yes">
			<Overload retVal="" descr="Return the current state of the encoder.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder.reset" func="yes">
			<Overload retVal="" descr="Resets the encoder to the initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.BufferedIncrementalEncoder.setstate" func="yes">
			<Overload retVal="" descr="Set the current state of the encoder. state must have been&#10;returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.Codec" func="yes">
			<Overload retVal="" descr="Defines the interface for stateless encoders/decoders.&#10;&#10;The .encode()/.decode() methods may use different error&#10;handling schemes by providing the errors argument. These&#10;string values are predefined:&#10;&#10; 'strict' - raise a ValueError error (or a subclass)&#10; 'ignore' - ignore the character and continue with the next&#10; 'replace' - replace with a suitable replacement character;&#10;            Python will use the official U+FFFD REPLACEMENT&#10;            CHARACTER for the builtin Unicode codecs on&#10;            decoding and '?' on encoding.&#10; 'surrogateescape' - replace with private code points U+DCnn.&#10; 'xmlcharrefreplace' - Replace with the appropriate XML&#10;                       character reference (only for encoding).&#10; 'backslashreplace'  - Replace with backslashed escape sequences.&#10; 'namereplace'       - Replace with \N{...} escape sequences&#10;                       (only for encoding).&#10;&#10;The set of allowed values can be extended via register_error.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.Codec.decode" func="yes">
			<Overload retVal="" descr="Decodes the object input and returns a tuple (output&#10;object, length consumed).&#10;&#10;input must be an object which provides the bf_getreadbuf&#10;buffer slot. Python strings, buffer objects and memory&#10;mapped files are examples of objects providing this slot.&#10;&#10;errors defines the error handling to apply. It defaults to&#10;'strict' handling.&#10;&#10;The method may not store state in the Codec instance. Use&#10;StreamReader for codecs which have to keep state in order to&#10;make decoding efficient.&#10;&#10;The decoder must be able to handle zero length input and&#10;return an empty object of the output object type in this&#10;situation.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[errors=strict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.Codec.encode" func="yes">
			<Overload retVal="" descr="Encodes the object input and returns a tuple (output&#10;object, length consumed).&#10;&#10;errors defines the error handling to apply. It defaults to&#10;'strict' handling.&#10;&#10;The method may not store state in the Codec instance. Use&#10;StreamWriter for codecs which have to keep state in order to&#10;make encoding efficient.&#10;&#10;The encoder must be able to handle zero length input and&#10;return an empty object of the output object type in this&#10;situation.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[errors=strict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.CodecInfo" func="yes">
			<Overload retVal="" descr="Codec details when looking up the codec registry">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.CodecInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.CodecInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.EncodedFile" func="yes">
			<Overload retVal="" descr="Return a wrapped version of file which provides transparent&#10;encoding translation.&#10;&#10;Data written to the wrapped file is decoded according&#10;to the given data_encoding and then encoded to the underlying&#10;file using file_encoding. The intermediate data type&#10;will usually be Unicode but depends on the specified codecs.&#10;&#10;Bytes read from the file are decoded using file_encoding and then&#10;passed back to the caller encoded using data_encoding.&#10;&#10;If file_encoding is not given, it defaults to data_encoding.&#10;&#10;errors may be given to define the error handling. It defaults&#10;to 'strict' which causes ValueErrors to be raised in case an&#10;encoding error occurs.&#10;&#10;The returned wrapped file object provides two extra attributes&#10;.data_encoding and .file_encoding which reflect the given&#10;parameters of the same name. The attributes can be used for&#10;introspection by Python programs.">
				<Param name="file" />
				<Param name="data_encoding" />
				<Param name="[file_encoding=None" />
				<Param name="[errors=strict]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder" func="yes">
			<Overload retVal="" descr="An IncrementalDecoder decodes an input in multiple steps. The input can&#10;be passed piece by piece to the decode() method. The IncrementalDecoder&#10;remembers the state of the decoding process between calls to decode().">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.decode" func="yes">
			<Overload retVal="" descr="Decode input and returns the resulting object.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.getstate" func="yes">
			<Overload retVal="" descr='Return the current state of the decoder.&#10;&#10;This must be a (buffered_input, additional_state_info) tuple.&#10;buffered_input must be a bytes object containing bytes that&#10;were passed to decode() that have not yet been converted.&#10;additional_state_info must be a non-negative integer&#10;representing the state of the decoder WITHOUT yet having&#10;processed the contents of buffered_input.  In the initial state&#10;and after reset(), getstate() must return (b"", 0).'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.reset" func="yes">
			<Overload retVal="" descr="Reset the decoder to the initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalDecoder.setstate" func="yes">
			<Overload retVal="" descr='Set the current state of the decoder.&#10;&#10;state must have been returned by getstate().  The effect of&#10;setstate((b"", 0)) must be equivalent to reset().'>
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder" func="yes">
			<Overload retVal="" descr="An IncrementalEncoder encodes an input in multiple steps. The input can&#10;be passed piece by piece to the encode() method. The IncrementalEncoder&#10;remembers the state of the encoding process between calls to encode().">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.encode" func="yes">
			<Overload retVal="" descr="Encodes input and returns the resulting object.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.getstate" func="yes">
			<Overload retVal="" descr="Return the current state of the encoder.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.reset" func="yes">
			<Overload retVal="" descr="Resets the encoder to the initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.IncrementalEncoder.setstate" func="yes">
			<Overload retVal="" descr="Set the current state of the encoder. state must have been&#10;returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader" func="yes">
			<Overload retVal="" descr="Defines the interface for stateless encoders/decoders.&#10;&#10;The .encode()/.decode() methods may use different error&#10;handling schemes by providing the errors argument. These&#10;string values are predefined:&#10;&#10; 'strict' - raise a ValueError error (or a subclass)&#10; 'ignore' - ignore the character and continue with the next&#10; 'replace' - replace with a suitable replacement character;&#10;            Python will use the official U+FFFD REPLACEMENT&#10;            CHARACTER for the builtin Unicode codecs on&#10;            decoding and '?' on encoding.&#10; 'surrogateescape' - replace with private code points U+DCnn.&#10; 'xmlcharrefreplace' - Replace with the appropriate XML&#10;                       character reference (only for encoding).&#10; 'backslashreplace'  - Replace with backslashed escape sequences.&#10; 'namereplace'       - Replace with \N{...} escape sequences&#10;                       (only for encoding).&#10;&#10;The set of allowed values can be extended via register_error.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.charbuffertype" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; str&#10;str(bytes_or_buffer[, encoding[, errors]]) -&gt; str&#10;&#10;Create a new string object from the given object. If encoding or&#10;errors is specified, then the object must expose a data buffer&#10;that will be decoded using the given encoding and error handler.&#10;Otherwise, returns the result of object.__str__() (if defined)&#10;or repr(object).&#10;encoding defaults to sys.getdefaultencoding().&#10;errors defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.decode" func="yes">
			<Overload retVal="" descr="Decodes the object input and returns a tuple (output&#10;object, length consumed).&#10;&#10;input must be an object which provides the bf_getreadbuf&#10;buffer slot. Python strings, buffer objects and memory&#10;mapped files are examples of objects providing this slot.&#10;&#10;errors defines the error handling to apply. It defaults to&#10;'strict' handling.&#10;&#10;The method may not store state in the Codec instance. Use&#10;StreamReader for codecs which have to keep state in order to&#10;make decoding efficient.&#10;&#10;The decoder must be able to handle zero length input and&#10;return an empty object of the output object type in this&#10;situation.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[errors=strict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.encode" func="yes">
			<Overload retVal="" descr="Encodes the object input and returns a tuple (output&#10;object, length consumed).&#10;&#10;errors defines the error handling to apply. It defaults to&#10;'strict' handling.&#10;&#10;The method may not store state in the Codec instance. Use&#10;StreamWriter for codecs which have to keep state in order to&#10;make encoding efficient.&#10;&#10;The encoder must be able to handle zero length input and&#10;return an empty object of the output object type in this&#10;situation.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[errors=strict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.read" func="yes">
			<Overload retVal="" descr="Decodes data from the stream self.stream and returns the&#10;resulting object.&#10;&#10;chars indicates the number of decoded code points or bytes to&#10;return. read() will never return more data than requested,&#10;but it might return less, if there is not enough available.&#10;&#10;size indicates the approximate maximum number of decoded&#10;bytes or code points to read for decoding. The decoder&#10;can modify this setting as appropriate. The default value&#10;-1 indicates to read and decode as much as possible.  size&#10;is intended to prevent having to decode huge files in one&#10;step.&#10;&#10;If firstline is true, and a UnicodeDecodeError happens&#10;after the first line terminator in the input only the first line&#10;will be returned, the rest of the input will be kept until the&#10;next call to read().&#10;&#10;The method should use a greedy read strategy, meaning that&#10;it should read as much data as is allowed within the&#10;definition of the encoding and the given size, e.g.  if&#10;optional encoding endings or state markers are available&#10;on the stream, these should be read too.">
				<Param name="self" />
				<Param name="[size=-1" />
				<Param name="[chars=-1" />
				<Param name="[firstline=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.readline" func="yes">
			<Overload retVal="" descr="Read one line from the input stream and return the&#10;decoded data.&#10;&#10;size, if given, is passed as size argument to the&#10;read() method.">
				<Param name="self" />
				<Param name="[size=None" />
				<Param name="[keepends=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.readlines" func="yes">
			<Overload retVal="" descr="Read all lines available on the input stream&#10;and return them as a list.&#10;&#10;Line breaks are implemented using the codec's decoder&#10;method and are included in the list entries.&#10;&#10;sizehint, if given, is ignored since there is no efficient&#10;way to finding the true end-of-line.">
				<Param name="self" />
				<Param name="[sizehint=None" />
				<Param name="[keepends=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.reset" func="yes">
			<Overload retVal="" descr="Resets the codec buffers used for keeping state.&#10;&#10;Note that no stream repositioning should take place.&#10;This method is primarily intended to be able to recover&#10;from decoding errors.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReader.seek" func="yes">
			<Overload retVal="" descr="Set the input stream's current position.&#10;&#10;Resets the codec buffers used for keeping state.">
				<Param name="self" />
				<Param name="offset" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter" func="yes">
			<Overload retVal="" descr="StreamReaderWriter instances allow wrapping streams which&#10;work in both read and write modes.&#10;&#10;The design is such that one can use the factory functions&#10;returned by the codec.lookup() function to construct the&#10;instance.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter.read" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter.readline" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter.readlines" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[sizehint=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter.reset" />
		<KeyWord name="codecs.StreamReaderWriter.seek" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="offset" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamReaderWriter.write" />
		<KeyWord name="codecs.StreamReaderWriter.writelines" />
		<KeyWord name="codecs.StreamRecoder" func="yes">
			<Overload retVal="" descr='StreamRecoder instances translate data from one encoding to another.&#10;&#10;They use the complete set of APIs returned by the&#10;codecs.lookup() function to implement their task.&#10;&#10;Data written to the StreamRecoder is first decoded into an&#10;intermediate format (depending on the "decode" codec) and then&#10;written to the underlying stream using an instance of the provided&#10;Writer class.&#10;&#10;In the other direction, data is read from the underlying stream using&#10;a Reader instance and then encoded and returned to the caller.'>
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder.data_encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder.file_encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder.read" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder.readline" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder.readlines" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[sizehint=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamRecoder.reset" />
		<KeyWord name="codecs.StreamRecoder.write" />
		<KeyWord name="codecs.StreamRecoder.writelines" />
		<KeyWord name="codecs.StreamWriter" func="yes">
			<Overload retVal="" descr="Defines the interface for stateless encoders/decoders.&#10;&#10;The .encode()/.decode() methods may use different error&#10;handling schemes by providing the errors argument. These&#10;string values are predefined:&#10;&#10; 'strict' - raise a ValueError error (or a subclass)&#10; 'ignore' - ignore the character and continue with the next&#10; 'replace' - replace with a suitable replacement character;&#10;            Python will use the official U+FFFD REPLACEMENT&#10;            CHARACTER for the builtin Unicode codecs on&#10;            decoding and '?' on encoding.&#10; 'surrogateescape' - replace with private code points U+DCnn.&#10; 'xmlcharrefreplace' - Replace with the appropriate XML&#10;                       character reference (only for encoding).&#10; 'backslashreplace'  - Replace with backslashed escape sequences.&#10; 'namereplace'       - Replace with \N{...} escape sequences&#10;                       (only for encoding).&#10;&#10;The set of allowed values can be extended via register_error.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter.decode" func="yes">
			<Overload retVal="" descr="Decodes the object input and returns a tuple (output&#10;object, length consumed).&#10;&#10;input must be an object which provides the bf_getreadbuf&#10;buffer slot. Python strings, buffer objects and memory&#10;mapped files are examples of objects providing this slot.&#10;&#10;errors defines the error handling to apply. It defaults to&#10;'strict' handling.&#10;&#10;The method may not store state in the Codec instance. Use&#10;StreamReader for codecs which have to keep state in order to&#10;make decoding efficient.&#10;&#10;The decoder must be able to handle zero length input and&#10;return an empty object of the output object type in this&#10;situation.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[errors=strict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter.encode" func="yes">
			<Overload retVal="" descr="Encodes the object input and returns a tuple (output&#10;object, length consumed).&#10;&#10;errors defines the error handling to apply. It defaults to&#10;'strict' handling.&#10;&#10;The method may not store state in the Codec instance. Use&#10;StreamWriter for codecs which have to keep state in order to&#10;make encoding efficient.&#10;&#10;The encoder must be able to handle zero length input and&#10;return an empty object of the output object type in this&#10;situation.">
				<Param name="self" />
				<Param name="input" />
				<Param name="[errors=strict]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter.reset" func="yes">
			<Overload retVal="" descr="Flushes and resets the codec buffers used for keeping state.&#10;&#10;Calling this method should ensure that the data on the&#10;output is put into a clean state, that allows appending&#10;of new fresh data without having to rescan the whole&#10;stream to recover state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter.seek" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="offset" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter.write" func="yes">
			<Overload retVal="" descr="Writes the object's contents encoded to self.stream.">
				<Param name="self" />
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.StreamWriter.writelines" func="yes">
			<Overload retVal="" descr="Writes the concatenated list of strings to the stream&#10;using .write().">
				<Param name="self" />
				<Param name="list" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.ascii_decode" />
		<KeyWord name="codecs.ascii_encode" />
		<KeyWord name="codecs.backslashreplace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'backslashreplace' error handling, which replaces malformed data with a backslashed escape sequence.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.charmap_build" />
		<KeyWord name="codecs.charmap_decode" />
		<KeyWord name="codecs.charmap_encode" />
		<KeyWord name="codecs.code_page_decode" />
		<KeyWord name="codecs.code_page_encode" />
		<KeyWord name="codecs.decode" func="yes">
			<Overload retVal="" descr="Decodes obj using the codec registered for encoding.&#10;&#10;Default encoding is 'utf-8'.  errors may be given to set a&#10;different error handling scheme.  Default is 'strict' meaning that encoding&#10;errors raise a ValueError.  Other possible values are 'ignore', 'replace'&#10;and 'backslashreplace' as well as any other name registered with&#10;codecs.register_error that can handle ValueErrors.">
				<Param name="obj" />
				<Param name="[encoding=utf-8" />
				<Param name="[errors=strict]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.encode" func="yes">
			<Overload retVal="" descr="Encodes obj using the codec registered for encoding.&#10;&#10;The default encoding is 'utf-8'.  errors may be given to set a&#10;different error handling scheme.  Default is 'strict' meaning that encoding&#10;errors raise a ValueError.  Other possible values are 'ignore', 'replace'&#10;and 'backslashreplace' as well as any other name registered with&#10;codecs.register_error that can handle ValueErrors.">
				<Param name="obj" />
				<Param name="[encoding=utf-8" />
				<Param name="[errors=strict]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.escape_decode" />
		<KeyWord name="codecs.escape_encode" />
		<KeyWord name="codecs.getdecoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its decoder function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getencoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its encoder function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getincrementaldecoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its IncrementalDecoder class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found&#10;or the codecs doesn't provide an incremental decoder.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getincrementalencoder" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its IncrementalEncoder class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found&#10;or the codecs doesn't provide an incremental encoder.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getreader" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its StreamReader class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.getwriter" func="yes">
			<Overload retVal="" descr="Lookup up the codec for the given encoding and return&#10;its StreamWriter class or factory function.&#10;&#10;Raises a LookupError in case the encoding cannot be found.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.ignore_errors" func="yes">
			<Overload retVal="" descr="Implements the 'ignore' error handling, which ignores malformed data and continues.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.iterdecode" func="yes">
			<Overload retVal="" descr="Decoding iterator.&#10;&#10;Decodes the input strings from the iterator using an IncrementalDecoder.&#10;&#10;errors and kwargs are passed through to the IncrementalDecoder&#10;constructor.">
				<Param name="iterator" />
				<Param name="encoding" />
				<Param name="[errors=strict" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.iterencode" func="yes">
			<Overload retVal="" descr="Encoding iterator.&#10;&#10;Encodes the input strings from the iterator using an IncrementalEncoder.&#10;&#10;errors and kwargs are passed through to the IncrementalEncoder&#10;constructor.">
				<Param name="iterator" />
				<Param name="encoding" />
				<Param name="[errors=strict" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.latin_1_decode" />
		<KeyWord name="codecs.latin_1_encode" />
		<KeyWord name="codecs.lookup" func="yes">
			<Overload retVal="" descr="Looks up a codec tuple in the Python codec registry and returns a CodecInfo object.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.lookup_error" func="yes">
			<Overload retVal="" descr="lookup_error(errors) -&gt; handler&#10;&#10;Return the error handler for the specified error handling name or raise a&#10;LookupError, if no handler exists under this name.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.make_encoding_map" func="yes">
			<Overload retVal="" descr="Creates an encoding map from a decoding map.&#10;&#10;If a target mapping in the decoding map occurs multiple&#10;times, then that target is mapped to None (undefined mapping),&#10;causing an exception when encountered by the charmap codec&#10;during translation.&#10;&#10;One example where this happens is cp875.py which decodes&#10;multiple character to \u001a.">
				<Param name="decoding_map" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.make_identity_dict" func="yes">
			<Overload retVal="" descr="make_identity_dict(rng) -&gt; dict&#10;&#10;Return a dictionary where elements of the rng sequence are&#10;mapped to themselves.">
				<Param name="rng" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.mbcs_decode" />
		<KeyWord name="codecs.mbcs_encode" />
		<KeyWord name="codecs.namereplace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'namereplace' error handling, which replaces an unencodable character with a \N{...} escape sequence.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.oem_decode" />
		<KeyWord name="codecs.oem_encode" />
		<KeyWord name="codecs.open" func="yes">
			<Overload retVal="" descr="Open an encoded file using the given mode and return&#10;a wrapped version providing transparent encoding/decoding.&#10;&#10;Note: The wrapped version will only accept the object format&#10;defined by the codecs, i.e. Unicode objects for most builtin&#10;codecs. Output is also codec dependent and will usually be&#10;Unicode as well.&#10;&#10;Underlying encoded files are always opened in binary mode.&#10;The default file mode is 'r', meaning to open the file in read mode.&#10;&#10;encoding specifies the encoding which is to be used for the&#10;file.&#10;&#10;errors may be given to define the error handling. It defaults&#10;to 'strict' which causes ValueErrors to be raised in case an&#10;encoding error occurs.&#10;&#10;buffering has the same meaning as for the builtin open() API.&#10;It defaults to line buffered.&#10;&#10;The returned wrapped file object provides an extra attribute&#10;.encoding which allows querying the used encoding. This&#10;attribute is only available if an encoding was specified as&#10;parameter.">
				<Param name="filename" />
				<Param name="[mode=r" />
				<Param name="[encoding=None" />
				<Param name="[errors=strict" />
				<Param name="[buffering=1]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.raw_unicode_escape_decode" />
		<KeyWord name="codecs.raw_unicode_escape_encode" />
		<KeyWord name="codecs.readbuffer_encode" />
		<KeyWord name="codecs.register" func="yes">
			<Overload retVal="" descr="Register a codec search function.&#10;&#10;Search functions are expected to take one argument, the encoding name in&#10;all lower case letters, and either return None, or a tuple of functions&#10;(encoder, decoder, stream_reader, stream_writer) (or a CodecInfo object).">
				<Param name="search_function" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.register_error" func="yes">
			<Overload retVal="" descr="Register the specified error handler under the name errors.&#10;&#10;handler must be a callable object, that will be called with an exception&#10;instance containing information about the location of the encoding/decoding&#10;error and must return a (replacement, new position) tuple.">
				<Param name="errors" />
				<Param name="handler" />
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.replace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'replace' error handling, which replaces malformed data with a replacement marker.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.strict_errors" func="yes">
			<Overload retVal="" descr="Implements the 'strict' error handling, which raises a UnicodeError on coding errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="codecs.unicode_escape_decode" />
		<KeyWord name="codecs.unicode_escape_encode" />
		<KeyWord name="codecs.unicode_internal_decode" />
		<KeyWord name="codecs.unicode_internal_encode" />
		<KeyWord name="codecs.utf_16_be_decode" />
		<KeyWord name="codecs.utf_16_be_encode" />
		<KeyWord name="codecs.utf_16_decode" />
		<KeyWord name="codecs.utf_16_encode" />
		<KeyWord name="codecs.utf_16_ex_decode" />
		<KeyWord name="codecs.utf_16_le_decode" />
		<KeyWord name="codecs.utf_16_le_encode" />
		<KeyWord name="codecs.utf_32_be_decode" />
		<KeyWord name="codecs.utf_32_be_encode" />
		<KeyWord name="codecs.utf_32_decode" />
		<KeyWord name="codecs.utf_32_encode" />
		<KeyWord name="codecs.utf_32_ex_decode" />
		<KeyWord name="codecs.utf_32_le_decode" />
		<KeyWord name="codecs.utf_32_le_encode" />
		<KeyWord name="codecs.utf_7_decode" />
		<KeyWord name="codecs.utf_7_encode" />
		<KeyWord name="codecs.utf_8_decode" />
		<KeyWord name="codecs.utf_8_encode" />
		<KeyWord name="codecs.xmlcharrefreplace_errors" func="yes">
			<Overload retVal="" descr="Implements the 'xmlcharrefreplace' error handling, which replaces an unencodable character with the appropriate XML character reference.">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop" func="yes">
			<Overload retVal="" descr="Utilities to compile possibly incomplete Python source code.&#10;&#10;This module provides two interfaces, broadly similar to the builtin&#10;function compile(), which take program text, a filename and a 'mode'&#10;and:&#10;&#10;- Return code object if the command is complete and valid&#10;- Return None if the command is incomplete&#10;- Raise SyntaxError, ValueError or OverflowError if the command is a&#10;  syntax error (OverflowError and ValueError can be produced by&#10;  malformed literals).&#10;&#10;Approach:&#10;&#10;First, check if the source consists entirely of blank lines and&#10;comments; if so, replace it with 'pass', because the built-in&#10;parser doesn't always do the right thing for these.&#10;&#10;Compile three times: as is, with \n, and with \n\n appended.  If it&#10;compiles as is, it's complete.  If it compiles with one \n appended,&#10;we expect more.  If it doesn't compile either way, we compare the&#10;error we get when compiling with \n or \n\n appended.  If the errors&#10;are the same, the code is broken.  But if the errors are different, we&#10;expect more.  Not intuitive; not even guaranteed to hold in future&#10;releases; but this matches the compiler's behavior from Python 1.4&#10;through 2.2, at least.&#10;&#10;Caveat:&#10;&#10;It is possible (but not likely) that the parser stops parsing with a&#10;successful outcome before reaching the end of the source; in this&#10;case, trailing symbols may be ignored instead of causing an error.&#10;For example, a backslash followed by two newlines may be followed by&#10;arbitrary garbage.  This will be fixed once the API for the parser is&#10;better.&#10;&#10;The two interfaces are:&#10;&#10;compile_command(source, filename, symbol):&#10;&#10;    Compiles a single command in the manner described above.&#10;&#10;CommandCompiler():&#10;&#10;    Instances of this class have __call__ methods identical in&#10;    signature to compile_command; the difference is that if the&#10;    instance compiles program text containing a __future__ statement,&#10;    the instance 'remembers' and compiles all subsequent program texts&#10;    with the statement in force.&#10;&#10;The module also provides another class:&#10;&#10;Compile():&#10;&#10;    Instances of this class act like the built-in function compile,&#10;    but with 'memory' in the sense described above.">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.CommandCompiler" func="yes">
			<Overload retVal="" descr="Instances of this class have __call__ methods identical in&#10;signature to compile_command; the difference is that if the&#10;instance compiles program text containing a __future__ statement,&#10;the instance 'remembers' and compiles all subsequent program texts&#10;with the statement in force.">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.Compile" func="yes">
			<Overload retVal="" descr='Instances of this class behave much like the built-in compile&#10;function, but if one is used to compile text containing a future&#10;statement, it "remembers" and compiles all subsequent program texts&#10;with the statement in force.'>
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.PyCF_DONT_IMPLY_DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="codeop.compile_command" func="yes">
			<Overload retVal="" descr='Compile a command and determine whether it is incomplete.&#10;&#10;Arguments:&#10;&#10;source -- the source string; may contain \n characters&#10;filename -- optional filename from which source was read; default&#10;            "&lt;input&gt;"&#10;symbol -- optional grammar start symbol; "single" (default) or "eval"&#10;&#10;Return value / exceptions raised:&#10;&#10;- Return a code object if the command is complete and valid&#10;- Return None if the command is incomplete&#10;- Raise SyntaxError, ValueError or OverflowError if the command is a&#10;  syntax error (OverflowError and ValueError can be produced by&#10;  malformed literals).'>
				<Param name="source" />
				<Param name="[filename=<input>" />
				<Param name="[symbol=single]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collapse_addresses" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="collect_incoming_data" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="collections" func="yes">
			<Overload retVal="" descr="This module implements specialized container datatypes providing&#10;alternatives to Python's general purpose built-in containers, dict,&#10;list, set, and tuple.&#10;&#10;* namedtuple   factory function for creating tuple subclasses with named fields&#10;* deque        list-like container with fast appends and pops on either end&#10;* ChainMap     dict-like class for creating a single view of multiple mappings&#10;* Counter      dict subclass for counting hashable objects&#10;* OrderedDict  dict subclass that remembers the order entries were added&#10;* defaultdict  dict subclass that calls a factory function to supply missing values&#10;* UserDict     wrapper around dictionary objects for easier dict subclassing&#10;* UserList     wrapper around list objects for easier list subclassing&#10;* UserString   wrapper around string objects for easier string subclassing">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.AsyncGenerator" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.AsyncIterable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.AsyncIterator" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Awaitable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.ByteString" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Callable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.ChainMap" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Collection" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Container" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Coroutine" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter" func="yes">
			<Overload retVal="" descr="Dict subclass for counting hashable items.  Sometimes called a bag&#10;or multiset.  Elements are stored as dictionary keys and their counts&#10;are stored as dictionary values.&#10;&#10;&gt;&gt;&gt; c = Counter('abcdeabcdabcaba')  # count elements from a string&#10;&#10;&gt;&gt;&gt; c.most_common(3)                # three most common elements&#10;[('a', 5), ('b', 4), ('c', 3)]&#10;&gt;&gt;&gt; sorted(c)                       # list all unique elements&#10;['a', 'b', 'c', 'd', 'e']&#10;&gt;&gt;&gt; ''.join(sorted(c.elements()))   # list elements with repetitions&#10;'aaaaabbbbcccdde'&#10;&gt;&gt;&gt; sum(c.values())                 # total of all counts&#10;15&#10;&#10;&gt;&gt;&gt; c['a']                          # count of letter 'a'&#10;5&#10;&gt;&gt;&gt; for elem in 'shazam':           # update counts from an iterable&#10;...     c[elem] += 1                # by adding 1 to each element's count&#10;&gt;&gt;&gt; c['a']                          # now there are seven 'a'&#10;7&#10;&gt;&gt;&gt; del c['b']                      # remove all 'b'&#10;&gt;&gt;&gt; c['b']                          # now there are zero 'b'&#10;0&#10;&#10;&gt;&gt;&gt; d = Counter('simsalabim')       # make another counter&#10;&gt;&gt;&gt; c.update(d)                     # add in the second counter&#10;&gt;&gt;&gt; c['a']                          # now there are nine 'a'&#10;9&#10;&#10;&gt;&gt;&gt; c.clear()                       # empty the counter&#10;&gt;&gt;&gt; c&#10;Counter()&#10;&#10;Note:  If a count is set to zero or reduced to zero, it will remain&#10;in the counter until the entry is deleted or the counter is cleared:&#10;&#10;&gt;&gt;&gt; c = Counter('aaabbc')&#10;&gt;&gt;&gt; c['b'] -= 2                     # reduce the count of 'b' by two&#10;&gt;&gt;&gt; c.most_common()                 # 'b' is still in, but its count is zero&#10;[('a', 3), ('c', 1), ('b', 0)]">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.elements" func="yes">
			<Overload retVal="" descr="Iterator over elements repeating each as many times as its count.&#10;&#10;&gt;&gt;&gt; c = Counter('ABCABC')&#10;&gt;&gt;&gt; sorted(c.elements())&#10;['A', 'A', 'B', 'B', 'C', 'C']&#10;&#10;# Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1&#10;&gt;&gt;&gt; prime_factors = Counter({2: 2, 3: 3, 17: 1})&#10;&gt;&gt;&gt; product = 1&#10;&gt;&gt;&gt; for factor in prime_factors.elements():     # loop over factors&#10;...     product *= factor                       # and multiply them&#10;&gt;&gt;&gt; product&#10;1836&#10;&#10;Note, if an element's count has been set to zero or is a negative&#10;number, elements() will ignore it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="cls" />
				<Param name="iterable" />
				<Param name="[v=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.most_common" func="yes">
			<Overload retVal="" descr="List the n most common elements and their counts from the most&#10;common to the least.  If n is None, then list all element counts.&#10;&#10;&gt;&gt;&gt; Counter('abcdeabcdabcaba').most_common(3)&#10;[('a', 5), ('b', 4), ('c', 3)]">
				<Param name="self" />
				<Param name="[n=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.subtract" func="yes">
			<Overload retVal="" descr="Like dict.update() but subtracts counts instead of replacing them.&#10;Counts can be reduced below zero.  Both the inputs and outputs are&#10;allowed to contain zero and negative counts.&#10;&#10;Source can be an iterable, a dictionary, or another Counter instance.&#10;&#10;&gt;&gt;&gt; c = Counter('which')&#10;&gt;&gt;&gt; c.subtract('witch')             # subtract elements from another iterable&#10;&gt;&gt;&gt; c.subtract(Counter('watch'))    # subtract elements from another counter&#10;&gt;&gt;&gt; c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch&#10;0&#10;&gt;&gt;&gt; c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch&#10;-1">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.update" func="yes">
			<Overload retVal="" descr="Like dict.update() but add counts instead of replacing them.&#10;&#10;Source can be an iterable, a dictionary, or another Counter instance.&#10;&#10;&gt;&gt;&gt; c = Counter('which')&#10;&gt;&gt;&gt; c.update('witch')           # add elements from another iterable&#10;&gt;&gt;&gt; d = Counter('watch')&#10;&gt;&gt;&gt; c.update(d)                 # add elements from another counter&#10;&gt;&gt;&gt; c['h']                      # four 'h' in which, witch, and watch&#10;4">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Counter.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Generator" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Hashable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.ItemsView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Iterable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Iterator" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.KeysView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Mapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MappingView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MutableMapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MutableSequence" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.MutableSet" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict" func="yes">
			<Overload retVal="" descr="Dictionary that remembers insertion order">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.clear" func="yes">
			<Overload retVal="" descr="od.clear() -&gt; None.  Remove all items from od.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.copy" func="yes">
			<Overload retVal="" descr="od.copy() -&gt; a shallow copy of od">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.fromkeys" func="yes">
			<Overload retVal="" descr="OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.&#10;If not specified, the value defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.move_to_end" func="yes">
			<Overload retVal="" descr="Move an existing element to the end (or beginning if last==False).&#10;&#10;Raises KeyError if the element does not exist.&#10;When last=True, acts like a fast version of self[key]=self.pop(key).">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.pop" func="yes">
			<Overload retVal="" descr="od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding&#10;value.  If key is not found, d is returned if given, otherwise KeyError&#10;is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.popitem" func="yes">
			<Overload retVal="" descr="Remove and return a (key, value) pair from the dictionary.&#10;&#10;Pairs are returned in LIFO order if last is true or FIFO order if false.">
				<Param name="self" />
				<Param name="[last=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.setdefault" func="yes">
			<Overload retVal="" descr="od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.OrderedDict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Reversible" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Sequence" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Set" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.Sized" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.UserDict" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.UserList" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.UserString" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.ValuesView" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict" func="yes">
			<Overload retVal="" descr="defaultdict(default_factory[, ...]) --&gt; dict with default factory&#10;&#10;The default factory is called without arguments to produce&#10;a new value when a key is not present, in __getitem__ only.&#10;A defaultdict compares equal to a dict with the same items.&#10;All remaining arguments are treated the same as if they were&#10;passed to the dict constructor, including keyword arguments.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.default_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="type" />
				<Param name="iterable" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.defaultdict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;A list-like sequence optimized for data accesses near its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.index" func="yes">
			<Overload retVal="" descr="D.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.insert" func="yes">
			<Overload retVal="" descr="D.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="collections.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys" func="yes">
			<Overload retVal="" descr="Conversion functions between RGB and other color systems.&#10;&#10;This modules provides two functions for each color system ABC:&#10;&#10;  rgb_to_abc(r, g, b) --&gt; a, b, c&#10;  abc_to_rgb(a, b, c) --&gt; r, g, b&#10;&#10;All inputs and outputs are triples of floats in the range [0.0...1.0]&#10;(with the exception of I and Q, which covers a slightly larger range).&#10;Inputs outside the valid range may cause exceptions or invalid outputs.&#10;&#10;Supported color systems:&#10;RGB: Red, Green, Blue components&#10;YIQ: Luminance, Chrominance (used by composite video signals)&#10;HLS: Hue, Luminance, Saturation&#10;HSV: Hue, Saturation, Value">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.ONE_SIXTH" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.ONE_THIRD" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.TWO_THIRD" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="colorsys.hls_to_rgb" />
		<KeyWord name="colorsys.hsv_to_rgb" />
		<KeyWord name="colorsys.rgb_to_hls" />
		<KeyWord name="colorsys.rgb_to_hsv" />
		<KeyWord name="colorsys.rgb_to_yiq" />
		<KeyWord name="colorsys.yiq_to_rgb" />
		<KeyWord name="columnize" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="combine" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="combining" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="commit" func="yes">
			<Overload retVal="" descr="Function of msilib.CAB">
			</Overload>
		</KeyWord>
		<KeyWord name="commonpath" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="commonprefix" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="communicate" func="yes">
			<Overload retVal="" descr="Function of subprocess.Popen">
			</Overload>
		</KeyWord>
		<KeyWord name="compact_traceback" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="compare" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_digest" func="yes">
			<Overload retVal="" descr="Function of hmac">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_networks" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_signal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_to" func="yes">
			<Overload retVal="" descr="Function of tracemalloc.Snapshot">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_total" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compare_total_mag" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="compat" func="yes">
			<Overload retVal="" descr="Function of tokenize.Untokenizer">
			</Overload>
		</KeyWord>
		<KeyWord name="compatible_platforms" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="compile" func="yes">
			<Overload retVal="" descr="Compile source into a code object that can be executed by exec() or eval().&#10;&#10;The source code may represent a Python module, statement or expression.&#10;The filename will be used for run-time error messages.&#10;The mode must be 'exec' to compile a module, 'single' to compile a&#10;single (interactive) statement, or 'eval' to compile an expression.&#10;The flags argument, if present, controls which future statements influence&#10;the compilation of the code.&#10;The dont_inherit argument, if true, stops the compilation inheriting&#10;the effects of any future statements in effect in the code calling&#10;compile; if absent or false these statements do influence the compilation,&#10;in addition to any features explicitly specified.">
				<Param name="source" />
				<Param name="filename" />
				<Param name="mode" />
				<Param name="[flags=0" />
				<Param name="[dont_inherit=False" />
				<Param name="[optimize=-1]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compile_command" func="yes">
			<Overload retVal="" descr="Function of code">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_dir" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_file" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="compile_path" func="yes">
			<Overload retVal="" descr="Function of compileall">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall" func="yes">
			<Overload retVal="" descr="Module/script to byte-compile all .py files to .pyc files.&#10;&#10;When called as a script with arguments, this compiles the directories&#10;given as arguments recursively; the -l option prevents it from&#10;recursing into directories.&#10;&#10;Without arguments, if compiles all modules on sys.path, without&#10;recursing into subdirectories.  (Even though it should do so for&#10;packages -- for now, you'll have to deal with packages separately.)&#10;&#10;See module py_compile for details of the actual byte-compilation.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.ProcessPoolExecutor" func="yes">
			<Overload retVal="" descr="This is an abstract base class for concrete asynchronous executors.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.ProcessPoolExecutor.map" func="yes">
			<Overload retVal="" descr="Returns an iterator equivalent to map(fn, iter).&#10;&#10;Args:&#10;    fn: A callable that will take as many arguments as there are&#10;        passed iterables.&#10;    timeout: The maximum number of seconds to wait. If None, then there&#10;        is no limit on the wait time.&#10;    chunksize: If greater than one, the iterables will be chopped into&#10;        chunks of size chunksize and submitted to the process pool.&#10;        If set to one, the items in the list will be sent one at a time.&#10;&#10;Returns:&#10;    An iterator equivalent to: map(func, *iterables) but the calls may&#10;    be evaluated out-of-order.&#10;&#10;Raises:&#10;    TimeoutError: If the entire result iterator could not be generated&#10;        before the given timeout.&#10;    Exception: If fn(*args) raises for any values.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.ProcessPoolExecutor.shutdown" func="yes">
			<Overload retVal="" descr="Clean-up the resources associated with the Executor.&#10;&#10;It is safe to call this method several times. Otherwise, no other&#10;methods can be called after this one.&#10;&#10;Args:&#10;    wait: If True then shutdown will not return until all running&#10;        futures have finished executing and the resources used by the&#10;        executor have been reclaimed.">
				<Param name="self" />
				<Param name="[wait=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.ProcessPoolExecutor.submit" func="yes">
			<Overload retVal="" descr="Submits a callable to be executed with the given arguments.&#10;&#10;Schedules the callable to be executed as fn(*args, **kwargs) and returns&#10;a Future instance representing the execution of the callable.&#10;&#10;Returns:&#10;    A Future representing the given call.">
				<Param name="self" />
				<Param name="fn" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.compile_dir" func="yes">
			<Overload retVal="" descr="Byte-compile all modules in the given directory tree.&#10;&#10;Arguments (only dir is required):&#10;&#10;dir:       the directory to byte-compile&#10;maxlevels: maximum recursion level (default 10)&#10;ddir:      the directory that will be prepended to the path to the&#10;           file as it is compiled into each byte-code file.&#10;force:     if True, force compilation, even if timestamps are up-to-date&#10;quiet:     full output with False or 0, errors only with 1,&#10;           no output with 2&#10;legacy:    if True, produce legacy pyc paths instead of PEP 3147 paths&#10;optimize:  optimization level or -1 for level of the interpreter&#10;workers:   maximum number of parallel workers">
				<Param name="dir" />
				<Param name="[maxlevels=10" />
				<Param name="[ddir=None" />
				<Param name="[force=False" />
				<Param name="[rx=None" />
				<Param name="[quiet=0" />
				<Param name="[legacy=False" />
				<Param name="[optimize=-1" />
				<Param name="[workers=1]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.compile_file" func="yes">
			<Overload retVal="" descr="Byte-compile one file.&#10;&#10;Arguments (only fullname is required):&#10;&#10;fullname:  the file to byte-compile&#10;ddir:      if given, the directory name compiled in to the&#10;           byte-code file.&#10;force:     if True, force compilation, even if timestamps are up-to-date&#10;quiet:     full output with False or 0, errors only with 1,&#10;           no output with 2&#10;legacy:    if True, produce legacy pyc paths instead of PEP 3147 paths&#10;optimize:  optimization level or -1 for level of the interpreter">
				<Param name="fullname" />
				<Param name="[ddir=None" />
				<Param name="[force=False" />
				<Param name="[rx=None" />
				<Param name="[quiet=0" />
				<Param name="[legacy=False" />
				<Param name="[optimize=-1]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.compile_path" func="yes">
			<Overload retVal="" descr="Byte-compile all module on sys.path.&#10;&#10;Arguments (all optional):&#10;&#10;skip_curdir: if true, skip current directory (default True)&#10;maxlevels:   max recursion level (default 0)&#10;force: as for compile_dir() (default False)&#10;quiet: as for compile_dir() (default 0)&#10;legacy: as for compile_dir() (default False)&#10;optimize: as for compile_dir() (default -1)">
				<Param name="[skip_curdir=1" />
				<Param name="[maxlevels=0" />
				<Param name="[force=False" />
				<Param name="[quiet=0" />
				<Param name="[legacy=False" />
				<Param name="[optimize=-1]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.main" func="yes">
			<Overload retVal="" descr="Script main program.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.partial" func="yes">
			<Overload retVal="" descr="partial(func, *args, **keywords) - new function with partial application&#10;of the given arguments and keywords.">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.partial.args" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.partial.func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="compileall.partial.keywords" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="complete" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_b" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_break" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_cl" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_clear" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_commands" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_condition" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_debug" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_disable" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_display" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_enable" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_help" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_ignore" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_p" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_pp" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_print" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_source" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_statement" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_tbreak" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_unalias" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_undisplay" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="complete_whatis" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="completedefault" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="completenames" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="complex" func="yes">
			<Overload retVal="" descr="complex(real[, imag]) -&gt; complex number&#10;&#10;Create a complex number from a real part and an optional imaginary part.&#10;This is equivalent to (real + imag*1j) where imag defaults to 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="compress" func="yes">
			<Overload retVal="" descr="Function of bz2">
			</Overload>
		</KeyWord>
		<KeyWord name="compression" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="concat" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="concurrent" />
		<KeyWord name="condition" func="yes">
			<Overload retVal="" descr="Function of msilib.Control">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser" func="yes">
			<Overload retVal="" descr="Configuration file parser.&#10;&#10;A configuration file consists of sections, lead by a &quot;[section]&quot; header,&#10;and followed by &quot;name: value&quot; entries, with continuations and such in&#10;the style of RFC 822.&#10;&#10;Intrinsic defaults can be specified by passing them into the&#10;ConfigParser constructor as a dictionary.&#10;&#10;class:&#10;&#10;ConfigParser -- responsible for parsing a list of&#10;                    configuration files, and managing the parsed database.&#10;&#10;    methods:&#10;&#10;    __init__(defaults=None, dict_type=_default_dict, allow_no_value=False,&#10;             delimiters=('=', ':'), comment_prefixes=('#', ';'),&#10;             inline_comment_prefixes=None, strict=True,&#10;             empty_lines_in_values=True, default_section='DEFAULT',&#10;             interpolation=&lt;unset&gt;, converters=&lt;unset&gt;):&#10;        Create the parser. When `defaults' is given, it is initialized into the&#10;        dictionary or intrinsic defaults. The keys must be strings, the values&#10;        must be appropriate for %()s string interpolation.&#10;&#10;        When `dict_type' is given, it will be used to create the dictionary&#10;        objects for the list of sections, for the options within a section, and&#10;        for the default values.&#10;&#10;        When `delimiters' is given, it will be used as the set of substrings&#10;        that divide keys from values.&#10;&#10;        When `comment_prefixes' is given, it will be used as the set of&#10;        substrings that prefix comments in empty lines. Comments can be&#10;        indented.&#10;&#10;        When `inline_comment_prefixes' is given, it will be used as the set of&#10;        substrings that prefix comments in non-empty lines.&#10;&#10;        When `strict` is True, the parser won't allow for any section or option&#10;        duplicates while reading from a single source (file, string or&#10;        dictionary). Default is True.&#10;&#10;        When `empty_lines_in_values' is False (default: True), each empty line&#10;        marks the end of an option. Otherwise, internal empty lines of&#10;        a multiline option are kept as part of the value.&#10;&#10;        When `allow_no_value' is True (default: False), options without&#10;        values are accepted; the value presented for these is None.&#10;&#10;        When `default_section' is given, the name of the special section is&#10;        named accordingly. By default it is called ``&quot;DEFAULT&quot;`` but this can&#10;        be customized to point to any other valid section name. Its current&#10;        value can be retrieved using the ``parser_instance.default_section``&#10;        attribute and may be modified at runtime.&#10;&#10;        When `interpolation` is given, it should be an Interpolation subclass&#10;        instance. It will be used as the handler for option value&#10;        pre-processing when using getters. RawConfigParser object s don't do&#10;        any sort of interpolation, whereas ConfigParser uses an instance of&#10;        BasicInterpolation. The library also provides a ``zc.buildbot``&#10;        inspired ExtendedInterpolation implementation.&#10;&#10;        When `converters` is given, it should be a dictionary where each key&#10;        represents the name of a type converter and each value is a callable&#10;        implementing the conversion from string to the desired datatype. Every&#10;        converter gets its corresponding get*() method on the parser object and&#10;        section proxies.&#10;&#10;    sections()&#10;        Return all the configuration section names, sans DEFAULT.&#10;&#10;    has_section(section)&#10;        Return whether the given section exists.&#10;&#10;    has_option(section, option)&#10;        Return whether the given option exists in the given section.&#10;&#10;    options(section)&#10;        Return list of configuration options for the named section.&#10;&#10;    read(filenames, encoding=None)&#10;        Read and parse the list of named configuration files, given by&#10;        name.  A single filename is also allowed.  Non-existing files&#10;        are ignored.  Return list of successfully read files.&#10;&#10;    read_file(f, filename=None)&#10;        Read and parse one configuration file, given as a file object.&#10;        The filename defaults to f.name; it is only used in error&#10;        messages (if f has no `name' attribute, the string `&lt;???&gt;' is used).&#10;&#10;    read_string(string)&#10;        Read configuration from a given string.&#10;&#10;    read_dict(dictionary)&#10;        Read configuration from a dictionary. Keys are section names,&#10;        values are dictionaries with keys and values that should be present&#10;        in the section. If the used dictionary type preserves order, sections&#10;        and their keys will be added in order. Values are automatically&#10;        converted to strings.&#10;&#10;    get(section, option, raw=False, vars=None, fallback=_UNSET)&#10;        Return a string value for the named option.  All % interpolations are&#10;        expanded in the return values, based on the defaults passed into the&#10;        constructor and the DEFAULT section.  Additional substitutions may be&#10;        provided using the `vars' argument, which must be a dictionary whose&#10;        contents override any pre-existing defaults. If `option' is a key in&#10;        `vars', the value from `vars' is used.&#10;&#10;    getint(section, options, raw=False, vars=None, fallback=_UNSET)&#10;        Like get(), but convert value to an integer.&#10;&#10;    getfloat(section, options, raw=False, vars=None, fallback=_UNSET)&#10;        Like get(), but convert value to a float.&#10;&#10;    getboolean(section, options, raw=False, vars=None, fallback=_UNSET)&#10;        Like get(), but convert value to a boolean (currently case&#10;        insensitively defined as 0, false, no, off for False, and 1, true,&#10;        yes, on for True).  Returns False or True.&#10;&#10;    items(section=_UNSET, raw=False, vars=None)&#10;        If section is given, return a list of tuples with (name, value) for&#10;        each option in the section. Otherwise, return a list of tuples with&#10;        (section_name, section_proxy) for each section, including DEFAULTSECT.&#10;&#10;    remove_section(section)&#10;        Remove the given file section and all its options.&#10;&#10;    remove_option(section, option)&#10;        Remove the given option from the given section.&#10;&#10;    set(section, option, value)&#10;        Set the given option.&#10;&#10;    write(fp, space_around_delimiters=True)&#10;        Write the configuration state in .ini format. If&#10;        `space_around_delimiters' is True (the default), delimiters&#10;        between keys and values are surrounded by spaces.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.BasicInterpolation" func="yes">
			<Overload retVal="" descr="Interpolation as implemented in the classic ConfigParser.&#10;&#10;The option values can contain format strings which refer to other values in&#10;the same section, or values in the special default section.&#10;&#10;For example:&#10;&#10;    something: %(dir)s/whatever&#10;&#10;would resolve the &quot;%(dir)s&quot; to the value of dir.  All reference&#10;expansions are done late, on demand. If a user needs to use a bare % in&#10;a configuration file, she can escape it by writing %%. Other % usage&#10;is considered a user error and raises `InterpolationSyntaxError'.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.BasicInterpolation.before_get" />
		<KeyWord name="configparser.BasicInterpolation.before_read" />
		<KeyWord name="configparser.BasicInterpolation.before_set" />
		<KeyWord name="configparser.BasicInterpolation.before_write" />
		<KeyWord name="configparser.ConfigParser" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ConverterMapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DEFAULTSECT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DuplicateOptionError" func="yes">
			<Overload retVal="" descr="Raised by strict parsers when an option is repeated in an input source.&#10;&#10;Current implementation raises this exception only when an option is found&#10;more than once in a single file, string or dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DuplicateOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DuplicateOptionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DuplicateSectionError" func="yes">
			<Overload retVal="" descr="Raised when a section is repeated in an input source.&#10;&#10;Possible repetitions that raise this exception are: multiple creation&#10;using the API or in strict parsers when a section is found more than once&#10;in a single input file, string or dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DuplicateSectionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.DuplicateSectionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.Error" func="yes">
			<Overload retVal="" descr="Base class for ConfigParser exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ExtendedInterpolation" func="yes">
			<Overload retVal="" descr="Advanced variant of interpolation, supports the syntax used by&#10;`zc.buildout'. Enables interpolation between sections.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ExtendedInterpolation.before_get" />
		<KeyWord name="configparser.ExtendedInterpolation.before_read" />
		<KeyWord name="configparser.ExtendedInterpolation.before_set" />
		<KeyWord name="configparser.ExtendedInterpolation.before_write" />
		<KeyWord name="configparser.Interpolation" func="yes">
			<Overload retVal="" descr="Dummy interpolation that passes the value through with no changes.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.Interpolation.before_get" />
		<KeyWord name="configparser.Interpolation.before_read" />
		<KeyWord name="configparser.Interpolation.before_set" />
		<KeyWord name="configparser.Interpolation.before_write" />
		<KeyWord name="configparser.InterpolationDepthError" func="yes">
			<Overload retVal="" descr="Raised when substitutions are nested too deeply.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationDepthError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationDepthError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationError" func="yes">
			<Overload retVal="" descr="Base class for interpolation-related exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationMissingOptionError" func="yes">
			<Overload retVal="" descr="A string substitution required a setting which was not available.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationMissingOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationMissingOptionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationSyntaxError" func="yes">
			<Overload retVal="" descr="Raised when the source text contains invalid syntax.&#10;&#10;Current implementation raises this exception when the source text into&#10;which substitutions are made does not conform to the required syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationSyntaxError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.InterpolationSyntaxError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.LegacyInterpolation" func="yes">
			<Overload retVal="" descr="Deprecated interpolation used in old versions of ConfigParser.&#10;Use BasicInterpolation or ExtendedInterpolation instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.LegacyInterpolation.before_get" />
		<KeyWord name="configparser.LegacyInterpolation.before_read" />
		<KeyWord name="configparser.LegacyInterpolation.before_set" />
		<KeyWord name="configparser.LegacyInterpolation.before_write" />
		<KeyWord name="configparser.MAX_INTERPOLATION_DEPTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.MissingSectionHeaderError" func="yes">
			<Overload retVal="" descr="Raised when a key-value pair is found before any section header.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.MissingSectionHeaderError.append" />
		<KeyWord name="configparser.MissingSectionHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.MissingSectionHeaderError.filename" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.MissingSectionHeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.MutableMapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.NoOptionError" func="yes">
			<Overload retVal="" descr="A requested option was not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.NoOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.NoOptionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.NoSectionError" func="yes">
			<Overload retVal="" descr="Raised when no section matches a requested option.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.NoSectionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.NoSectionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ParsingError" func="yes">
			<Overload retVal="" descr="Raised when a configuration file does not follow legal syntax.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ParsingError.append" />
		<KeyWord name="configparser.ParsingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ParsingError.filename" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.ParsingError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.RawConfigParser" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.SafeConfigParser" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="configparser.SectionProxy" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="connect" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="connect_accepted_socket" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="connect_ex" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="connect_pipe" func="yes">
			<Overload retVal="" descr="Function of asyncio.IocpProactor">
			</Overload>
		</KeyWord>
		<KeyWord name="connect_read_pipe" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="connect_write_pipe" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="connection_lost" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="connection_made" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="constructor" func="yes">
			<Overload retVal="" descr="Function of copyreg">
			</Overload>
		</KeyWord>
		<KeyWord name="contains" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="context_diff" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib" func="yes">
			<Overload retVal="" descr="Utilities for with-statement contexts.  See PEP 343.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.AbstractContextManager" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.ContextDecorator" func="yes">
			<Overload retVal="" descr="A base class or mixin that enables context managers to work as decorators.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.ExitStack" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.closing" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.contextmanager" func="yes">
			<Overload retVal="" descr="@contextmanager decorator.&#10;&#10;Typical usage:&#10;&#10;    @contextmanager&#10;    def some_generator(&lt;arguments&gt;):&#10;        &lt;setup&gt;&#10;        try:&#10;            yield &lt;value&gt;&#10;        finally:&#10;            &lt;cleanup&gt;&#10;&#10;This makes this:&#10;&#10;    with some_generator(&lt;arguments&gt;) as &lt;variable&gt;:&#10;        &lt;body&gt;&#10;&#10;equivalent to this:&#10;&#10;    &lt;setup&gt;&#10;    try:&#10;        &lt;variable&gt; = &lt;value&gt;&#10;        &lt;body&gt;&#10;    finally:&#10;        &lt;cleanup&gt;">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;A list-like sequence optimized for data accesses near its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.index" func="yes">
			<Overload retVal="" descr="D.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.insert" func="yes">
			<Overload retVal="" descr="D.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.redirect_stderr" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.redirect_stdout" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.suppress" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="contextlib.wraps" func="yes">
			<Overload retVal="" descr="Decorator factory to apply update_wrapper() to a wrapper function&#10;&#10;Returns a decorator that invokes update_wrapper() with the decorated&#10;function as the wrapper argument and the arguments to wraps() as the&#10;remaining arguments. Default arguments are as for update_wrapper().&#10;This is a convenience function to simplify applying partial() to&#10;update_wrapper().">
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="contextmanager" func="yes">
			<Overload retVal="" descr="Function of contextlib">
			</Overload>
		</KeyWord>
		<KeyWord name="continue" />
		<KeyWord name="control" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="convert_arg_line_to_args" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="convert_field" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="convert_path" func="yes">
			<Overload retVal="" descr="Function of setuptools">
			</Overload>
		</KeyWord>
		<KeyWord name="convert_value" func="yes">
			<Overload retVal="" descr="Function of optparse.Option">
			</Overload>
		</KeyWord>
		<KeyWord name="converter" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a set.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.copy" func="yes">
			<Overload retVal="" descr="Shallow copy operation on arbitrary Python objects.&#10;&#10;See the module's __doc__ string for more info.">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy.deepcopy" func="yes">
			<Overload retVal="" descr="Deep copy operation on arbitrary Python objects.&#10;&#10;See the module's __doc__ string for more info.">
				<Param name="x" />
				<Param name="[memo=None" />
				<Param name="[_nil=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="copy.dispatch_table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="copy.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="copy2" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_abs" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_decimal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_file" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_location" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_negate" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_sign" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="copy_tree" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="copyfile" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copyfileobj" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copymode" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copyreg" func="yes">
			<Overload retVal="" descr="Helper to provide extensibility for pickle.&#10;&#10;This is only useful to add pickle support for extension types defined in&#10;C, not for instances of user-defined classes.">
			</Overload>
		</KeyWord>
		<KeyWord name="copyreg.add_extension" func="yes">
			<Overload retVal="" descr="Register an extension code.">
				<Param name="module" />
				<Param name="name" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="copyreg.clear_extension_cache" />
		<KeyWord name="copyreg.constructor" />
		<KeyWord name="copyreg.dispatch_table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="copyreg.pickle" func="yes">
			<Overload retVal="" descr=>
				<Param name="ob_type" />
				<Param name="pickle_function" />
				<Param name="[constructor_ob=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="copyreg.pickle_complex" />
		<KeyWord name="copyreg.remove_extension" func="yes">
			<Overload retVal="" descr="Unregister an extension code.  For testing only.">
				<Param name="module" />
				<Param name="name" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="copystat" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="copytree" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="coroutine" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="countOf" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="countTestCases" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="count_calls" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="cpu_count" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="cram" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="crc32" func="yes">
			<Overload retVal="" descr="Function of zipfile">
			</Overload>
		</KeyWord>
		<KeyWord name="create" func="yes">
			<Overload retVal="" descr="Function of venv">
			</Overload>
		</KeyWord>
		<KeyWord name="createLock" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="createTests" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="create_aggregate" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="create_archive" func="yes">
			<Overload retVal="" descr="Function of zipapp">
			</Overload>
		</KeyWord>
		<KeyWord name="create_collation" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="create_configuration" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="create_connection" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="create_datagram_endpoint" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_decimal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="create_decimal_from_float" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="create_default_context" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="create_dynamic" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="create_function" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="create_future" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_gnu_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="create_main_parser" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="create_module" func="yes">
			<Overload retVal="" descr="Function of imp.SourcelessFileLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="create_pax_global_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="create_pax_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="create_pipe_connection" func="yes">
			<Overload retVal="" descr="Function of asyncio.ProactorEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_server" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_socket" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="create_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="create_string_buffer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="create_subprocess_exec" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="create_subprocess_shell" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="create_task" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_unicode_buffer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="create_unix_connection" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_unix_server" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="create_ustar_header" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="critical" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="csv" func="yes">
			<Overload retVal="" descr="CSV parsing and writing.&#10;&#10;This module provides classes that assist in the reading and writing&#10;of Comma Separated Value (CSV) files, and implements the interface&#10;described by PEP 305.  Although many CSV files are simple to parse,&#10;the format is not formally defined by a stable specification and&#10;is subtle enough that parsing lines of a CSV file with something&#10;like line.split(&quot;,&quot;) is bound to fail.  The module supports three&#10;basic APIs: reading, writing, and registration of dialects.&#10;&#10;&#10;DIALECT REGISTRATION:&#10;&#10;Readers and writers support a dialect argument, which is a convenient&#10;handle on a group of settings.  When the dialect argument is a string,&#10;it identifies one of the dialects previously registered with the module.&#10;If it is a class or instance, the attributes of the argument are used as&#10;the settings for the reader or writer:&#10;&#10;    class excel:&#10;        delimiter = ','&#10;        quotechar = '&quot;'&#10;        escapechar = None&#10;        doublequote = True&#10;        skipinitialspace = False&#10;        lineterminator = '\r\n'&#10;        quoting = QUOTE_MINIMAL&#10;&#10;SETTINGS:&#10;&#10;    * quotechar - specifies a one-character string to use as the &#10;        quoting character.  It defaults to '&quot;'.&#10;    * delimiter - specifies a one-character string to use as the &#10;        field separator.  It defaults to ','.&#10;    * skipinitialspace - specifies how to interpret whitespace which&#10;        immediately follows a delimiter.  It defaults to False, which&#10;        means that whitespace immediately following a delimiter is part&#10;        of the following field.&#10;    * lineterminator -  specifies the character sequence which should &#10;        terminate rows.&#10;    * quoting - controls when quotes should be generated by the writer.&#10;        It can take on any of the following module constants:&#10;&#10;        csv.QUOTE_MINIMAL means only when required, for example, when a&#10;            field contains either the quotechar or the delimiter&#10;        csv.QUOTE_ALL means that quotes are always placed around fields.&#10;        csv.QUOTE_NONNUMERIC means that quotes are always placed around&#10;            fields which do not parse as integers or floating point&#10;            numbers.&#10;        csv.QUOTE_NONE means that quotes are never placed around fields.&#10;    * escapechar - specifies a one-character string used to escape &#10;        the delimiter when quoting is set to QUOTE_NONE.&#10;    * doublequote - controls the handling of quotes inside fields.  When&#10;        True, two consecutive quotes are interpreted as one during read,&#10;        and when writing, each quote character embedded in the data is&#10;        written as two quotes">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Dialect" func="yes">
			<Overload retVal="" descr="Describe a CSV dialect.&#10;&#10;This must be subclassed (see csv.excel).  Valid attributes are:&#10;delimiter, quotechar, escapechar, doublequote, skipinitialspace,&#10;lineterminator, quoting.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.DictReader" />
		<KeyWord name="csv.DictReader.fieldnames" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.DictWriter" />
		<KeyWord name="csv.DictWriter.writeheader" />
		<KeyWord name="csv.DictWriter.writerow" />
		<KeyWord name="csv.DictWriter.writerows" />
		<KeyWord name="csv.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict" func="yes">
			<Overload retVal="" descr="Dictionary that remembers insertion order">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.clear" func="yes">
			<Overload retVal="" descr="od.clear() -&gt; None.  Remove all items from od.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.copy" func="yes">
			<Overload retVal="" descr="od.copy() -&gt; a shallow copy of od">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.fromkeys" func="yes">
			<Overload retVal="" descr="OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.&#10;If not specified, the value defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.move_to_end" func="yes">
			<Overload retVal="" descr="Move an existing element to the end (or beginning if last==False).&#10;&#10;Raises KeyError if the element does not exist.&#10;When last=True, acts like a fast version of self[key]=self.pop(key).">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.pop" func="yes">
			<Overload retVal="" descr="od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding&#10;value.  If key is not found, d is returned if given, otherwise KeyError&#10;is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.popitem" func="yes">
			<Overload retVal="" descr="Remove and return a (key, value) pair from the dictionary.&#10;&#10;Pairs are returned in LIFO order if last is true or FIFO order if false.">
				<Param name="self" />
				<Param name="[last=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.setdefault" func="yes">
			<Overload retVal="" descr="od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.OrderedDict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.QUOTE_ALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.QUOTE_NONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.QUOTE_NONNUMERIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Sniffer" func="yes">
			<Overload retVal="" descr='"Sniffs" the format of a CSV file (i.e. delimiter, quotechar)&#10;Returns a Dialect object.'>
			</Overload>
		</KeyWord>
		<KeyWord name="csv.Sniffer.has_header" />
		<KeyWord name="csv.Sniffer.sniff" func="yes">
			<Overload retVal="" descr="Returns a dialect (or None) corresponding to the sample">
				<Param name="self" />
				<Param name="sample" />
				<Param name="[delimiters=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO" func="yes">
			<Overload retVal="" descr="Text I/O implementation using an in-memory buffer.&#10;&#10;The initial_value argument sets the value of object.  The newline&#10;argument is like the one of TextIOWrapper's constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.close" func="yes">
			<Overload retVal="" descr="Close the IO object.&#10;&#10;Attempting any further operation after the object is closed&#10;will raise a ValueError.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.encoding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.line_buffering" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.read" func="yes">
			<Overload retVal="" descr="Read at most size characters, returned as a string.&#10;&#10;If the argument is negative or omitted, read until EOF&#10;is reached. Return an empty string at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to character offset pos relative to position indicated by whence:&#10;    0  Start of stream (the default).  pos should be &gt;= 0;&#10;    1  Current position - pos must be 0;&#10;    2  End of stream - pos must be 0.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.tell" func="yes">
			<Overload retVal="" descr="Tell the current file position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate size to pos.&#10;&#10;The pos argument defaults to the current file position, as&#10;returned by tell().  The current file position is unchanged.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.write" func="yes">
			<Overload retVal="" descr="Write string to file.&#10;&#10;Returns the number of characters written, which is always equal to&#10;the length of the string.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="csv.StringIO.writelines" />
		<KeyWord name="csv.excel" func="yes">
			<Overload retVal="" descr="Describe the usual properties of Excel-generated CSV files.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel.delimiter" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel.doublequote" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel.lineterminator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel.quotechar" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel_tab" func="yes">
			<Overload retVal="" descr="Describe the usual properties of Excel-generated TAB-delimited files.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel_tab.delimiter" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel_tab.doublequote" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel_tab.lineterminator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.excel_tab.quotechar" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.field_size_limit" func="yes">
			<Overload retVal="" descr="Sets an upper limit on parsed fields.&#10;    csv.field_size_limit([limit])&#10;&#10;Returns old limit. If limit is not given, no new limit is set and&#10;the old limit is returned">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.get_dialect" func="yes">
			<Overload retVal="" descr="Return the dialect instance associated with name.&#10;dialect = csv.get_dialect(name)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.list_dialects" func="yes">
			<Overload retVal="" descr="Return a list of all know dialect names.&#10;names = csv.list_dialects()">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.reader" func="yes">
			<Overload retVal="" descr="csv_reader = reader(iterable [, dialect='excel']&#10;                        [optional keyword args])&#10;    for row in csv_reader:&#10;        process(row)&#10;&#10;The &quot;iterable&quot; argument can be any object that returns a line&#10;of input for each iteration, such as a file object or a list.  The&#10;optional &quot;dialect&quot; parameter is discussed below.  The function&#10;also accepts optional keyword arguments which override settings&#10;provided by the dialect.&#10;&#10;The returned object is an iterator.  Each iteration returns a row&#10;of the CSV file (which can span multiple input lines).">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.register_dialect" func="yes">
			<Overload retVal="" descr="Create a mapping from a string name to a dialect class.&#10;dialect = csv.register_dialect(name[, dialect[, **fmtparams]])">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unix_dialect" func="yes">
			<Overload retVal="" descr="Describe the usual properties of Unix-generated CSV files.">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unix_dialect.delimiter" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unix_dialect.doublequote" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unix_dialect.lineterminator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unix_dialect.quotechar" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unix_dialect.quoting" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.unregister_dialect" func="yes">
			<Overload retVal="" descr="Delete the name/dialect mapping associated with a string name.&#10;csv.unregister_dialect(name)">
			</Overload>
		</KeyWord>
		<KeyWord name="csv.writer" func="yes">
			<Overload retVal="" descr="csv_writer = csv.writer(fileobj [, dialect='excel']&#10;                            [optional keyword args])&#10;    for row in sequence:&#10;        csv_writer.writerow(row)&#10;&#10;    [or]&#10;&#10;    csv_writer = csv.writer(fileobj [, dialect='excel']&#10;                            [optional keyword args])&#10;    csv_writer.writerows(rows)&#10;&#10;The &quot;fileobj&quot; argument can be any object that supports the file API.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctime" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes" func="yes">
			<Overload retVal="" descr="create and manipulate C data types in Python">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.ARRAY" />
		<KeyWord name="ctypes.ArgumentError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.ArgumentError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.ArgumentError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.Array" func="yes">
			<Overload retVal="" descr="(PyCArrayType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.BigEndianStructure" func="yes">
			<Overload retVal="" descr="(_swapped_meta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.CDLL" func="yes">
			<Overload retVal="" descr="An instance of this class represents a loaded dll/shared&#10;library, exporting functions using the standard C calling&#10;convention (named 'cdecl' on Windows).&#10;&#10;The exported functions can be accessed as attributes, or by&#10;indexing with the function name.  Examples:&#10;&#10;&lt;obj&gt;.qsort -&gt; callable object&#10;&lt;obj&gt;['qsort'] -&gt; callable object&#10;&#10;Calling the functions releases the Python GIL during the call and&#10;reacquires it afterwards.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.CFUNCTYPE" func="yes">
			<Overload retVal="" descr="CFUNCTYPE(restype, *argtypes,&#10;             use_errno=False, use_last_error=False) -&gt; function prototype.&#10;&#10;restype: the result type&#10;argtypes: a sequence specifying the argument types&#10;&#10;The function prototype can be called in different ways to create a&#10;callable object:&#10;&#10;prototype(integer address) -&gt; foreign function&#10;prototype(callable) -&gt; create and return a C callable function from callable&#10;prototype(integer index, method name[, paramflags]) -&gt; foreign function calling a COM method&#10;prototype((ordinal number, dll object)[, paramflags]) -&gt; foreign function exported by ordinal&#10;prototype((function name, dll object)[, paramflags]) -&gt; foreign function exported by name">
				<Param name="restype" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.DllCanUnloadNow" />
		<KeyWord name="ctypes.DllGetClassObject" />
		<KeyWord name="ctypes.FormatError" func="yes">
			<Overload retVal="" descr="FormatError([integer]) -&gt; string&#10;&#10;Convert a win32 error code into a string. If the error code is not&#10;given, the return value of a call to GetLastError() is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.GetLastError" func="yes">
			<Overload retVal="" descr="(_FuncPtr)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.HRESULT" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.LibraryLoader" />
		<KeyWord name="ctypes.LibraryLoader.LoadLibrary" />
		<KeyWord name="ctypes.LittleEndianStructure" func="yes">
			<Overload retVal="" descr="(PyCStructType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.OleDLL" func="yes">
			<Overload retVal="" descr="This class represents a dll exporting functions using the&#10;Windows stdcall calling convention, and returning HRESULT.&#10;HRESULT error values are automatically raised as OSError&#10;exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.POINTER" />
		<KeyWord name="ctypes.PYFUNCTYPE" />
		<KeyWord name="ctypes.PyDLL" func="yes">
			<Overload retVal="" descr="This class represents the Python library itself.  It allows&#10;accessing Python API functions.  The GIL is not released, and&#10;Python exceptions are handled correctly.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.SetPointerType" />
		<KeyWord name="ctypes.Structure" func="yes">
			<Overload retVal="" descr="(PyCStructType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.Union" func="yes">
			<Overload retVal="" descr="(UnionType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.WINFUNCTYPE" func="yes">
			<Overload retVal="" descr=>
				<Param name="restype" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.WinDLL" func="yes">
			<Overload retVal="" descr="This class represents a dll exporting functions using the&#10;Windows stdcall calling convention.">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.WinError" func="yes">
			<Overload retVal="" descr=>
				<Param name="[code=None" />
				<Param name="[descr=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.addressof" func="yes">
			<Overload retVal="" descr="addressof(C instance) -&gt; integer&#10;Return the address of the C instance internal buffer">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.alignment" func="yes">
			<Overload retVal="" descr="alignment(C type) -&gt; integer&#10;alignment(C instance) -&gt; integer&#10;Return the alignment requirements of a C instance">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.byref" func="yes">
			<Overload retVal="" descr="byref(C instance[, offset=0]) -&gt; byref-object&#10;Return a pointer lookalike to a C instance, only usable&#10;as function argument">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_bool" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_buffer" func="yes">
			<Overload retVal="" descr=>
				<Param name="init" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_byte" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_char" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_char_p" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_double" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_float" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int16" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int32" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int64" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_int8" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_long" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_longdouble" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_longlong" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_short" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_size_t" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ssize_t" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ubyte" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint16" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint32" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint64" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_uint8" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ulong" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ulonglong" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_ushort" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_void_p" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_voidp" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_wchar" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.c_wchar_p" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.cast" />
		<KeyWord name="ctypes.cdll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.create_string_buffer" func="yes">
			<Overload retVal="" descr="create_string_buffer(aBytes) -&gt; character array&#10;create_string_buffer(anInteger) -&gt; character array&#10;create_string_buffer(aBytes, anInteger) -&gt; character array">
				<Param name="init" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.create_unicode_buffer" func="yes">
			<Overload retVal="" descr="create_unicode_buffer(aString) -&gt; character array&#10;create_unicode_buffer(anInteger) -&gt; character array&#10;create_unicode_buffer(aString, anInteger) -&gt; character array">
				<Param name="init" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.get_errno" />
		<KeyWord name="ctypes.get_last_error" />
		<KeyWord name="ctypes.memmove" func="yes">
			<Overload retVal="" descr="(CFunctionType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.memset" func="yes">
			<Overload retVal="" descr="(CFunctionType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.oledll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.pointer" />
		<KeyWord name="ctypes.py_object" func="yes">
			<Overload retVal="" descr="(PyCSimpleType)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.pydll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.pythonapi" func="yes">
			<Overload retVal="" descr="(PyDLL)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.resize" func="yes">
			<Overload retVal="" descr="Resize the memory buffer of a ctypes instance">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.set_errno" />
		<KeyWord name="ctypes.set_last_error" />
		<KeyWord name="ctypes.sizeof" func="yes">
			<Overload retVal="" descr="sizeof(C type) -&gt; integer&#10;sizeof(C instance) -&gt; integer&#10;Return the size in bytes of a C instance">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.string_at" func="yes">
			<Overload retVal="" descr="string_at(addr[, size]) -&gt; string&#10;&#10;Return the string at addr.">
				<Param name="ptr" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.windll" func="yes">
			<Overload retVal="" descr="(LibraryLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="ctypes.wstring_at" func="yes">
			<Overload retVal="" descr="wstring_at(addr[, size]) -&gt; string&#10;&#10;Return the string at addr.">
				<Param name="ptr" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="currency" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="currentThread" func="yes">
			<Overload retVal="" descr="Function of threading">
			</Overload>
		</KeyWord>
		<KeyWord name="current_process" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="current_task" func="yes">
			<Overload retVal="" descr="Function of asyncio.Task">
			</Overload>
		</KeyWord>
		<KeyWord name="current_thread" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="currentframe" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="cursor" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="cwd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="data" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="data_received" func="yes">
			<Overload retVal="" descr="Function of asyncio.Protocol">
			</Overload>
		</KeyWord>
		<KeyWord name="datagram_received" func="yes">
			<Overload retVal="" descr="Function of asyncio.DatagramProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="date" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime" func="yes">
			<Overload retVal="" descr="Fast implementation of the datetime type.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.MAXYEAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.MINYEAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date" func="yes">
			<Overload retVal="" descr="date(year, month, day) --&gt; date object">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp -&gt; local date from a POSIX timestamp (like time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.isoformat" func="yes">
			<Overload retVal="" descr="Return string in ISO 8601 format, YYYY-MM-DD.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.max" func="yes">
			<Overload retVal="" descr="(date)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.min" func="yes">
			<Overload retVal="" descr="(date)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.replace" func="yes">
			<Overload retVal="" descr="Return date with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.date.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime" func="yes">
			<Overload retVal="" descr="datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])&#10;&#10;The year, month and day arguments are required. tzinfo may be None, or an&#10;instance of a tzinfo subclass. The remaining arguments may be ints.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.astimezone" func="yes">
			<Overload retVal="" descr="tz -&gt; convert to local time in new timezone tz">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.combine" func="yes">
			<Overload retVal="" descr="date, time -&gt; datetime with same date and time fields">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.date" func="yes">
			<Overload retVal="" descr="Return date object with same year, month and day.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.fold" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp[, tz] -&gt; tz's local time from POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.isoformat" func="yes">
			<Overload retVal="" descr="[sep] -&gt; string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].&#10;sep is used to separate the year from the time, and defaults to 'T'.&#10;timespec specifies what components of the time to include (allowed values are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds', and 'microseconds').">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.max" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.min" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.now" func="yes">
			<Overload retVal="" descr="Returns new datetime object representing current time local to tz.&#10;&#10;  tz&#10;    Timezone object.&#10;&#10;If no tz is specified, uses local timezone.">
				<Param name="type" />
				<Param name="[tz=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.replace" func="yes">
			<Overload retVal="" descr="Return datetime with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.strptime" func="yes">
			<Overload retVal="" descr="string, format -&gt; new datetime parsed from a string (like time.strptime()).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.time" func="yes">
			<Overload retVal="" descr="Return time object with same time but with tzinfo=None.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.timestamp" func="yes">
			<Overload retVal="" descr="Return POSIX timestamp as float.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.timetz" func="yes">
			<Overload retVal="" descr="Return time object with same time and tzinfo.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.utcfromtimestamp" func="yes">
			<Overload retVal="" descr="Construct a naive UTC datetime from a POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.utcnow" func="yes">
			<Overload retVal="" descr="Return a new datetime representing UTC day and time.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.utctimetuple" func="yes">
			<Overload retVal="" descr="Return UTC time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.datetime_CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time" func="yes">
			<Overload retVal="" descr="time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --&gt; a time object&#10;&#10;All arguments are optional. tzinfo may be None, or an instance of&#10;a tzinfo subclass. The remaining arguments may be ints.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.fold" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.isoformat" func="yes">
			<Overload retVal="" descr="Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].&#10;&#10;timespec specifies what components of the time to include.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.max" func="yes">
			<Overload retVal="" descr="(time)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.min" func="yes">
			<Overload retVal="" descr="(time)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.replace" func="yes">
			<Overload retVal="" descr="Return time with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.time.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta" func="yes">
			<Overload retVal="" descr="Difference between two datetime values.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.days" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.max" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.microseconds" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.min" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.seconds" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timedelta.total_seconds" func="yes">
			<Overload retVal="" descr="Total seconds in the duration.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone" func="yes">
			<Overload retVal="" descr="Fixed offset from UTC implementation of tzinfo.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.dst" func="yes">
			<Overload retVal="" descr="Return None.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.fromutc" func="yes">
			<Overload retVal="" descr="datetime in UTC -&gt; datetime in local time.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.max" func="yes">
			<Overload retVal="" descr="(timezone)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.min" func="yes">
			<Overload retVal="" descr="(timezone)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.tzname" func="yes">
			<Overload retVal="" descr="If name is specified when timezone is created, returns the name.  Otherwise returns offset as 'UTC(+|-)HH:MM'.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.utc" func="yes">
			<Overload retVal="" descr="(timezone)">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.timezone.utcoffset" func="yes">
			<Overload retVal="" descr="Return fixed offset.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.tzinfo" func="yes">
			<Overload retVal="" descr="Abstract base class for time zone info objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.tzinfo.dst" func="yes">
			<Overload retVal="" descr="datetime -&gt; DST offset in minutes east of UTC.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.tzinfo.fromutc" func="yes">
			<Overload retVal="" descr="datetime in UTC -&gt; datetime in local time.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.tzinfo.tzname" func="yes">
			<Overload retVal="" descr="datetime -&gt; string name of time zone.">
			</Overload>
		</KeyWord>
		<KeyWord name="datetime.tzinfo.utcoffset" func="yes">
			<Overload retVal="" descr="datetime -&gt; timedelta showing offset from UTC, negative values indicating West of UTC">
			</Overload>
		</KeyWord>
		<KeyWord name="dbm" func="yes">
			<Overload retVal="" descr="Generic interface to all dbm clones.&#10;&#10;Use&#10;&#10;        import dbm&#10;        d = dbm.open(file, 'w', 0o666)&#10;&#10;The returned object is a dbm.gnu, dbm.ndbm or dbm.dumb object, dependent on the&#10;type of database being opened (determined by the whichdb function) in the case&#10;of an existing dbm. If the dbm does not exist and the create or new flag ('c'&#10;or 'n') was specified, the dbm type will be determined by the availability of&#10;the modules (tested in the above order).&#10;&#10;It has the following interface (key and data are strings):&#10;&#10;        d[key] = data   # store data at key (may override data at&#10;                        # existing key)&#10;        data = d[key]   # retrieve data at key (raise KeyError if no&#10;                        # such key)&#10;        del d[key]      # delete data stored at key (raises KeyError&#10;                        # if no such key)&#10;        flag = key in d # true if the key exists&#10;        list = d.keys() # return a list of all existing keys (slow!)&#10;&#10;Future versions may change the order in which implementations are&#10;tested for existence, and add interfaces to other dbm-like&#10;implementations.">
			</Overload>
		</KeyWord>
		<KeyWord name="dbm.error" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="dbm.open" func="yes">
			<Overload retVal="" descr="Open or create database at path given by *file*.&#10;&#10;Optional argument *flag* can be 'r' (default) for read-only access, 'w'&#10;for read-write access of an existing database, 'c' for read-write access&#10;to a new or existing database, and 'n' for read-write access to a new&#10;database.&#10;&#10;Note: 'r' and 'w' fail if the database doesn't exist; 'c' creates it&#10;only if it doesn't exist; and 'n' always creates a new database.">
				<Param name="file" />
				<Param name="[flag=r" />
				<Param name="[mode=438]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dbm.whichdb" func="yes">
			<Overload retVal="" descr="Guess which db package to use to open a db file.&#10;&#10;Return values:&#10;&#10;- None if the database file can't be read;&#10;- empty string if the file can be read but can't be recognized&#10;- the name of the dbm submodule (e.g. &quot;ndbm&quot; or &quot;gnu&quot;) if recognized.&#10;&#10;Importing the given module may still fail, and opening the&#10;database using that module may still fail.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="debug" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="debug_print" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="debug_script" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="debug_src" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal" func="yes">
			<Overload retVal="" descr="C decimal arithmetic module">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.BasicContext" func="yes">
			<Overload retVal="" descr="(Context)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Clamped" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Clamped.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Clamped.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context" func="yes">
			<Overload retVal="" descr="The context affects almost all operations and controls rounding,&#10;Over/Underflow, raising of exceptions and much more.  A new context&#10;can be constructed as follows:&#10;&#10;    &gt;&gt;&gt; c = Context(prec=28, Emin=-425000000, Emax=425000000,&#10;    ...             rounding=ROUND_HALF_EVEN, capitals=1, clamp=1,&#10;    ...             traps=[InvalidOperation, DivisionByZero, Overflow],&#10;    ...             flags=[])&#10;    &gt;&gt;&gt;">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.Emax" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.Emin" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.Etiny" func="yes">
			<Overload retVal="" descr="Return a value equal to Emin - prec + 1, which is the minimum exponent value&#10;for subnormal results.  When underflow occurs, the exponent is set to Etiny.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.Etop" func="yes">
			<Overload retVal="" descr="Return a value equal to Emax - prec + 1.  This is the maximum exponent&#10;if the _clamp field of the context is set to 1 (IEEE clamp mode).  Etop()&#10;must not be negative.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.abs" func="yes">
			<Overload retVal="" descr="Return the absolute value of x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.add" func="yes">
			<Overload retVal="" descr="Return the sum of x and y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.canonical" func="yes">
			<Overload retVal="" descr="Return a new instance of x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.capitals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.clamp" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.clear_flags" func="yes">
			<Overload retVal="" descr="Reset all flags to False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.clear_traps" func="yes">
			<Overload retVal="" descr="Set all traps to False.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare" func="yes">
			<Overload retVal="" descr="Compare x and y numerically.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare_signal" func="yes">
			<Overload retVal="" descr="Compare x and y numerically.  All NaNs signal.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare_total" func="yes">
			<Overload retVal="" descr="Compare x and y using their abstract representation.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compare x and y using their abstract representation, ignoring sign.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy" func="yes">
			<Overload retVal="" descr="Return a duplicate of the context with all flags cleared.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_abs" func="yes">
			<Overload retVal="" descr="Return a copy of x with the sign set to 0.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_decimal" func="yes">
			<Overload retVal="" descr="Return a copy of Decimal x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_negate" func="yes">
			<Overload retVal="" descr="Return a copy of x with the sign inverted.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.copy_sign" func="yes">
			<Overload retVal="" descr="Copy the sign from y to x.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.create_decimal" func="yes">
			<Overload retVal="" descr="Create a new Decimal instance from num, using self as the context. Unlike the&#10;Decimal constructor, this function observes the context limits.">
				<Param name="self" />
				<Param name="num" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.create_decimal_from_float" func="yes">
			<Overload retVal="" descr="Create a new Decimal instance from float f.  Unlike the Decimal.from_float()&#10;class method, this function observes the context limits.">
				<Param name="self" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.divide" func="yes">
			<Overload retVal="" descr="Return x divided by y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.divide_int" func="yes">
			<Overload retVal="" descr="Return x divided by y, truncated to an integer.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.divmod" func="yes">
			<Overload retVal="" descr="Return quotient and remainder of the division x / y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.exp" func="yes">
			<Overload retVal="" descr="Return e ** x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.fma" func="yes">
			<Overload retVal="" descr="Return x multiplied by y, plus z.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
				<Param name="z" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if x is canonical, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_finite" func="yes">
			<Overload retVal="" descr="Return True if x is finite, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if x is infinite, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_nan" func="yes">
			<Overload retVal="" descr="Return True if x is a qNaN or sNaN, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_normal" func="yes">
			<Overload retVal="" descr="Return True if x is a normal number, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if x is a quiet NaN, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_signed" func="yes">
			<Overload retVal="" descr="Return True if x is negative, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_snan" func="yes">
			<Overload retVal="" descr="Return True if x is a signaling NaN, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if x is subnormal, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.is_zero" func="yes">
			<Overload retVal="" descr="Return True if x is a zero, False otherwise.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.ln" func="yes">
			<Overload retVal="" descr="Return the natural (base e) logarithm of x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.log10" func="yes">
			<Overload retVal="" descr="Return the base 10 logarithm of x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logb" func="yes">
			<Overload retVal="" descr="Return the exponent of the magnitude of the operand's MSD.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_and" func="yes">
			<Overload retVal="" descr="Digit-wise and of x and y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_invert" func="yes">
			<Overload retVal="" descr="Invert all digits of x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_or" func="yes">
			<Overload retVal="" descr="Digit-wise or of x and y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.logical_xor" func="yes">
			<Overload retVal="" descr="Digit-wise xor of x and y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.max" func="yes">
			<Overload retVal="" descr="Compare the values numerically and return the maximum.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.max_mag" func="yes">
			<Overload retVal="" descr="Compare the values numerically with their sign ignored.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.min" func="yes">
			<Overload retVal="" descr="Compare the values numerically and return the minimum.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.min_mag" func="yes">
			<Overload retVal="" descr="Compare the values numerically with their sign ignored.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.minus" func="yes">
			<Overload retVal="" descr="Minus corresponds to the unary prefix minus operator in Python, but applies&#10;the context to the result.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.multiply" func="yes">
			<Overload retVal="" descr="Return the product of x and y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.next_minus" func="yes">
			<Overload retVal="" descr="Return the largest representable number smaller than x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.next_plus" func="yes">
			<Overload retVal="" descr="Return the smallest representable number larger than x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.next_toward" func="yes">
			<Overload retVal="" descr="Return the number closest to x, in the direction towards y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.normalize" func="yes">
			<Overload retVal="" descr="Reduce x to its simplest form. Alias for reduce(x).">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.number_class" func="yes">
			<Overload retVal="" descr="Return an indication of the class of x.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.plus" func="yes">
			<Overload retVal="" descr="Plus corresponds to the unary prefix plus operator in Python, but applies&#10;the context to the result.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.power" func="yes">
			<Overload retVal="" descr="Compute a**b. If 'a' is negative, then 'b' must be integral. The result&#10;will be inexact unless 'a' is integral and the result is finite and can&#10;be expressed exactly in 'precision' digits.  In the Python version the&#10;result is always correctly rounded, in the C version the result is almost&#10;always correctly rounded.&#10;&#10;If modulo is given, compute (a**b) % modulo. The following restrictions&#10;hold:&#10;&#10;    * all three arguments must be integral&#10;    * 'b' must be nonnegative&#10;    * at least one of 'a' or 'b' must be nonzero&#10;    * modulo must be nonzero and less than 10**prec in absolute value">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[modulo=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.prec" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.quantize" func="yes">
			<Overload retVal="" descr="Return a value equal to x (rounded), having the exponent of y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.radix" func="yes">
			<Overload retVal="" descr="Return 10.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.remainder" func="yes">
			<Overload retVal="" descr="Return the remainder from integer division.  The sign of the result,&#10;if non-zero, is the same as that of the original dividend.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.remainder_near" func="yes">
			<Overload retVal="" descr="Return x - y * n, where n is the integer nearest the exact value of x / y&#10;(if the result is 0 then its sign will be the sign of x).">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.rotate" func="yes">
			<Overload retVal="" descr="Return a copy of x, rotated by y places.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.rounding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.same_quantum" func="yes">
			<Overload retVal="" descr="Return True if the two operands have the same exponent.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.scaleb" func="yes">
			<Overload retVal="" descr="Return the first operand after adding the second value to its exp.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.shift" func="yes">
			<Overload retVal="" descr="Return a copy of x, shifted by y places.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.sqrt" func="yes">
			<Overload retVal="" descr="Square root of a non-negative number to context precision.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.subtract" func="yes">
			<Overload retVal="" descr="Return the difference between x and y.">
				<Param name="self" />
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_eng_string" func="yes">
			<Overload retVal="" descr="Convert a number to a string, using engineering notation.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_integral" func="yes">
			<Overload retVal="" descr="Identical to to_integral_value(x).">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_integral_exact" func="yes">
			<Overload retVal="" descr="Round to an integer. Signal if the result is rounded or inexact.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_integral_value" func="yes">
			<Overload retVal="" descr="Round to an integer.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Context.to_sci_string" func="yes">
			<Overload retVal="" descr="Convert a number to a string using scientific notation.">
				<Param name="self" />
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ConversionSyntax" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ConversionSyntax.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ConversionSyntax.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal" func="yes">
			<Overload retVal="" descr="Construct a new Decimal object. 'value' can be an integer, string, tuple,&#10;or another Decimal object. If no value is given, return Decimal('0'). The&#10;context does not affect the conversion and is only passed to determine if&#10;the InvalidOperation trap is active.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.adjusted" func="yes">
			<Overload retVal="" descr="Return the adjusted exponent of the number.  Defined as exp + digits - 1.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.as_integer_ratio" func="yes">
			<Overload retVal="" descr="Decimal.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;Decimal and with a positive denominator. The ratio is in lowest terms.&#10;Raise OverflowError on infinities and a ValueError on NaNs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.as_tuple" func="yes">
			<Overload retVal="" descr="Return a tuple representation of the number.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.canonical" func="yes">
			<Overload retVal="" descr="Return the canonical encoding of the argument.  Currently, the encoding&#10;of a Decimal instance is always canonical, so this operation returns its&#10;argument unchanged.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare" func="yes">
			<Overload retVal="" descr="Compare self to other.  Return a decimal value:&#10;&#10;a or b is a NaN ==&gt; Decimal('NaN')&#10;a &lt; b           ==&gt; Decimal('-1')&#10;a == b          ==&gt; Decimal('0')&#10;a &gt; b           ==&gt; Decimal('1')">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare_signal" func="yes">
			<Overload retVal="" descr="Identical to compare, except that all NaNs signal.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare_total" func="yes">
			<Overload retVal="" descr="Compare two operands using their abstract representation rather than&#10;their numerical value.  Similar to the compare() method, but the result&#10;gives a total ordering on Decimal instances.  Two Decimal instances with&#10;the same numeric value but different representations compare unequal&#10;in this ordering:&#10;&#10;    &gt;&gt;&gt; Decimal('12.0').compare_total(Decimal('12'))&#10;    Decimal('-1')&#10;&#10;Quiet and signaling NaNs are also included in the total ordering. The result&#10;of this function is Decimal('0') if both operands have the same representation,&#10;Decimal('-1') if the first operand is lower in the total order than the second,&#10;and Decimal('1') if the first operand is higher in the total order than the&#10;second operand. See the specification for details of the total order.&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compare two operands using their abstract representation rather than their&#10;value as in compare_total(), but ignoring the sign of each operand.&#10;&#10;x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()).&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.conjugate" func="yes">
			<Overload retVal="" descr="Return self.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.copy_abs" func="yes">
			<Overload retVal="" descr="Return the absolute value of the argument.  This operation is unaffected by&#10;context and is quiet: no flags are changed and no rounding is performed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.copy_negate" func="yes">
			<Overload retVal="" descr="Return the negation of the argument.  This operation is unaffected by context&#10;and is quiet: no flags are changed and no rounding is performed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.copy_sign" func="yes">
			<Overload retVal="" descr="Return a copy of the first operand with the sign set to be the same as the&#10;sign of the second operand. For example:&#10;&#10;    &gt;&gt;&gt; Decimal('2.3').copy_sign(Decimal('-1.5'))&#10;    Decimal('-2.3')&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.exp" func="yes">
			<Overload retVal="" descr="Return the value of the (natural) exponential function e**x at the given&#10;number.  The function always uses the ROUND_HALF_EVEN mode and the result&#10;is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.fma" func="yes">
			<Overload retVal="" descr="Fused multiply-add.  Return self*other+third with no rounding of the&#10;intermediate product self*other.&#10;&#10;    &gt;&gt;&gt; Decimal(2).fma(3, 5)&#10;    Decimal('11')">
				<Param name="self" />
				<Param name="other" />
				<Param name="third" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.from_float" func="yes">
			<Overload retVal="" descr="Class method that converts a float to a decimal number, exactly.&#10;Since 0.1 is not exactly representable in binary floating point,&#10;Decimal.from_float(0.1) is not the same as Decimal('0.1').&#10;&#10;    &gt;&gt;&gt; Decimal.from_float(0.1)&#10;    Decimal('0.1000000000000000055511151231257827021181583404541015625')&#10;    &gt;&gt;&gt; Decimal.from_float(float('nan'))&#10;    Decimal('NaN')&#10;    &gt;&gt;&gt; Decimal.from_float(float('inf'))&#10;    Decimal('Infinity')&#10;    &gt;&gt;&gt; Decimal.from_float(float('-inf'))&#10;    Decimal('-Infinity')">
				<Param name="type" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if the argument is canonical and False otherwise.  Currently,&#10;a Decimal instance is always canonical, so this operation always returns&#10;True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_finite" func="yes">
			<Overload retVal="" descr="Return True if the argument is a finite number, and False if the argument&#10;is infinite or a NaN.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if the argument is either positive or negative infinity and&#10;False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_nan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a (quiet or signaling) NaN and False&#10;otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_normal" func="yes">
			<Overload retVal="" descr="Return True if the argument is a normal finite non-zero number with an&#10;adjusted exponent greater than or equal to Emin. Return False if the&#10;argument is zero, subnormal, infinite or a NaN.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a quiet NaN, and False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_signed" func="yes">
			<Overload retVal="" descr="Return True if the argument has a negative sign and False otherwise.&#10;Note that both zeros and NaNs can carry signs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_snan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a signaling NaN and False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if the argument is subnormal, and False otherwise. A number is&#10;subnormal if it is non-zero, finite, and has an adjusted exponent less&#10;than Emin.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.is_zero" func="yes">
			<Overload retVal="" descr="Return True if the argument is a (positive or negative) zero and False&#10;otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.ln" func="yes">
			<Overload retVal="" descr="Return the natural (base e) logarithm of the operand. The function always&#10;uses the ROUND_HALF_EVEN mode and the result is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.log10" func="yes">
			<Overload retVal="" descr="Return the base ten logarithm of the operand. The function always uses the&#10;ROUND_HALF_EVEN mode and the result is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logb" func="yes">
			<Overload retVal="" descr="For a non-zero number, return the adjusted exponent of the operand as a&#10;Decimal instance.  If the operand is a zero, then Decimal('-Infinity') is&#10;returned and the DivisionByZero condition is raised. If the operand is&#10;an infinity then Decimal('Infinity') is returned.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_and" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'and' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_invert" func="yes">
			<Overload retVal="" descr="Return the digit-wise inversion of the (logical) operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_or" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'or' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.logical_xor" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'exclusive or' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.max" func="yes">
			<Overload retVal="" descr="Maximum of self and other.  If one operand is a quiet NaN and the other is&#10;numeric, the numeric operand is returned.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.max_mag" func="yes">
			<Overload retVal="" descr="Similar to the max() method, but the comparison is done using the absolute&#10;values of the operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.min" func="yes">
			<Overload retVal="" descr="Minimum of self and other. If one operand is a quiet NaN and the other is&#10;numeric, the numeric operand is returned.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.min_mag" func="yes">
			<Overload retVal="" descr="Similar to the min() method, but the comparison is done using the absolute&#10;values of the operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.next_minus" func="yes">
			<Overload retVal="" descr="Return the largest number representable in the given context (or in the&#10;current default context if no context is given) that is smaller than the&#10;given operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.next_plus" func="yes">
			<Overload retVal="" descr="Return the smallest number representable in the given context (or in the&#10;current default context if no context is given) that is larger than the&#10;given operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.next_toward" func="yes">
			<Overload retVal="" descr="If the two operands are unequal, return the number closest to the first&#10;operand in the direction of the second operand.  If both operands are&#10;numerically equal, return a copy of the first operand with the sign set&#10;to be the same as the sign of the second operand.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.normalize" func="yes">
			<Overload retVal="" descr="Normalize the number by stripping the rightmost trailing zeros and&#10;converting any result equal to Decimal('0') to Decimal('0e0').  Used&#10;for producing canonical values for members of an equivalence class.&#10;For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize&#10;to the equivalent value Decimal('32.1').">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.number_class" func="yes">
			<Overload retVal="" descr="Return a string describing the class of the operand.  The returned value&#10;is one of the following ten strings:&#10;&#10;    * '-Infinity', indicating that the operand is negative infinity.&#10;    * '-Normal', indicating that the operand is a negative normal number.&#10;    * '-Subnormal', indicating that the operand is negative and subnormal.&#10;    * '-Zero', indicating that the operand is a negative zero.&#10;    * '+Zero', indicating that the operand is a positive zero.&#10;    * '+Subnormal', indicating that the operand is positive and subnormal.&#10;    * '+Normal', indicating that the operand is a positive normal number.&#10;    * '+Infinity', indicating that the operand is positive infinity.&#10;    * 'NaN', indicating that the operand is a quiet NaN (Not a Number).&#10;    * 'sNaN', indicating that the operand is a signaling NaN.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.quantize" func="yes">
			<Overload retVal="" descr="Return a value equal to the first operand after rounding and having the&#10;exponent of the second operand.&#10;&#10;    &gt;&gt;&gt; Decimal('1.41421356').quantize(Decimal('1.000'))&#10;    Decimal('1.414')&#10;&#10;Unlike other operations, if the length of the coefficient after the quantize&#10;operation would be greater than precision, then an InvalidOperation is signaled.&#10;This guarantees that, unless there is an error condition, the quantized exponent&#10;is always equal to that of the right-hand operand.&#10;&#10;Also unlike other operations, quantize never signals Underflow, even if the&#10;result is subnormal and inexact.&#10;&#10;If the exponent of the second operand is larger than that of the first, then&#10;rounding may be necessary. In this case, the rounding mode is determined by the&#10;rounding argument if given, else by the given context argument; if neither&#10;argument is given, the rounding mode of the current thread's context is used.">
				<Param name="self" />
				<Param name="exp" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.radix" func="yes">
			<Overload retVal="" descr="Return Decimal(10), the radix (base) in which the Decimal class does&#10;all its arithmetic. Included for compatibility with the specification.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.remainder_near" func="yes">
			<Overload retVal="" descr="Return the remainder from dividing self by other.  This differs from&#10;self % other in that the sign of the remainder is chosen so as to minimize&#10;its absolute value. More precisely, the return value is self - n * other&#10;where n is the integer nearest to the exact value of self / other, and&#10;if two integers are equally near then the even one is chosen.&#10;&#10;If the result is zero then its sign will be the sign of self.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.rotate" func="yes">
			<Overload retVal="" descr="Return the result of rotating the digits of the first operand by an amount&#10;specified by the second operand.  The second operand must be an integer in&#10;the range -precision through precision. The absolute value of the second&#10;operand gives the number of places to rotate. If the second operand is&#10;positive then rotation is to the left; otherwise rotation is to the right.&#10;The coefficient of the first operand is padded on the left with zeros to&#10;length precision if necessary. The sign and exponent of the first operand are&#10;unchanged.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.same_quantum" func="yes">
			<Overload retVal="" descr="Test whether self and other have the same exponent or whether both are NaN.&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.scaleb" func="yes">
			<Overload retVal="" descr="Return the first operand with the exponent adjusted the second.  Equivalently,&#10;return the first operand multiplied by 10**other. The second operand must be&#10;an integer.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.shift" func="yes">
			<Overload retVal="" descr="Return the result of shifting the digits of the first operand by an amount&#10;specified by the second operand.  The second operand must be an integer in&#10;the range -precision through precision. The absolute value of the second&#10;operand gives the number of places to shift. If the second operand is&#10;positive, then the shift is to the left; otherwise the shift is to the&#10;right. Digits shifted into the coefficient are zeros. The sign and exponent&#10;of the first operand are unchanged.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.sqrt" func="yes">
			<Overload retVal="" descr="Return the square root of the argument to full precision. The result is&#10;correctly rounded using the ROUND_HALF_EVEN rounding mode.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_eng_string" func="yes">
			<Overload retVal="" descr="Convert to an engineering-type string.  Engineering notation has an exponent&#10;which is a multiple of 3, so there are up to 3 digits left of the decimal&#10;place. For example, Decimal('123E+1') is converted to Decimal('1.23E+3').&#10;&#10;The value of context.capitals determines whether the exponent sign is lower&#10;or upper case. Otherwise, the context does not affect the operation.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_integral" func="yes">
			<Overload retVal="" descr="Identical to the to_integral_value() method.  The to_integral() name has been&#10;kept for compatibility with older versions.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_integral_exact" func="yes">
			<Overload retVal="" descr="Round to the nearest integer, signaling Inexact or Rounded as appropriate if&#10;rounding occurs.  The rounding mode is determined by the rounding parameter&#10;if given, else by the given context. If neither parameter is given, then the&#10;rounding mode of the current default context is used.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Decimal.to_integral_value" func="yes">
			<Overload retVal="" descr="Round to the nearest integer without signaling Inexact or Rounded.  The&#10;rounding mode is determined by the rounding parameter if given, else by&#10;the given context. If neither parameter is given, then the rounding mode&#10;of the current default context is used.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalException" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalException.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple" func="yes">
			<Overload retVal="" descr="DecimalTuple(sign, digits, exponent)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.digits" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.exponent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DecimalTuple.sign" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DefaultContext" func="yes">
			<Overload retVal="" descr="(Context)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionByZero" func="yes">
			<Overload retVal="" descr="Second argument to a division or modulo operation was zero.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionByZero.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionByZero.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionImpossible" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionImpossible.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionImpossible.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionUndefined" func="yes">
			<Overload retVal="" descr="Second argument to a division or modulo operation was zero.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionUndefined.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.DivisionUndefined.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ExtendedContext" func="yes">
			<Overload retVal="" descr="(Context)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.FloatOperation" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.FloatOperation.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.FloatOperation.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.HAVE_THREADS" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Inexact" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Inexact.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Inexact.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidContext" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidContext.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidContext.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidOperation" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidOperation.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.InvalidOperation.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.MAX_EMAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.MAX_PREC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.MIN_EMIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.MIN_ETINY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Overflow" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Overflow.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Overflow.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_05UP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_CEILING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_DOWN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_FLOOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_HALF_DOWN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_HALF_EVEN" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_HALF_UP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.ROUND_UP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Rounded" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Rounded.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Rounded.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Subnormal" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Subnormal.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Subnormal.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Underflow" func="yes">
			<Overload retVal="" descr="Base class for arithmetic errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Underflow.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.Underflow.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.getcontext" func="yes">
			<Overload retVal="" descr="Get the current default context.">
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.localcontext" func="yes">
			<Overload retVal="" descr="Return a context manager that will set the default context to a copy of ctx&#10;on entry to the with-statement and restore the previous default context when&#10;exiting the with-statement. If no context is specified, a copy of the current&#10;default context is used.">
				<Param name="[ctx=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decimal.setcontext" func="yes">
			<Overload retVal="" descr="Set a new default context.">
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="declare_namespace" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="decode" func="yes">
			<Overload retVal="" descr="Decode the bytes using the codec registered for encoding.&#10;&#10;encoding&#10;  The encoding with which to decode the bytes.&#10;errors&#10;  The error handling scheme to use for the handling of decoding errors.&#10;  The default is 'strict' meaning that decoding errors raise a&#10;  UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#10;  as well as any other name registered with codecs.register_error that&#10;  can handle UnicodeDecodeErrors.">
				<Param name="self" />
				<Param name="[encoding=utf-8" />
				<Param name="[errors=strict]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="decode_header" func="yes">
			<Overload retVal="" descr="Function of nntplib">
			</Overload>
		</KeyWord>
		<KeyWord name="decode_long" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="decodebytes" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="decodestring" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="decomposition" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="decompress" func="yes">
			<Overload retVal="" descr="Function of bz2">
			</Overload>
		</KeyWord>
		<KeyWord name="dedent" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="deepcopy" func="yes">
			<Overload retVal="" descr="Function of copy">
			</Overload>
		</KeyWord>
		<KeyWord name="def" />
		<KeyWord name="default" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="defaultFile" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="defaultTestResult" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="default_exception_handler" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="default_int_handler" func="yes">
			<Overload retVal="" descr="Function of signal">
			</Overload>
		</KeyWord>
		<KeyWord name="default_timer" func="yes">
			<Overload retVal="" descr="Function of timeit">
			</Overload>
		</KeyWord>
		<KeyWord name="defaultdict" func="yes">
			<Overload retVal="" descr="Function of collections.defaultdict">
			</Overload>
		</KeyWord>
		<KeyWord name="del" />
		<KeyWord name="del_channel" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="del_param" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="delattr" func="yes">
			<Overload retVal="" descr="Deletes the named attribute from the given object.&#10;&#10;delattr(x, 'y') is equivalent to ``del x.y''">
				<Param name="obj" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="dele" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="delete" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="deleteMe" func="yes">
			<Overload retVal="" descr="Function of bdb.Breakpoint">
			</Overload>
		</KeyWord>
		<KeyWord name="deleteacl" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="deleter" func="yes">
			<Overload retVal="" descr="Descriptor to change the deleter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="delitem" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="delocalize" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="demo" func="yes">
			<Overload retVal="" descr="Function of filecmp">
			</Overload>
		</KeyWord>
		<KeyWord name="deque" func="yes">
			<Overload retVal="" descr="Function of asynchat.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="describe" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="description" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="descriptions" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="destroy" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="detach" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="detect_encoding" func="yes">
			<Overload retVal="" descr="Function of json">
			</Overload>
		</KeyWord>
		<KeyWord name="determine_parent" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="device_encoding" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="dgettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="dict" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="diff_bytes" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="difference" func="yes">
			<Overload retVal="" descr="Return the difference of two or more sets as a new set.&#10;&#10;(i.e. all elements that are in this set but not the others.)">
			</Overload>
		</KeyWord>
		<KeyWord name="difference_update" func="yes">
			<Overload retVal="" descr="Remove all elements of another set from this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib" func="yes">
			<Overload retVal="" descr='Module difflib -- helpers for computing deltas between objects.&#10;&#10;Function get_close_matches(word, possibilities, n=3, cutoff=0.6):&#10;    Use SequenceMatcher to return list of the best "good enough" matches.&#10;&#10;Function context_diff(a, b):&#10;    For two lists of strings, return a delta in context diff format.&#10;&#10;Function ndiff(a, b):&#10;    Return a delta: the difference between `a` and `b` (lists of strings).&#10;&#10;Function restore(delta, which):&#10;    Return one of the two sequences that generated an ndiff delta.&#10;&#10;Function unified_diff(a, b):&#10;    For two lists of strings, return a delta in unified diff format.&#10;&#10;Class SequenceMatcher:&#10;    A flexible class for comparing pairs of sequences of any type.&#10;&#10;Class Differ:&#10;    For producing human-readable deltas from sequences of lines of text.&#10;&#10;Class HtmlDiff:&#10;    For producing HTML side by side comparison with change highlights.'>
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Differ" func="yes">
			<Overload retVal="" descr="Differ is a class for comparing sequences of lines of text, and&#10;producing human-readable differences or deltas.  Differ uses&#10;SequenceMatcher both to compare sequences of lines, and to compare&#10;sequences of characters within similar (near-matching) lines.&#10;&#10;Each line of a Differ delta begins with a two-letter code:&#10;&#10;    '- '    line unique to sequence 1&#10;    '+ '    line unique to sequence 2&#10;    '  '    line common to both sequences&#10;    '? '    line not present in either input sequence&#10;&#10;Lines beginning with '? ' attempt to guide the eye to intraline&#10;differences, and were not present in either input sequence.  These lines&#10;can be confusing if the sequences contain tab characters.&#10;&#10;Note that Differ makes no claim to produce a *minimal* diff.  To the&#10;contrary, minimal diffs are often counter-intuitive, because they synch&#10;up anywhere possible, sometimes accidental matches 100 pages apart.&#10;Restricting synch points to contiguous matches preserves some notion of&#10;locality, at the occasional cost of producing a longer diff.&#10;&#10;Example: Comparing two texts.&#10;&#10;First we set up the texts, sequences of individual single-line strings&#10;ending with newlines (such sequences can also be obtained from the&#10;`readlines()` method of file-like objects):&#10;&#10;&gt;&gt;&gt; text1 = '''  1. Beautiful is better than ugly.&#10;...   2. Explicit is better than implicit.&#10;...   3. Simple is better than complex.&#10;...   4. Complex is better than complicated.&#10;... '''.splitlines(keepends=True)&#10;&gt;&gt;&gt; len(text1)&#10;4&#10;&gt;&gt;&gt; text1[0][-1]&#10;'\n'&#10;&gt;&gt;&gt; text2 = '''  1. Beautiful is better than ugly.&#10;...   3.   Simple is better than complex.&#10;...   4. Complicated is better than complex.&#10;...   5. Flat is better than nested.&#10;... '''.splitlines(keepends=True)&#10;&#10;Next we instantiate a Differ object:&#10;&#10;&gt;&gt;&gt; d = Differ()&#10;&#10;Note that when instantiating a Differ object we may pass functions to&#10;filter out line and character 'junk'.  See Differ.__init__ for details.&#10;&#10;Finally, we compare the two:&#10;&#10;&gt;&gt;&gt; result = list(d.compare(text1, text2))&#10;&#10;'result' is a list of strings, so let's pretty-print it:&#10;&#10;&gt;&gt;&gt; from pprint import pprint as _pprint&#10;&gt;&gt;&gt; _pprint(result)&#10;['    1. Beautiful is better than ugly.\n',&#10; '-   2. Explicit is better than implicit.\n',&#10; '-   3. Simple is better than complex.\n',&#10; '+   3.   Simple is better than complex.\n',&#10; '?     ++\n',&#10; '-   4. Complex is better than complicated.\n',&#10; '?            ^                     ---- ^\n',&#10; '+   4. Complicated is better than complex.\n',&#10; '?           ++++ ^                      ^\n',&#10; '+   5. Flat is better than nested.\n']&#10;&#10;As a single multi-line string it looks like this:&#10;&#10;&gt;&gt;&gt; print(''.join(result), end=&quot;&quot;)&#10;    1. Beautiful is better than ugly.&#10;-   2. Explicit is better than implicit.&#10;-   3. Simple is better than complex.&#10;+   3.   Simple is better than complex.&#10;?     ++&#10;-   4. Complex is better than complicated.&#10;?            ^                     ---- ^&#10;+   4. Complicated is better than complex.&#10;?           ++++ ^                      ^&#10;+   5. Flat is better than nested.&#10;&#10;Methods:&#10;&#10;__init__(linejunk=None, charjunk=None)&#10;    Construct a text differencer, with optional filters.&#10;&#10;compare(a, b)&#10;    Compare two sequences of lines; generate the resulting delta.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Differ.compare" func="yes">
			<Overload retVal="" descr="Compare two sequences of lines; generate the resulting delta.&#10;&#10;Each sequence must contain individual single-line strings ending with&#10;newlines. Such sequences can be obtained from the `readlines()` method&#10;of file-like objects.  The delta generated also consists of newline-&#10;terminated strings, ready to be printed as-is via the writeline()&#10;method of a file-like object.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; print(''.join(Differ().compare('one\ntwo\nthree\n'.splitlines(True),&#10;...                                'ore\ntree\nemu\n'.splitlines(True))),&#10;...       end=&quot;&quot;)&#10;- one&#10;?  ^&#10;+ ore&#10;?  ^&#10;- two&#10;- three&#10;?  -&#10;+ tree&#10;+ emu">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.HtmlDiff" func="yes">
			<Overload retVal="" descr="For producing HTML side by side comparison with change highlights.&#10;&#10;This class can be used to create an HTML table (or a complete HTML file&#10;containing the table) showing a side by side, line by line comparison&#10;of text with inter-line and intra-line change highlights.  The table can&#10;be generated in either full or contextual difference mode.&#10;&#10;The following methods are provided for HTML generation:&#10;&#10;make_table -- generates HTML for a single side by side table&#10;make_file -- generates complete HTML file with a single side by side table&#10;&#10;See tools/scripts/diff.py for an example usage of this class.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.HtmlDiff.make_file" func="yes">
			<Overload retVal="" descr='Returns HTML file of side by side comparison with change highlights&#10;&#10;Arguments:&#10;fromlines -- list of "from" lines&#10;tolines -- list of "to" lines&#10;fromdesc -- "from" file column header string&#10;todesc -- "to" file column header string&#10;context -- set to True for contextual differences (defaults to False&#10;    which shows full differences).&#10;numlines -- number of context lines.  When context is set True,&#10;    controls number of lines displayed before and after the change.&#10;    When context is False, controls the number of lines to place&#10;    the "next" link anchors before the next change (so click of&#10;    "next" link jumps to just before the change).&#10;charset -- charset of the HTML document'>
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.HtmlDiff.make_table" func="yes">
			<Overload retVal="" descr='Returns HTML table of side by side comparison with change highlights&#10;&#10;Arguments:&#10;fromlines -- list of "from" lines&#10;tolines -- list of "to" lines&#10;fromdesc -- "from" file column header string&#10;todesc -- "to" file column header string&#10;context -- set to True for contextual differences (defaults to False&#10;    which shows full differences).&#10;numlines -- number of context lines.  When context is set True,&#10;    controls number of lines displayed before and after the change.&#10;    When context is False, controls the number of lines to place&#10;    the "next" link anchors before the next change (so click of&#10;    "next" link jumps to just before the change).'>
				<Param name="self" />
				<Param name="fromlines" />
				<Param name="tolines" />
				<Param name="[fromdesc" />
				<Param name="[todesc" />
				<Param name="[context=False" />
				<Param name="[numlines=5]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.IS_CHARACTER_JUNK" func="yes">
			<Overload retVal="" descr="Return 1 for ignorable character: iff `ch` is a space or tab.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK(' ')&#10;True&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK('\t')&#10;True&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK('\n')&#10;False&#10;&gt;&gt;&gt; IS_CHARACTER_JUNK('x')&#10;False">
				<Param name="ch" />
				<Param name="[ws= 	]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.IS_LINE_JUNK" func="yes">
			<Overload retVal="" descr="Return 1 for ignorable line: iff `line` is blank or contains a single '#'.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; IS_LINE_JUNK('\n')&#10;True&#10;&gt;&gt;&gt; IS_LINE_JUNK('  #   \n')&#10;True&#10;&gt;&gt;&gt; IS_LINE_JUNK('hello\n')&#10;False">
				<Param name="line" />
				<Param name="[pat=<built-in method match of _sre.SRE_Pattern object at 0x036927A0>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match" func="yes">
			<Overload retVal="" descr="Match(a, b, size)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.a" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.b" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.Match.size" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher" func="yes">
			<Overload retVal="" descr="SequenceMatcher is a flexible class for comparing pairs of sequences of&#10;any type, so long as the sequence elements are hashable.  The basic&#10;algorithm predates, and is a little fancier than, an algorithm&#10;published in the late 1980's by Ratcliff and Obershelp under the&#10;hyperbolic name &quot;gestalt pattern matching&quot;.  The basic idea is to find&#10;the longest contiguous matching subsequence that contains no &quot;junk&quot;&#10;elements (R-O doesn't address junk).  The same idea is then applied&#10;recursively to the pieces of the sequences to the left and to the right&#10;of the matching subsequence.  This does not yield minimal edit&#10;sequences, but does tend to yield matches that &quot;look right&quot; to people.&#10;&#10;SequenceMatcher tries to compute a &quot;human-friendly diff&quot; between two&#10;sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the&#10;longest *contiguous* &amp; junk-free matching subsequence.  That's what&#10;catches peoples' eyes.  The Windows(tm) windiff has another interesting&#10;notion, pairing up elements that appear uniquely in each sequence.&#10;That, and the method here, appear to yield more intuitive difference&#10;reports than does diff.  This method appears to be the least vulnerable&#10;to synching up on blocks of &quot;junk lines&quot;, though (like blank lines in&#10;ordinary text files, or maybe &quot;&lt;P&gt;&quot; lines in HTML files).  That may be&#10;because this is the only method of the 3 that has a *concept* of&#10;&quot;junk&quot; &lt;wink&gt;.&#10;&#10;Example, comparing two strings, and considering blanks to be &quot;junk&quot;:&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(lambda x: x == &quot; &quot;,&#10;...                     &quot;private Thread currentThread;&quot;,&#10;...                     &quot;private volatile Thread currentThread;&quot;)&#10;&gt;&gt;&gt;&#10;&#10;.ratio() returns a float in [0, 1], measuring the &quot;similarity&quot; of the&#10;sequences.  As a rule of thumb, a .ratio() value over 0.6 means the&#10;sequences are close matches:&#10;&#10;&gt;&gt;&gt; print(round(s.ratio(), 3))&#10;0.866&#10;&gt;&gt;&gt;&#10;&#10;If you're only interested in where the sequences match,&#10;.get_matching_blocks() is handy:&#10;&#10;&gt;&gt;&gt; for block in s.get_matching_blocks():&#10;...     print(&quot;a[%d] and b[%d] match for %d elements&quot; % block)&#10;a[0] and b[0] match for 8 elements&#10;a[8] and b[17] match for 21 elements&#10;a[29] and b[38] match for 0 elements&#10;&#10;Note that the last tuple returned by .get_matching_blocks() is always a&#10;dummy, (len(a), len(b), 0), and this is the only case in which the last&#10;tuple element (number of elements matched) is 0.&#10;&#10;If you want to know how to change the first sequence into the second,&#10;use .get_opcodes():&#10;&#10;&gt;&gt;&gt; for opcode in s.get_opcodes():&#10;...     print(&quot;%6s a[%d:%d] b[%d:%d]&quot; % opcode)&#10; equal a[0:8] b[0:8]&#10;insert a[8:8] b[8:17]&#10; equal a[8:29] b[17:38]&#10;&#10;See the Differ class for a fancy human-friendly file differencer, which&#10;uses SequenceMatcher both to compare sequences of lines, and to compare&#10;sequences of characters within similar (near-matching) lines.&#10;&#10;See also function get_close_matches() in this module, which shows how&#10;simple code building on SequenceMatcher can be used to do useful work.&#10;&#10;Timing:  Basic R-O is cubic time worst case and quadratic time expected&#10;case.  SequenceMatcher is quadratic time for the worst case and has&#10;expected-case behavior dependent in a complicated way on how many&#10;elements the sequences have in common; best case time is linear.&#10;&#10;Methods:&#10;&#10;__init__(isjunk=None, a='', b='')&#10;    Construct a SequenceMatcher.&#10;&#10;set_seqs(a, b)&#10;    Set the two sequences to be compared.&#10;&#10;set_seq1(a)&#10;    Set the first sequence to be compared.&#10;&#10;set_seq2(b)&#10;    Set the second sequence to be compared.&#10;&#10;find_longest_match(alo, ahi, blo, bhi)&#10;    Find longest matching block in a[alo:ahi] and b[blo:bhi].&#10;&#10;get_matching_blocks()&#10;    Return list of triples describing matching subsequences.&#10;&#10;get_opcodes()&#10;    Return list of 5-tuples describing how to turn a into b.&#10;&#10;ratio()&#10;    Return a measure of the sequences' similarity (float in [0,1]).&#10;&#10;quick_ratio()&#10;    Return an upper bound on .ratio() relatively quickly.&#10;&#10;real_quick_ratio()&#10;    Return an upper bound on ratio() very quickly.">
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.find_longest_match" func="yes">
			<Overload retVal="" descr="Find longest matching block in a[alo:ahi] and b[blo:bhi].&#10;&#10;If isjunk is not defined:&#10;&#10;Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where&#10;    alo &lt;= i &lt;= i+k &lt;= ahi&#10;    blo &lt;= j &lt;= j+k &lt;= bhi&#10;and for all (i',j',k') meeting those conditions,&#10;    k &gt;= k'&#10;    i &lt;= i'&#10;    and if i == i', j &lt;= j'&#10;&#10;In other words, of all maximal matching blocks, return one that&#10;starts earliest in a, and of all those maximal matching blocks that&#10;start earliest in a, return the one that starts earliest in b.&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, &quot; abcd&quot;, &quot;abcd abcd&quot;)&#10;&gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)&#10;Match(a=0, b=4, size=5)&#10;&#10;If isjunk is defined, first the longest matching block is&#10;determined as above, but with the additional restriction that no&#10;junk element appears in the block.  Then that block is extended as&#10;far as possible by matching (only) junk elements on both sides.  So&#10;the resulting block never matches on junk except as identical junk&#10;happens to be adjacent to an &quot;interesting&quot; match.&#10;&#10;Here's the same example as before, but considering blanks to be&#10;junk.  That prevents &quot; abcd&quot; from matching the &quot; abcd&quot; at the tail&#10;end of the second sequence directly.  Instead only the &quot;abcd&quot; can&#10;match, and matches the leftmost &quot;abcd&quot; in the second sequence:&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(lambda x: x==&quot; &quot;, &quot; abcd&quot;, &quot;abcd abcd&quot;)&#10;&gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)&#10;Match(a=1, b=0, size=4)&#10;&#10;If no blocks match, return (alo, blo, 0).&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, &quot;ab&quot;, &quot;c&quot;)&#10;&gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)&#10;Match(a=0, b=0, size=0)">
				<Param name="self" />
				<Param name="alo" />
				<Param name="ahi" />
				<Param name="blo" />
				<Param name="bhi" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.get_grouped_opcodes" func="yes">
			<Overload retVal="" descr="Isolate change clusters by eliminating ranges with no changes.&#10;&#10;Return a generator of groups with up to n lines of context.&#10;Each group is in the same format as returned by get_opcodes().&#10;&#10;&gt;&gt;&gt; from pprint import pprint&#10;&gt;&gt;&gt; a = list(map(str, range(1,40)))&#10;&gt;&gt;&gt; b = a[:]&#10;&gt;&gt;&gt; b[8:8] = ['i']     # Make an insertion&#10;&gt;&gt;&gt; b[20] += 'x'       # Make a replacement&#10;&gt;&gt;&gt; b[23:28] = []      # Make a deletion&#10;&gt;&gt;&gt; b[30] += 'y'       # Make another replacement&#10;&gt;&gt;&gt; pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))&#10;[[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],&#10; [('equal', 16, 19, 17, 20),&#10;  ('replace', 19, 20, 20, 21),&#10;  ('equal', 20, 22, 21, 23),&#10;  ('delete', 22, 27, 23, 23),&#10;  ('equal', 27, 30, 23, 26)],&#10; [('equal', 31, 34, 27, 30),&#10;  ('replace', 34, 35, 30, 31),&#10;  ('equal', 35, 38, 31, 34)]]">
				<Param name="self" />
				<Param name="[n=3]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.get_matching_blocks" func="yes">
			<Overload retVal="" descr="Return list of triples describing matching subsequences.&#10;&#10;Each triple is of the form (i, j, n), and means that&#10;a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in&#10;i and in j.  New in Python 2.5, it's also guaranteed that if&#10;(i, j, n) and (i', j', n') are adjacent triples in the list, and&#10;the second is not the last triple in the list, then i+n != i' or&#10;j+n != j'.  IOW, adjacent triples never describe adjacent equal&#10;blocks.&#10;&#10;The last triple is a dummy, (len(a), len(b), 0), and is the only&#10;triple with n==0.&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, &quot;abxcd&quot;, &quot;abcd&quot;)&#10;&gt;&gt;&gt; list(s.get_matching_blocks())&#10;[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.get_opcodes" func="yes">
			<Overload retVal="" descr="Return list of 5-tuples describing how to turn a into b.&#10;&#10;Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple&#10;has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the&#10;tuple preceding it, and likewise for j1 == the previous j2.&#10;&#10;The tags are strings, with these meanings:&#10;&#10;'replace':  a[i1:i2] should be replaced by b[j1:j2]&#10;'delete':   a[i1:i2] should be deleted.&#10;            Note that j1==j2 in this case.&#10;'insert':   b[j1:j2] should be inserted at a[i1:i1].&#10;            Note that i1==i2 in this case.&#10;'equal':    a[i1:i2] == b[j1:j2]&#10;&#10;&gt;&gt;&gt; a = &quot;qabxcd&quot;&#10;&gt;&gt;&gt; b = &quot;abycdf&quot;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, a, b)&#10;&gt;&gt;&gt; for tag, i1, i2, j1, j2 in s.get_opcodes():&#10;...    print((&quot;%7s a[%d:%d] (%s) b[%d:%d] (%s)&quot; %&#10;...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2])))&#10; delete a[0:1] (q) b[0:0] ()&#10;  equal a[1:3] (ab) b[0:2] (ab)&#10;replace a[3:4] (x) b[2:3] (y)&#10;  equal a[4:6] (cd) b[3:5] (cd)&#10; insert a[6:6] () b[5:6] (f)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.quick_ratio" func="yes">
			<Overload retVal="" descr="Return an upper bound on ratio() relatively quickly.&#10;&#10;This isn't defined beyond that it is an upper bound on .ratio(), and&#10;is faster to compute.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.ratio" func="yes">
			<Overload retVal="" descr="Return a measure of the sequences' similarity (float in [0,1]).&#10;&#10;Where T is the total number of elements in both sequences, and&#10;M is the number of matches, this is 2.0*M / T.&#10;Note that this is 1 if the sequences are identical, and 0 if&#10;they have nothing in common.&#10;&#10;.ratio() is expensive to compute if you haven't already computed&#10;.get_matching_blocks() or .get_opcodes(), in which case you may&#10;want to try .quick_ratio() or .real_quick_ratio() first to get an&#10;upper bound.&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, &quot;abcd&quot;, &quot;bcde&quot;)&#10;&gt;&gt;&gt; s.ratio()&#10;0.75&#10;&gt;&gt;&gt; s.quick_ratio()&#10;0.75&#10;&gt;&gt;&gt; s.real_quick_ratio()&#10;1.0">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.real_quick_ratio" func="yes">
			<Overload retVal="" descr="Return an upper bound on ratio() very quickly.&#10;&#10;This isn't defined beyond that it is an upper bound on .ratio(), and&#10;is faster to compute than either .ratio() or .quick_ratio().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.set_seq1" func="yes">
			<Overload retVal="" descr='Set the first sequence to be compared.&#10;&#10;The second sequence to be compared is not changed.&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")&#10;&gt;&gt;&gt; s.ratio()&#10;0.75&#10;&gt;&gt;&gt; s.set_seq1("bcde")&#10;&gt;&gt;&gt; s.ratio()&#10;1.0&#10;&gt;&gt;&gt;&#10;&#10;SequenceMatcher computes and caches detailed information about the&#10;second sequence, so if you want to compare one sequence S against&#10;many sequences, use .set_seq2(S) once and call .set_seq1(x)&#10;repeatedly for each of the other sequences.&#10;&#10;See also set_seqs() and set_seq2().'>
				<Param name="self" />
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.set_seq2" func="yes">
			<Overload retVal="" descr='Set the second sequence to be compared.&#10;&#10;The first sequence to be compared is not changed.&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")&#10;&gt;&gt;&gt; s.ratio()&#10;0.75&#10;&gt;&gt;&gt; s.set_seq2("abcd")&#10;&gt;&gt;&gt; s.ratio()&#10;1.0&#10;&gt;&gt;&gt;&#10;&#10;SequenceMatcher computes and caches detailed information about the&#10;second sequence, so if you want to compare one sequence S against&#10;many sequences, use .set_seq2(S) once and call .set_seq1(x)&#10;repeatedly for each of the other sequences.&#10;&#10;See also set_seqs() and set_seq1().'>
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.SequenceMatcher.set_seqs" func="yes">
			<Overload retVal="" descr='Set the two sequences to be compared.&#10;&#10;&gt;&gt;&gt; s = SequenceMatcher()&#10;&gt;&gt;&gt; s.set_seqs("abcd", "bcde")&#10;&gt;&gt;&gt; s.ratio()&#10;0.75'>
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.context_diff" func="yes">
			<Overload retVal="" descr="Compare two sequences of lines; generate the delta as a context diff.&#10;&#10;Context diffs are a compact way of showing line changes and a few&#10;lines of context.  The number of context lines is set by 'n' which&#10;defaults to three.&#10;&#10;By default, the diff control lines (those with *** or ---) are&#10;created with a trailing newline.  This is helpful so that inputs&#10;created from file.readlines() result in diffs that are suitable for&#10;file.writelines() since both the inputs and outputs have trailing&#10;newlines.&#10;&#10;For inputs that do not have trailing newlines, set the lineterm&#10;argument to &quot;&quot; so that the output will be uniformly newline free.&#10;&#10;The context diff format normally has a header for filenames and&#10;modification times.  Any or all of these may be specified using&#10;strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.&#10;The modification times are normally expressed in the ISO 8601 format.&#10;If not specified, the strings default to blanks.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; print(''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(True),&#10;...       'zero\none\ntree\nfour\n'.splitlines(True), 'Original', 'Current')),&#10;...       end=&quot;&quot;)&#10;*** Original&#10;--- Current&#10;***************&#10;*** 1,4 ****&#10;  one&#10;! two&#10;! three&#10;  four&#10;--- 1,4 ----&#10;+ zero&#10;  one&#10;! tree&#10;  four">
				<Param name="a" />
				<Param name="b" />
				<Param name="[fromfile" />
				<Param name="[tofile" />
				<Param name="[fromfiledate" />
				<Param name="[tofiledate" />
				<Param name="[n=3" />
				<Param name="[lineterm=
]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.diff_bytes" func="yes">
			<Overload retVal="" descr="Compare `a` and `b`, two sequences of lines represented as bytes rather&#10;than str. This is a wrapper for `dfunc`, which is typically either&#10;unified_diff() or context_diff(). Inputs are losslessly converted to&#10;strings so that `dfunc` only has to worry about strings, and encoded&#10;back to bytes on return. This is necessary to compare files with&#10;unknown or inconsistent encoding. All other inputs (except `n`) must be&#10;bytes rather than str.">
				<Param name="dfunc" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[fromfile=b''" />
				<Param name="[tofile=b''" />
				<Param name="[fromfiledate=b''" />
				<Param name="[tofiledate=b''" />
				<Param name="[n=3" />
				<Param name="[lineterm=b'\n']]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.get_close_matches" func="yes">
			<Overload retVal="" descr="Use SequenceMatcher to return list of the best &quot;good enough&quot; matches.&#10;&#10;word is a sequence for which close matches are desired (typically a&#10;string).&#10;&#10;possibilities is a list of sequences against which to match word&#10;(typically a list of strings).&#10;&#10;Optional arg n (default 3) is the maximum number of close matches to&#10;return.  n must be &gt; 0.&#10;&#10;Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities&#10;that don't score at least that similar to word are ignored.&#10;&#10;The best (no more than n) matches among the possibilities are returned&#10;in a list, sorted by similarity score, most similar first.&#10;&#10;&gt;&gt;&gt; get_close_matches(&quot;appel&quot;, [&quot;ape&quot;, &quot;apple&quot;, &quot;peach&quot;, &quot;puppy&quot;])&#10;['apple', 'ape']&#10;&gt;&gt;&gt; import keyword as _keyword&#10;&gt;&gt;&gt; get_close_matches(&quot;wheel&quot;, _keyword.kwlist)&#10;['while']&#10;&gt;&gt;&gt; get_close_matches(&quot;Apple&quot;, _keyword.kwlist)&#10;[]&#10;&gt;&gt;&gt; get_close_matches(&quot;accept&quot;, _keyword.kwlist)&#10;['except']">
				<Param name="word" />
				<Param name="possibilities" />
				<Param name="[n=3" />
				<Param name="[cutoff=0.6]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.ndiff" func="yes">
			<Overload retVal="" descr="Compare `a` and `b` (lists of strings); return a `Differ`-style delta.&#10;&#10;Optional keyword parameters `linejunk` and `charjunk` are for filter&#10;functions, or can be None:&#10;&#10;- linejunk: A function that should accept a single string argument and&#10;  return true iff the string is junk.  The default is None, and is&#10;  recommended; the underlying SequenceMatcher class has an adaptive&#10;  notion of &quot;noise&quot; lines.&#10;&#10;- charjunk: A function that accepts a character (string of length&#10;  1), and returns true iff the character is junk. The default is&#10;  the module-level function IS_CHARACTER_JUNK, which filters out&#10;  whitespace characters (a blank or tab; note: it's a bad idea to&#10;  include newline in this!).&#10;&#10;Tools/scripts/ndiff.py is a command-line front-end to this function.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),&#10;...              'ore\ntree\nemu\n'.splitlines(keepends=True))&#10;&gt;&gt;&gt; print(''.join(diff), end=&quot;&quot;)&#10;- one&#10;?  ^&#10;+ ore&#10;?  ^&#10;- two&#10;- three&#10;?  -&#10;+ tree&#10;+ emu">
				<Param name="a" />
				<Param name="b" />
				<Param name="[linejunk=None" />
				<Param name="[charjunk=<function IS_CHARACTER_JUNK at 0x036E9E88>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.restore" func="yes">
			<Overload retVal="" descr="Generate one of the two sequences that generated a delta.&#10;&#10;Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract&#10;lines originating from file 1 or 2 (parameter `which`), stripping off line&#10;prefixes.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),&#10;...              'ore\ntree\nemu\n'.splitlines(keepends=True))&#10;&gt;&gt;&gt; diff = list(diff)&#10;&gt;&gt;&gt; print(''.join(restore(diff, 1)), end=&quot;&quot;)&#10;one&#10;two&#10;three&#10;&gt;&gt;&gt; print(''.join(restore(diff, 2)), end=&quot;&quot;)&#10;ore&#10;tree&#10;emu">
				<Param name="delta" />
				<Param name="which" />
			</Overload>
		</KeyWord>
		<KeyWord name="difflib.unified_diff" func="yes">
			<Overload retVal="" descr="Compare two sequences of lines; generate the delta as a unified diff.&#10;&#10;Unified diffs are a compact way of showing line changes and a few&#10;lines of context.  The number of context lines is set by 'n' which&#10;defaults to three.&#10;&#10;By default, the diff control lines (those with ---, +++, or @@) are&#10;created with a trailing newline.  This is helpful so that inputs&#10;created from file.readlines() result in diffs that are suitable for&#10;file.writelines() since both the inputs and outputs have trailing&#10;newlines.&#10;&#10;For inputs that do not have trailing newlines, set the lineterm&#10;argument to &quot;&quot; so that the output will be uniformly newline free.&#10;&#10;The unidiff format normally has a header for filenames and modification&#10;times.  Any or all of these may be specified using strings for&#10;'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.&#10;The modification times are normally expressed in the ISO 8601 format.&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; for line in unified_diff('one two three four'.split(),&#10;...             'zero one tree four'.split(), 'Original', 'Current',&#10;...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',&#10;...             lineterm=''):&#10;...     print(line)                 # doctest: +NORMALIZE_WHITESPACE&#10;--- Original        2005-01-26 23:30:50&#10;+++ Current         2010-04-02 10:20:52&#10;@@ -1,4 +1,4 @@&#10;+zero&#10; one&#10;-two&#10;-three&#10;+tree&#10; four">
				<Param name="a" />
				<Param name="b" />
				<Param name="[fromfile" />
				<Param name="[tofile" />
				<Param name="[fromfiledate" />
				<Param name="[tofiledate" />
				<Param name="[n=3" />
				<Param name="[lineterm=
]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="digest" func="yes">
			<Overload retVal="" descr="Function of hashlib.blake2b">
			</Overload>
		</KeyWord>
		<KeyWord name="digit" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="dir" func="yes">
			<Overload retVal="" descr="dir([object]) -&gt; list of strings&#10;&#10;If called without an argument, return the names in the current scope.&#10;Else, return an alphabetized list of names comprising (some of) the attributes&#10;of the given object, and of attributes reachable from it.&#10;If the object supplies a method named __dir__, it will be used; otherwise&#10;the default dir() logic is used and returns:&#10;  for a module object: the module's attributes.&#10;  for a class object:  its attributes, and recursively the attributes&#10;    of its bases.&#10;  for any other object: its attributes, its class's attributes, and&#10;    recursively the attributes of its class's base classes.">
			</Overload>
		</KeyWord>
		<KeyWord name="dircmp" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="dirname" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="dis" func="yes">
			<Overload retVal="" descr="Disassembler of Python byte code into mnemonics.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Bytecode" func="yes">
			<Overload retVal="" descr="The bytecode operations of a piece of code&#10;&#10;Instantiate this with a function, method, string of code, or a code object&#10;(as returned by compile()).&#10;&#10;Iterating over this yields the bytecode operations as Instruction instances.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Bytecode.dis" func="yes">
			<Overload retVal="" descr="Return a formatted view of the bytecode operations.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Bytecode.from_traceback" func="yes">
			<Overload retVal="" descr="Construct a Bytecode from the given traceback">
				<Param name="cls" />
				<Param name="tb" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Bytecode.info" func="yes">
			<Overload retVal="" descr="Return formatted information about the code object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.COMPILER_FLAG_NAMES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.EXTENDED_ARG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.FORMAT_VALUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.HAVE_ARGUMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction" func="yes">
			<Overload retVal="" descr="Details for a bytecode operation&#10;&#10;Defined fields:&#10;  opname - human readable name for operation&#10;  opcode - numeric code for operation&#10;  arg - numeric argument to operation (if any), otherwise None&#10;  argval - resolved arg value (if known), otherwise same as arg&#10;  argrepr - human readable description of operation argument&#10;  offset - start index of operation within bytecode sequence&#10;  starts_line - line started by this opcode (if any), otherwise None&#10;  is_jump_target - True if other code jumps to here, otherwise False">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.arg" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.argrepr" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.argval" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.is_jump_target" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.offset" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.opcode" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.opname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.Instruction.starts_line" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.cmp_op" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.code_info" func="yes">
			<Overload retVal="" descr="Formatted details of methods, functions, or code.">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.dis" func="yes">
			<Overload retVal="" descr="Disassemble classes, methods, functions, generators, or code.&#10;&#10;With no argument, disassemble the last traceback.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.disassemble" func="yes">
			<Overload retVal="" descr="Disassemble a code object.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.disco" func="yes">
			<Overload retVal="" descr="Disassemble a code object.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.distb" func="yes">
			<Overload retVal="" descr="Disassemble a traceback (default: last traceback).">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.findlabels" func="yes">
			<Overload retVal="" descr="Detect all offsets in a byte code which are jump targets.&#10;&#10;Return the list of offsets.">
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.findlinestarts" func="yes">
			<Overload retVal="" descr="Find the offsets in a byte code which are start of lines in the source.&#10;&#10;Generate pairs (offset, lineno) as described in Python/compile.c.">
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.get_instructions" func="yes">
			<Overload retVal="" descr="Iterator for the opcodes in methods, functions or code&#10;&#10;Generates a series of Instruction named tuples giving the details of&#10;each operations in the supplied code.&#10;&#10;If *first_line* is not None, it indicates the line number that should&#10;be reported for the first source line in the disassembled code.&#10;Otherwise, the source line information (if any) is taken directly from&#10;the disassembled code object.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hascompare" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasconst" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasfree" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasjabs" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasjrel" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.haslocal" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.hasname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.opmap" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.opname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.pretty_flags" func="yes">
			<Overload retVal="" descr="Return pretty representation of code flags.">
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="dis.show_code" func="yes">
			<Overload retVal="" descr="Print details of methods, functions, or code to *file*.&#10;&#10;If *file* is not provided, the output is printed on stdout.">
			</Overload>
		</KeyWord>
		<KeyWord name="dis.stack_effect" func="yes">
			<Overload retVal="" descr="Compute the stack effect of the opcode.">
				<Param name="opcode" />
				<Param name="oparg" />
			</Overload>
		</KeyWord>
		<KeyWord name="disable" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="disable_interspersed_args" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="disassemble" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="discard" func="yes">
			<Overload retVal="" descr="Remove an element from a set if it is a member.&#10;&#10;If the element is not a member, do nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="discard_buffers" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="disco" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="discover" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="disk_usage" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="dispatch_call" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="dispatch_exception" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="dispatch_line" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="dispatch_return" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="dispatcher" func="yes">
			<Overload retVal="" descr="Function of asyncore.dispatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="dispatcher_with_send" func="yes">
			<Overload retVal="" descr="Function of asyncore.dispatcher_with_send">
			</Overload>
		</KeyWord>
		<KeyWord name="display" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cache">
			</Overload>
		</KeyWord>
		<KeyWord name="displayhook" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="dist" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="dist_is_editable" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="distb" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="distutils" func="yes">
			<Overload retVal="" descr="distutils&#10;&#10;The main package for the Python Module Distribution Utilities.  Normally&#10;used from a setup script as&#10;&#10;   from distutils.core import setup&#10;&#10;   setup (...)">
			</Overload>
		</KeyWord>
		<KeyWord name="divide" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="divide_int" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="divmod" func="yes">
			<Overload retVal="" descr="Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.">
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="dngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="doCleanups" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="do_EOF" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_a" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_alias" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_args" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_b" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_break" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_bt" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_c" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_cl" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_clear" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_commands" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_condition" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_cont" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_continue" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_d" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_debug" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_disable" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_display" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_down" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_enable" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_exit" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_h" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_handshake" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="do_help" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="do_ignore" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_interact" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_j" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_jump" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_l" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_list" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_ll" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_longlist" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_longs" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="do_n" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_next" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_p" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_pp" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_q" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_quit" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_r" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_restart" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_return" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_retval" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_run" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_rv" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_s" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_shorts" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="do_source" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_step" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_tbreak" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_u" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_unalias" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_undisplay" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_unt" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_until" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_up" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_w" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_whatis" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="do_where" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="doc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="docclass" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="docdata" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="docmd" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="docmodule" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="docother" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="docproperty" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="docroutine" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest" func="yes">
			<Overload retVal="" descr="Module doctest -- a framework for running examples in docstrings.&#10;&#10;In simplest use, end each module M to be tested with:&#10;&#10;def _test():&#10;    import doctest&#10;    doctest.testmod()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    _test()&#10;&#10;Then running the module as a script will cause the examples in the&#10;docstrings to get executed and verified:&#10;&#10;python M.py&#10;&#10;This won't display anything unless an example fails, in which case the&#10;failing example(s) and the cause(s) of the failure(s) are printed to stdout&#10;(why not stderr? because stderr is a lame hack &lt;0.2 wink&gt;), and the final&#10;line of output is &quot;Test failed.&quot;.&#10;&#10;Run it with the -v switch instead:&#10;&#10;python M.py -v&#10;&#10;and a detailed report of all examples tried is printed to stdout, along&#10;with assorted summaries at the end.&#10;&#10;You can force verbose mode by passing &quot;verbose=True&quot; to testmod, or prohibit&#10;it by passing &quot;verbose=False&quot;.  In either of those cases, sys.argv is not&#10;examined by testmod.&#10;&#10;There are a variety of other ways to run doctests, including integration&#10;with the unittest framework, and support for running non-Python text&#10;files containing doctests.  There are also many ways to override parts&#10;of doctest's default behaviors.  See the Library Reference Manual for&#10;details.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.BLANKLINE_MARKER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.COMPARISON_FLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DONT_ACCEPT_BLANKLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DONT_ACCEPT_TRUE_FOR_1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner" func="yes">
			<Overload retVal="" descr="Run doc tests but raise an exception as soon as there is a failure.&#10;&#10;If an unexpected exception occurs, an UnexpectedException is raised.&#10;It contains the test, the example, and the original exception:&#10;&#10;  &gt;&gt;&gt; runner = DebugRunner(verbose=False)&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                                    {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; try:&#10;  ...     runner.run(test)&#10;  ... except UnexpectedException as f:&#10;  ...     failure = f&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[1] # Already has the traceback&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;We wrap the original exception to give the calling application&#10;access to the test and example information.&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    runner.run(test)&#10;  ... except DocTestFailure as f:&#10;  ...    failure = f&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'&#10;&#10;If a failure or error occurs, the globals are left intact:&#10;&#10;  &gt;&gt;&gt; del test.globs['__builtins__']&#10;  &gt;&gt;&gt; test.globs&#10;  {'x': 1}&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 2&#10;  ...      &gt;&gt;&gt; raise KeyError&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;&#10;  &gt;&gt;&gt; runner.run(test)&#10;  Traceback (most recent call last):&#10;  ...&#10;  doctest.UnexpectedException: &lt;DocTest foo from foo.py:0 (2 examples)&gt;&#10;&#10;  &gt;&gt;&gt; del test.globs['__builtins__']&#10;  &gt;&gt;&gt; test.globs&#10;  {'x': 2}&#10;&#10;But the globals are cleared if there is no error:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;&#10;  &gt;&gt;&gt; runner.run(test)&#10;  TestResults(failed=0, attempted=1)&#10;&#10;  &gt;&gt;&gt; test.globs&#10;  {}">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.DIVIDER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.merge" />
		<KeyWord name="doctest.DebugRunner.report_failure" func="yes">
			<Overload retVal="" descr="Report that the given example failed.">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
				<Param name="got" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.report_start" func="yes">
			<Overload retVal="" descr="Report that the test runner is about to process the given&#10;example.  (Only displays a message if verbose=True)">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.report_success" func="yes">
			<Overload retVal="" descr="Report that the given example ran successfully.  (Only&#10;displays a message if verbose=True)">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
				<Param name="got" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.report_unexpected_exception" func="yes">
			<Overload retVal="" descr="Report that the given example raised an unexpected exception.">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
				<Param name="exc_info" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.run" func="yes">
			<Overload retVal="" descr="Run the examples in `test`, and display the results using the&#10;writer function `out`.&#10;&#10;The examples are run in the namespace `test.globs`.  If&#10;`clear_globs` is true (the default), then this namespace will&#10;be cleared after the test runs, to help with garbage&#10;collection.  If you would like to examine the namespace after&#10;the test completes, then use `clear_globs=False`.&#10;&#10;`compileflags` gives the set of flags that should be used by&#10;the Python compiler when running the examples.  If not&#10;specified, then it will default to the set of future-import&#10;flags that apply to `globs`.&#10;&#10;The output of each example is checked using&#10;`DocTestRunner.check_output`, and the results are formatted by&#10;the `DocTestRunner.report_*` methods.">
				<Param name="self" />
				<Param name="test" />
				<Param name="[compileflags=None" />
				<Param name="[out=None" />
				<Param name="[clear_globs=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DebugRunner.summarize" func="yes">
			<Overload retVal="" descr="Print a summary of all the test cases that have been run by&#10;this DocTestRunner, and return a tuple `(f, t)`, where `f` is&#10;the total number of failed examples, and `t` is the total&#10;number of tried examples.&#10;&#10;The optional `verbose` argument controls how detailed the&#10;summary is.  If the verbosity is not specified, then the&#10;DocTestRunner's verbosity is used.">
				<Param name="self" />
				<Param name="[verbose=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase" func="yes">
			<Overload retVal="" descr="A class whose instances are single test cases.&#10;&#10;By default, the test code itself should be placed in a method named&#10;'runTest'.&#10;&#10;If the fixture may be used for many test cases, create as&#10;many test methods as are needed. When instantiating such a TestCase&#10;subclass, specify in the constructor arguments the name of the test method&#10;that the instance is to execute.&#10;&#10;Test authors should subclass TestCase for their own tests. Construction&#10;and deconstruction of the test's environment ('fixture') can be&#10;implemented by overriding the 'setUp' and 'tearDown' methods respectively.&#10;&#10;If it is necessary to override the __init__ method, the base class&#10;__init__ method must always be called. It is important that subclasses&#10;should not change the signature of their __init__ method, since instances&#10;of the classes are instantiated automatically by parts of the framework&#10;in order to be run.&#10;&#10;When subclassing TestCase, you can set these attributes:&#10;* failureException: determines which exception will be raised when&#10;    the instance's assertion methods fail; test methods raising this&#10;    exception will be deemed to have 'failed' rather than 'errored'.&#10;* longMessage: determines whether long messages (including repr of&#10;    objects used in assert methods) will be printed on failure in *addition*&#10;    to any explicit message passed.&#10;* maxDiff: sets the maximum length of a diff in failure messages&#10;    by assert methods using difflib. It is looked up as an instance&#10;    attribute so can be configured by individual tests if required.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is more than the given&#10;delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertCountEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence comparison asserting that the same elements,&#10;regardless of order.  If the same element occurs more than once,&#10;it verifies that the elements occur the same number of times.&#10;&#10;    self.assertEqual(Counter(list(first)),&#10;                     Counter(list(second)))&#10;&#10; Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether dictionary is a superset of subset.">
				<Param name="self" />
				<Param name="subset" />
				<Param name="dictionary" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertLogs" func="yes">
			<Overload retVal="" descr="Fail unless a log message of level *level* or higher is emitted&#10;on *logger_name* or its children.  If omitted, *level* defaults to&#10;INFO and *logger* defaults to the root logger.&#10;&#10;This method must be used as a context manager, and will yield&#10;a recording object with two attributes: `output` and `records`.&#10;At the end of the context manager, the `output` attribute will&#10;be a list of the matching formatted log messages and the&#10;`records` attribute will be a list of the corresponding LogRecord&#10;objects.&#10;&#10;Example::&#10;&#10;    with self.assertLogs('foo', level='INFO') as cm:&#10;        logging.getLogger('foo').info('first message')&#10;        logging.getLogger('foo.bar').error('second message')&#10;    self.assertEqual(cm.output, ['INFO:foo:first message',&#10;                                 'ERROR:foo.bar:second message'])">
				<Param name="self" />
				<Param name="[logger=None" />
				<Param name="[level=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotRegex" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class expected_exception is raised&#10;by the callable when invoked with specified positional and&#10;keyword arguments. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertRaises&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRaisesRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regex.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertRaisesRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRegex" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertWarns" func="yes">
			<Overload retVal="" descr="Fail unless a warning of class warnClass is triggered&#10;by the callable when invoked with specified positional and&#10;keyword arguments.  If a different type of warning is&#10;triggered, it will not be handled: depending on the other&#10;warning filtering rules in effect, it might be silenced, printed&#10;out, or raised as an exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertWarns(SomeWarning):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertWarns&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the first matching&#10;warning as the 'warning' attribute; similarly, the 'filename'&#10;and 'lineno' attributes give you information about the line&#10;of Python code from which the warning was triggered.&#10;This allows you to inspect the warning after the assertion::&#10;&#10;    with self.assertWarns(SomeWarning) as cm:&#10;        do_something()&#10;    the_warning = cm.warning&#10;    self.assertEqual(the_warning.some_attribute, 147)">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.assertWarnsRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a triggered warning matches a regexp.&#10;Basic functioning is similar to assertWarns() with the addition&#10;that only warnings whose messages also match the regular expression&#10;are considered successful matches.&#10;&#10;Args:&#10;    expected_warning: Warning class expected to be triggered.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertWarnsRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.countTestCases" />
		<KeyWord name="doctest.DocFileCase.debug" func="yes">
			<Overload retVal="" descr="Run the test case without results and without catching exceptions&#10;&#10;The unit test framework includes a debug method on test cases&#10;and test suites to support post-mortem debugging.  The test code&#10;is run in such a way that errors are not caught.  This way a&#10;caller can catch the errors and initiate post-mortem debugging.&#10;&#10;The DocTestCase provides a debug method that raises&#10;UnexpectedException errors if there is an unexpected&#10;exception:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;  &gt;&gt;&gt; try:&#10;  ...     case.debug()&#10;  ... except UnexpectedException as f:&#10;  ...     failure = f&#10;&#10;The UnexpectedException contains the test, the example, and&#10;the original exception:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[1] # Already has the traceback&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    case.debug()&#10;  ... except DocTestFailure as f:&#10;  ...    failure = f&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.defaultTestResult" />
		<KeyWord name="doctest.DocFileCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.format_failure" />
		<KeyWord name="doctest.DocFileCase.id" />
		<KeyWord name="doctest.DocFileCase.longMessage" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.runTest" />
		<KeyWord name="doctest.DocFileCase.setUp" func="yes">
			<Overload retVal="" descr="Hook method for setting up the test fixture before exercising it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.shortDescription" func="yes">
			<Overload retVal="" descr="Returns a one-line description of the test, or None if no&#10;description has been provided.&#10;&#10;The default implementation of this method returns the first line of&#10;the specified test method's docstring.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.subTest" func="yes">
			<Overload retVal="" descr="Return a context manager that will return the enclosed block&#10;of code in a subtest identified by the optional message and&#10;keyword parameters.  A failure in the subtest marks the test&#10;case as failed but resumes execution at the end of the enclosed&#10;block, allowing further test code to be executed.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.tearDown" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the test fixture after testing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileSuite" func="yes">
			<Overload retVal="" descr="A unittest suite for one or more doctest files.&#10;&#10;The path to each doctest file is given as a string; the&#10;interpretation of that string depends on the keyword argument&#10;&quot;module_relative&quot;.&#10;&#10;A number of options may be provided as keyword arguments:&#10;&#10;module_relative&#10;  If &quot;module_relative&quot; is True, then the given file paths are&#10;  interpreted as os-independent module-relative paths.  By&#10;  default, these paths are relative to the calling module's&#10;  directory; but if the &quot;package&quot; argument is specified, then&#10;  they are relative to that package.  To ensure os-independence,&#10;  &quot;filename&quot; should use &quot;/&quot; characters to separate path&#10;  segments, and may not be an absolute path (i.e., it may not&#10;  begin with &quot;/&quot;).&#10;&#10;  If &quot;module_relative&quot; is False, then the given file paths are&#10;  interpreted as os-specific paths.  These paths may be absolute&#10;  or relative (to the current working directory).&#10;&#10;package&#10;  A Python package or the name of a Python package whose directory&#10;  should be used as the base directory for module relative paths.&#10;  If &quot;package&quot; is not specified, then the calling module's&#10;  directory is used as the base directory for module relative&#10;  filenames.  It is an error to specify &quot;package&quot; if&#10;  &quot;module_relative&quot; is False.&#10;&#10;setUp&#10;  A set-up function.  This is called before running the&#10;  tests in each file. The setUp function will be passed a DocTest&#10;  object.  The setUp function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;tearDown&#10;  A tear-down function.  This is called after running the&#10;  tests in each file.  The tearDown function will be passed a DocTest&#10;  object.  The tearDown function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;globs&#10;  A dictionary containing initial global variables for the tests.&#10;&#10;optionflags&#10;  A set of doctest option flags expressed as an integer.&#10;&#10;parser&#10;  A DocTestParser (or subclass) that should be used to extract&#10;  tests from the files.&#10;&#10;encoding&#10;  An encoding that will be used to convert the files to unicode.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocFileTest" func="yes">
			<Overload retVal="" descr=>
				<Param name="path" />
				<Param name="[module_relative=True" />
				<Param name="[package=None" />
				<Param name="[globs=None" />
				<Param name="[parser=<doctest.DocTestParser object at 0x03762A50>" />
				<Param name="[encoding=None" />
				<Param name="[**]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTest" func="yes">
			<Overload retVal="" descr="A collection of doctest examples that should be run in a single&#10;namespace.  Each `DocTest` defines the following attributes:&#10;&#10;  - examples: the list of examples.&#10;&#10;  - globs: The namespace (aka globals) that the examples should&#10;    be run in.&#10;&#10;  - name: A name identifying the DocTest (typically, the name of&#10;    the object whose docstring this DocTest was extracted from).&#10;&#10;  - filename: The name of the file that this DocTest was extracted&#10;    from, or `None` if the filename is unknown.&#10;&#10;  - lineno: The line number within filename where this DocTest&#10;    begins, or `None` if the line number is unavailable.  This&#10;    line number is zero-based, with respect to the beginning of&#10;    the file.&#10;&#10;  - docstring: The string that the examples were extracted from,&#10;    or `None` if the string is unavailable.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase" func="yes">
			<Overload retVal="" descr="A class whose instances are single test cases.&#10;&#10;By default, the test code itself should be placed in a method named&#10;'runTest'.&#10;&#10;If the fixture may be used for many test cases, create as&#10;many test methods as are needed. When instantiating such a TestCase&#10;subclass, specify in the constructor arguments the name of the test method&#10;that the instance is to execute.&#10;&#10;Test authors should subclass TestCase for their own tests. Construction&#10;and deconstruction of the test's environment ('fixture') can be&#10;implemented by overriding the 'setUp' and 'tearDown' methods respectively.&#10;&#10;If it is necessary to override the __init__ method, the base class&#10;__init__ method must always be called. It is important that subclasses&#10;should not change the signature of their __init__ method, since instances&#10;of the classes are instantiated automatically by parts of the framework&#10;in order to be run.&#10;&#10;When subclassing TestCase, you can set these attributes:&#10;* failureException: determines which exception will be raised when&#10;    the instance's assertion methods fail; test methods raising this&#10;    exception will be deemed to have 'failed' rather than 'errored'.&#10;* longMessage: determines whether long messages (including repr of&#10;    objects used in assert methods) will be printed on failure in *addition*&#10;    to any explicit message passed.&#10;* maxDiff: sets the maximum length of a diff in failure messages&#10;    by assert methods using difflib. It is looked up as an instance&#10;    attribute so can be configured by individual tests if required.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is more than the given&#10;delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertCountEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence comparison asserting that the same elements,&#10;regardless of order.  If the same element occurs more than once,&#10;it verifies that the elements occur the same number of times.&#10;&#10;    self.assertEqual(Counter(list(first)),&#10;                     Counter(list(second)))&#10;&#10; Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether dictionary is a superset of subset.">
				<Param name="self" />
				<Param name="subset" />
				<Param name="dictionary" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertLogs" func="yes">
			<Overload retVal="" descr="Fail unless a log message of level *level* or higher is emitted&#10;on *logger_name* or its children.  If omitted, *level* defaults to&#10;INFO and *logger* defaults to the root logger.&#10;&#10;This method must be used as a context manager, and will yield&#10;a recording object with two attributes: `output` and `records`.&#10;At the end of the context manager, the `output` attribute will&#10;be a list of the matching formatted log messages and the&#10;`records` attribute will be a list of the corresponding LogRecord&#10;objects.&#10;&#10;Example::&#10;&#10;    with self.assertLogs('foo', level='INFO') as cm:&#10;        logging.getLogger('foo').info('first message')&#10;        logging.getLogger('foo.bar').error('second message')&#10;    self.assertEqual(cm.output, ['INFO:foo:first message',&#10;                                 'ERROR:foo.bar:second message'])">
				<Param name="self" />
				<Param name="[logger=None" />
				<Param name="[level=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotRegex" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class expected_exception is raised&#10;by the callable when invoked with specified positional and&#10;keyword arguments. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertRaises&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRaisesRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regex.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertRaisesRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRegex" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertWarns" func="yes">
			<Overload retVal="" descr="Fail unless a warning of class warnClass is triggered&#10;by the callable when invoked with specified positional and&#10;keyword arguments.  If a different type of warning is&#10;triggered, it will not be handled: depending on the other&#10;warning filtering rules in effect, it might be silenced, printed&#10;out, or raised as an exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertWarns(SomeWarning):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertWarns&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the first matching&#10;warning as the 'warning' attribute; similarly, the 'filename'&#10;and 'lineno' attributes give you information about the line&#10;of Python code from which the warning was triggered.&#10;This allows you to inspect the warning after the assertion::&#10;&#10;    with self.assertWarns(SomeWarning) as cm:&#10;        do_something()&#10;    the_warning = cm.warning&#10;    self.assertEqual(the_warning.some_attribute, 147)">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.assertWarnsRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a triggered warning matches a regexp.&#10;Basic functioning is similar to assertWarns() with the addition&#10;that only warnings whose messages also match the regular expression&#10;are considered successful matches.&#10;&#10;Args:&#10;    expected_warning: Warning class expected to be triggered.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertWarnsRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.countTestCases" />
		<KeyWord name="doctest.DocTestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test case without results and without catching exceptions&#10;&#10;The unit test framework includes a debug method on test cases&#10;and test suites to support post-mortem debugging.  The test code&#10;is run in such a way that errors are not caught.  This way a&#10;caller can catch the errors and initiate post-mortem debugging.&#10;&#10;The DocTestCase provides a debug method that raises&#10;UnexpectedException errors if there is an unexpected&#10;exception:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;  &gt;&gt;&gt; try:&#10;  ...     case.debug()&#10;  ... except UnexpectedException as f:&#10;  ...     failure = f&#10;&#10;The UnexpectedException contains the test, the example, and&#10;the original exception:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[1] # Already has the traceback&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    case.debug()&#10;  ... except DocTestFailure as f:&#10;  ...    failure = f&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.defaultTestResult" />
		<KeyWord name="doctest.DocTestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.format_failure" />
		<KeyWord name="doctest.DocTestCase.id" />
		<KeyWord name="doctest.DocTestCase.longMessage" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.runTest" />
		<KeyWord name="doctest.DocTestCase.setUp" func="yes">
			<Overload retVal="" descr="Hook method for setting up the test fixture before exercising it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.shortDescription" func="yes">
			<Overload retVal="" descr="Returns a one-line description of the test, or None if no&#10;description has been provided.&#10;&#10;The default implementation of this method returns the first line of&#10;the specified test method's docstring.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.subTest" func="yes">
			<Overload retVal="" descr="Return a context manager that will return the enclosed block&#10;of code in a subtest identified by the optional message and&#10;keyword parameters.  A failure in the subtest marks the test&#10;case as failed but resumes execution at the end of the enclosed&#10;block, allowing further test code to be executed.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.tearDown" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the test fixture after testing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFailure" func="yes">
			<Overload retVal="" descr="A DocTest example has failed in debugging mode.&#10;&#10;The exception instance has variables:&#10;&#10;- test: the DocTest object being run&#10;&#10;- example: the Example object that failed&#10;&#10;- got: the actual output">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFailure.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFailure.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFinder" func="yes">
			<Overload retVal="" descr="A class used to extract the DocTests that are relevant to a given&#10;object, from its docstring and the docstrings of its contained&#10;objects.  Doctests can currently be extracted from the following&#10;object types: modules, functions, classes, methods, staticmethods,&#10;classmethods, and properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestFinder.find" func="yes">
			<Overload retVal="" descr="Return a list of the DocTests that are defined by the given&#10;object's docstring, or by any of its contained objects'&#10;docstrings.&#10;&#10;The optional parameter `module` is the module that contains&#10;the given object.  If the module is not specified or is None, then&#10;the test finder will attempt to automatically determine the&#10;correct module.  The object's module is used:&#10;&#10;    - As a default namespace, if `globs` is not specified.&#10;    - To prevent the DocTestFinder from extracting DocTests&#10;      from objects that are imported from other modules.&#10;    - To find the name of the file containing the object.&#10;    - To help find the line number of the object within its&#10;      file.&#10;&#10;Contained objects whose module does not match `module` are ignored.&#10;&#10;If `module` is False, no attempt to find the module will be made.&#10;This is obscure, of use mostly in tests:  if `module` is False, or&#10;is None but cannot be found automatically, then all objects are&#10;considered to belong to the (non-existent) module, so all contained&#10;objects will (recursively) be searched for doctests.&#10;&#10;The globals for each DocTest is formed by combining `globs`&#10;and `extraglobs` (bindings in `extraglobs` override bindings&#10;in `globs`).  A new copy of the globals dictionary is created&#10;for each DocTest.  If `globs` is not specified, then it&#10;defaults to the module's `__dict__`, if specified, or {}&#10;otherwise.  If `extraglobs` is not specified, then it defaults&#10;to {}.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[name=None" />
				<Param name="[module=None" />
				<Param name="[globs=None" />
				<Param name="[extraglobs=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestParser" func="yes">
			<Overload retVal="" descr="A class used to parse strings containing doctest examples.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestParser.get_doctest" func="yes">
			<Overload retVal="" descr="Extract all doctest examples from the given string, and&#10;collect them into a `DocTest` object.&#10;&#10;`globs`, `name`, `filename`, and `lineno` are attributes for&#10;the new `DocTest` object.  See the documentation for `DocTest`&#10;for more information.">
				<Param name="self" />
				<Param name="string" />
				<Param name="globs" />
				<Param name="name" />
				<Param name="filename" />
				<Param name="lineno" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestParser.get_examples" func="yes">
			<Overload retVal="" descr="Extract all doctest examples from the given string, and return&#10;them as a list of `Example` objects.  Line numbers are&#10;0-based, because it's most common in doctests that nothing&#10;interesting appears on the same line as opening triple-quote,&#10;and so the first interesting line is called &quot;line 1&quot; then.&#10;&#10;The optional argument `name` is a name identifying this&#10;string, and is only used for error messages.">
				<Param name="self" />
				<Param name="string" />
				<Param name="[name=<string>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestParser.parse" func="yes">
			<Overload retVal="" descr="Divide the given string into examples and intervening text,&#10;and return them as a list of alternating Examples and strings.&#10;Line numbers for the Examples are 0-based.  The optional&#10;argument `name` is a name identifying this string, and is only&#10;used for error messages.">
				<Param name="self" />
				<Param name="string" />
				<Param name="[name=<string>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner" func="yes">
			<Overload retVal="" descr="A class used to run DocTest test cases, and accumulate statistics.&#10;The `run` method is used to process a single DocTest case.  It&#10;returns a tuple `(f, t)`, where `t` is the number of test cases&#10;tried, and `f` is the number of test cases that failed.&#10;&#10;    &gt;&gt;&gt; tests = DocTestFinder().find(_TestClass)&#10;    &gt;&gt;&gt; runner = DocTestRunner(verbose=False)&#10;    &gt;&gt;&gt; tests.sort(key = lambda test: test.name)&#10;    &gt;&gt;&gt; for test in tests:&#10;    ...     print(test.name, '-&gt;', runner.run(test))&#10;    _TestClass -&gt; TestResults(failed=0, attempted=2)&#10;    _TestClass.__init__ -&gt; TestResults(failed=0, attempted=2)&#10;    _TestClass.get -&gt; TestResults(failed=0, attempted=2)&#10;    _TestClass.square -&gt; TestResults(failed=0, attempted=1)&#10;&#10;The `summarize` method prints a summary of all the test cases that&#10;have been run by the runner, and returns an aggregated `(f, t)`&#10;tuple:&#10;&#10;    &gt;&gt;&gt; runner.summarize(verbose=1)&#10;    4 items passed all tests:&#10;       2 tests in _TestClass&#10;       2 tests in _TestClass.__init__&#10;       2 tests in _TestClass.get&#10;       1 tests in _TestClass.square&#10;    7 tests in 4 items.&#10;    7 passed and 0 failed.&#10;    Test passed.&#10;    TestResults(failed=0, attempted=7)&#10;&#10;The aggregated number of tried examples and failed examples is&#10;also available via the `tries` and `failures` attributes:&#10;&#10;    &gt;&gt;&gt; runner.tries&#10;    7&#10;    &gt;&gt;&gt; runner.failures&#10;    0&#10;&#10;The comparison between expected outputs and actual outputs is done&#10;by an `OutputChecker`.  This comparison may be customized with a&#10;number of option flags; see the documentation for `testmod` for&#10;more information.  If the option flags are insufficient, then the&#10;comparison may also be customized by passing a subclass of&#10;`OutputChecker` to the constructor.&#10;&#10;The test runner's display output can be controlled in two ways.&#10;First, an output function (`out) can be passed to&#10;`TestRunner.run`; this function will be called with strings that&#10;should be displayed.  It defaults to `sys.stdout.write`.  If&#10;capturing the output is not sufficient, then the display output&#10;can be also customized by subclassing DocTestRunner, and&#10;overriding the methods `report_start`, `report_success`,&#10;`report_unexpected_exception`, and `report_failure`.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.DIVIDER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.merge" />
		<KeyWord name="doctest.DocTestRunner.report_failure" func="yes">
			<Overload retVal="" descr="Report that the given example failed.">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
				<Param name="got" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.report_start" func="yes">
			<Overload retVal="" descr="Report that the test runner is about to process the given&#10;example.  (Only displays a message if verbose=True)">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.report_success" func="yes">
			<Overload retVal="" descr="Report that the given example ran successfully.  (Only&#10;displays a message if verbose=True)">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
				<Param name="got" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.report_unexpected_exception" func="yes">
			<Overload retVal="" descr="Report that the given example raised an unexpected exception.">
				<Param name="self" />
				<Param name="out" />
				<Param name="test" />
				<Param name="example" />
				<Param name="exc_info" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.run" func="yes">
			<Overload retVal="" descr="Run the examples in `test`, and display the results using the&#10;writer function `out`.&#10;&#10;The examples are run in the namespace `test.globs`.  If&#10;`clear_globs` is true (the default), then this namespace will&#10;be cleared after the test runs, to help with garbage&#10;collection.  If you would like to examine the namespace after&#10;the test completes, then use `clear_globs=False`.&#10;&#10;`compileflags` gives the set of flags that should be used by&#10;the Python compiler when running the examples.  If not&#10;specified, then it will default to the set of future-import&#10;flags that apply to `globs`.&#10;&#10;The output of each example is checked using&#10;`DocTestRunner.check_output`, and the results are formatted by&#10;the `DocTestRunner.report_*` methods.">
				<Param name="self" />
				<Param name="test" />
				<Param name="[compileflags=None" />
				<Param name="[out=None" />
				<Param name="[clear_globs=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestRunner.summarize" func="yes">
			<Overload retVal="" descr="Print a summary of all the test cases that have been run by&#10;this DocTestRunner, and return a tuple `(f, t)`, where `f` is&#10;the total number of failed examples, and `t` is the total&#10;number of tried examples.&#10;&#10;The optional `verbose` argument controls how detailed the&#10;summary is.  If the verbosity is not specified, then the&#10;DocTestRunner's verbosity is used.">
				<Param name="self" />
				<Param name="[verbose=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.DocTestSuite" func="yes">
			<Overload retVal="" descr="Convert doctest tests for a module to a unittest test suite.&#10;&#10;This converts each documentation string in a module that&#10;contains doctest tests to a unittest test case.  If any of the&#10;tests in a doc string fail, then the test case fails.  An exception&#10;is raised showing the name of the file containing the test and a&#10;(sometimes approximate) line number.&#10;&#10;The `module` argument provides the module to be tested.  The argument&#10;can be either a module or a module name.&#10;&#10;If no argument is given, the calling module is used.&#10;&#10;A number of options may be provided as keyword arguments:&#10;&#10;setUp&#10;  A set-up function.  This is called before running the&#10;  tests in each file. The setUp function will be passed a DocTest&#10;  object.  The setUp function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;tearDown&#10;  A tear-down function.  This is called after running the&#10;  tests in each file.  The tearDown function will be passed a DocTest&#10;  object.  The tearDown function can access the test globals as the&#10;  globs attribute of the test passed.&#10;&#10;globs&#10;  A dictionary containing initial global variables for the tests.&#10;&#10;optionflags&#10;   A set of doctest option flags expressed as an integer.">
				<Param name="[module=None" />
				<Param name="[globs=None" />
				<Param name="[extraglobs=None" />
				<Param name="[test_finder=None" />
				<Param name="[**]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.ELLIPSIS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.ELLIPSIS_MARKER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.Example" func="yes">
			<Overload retVal="" descr="A single doctest example, consisting of source code and expected&#10;output.  `Example` defines the following attributes:&#10;&#10;  - source: A single Python statement, always ending with a newline.&#10;    The constructor adds a newline if needed.&#10;&#10;  - want: The expected output from running the source code (either&#10;    from stdout, or a traceback in case of exception).  `want` ends&#10;    with a newline unless it's empty, in which case it's an empty&#10;    string.  The constructor adds a newline if needed.&#10;&#10;  - exc_msg: The exception message generated by the example, if&#10;    the example is expected to generate an exception; or `None` if&#10;    it is not expected to generate an exception.  This exception&#10;    message is compared against the return value of&#10;    `traceback.format_exception_only()`.  `exc_msg` ends with a&#10;    newline unless it's `None`.  The constructor adds a newline&#10;    if needed.&#10;&#10;  - lineno: The line number within the DocTest string containing&#10;    this Example where the Example begins.  This line number is&#10;    zero-based, with respect to the beginning of the DocTest.&#10;&#10;  - indent: The example's indentation in the DocTest string.&#10;    I.e., the number of space characters that precede the&#10;    example's first prompt.&#10;&#10;  - options: A dictionary mapping from option flags to True or&#10;    False, which is used to override default options for this&#10;    example.  Any option flags not contained in this dictionary&#10;    are left at their default value (as specified by the&#10;    DocTestRunner's optionflags).  By default, no options are set.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.FAIL_FAST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.IGNORE_EXCEPTION_DETAIL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.NORMALIZE_WHITESPACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.OPTIONFLAGS_BY_NAME" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.OutputChecker" func="yes">
			<Overload retVal="" descr="A class used to check the whether the actual output from a doctest&#10;example matches the expected output.  `OutputChecker` defines two&#10;methods: `check_output`, which compares a given pair of outputs,&#10;and returns true if they match; and `output_difference`, which&#10;returns a string describing the differences between two outputs.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.OutputChecker.check_output" func="yes">
			<Overload retVal="" descr="Return True iff the actual output from an example (`got`)&#10;matches the expected output (`want`).  These strings are&#10;always considered to match if they are identical; but&#10;depending on what option flags the test runner is using,&#10;several non-exact match types are also possible.  See the&#10;documentation for `TestRunner` for more information about&#10;option flags.">
				<Param name="self" />
				<Param name="want" />
				<Param name="got" />
				<Param name="optionflags" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.OutputChecker.output_difference" func="yes">
			<Overload retVal="" descr="Return a string describing the differences between the&#10;expected output for a given example (`example`) and the actual&#10;output (`got`).  `optionflags` is the set of option flags used&#10;to compare `want` and `got`.">
				<Param name="self" />
				<Param name="example" />
				<Param name="got" />
				<Param name="optionflags" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORTING_FLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_CDIFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_NDIFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_ONLY_FIRST_FAILURE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.REPORT_UDIFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SKIP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase" func="yes">
			<Overload retVal="" descr="A class whose instances are single test cases.&#10;&#10;By default, the test code itself should be placed in a method named&#10;'runTest'.&#10;&#10;If the fixture may be used for many test cases, create as&#10;many test methods as are needed. When instantiating such a TestCase&#10;subclass, specify in the constructor arguments the name of the test method&#10;that the instance is to execute.&#10;&#10;Test authors should subclass TestCase for their own tests. Construction&#10;and deconstruction of the test's environment ('fixture') can be&#10;implemented by overriding the 'setUp' and 'tearDown' methods respectively.&#10;&#10;If it is necessary to override the __init__ method, the base class&#10;__init__ method must always be called. It is important that subclasses&#10;should not change the signature of their __init__ method, since instances&#10;of the classes are instantiated automatically by parts of the framework&#10;in order to be run.&#10;&#10;When subclassing TestCase, you can set these attributes:&#10;* failureException: determines which exception will be raised when&#10;    the instance's assertion methods fail; test methods raising this&#10;    exception will be deemed to have 'failed' rather than 'errored'.&#10;* longMessage: determines whether long messages (including repr of&#10;    objects used in assert methods) will be printed on failure in *addition*&#10;    to any explicit message passed.&#10;* maxDiff: sets the maximum length of a diff in failure messages&#10;    by assert methods using difflib. It is looked up as an instance&#10;    attribute so can be configured by individual tests if required.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is more than the given&#10;delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertCountEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence comparison asserting that the same elements,&#10;regardless of order.  If the same element occurs more than once,&#10;it verifies that the elements occur the same number of times.&#10;&#10;    self.assertEqual(Counter(list(first)),&#10;                     Counter(list(second)))&#10;&#10; Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether dictionary is a superset of subset.">
				<Param name="self" />
				<Param name="subset" />
				<Param name="dictionary" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertLogs" func="yes">
			<Overload retVal="" descr="Fail unless a log message of level *level* or higher is emitted&#10;on *logger_name* or its children.  If omitted, *level* defaults to&#10;INFO and *logger* defaults to the root logger.&#10;&#10;This method must be used as a context manager, and will yield&#10;a recording object with two attributes: `output` and `records`.&#10;At the end of the context manager, the `output` attribute will&#10;be a list of the matching formatted log messages and the&#10;`records` attribute will be a list of the corresponding LogRecord&#10;objects.&#10;&#10;Example::&#10;&#10;    with self.assertLogs('foo', level='INFO') as cm:&#10;        logging.getLogger('foo').info('first message')&#10;        logging.getLogger('foo.bar').error('second message')&#10;    self.assertEqual(cm.output, ['INFO:foo:first message',&#10;                                 'ERROR:foo.bar:second message'])">
				<Param name="self" />
				<Param name="[logger=None" />
				<Param name="[level=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotRegex" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class expected_exception is raised&#10;by the callable when invoked with specified positional and&#10;keyword arguments. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertRaises&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRaisesRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regex.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertRaisesRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRegex" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertWarns" func="yes">
			<Overload retVal="" descr="Fail unless a warning of class warnClass is triggered&#10;by the callable when invoked with specified positional and&#10;keyword arguments.  If a different type of warning is&#10;triggered, it will not be handled: depending on the other&#10;warning filtering rules in effect, it might be silenced, printed&#10;out, or raised as an exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertWarns(SomeWarning):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertWarns&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the first matching&#10;warning as the 'warning' attribute; similarly, the 'filename'&#10;and 'lineno' attributes give you information about the line&#10;of Python code from which the warning was triggered.&#10;This allows you to inspect the warning after the assertion::&#10;&#10;    with self.assertWarns(SomeWarning) as cm:&#10;        do_something()&#10;    the_warning = cm.warning&#10;    self.assertEqual(the_warning.some_attribute, 147)">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.assertWarnsRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a triggered warning matches a regexp.&#10;Basic functioning is similar to assertWarns() with the addition&#10;that only warnings whose messages also match the regular expression&#10;are considered successful matches.&#10;&#10;Args:&#10;    expected_warning: Warning class expected to be triggered.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertWarnsRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.countTestCases" />
		<KeyWord name="doctest.SkipDocTestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test case without results and without catching exceptions&#10;&#10;The unit test framework includes a debug method on test cases&#10;and test suites to support post-mortem debugging.  The test code&#10;is run in such a way that errors are not caught.  This way a&#10;caller can catch the errors and initiate post-mortem debugging.&#10;&#10;The DocTestCase provides a debug method that raises&#10;UnexpectedException errors if there is an unexpected&#10;exception:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('&gt;&gt;&gt; raise KeyError\n42',&#10;  ...                {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;  &gt;&gt;&gt; try:&#10;  ...     case.debug()&#10;  ... except UnexpectedException as f:&#10;  ...     failure = f&#10;&#10;The UnexpectedException contains the test, the example, and&#10;the original exception:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '42\n'&#10;&#10;  &gt;&gt;&gt; exc_info = failure.exc_info&#10;  &gt;&gt;&gt; raise exc_info[1] # Already has the traceback&#10;  Traceback (most recent call last):&#10;  ...&#10;  KeyError&#10;&#10;If the output doesn't match, then a DocTestFailure is raised:&#10;&#10;  &gt;&gt;&gt; test = DocTestParser().get_doctest('''&#10;  ...      &gt;&gt;&gt; x = 1&#10;  ...      &gt;&gt;&gt; x&#10;  ...      2&#10;  ...      ''', {}, 'foo', 'foo.py', 0)&#10;  &gt;&gt;&gt; case = DocTestCase(test)&#10;&#10;  &gt;&gt;&gt; try:&#10;  ...    case.debug()&#10;  ... except DocTestFailure as f:&#10;  ...    failure = f&#10;&#10;DocTestFailure objects provide access to the test:&#10;&#10;  &gt;&gt;&gt; failure.test is test&#10;  True&#10;&#10;As well as to the example:&#10;&#10;  &gt;&gt;&gt; failure.example.want&#10;  '2\n'&#10;&#10;and the actual output:&#10;&#10;  &gt;&gt;&gt; failure.got&#10;  '1\n'">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.defaultTestResult" />
		<KeyWord name="doctest.SkipDocTestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.format_failure" />
		<KeyWord name="doctest.SkipDocTestCase.id" />
		<KeyWord name="doctest.SkipDocTestCase.longMessage" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.runTest" />
		<KeyWord name="doctest.SkipDocTestCase.setUp" func="yes">
			<Overload retVal="" descr="Hook method for setting up the test fixture before exercising it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.shortDescription" func="yes">
			<Overload retVal="" descr="Returns a one-line description of the test, or None if no&#10;description has been provided.&#10;&#10;The default implementation of this method returns the first line of&#10;the specified test method's docstring.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.subTest" func="yes">
			<Overload retVal="" descr="Return a context manager that will return the enclosed block&#10;of code in a subtest identified by the optional message and&#10;keyword parameters.  A failure in the subtest marks the test&#10;case as failed but resumes execution at the end of the enclosed&#10;block, allowing further test code to be executed.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.tearDown" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the test fixture after testing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.SkipDocTestCase.test_skip" />
		<KeyWord name="doctest.StringIO" func="yes">
			<Overload retVal="" descr="Text I/O implementation using an in-memory buffer.&#10;&#10;The initial_value argument sets the value of object.  The newline&#10;argument is like the one of TextIOWrapper's constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.close" func="yes">
			<Overload retVal="" descr="Close the IO object.&#10;&#10;Attempting any further operation after the object is closed&#10;will raise a ValueError.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.encoding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.line_buffering" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.read" func="yes">
			<Overload retVal="" descr="Read at most size characters, returned as a string.&#10;&#10;If the argument is negative or omitted, read until EOF&#10;is reached. Return an empty string at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to character offset pos relative to position indicated by whence:&#10;    0  Start of stream (the default).  pos should be &gt;= 0;&#10;    1  Current position - pos must be 0;&#10;    2  End of stream - pos must be 0.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.tell" func="yes">
			<Overload retVal="" descr="Tell the current file position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate size to pos.&#10;&#10;The pos argument defaults to the current file position, as&#10;returned by tell().  The current file position is unchanged.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.write" func="yes">
			<Overload retVal="" descr="Write string to file.&#10;&#10;Returns the number of characters written, which is always equal to&#10;the length of the string.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.StringIO.writelines" />
		<KeyWord name="doctest.TestResults" func="yes">
			<Overload retVal="" descr="TestResults(failed, attempted)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.attempted" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.failed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.TestResults.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.UnexpectedException" func="yes">
			<Overload retVal="" descr="A DocTest example has encountered an unexpected exception&#10;&#10;The exception instance has variables:&#10;&#10;- test: the DocTest object being run&#10;&#10;- example: the Example object that failed&#10;&#10;- exc_info: the exception info">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.UnexpectedException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.UnexpectedException.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.debug" func="yes">
			<Overload retVal="" descr="Debug a single doctest docstring.&#10;&#10;Provide the module (or dotted name of the module) containing the&#10;test to be debugged and the name (within the module) of the object&#10;with the docstring with tests to be debugged.">
				<Param name="module" />
				<Param name="name" />
				<Param name="[pm=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.debug_script" func="yes">
			<Overload retVal="" descr="Debug a test script.  `src` is the script, as a string.">
				<Param name="src" />
				<Param name="[pm=False" />
				<Param name="[globs=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.debug_src" func="yes">
			<Overload retVal="" descr="Debug a single doctest docstring, in argument `src`'">
				<Param name="src" />
				<Param name="[pm=False" />
				<Param name="[globs=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.register_optionflag" />
		<KeyWord name="doctest.run_docstring_examples" func="yes">
			<Overload retVal="" descr="Test examples in the given object's docstring (`f`), using `globs`&#10;as globals.  Optional argument `name` is used in failure messages.&#10;If the optional argument `verbose` is true, then generate output&#10;even if there are no failures.&#10;&#10;`compileflags` gives the set of flags that should be used by the&#10;Python compiler when running the examples.  If not specified, then&#10;it will default to the set of future-import flags that apply to&#10;`globs`.&#10;&#10;Optional keyword arg `optionflags` specifies options for the&#10;testing and output.  See the documentation for `testmod` for more&#10;information.">
				<Param name="f" />
				<Param name="globs" />
				<Param name="[verbose=False" />
				<Param name="[name=NoName" />
				<Param name="[compileflags=None" />
				<Param name="[optionflags=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.script_from_examples" func="yes">
			<Overload retVal="" descr="Extract script from text with examples.&#10;&#10;Converts text with examples to a Python script.  Example input is&#10;converted to regular code.  Example output and all other words&#10;are converted to comments:&#10;&#10;&gt;&gt;&gt; text = '''&#10;...       Here are examples of simple math.&#10;...&#10;...           Python has super accurate integer addition&#10;...&#10;...           &gt;&gt;&gt; 2 + 2&#10;...           5&#10;...&#10;...           And very friendly error messages:&#10;...&#10;...           &gt;&gt;&gt; 1/0&#10;...           To Infinity&#10;...           And&#10;...           Beyond&#10;...&#10;...           You can use logic if you want:&#10;...&#10;...           &gt;&gt;&gt; if 0:&#10;...           ...    blah&#10;...           ...    blah&#10;...           ...&#10;...&#10;...           Ho hum&#10;...           '''&#10;&#10;&gt;&gt;&gt; print(script_from_examples(text))&#10;# Here are examples of simple math.&#10;#&#10;#     Python has super accurate integer addition&#10;#&#10;2 + 2&#10;# Expected:&#10;## 5&#10;#&#10;#     And very friendly error messages:&#10;#&#10;1/0&#10;# Expected:&#10;## To Infinity&#10;## And&#10;## Beyond&#10;#&#10;#     You can use logic if you want:&#10;#&#10;if 0:&#10;   blah&#10;   blah&#10;#&#10;#     Ho hum&#10;&lt;BLANKLINE&gt;">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.set_unittest_reportflags" func="yes">
			<Overload retVal="" descr="Sets the unittest option flags.&#10;&#10;The old flag is returned so that a runner could restore the old&#10;value if it wished to:&#10;&#10;  &gt;&gt;&gt; import doctest&#10;  &gt;&gt;&gt; old = doctest._unittest_reportflags&#10;  &gt;&gt;&gt; doctest.set_unittest_reportflags(REPORT_NDIFF |&#10;  ...                          REPORT_ONLY_FIRST_FAILURE) == old&#10;  True&#10;&#10;  &gt;&gt;&gt; doctest._unittest_reportflags == (REPORT_NDIFF |&#10;  ...                                   REPORT_ONLY_FIRST_FAILURE)&#10;  True&#10;&#10;Only reporting flags can be set:&#10;&#10;  &gt;&gt;&gt; doctest.set_unittest_reportflags(ELLIPSIS)&#10;  Traceback (most recent call last):&#10;  ...&#10;  ValueError: ('Only reporting flags allowed', 8)&#10;&#10;  &gt;&gt;&gt; doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |&#10;  ...                                   REPORT_ONLY_FIRST_FAILURE)&#10;  True">
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.testfile" func="yes">
			<Overload retVal="" descr="Test examples in the given file.  Return (#failures, #tests).&#10;&#10;Optional keyword arg &quot;module_relative&quot; specifies how filenames&#10;should be interpreted:&#10;&#10;  - If &quot;module_relative&quot; is True (the default), then &quot;filename&quot;&#10;     specifies a module-relative path.  By default, this path is&#10;     relative to the calling module's directory; but if the&#10;     &quot;package&quot; argument is specified, then it is relative to that&#10;     package.  To ensure os-independence, &quot;filename&quot; should use&#10;     &quot;/&quot; characters to separate path segments, and should not&#10;     be an absolute path (i.e., it may not begin with &quot;/&quot;).&#10;&#10;  - If &quot;module_relative&quot; is False, then &quot;filename&quot; specifies an&#10;    os-specific path.  The path may be absolute or relative (to&#10;    the current working directory).&#10;&#10;Optional keyword arg &quot;name&quot; gives the name of the test; by default&#10;use the file's basename.&#10;&#10;Optional keyword argument &quot;package&quot; is a Python package or the&#10;name of a Python package whose directory should be used as the&#10;base directory for a module relative filename.  If no package is&#10;specified, then the calling module's directory is used as the base&#10;directory for module relative filenames.  It is an error to&#10;specify &quot;package&quot; if &quot;module_relative&quot; is False.&#10;&#10;Optional keyword arg &quot;globs&quot; gives a dict to be used as the globals&#10;when executing examples; by default, use {}.  A copy of this dict&#10;is actually used for each docstring, so that each docstring's&#10;examples start with a clean slate.&#10;&#10;Optional keyword arg &quot;extraglobs&quot; gives a dictionary that should be&#10;merged into the globals that are used to execute examples.  By&#10;default, no extra globals are used.&#10;&#10;Optional keyword arg &quot;verbose&quot; prints lots of stuff if true, prints&#10;only failures if false; by default, it's true iff &quot;-v&quot; is in sys.argv.&#10;&#10;Optional keyword arg &quot;report&quot; prints a summary at the end when true,&#10;else prints nothing at the end.  In verbose mode, the summary is&#10;detailed, else very brief (in fact, empty if all tests passed).&#10;&#10;Optional keyword arg &quot;optionflags&quot; or's together module constants,&#10;and defaults to 0.  Possible values (see the docs for details):&#10;&#10;    DONT_ACCEPT_TRUE_FOR_1&#10;    DONT_ACCEPT_BLANKLINE&#10;    NORMALIZE_WHITESPACE&#10;    ELLIPSIS&#10;    SKIP&#10;    IGNORE_EXCEPTION_DETAIL&#10;    REPORT_UDIFF&#10;    REPORT_CDIFF&#10;    REPORT_NDIFF&#10;    REPORT_ONLY_FIRST_FAILURE&#10;&#10;Optional keyword arg &quot;raise_on_error&quot; raises an exception on the&#10;first unexpected exception or failure. This allows failures to be&#10;post-mortem debugged.&#10;&#10;Optional keyword arg &quot;parser&quot; specifies a DocTestParser (or&#10;subclass) that should be used to extract tests from the files.&#10;&#10;Optional keyword arg &quot;encoding&quot; specifies an encoding that should&#10;be used to convert the file to unicode.&#10;&#10;Advanced tomfoolery:  testmod runs methods of a local instance of&#10;class doctest.Tester, then merges the results into (or creates)&#10;global Tester instance doctest.master.  Methods of doctest.master&#10;can be called directly too, if you want to do something unusual.&#10;Passing report=0 to testmod is especially useful then, to delay&#10;displaying a summary.  Invoke doctest.master.summarize(verbose)&#10;when you're done fiddling.">
				<Param name="filename" />
				<Param name="[module_relative=True" />
				<Param name="[name=None" />
				<Param name="[package=None" />
				<Param name="[globs=None" />
				<Param name="[verbose=None" />
				<Param name="[report=True" />
				<Param name="[optionflags=0" />
				<Param name="[extraglobs=None" />
				<Param name="[raise_on_error=False" />
				<Param name="[parser=<doctest.DocTestParser object at 0x037628B0>" />
				<Param name="[encoding=None]]]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.testmod" func="yes">
			<Overload retVal="" descr="m=None, name=None, globs=None, verbose=None, report=True,&#10;   optionflags=0, extraglobs=None, raise_on_error=False,&#10;   exclude_empty=False&#10;&#10;Test examples in docstrings in functions and classes reachable&#10;from module m (or the current module if m is not supplied), starting&#10;with m.__doc__.&#10;&#10;Also test examples reachable from dict m.__test__ if it exists and is&#10;not None.  m.__test__ maps names to functions, classes and strings;&#10;function and class docstrings are tested even if the name is private;&#10;strings are tested directly, as if they were docstrings.&#10;&#10;Return (#failures, #tests).&#10;&#10;See help(doctest) for an overview.&#10;&#10;Optional keyword arg &quot;name&quot; gives the name of the module; by default&#10;use m.__name__.&#10;&#10;Optional keyword arg &quot;globs&quot; gives a dict to be used as the globals&#10;when executing examples; by default, use m.__dict__.  A copy of this&#10;dict is actually used for each docstring, so that each docstring's&#10;examples start with a clean slate.&#10;&#10;Optional keyword arg &quot;extraglobs&quot; gives a dictionary that should be&#10;merged into the globals that are used to execute examples.  By&#10;default, no extra globals are used.  This is new in 2.4.&#10;&#10;Optional keyword arg &quot;verbose&quot; prints lots of stuff if true, prints&#10;only failures if false; by default, it's true iff &quot;-v&quot; is in sys.argv.&#10;&#10;Optional keyword arg &quot;report&quot; prints a summary at the end when true,&#10;else prints nothing at the end.  In verbose mode, the summary is&#10;detailed, else very brief (in fact, empty if all tests passed).&#10;&#10;Optional keyword arg &quot;optionflags&quot; or's together module constants,&#10;and defaults to 0.  This is new in 2.3.  Possible values (see the&#10;docs for details):&#10;&#10;    DONT_ACCEPT_TRUE_FOR_1&#10;    DONT_ACCEPT_BLANKLINE&#10;    NORMALIZE_WHITESPACE&#10;    ELLIPSIS&#10;    SKIP&#10;    IGNORE_EXCEPTION_DETAIL&#10;    REPORT_UDIFF&#10;    REPORT_CDIFF&#10;    REPORT_NDIFF&#10;    REPORT_ONLY_FIRST_FAILURE&#10;&#10;Optional keyword arg &quot;raise_on_error&quot; raises an exception on the&#10;first unexpected exception or failure. This allows failures to be&#10;post-mortem debugged.&#10;&#10;Advanced tomfoolery:  testmod runs methods of a local instance of&#10;class doctest.Tester, then merges the results into (or creates)&#10;global Tester instance doctest.master.  Methods of doctest.master&#10;can be called directly too, if you want to do something unusual.&#10;Passing report=0 to testmod is especially useful then, to delay&#10;displaying a summary.  Invoke doctest.master.summarize(verbose)&#10;when you're done fiddling.">
				<Param name="[m=None" />
				<Param name="[name=None" />
				<Param name="[globs=None" />
				<Param name="[verbose=None" />
				<Param name="[report=True" />
				<Param name="[optionflags=0" />
				<Param name="[extraglobs=None" />
				<Param name="[raise_on_error=False" />
				<Param name="[exclude_empty=False]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="doctest.testsource" func="yes">
			<Overload retVal="" descr="Extract the test sources from a doctest docstring as a script.&#10;&#10;Provide the module (or dotted name of the module) containing the&#10;test to be debugged and the name (within the module) of the object&#10;with the doc string with tests to be debugged.">
				<Param name="module" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="document" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="dolog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="done" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="drain" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="dst" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading" func="yes">
			<Overload retVal="" descr="Faux ``threading`` version using ``dummy_thread`` instead of ``thread``.&#10;&#10;The module ``_dummy_threading`` is added to ``sys.modules`` in order&#10;to not have ``threading`` considered imported.  Had ``threading`` been&#10;directly imported it would have made all subsequent imports succeed&#10;regardless of whether ``_thread`` was available which is not desired.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier" func="yes">
			<Overload retVal="" descr="Implements a Barrier.&#10;&#10;Useful for synchronizing a fixed number of threads at known synchronization&#10;points.  Threads block on 'wait()' and are simultaneously once they have all&#10;made that call.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier.abort" func="yes">
			<Overload retVal="" descr="Place the barrier into a 'broken' state.&#10;&#10;Useful in case of error.  Any currently waiting threads and threads&#10;attempting to 'wait()' will have BrokenBarrierError raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier.broken" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier.n_waiting" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier.parties" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier.reset" func="yes">
			<Overload retVal="" descr="Reset the barrier to the initial state.&#10;&#10;Any threads currently waiting will get the BrokenBarrier exception&#10;raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Barrier.wait" func="yes">
			<Overload retVal="" descr="Wait for the barrier.&#10;&#10;When the specified number of threads have started waiting, they are all&#10;simultaneously awoken. If an 'action' was provided for the barrier, one&#10;of the threads will have executed that callback prior to returning.&#10;Returns an individual index number from 0 to 'parties-1'.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="Implements a bounded semaphore.&#10;&#10;A bounded semaphore checks to make sure its current value doesn't exceed its&#10;initial value. If it does, ValueError is raised. In most situations&#10;semaphores are used to guard resources with limited capacity.&#10;&#10;If the semaphore is released too many times it's a sign of a bug. If not&#10;given, value defaults to 1.&#10;&#10;Like regular semaphores, bounded semaphores manage a counter representing&#10;the number of release() calls minus the number of acquire() calls, plus an&#10;initial value. The acquire() method blocks if necessary until it can return&#10;without making the counter negative. If not given, value defaults to 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BoundedSemaphore.acquire" func="yes">
			<Overload retVal="" descr="Acquire a semaphore, decrementing the internal counter by one.&#10;&#10;When invoked without arguments: if the internal counter is larger than&#10;zero on entry, decrement it by one and return immediately. If it is zero&#10;on entry, block, waiting until some other thread has called release() to&#10;make it larger than zero. This is done with proper interlocking so that&#10;if multiple acquire() calls are blocked, release() will wake exactly one&#10;of them up. The implementation may pick one at random, so the order in&#10;which blocked threads are awakened should not be relied on. There is no&#10;return value in this case.&#10;&#10;When invoked with blocking set to true, do the same thing as when called&#10;without arguments, and return true.&#10;&#10;When invoked with blocking set to false, do not block. If a call without&#10;an argument would block, return false immediately; otherwise, do the&#10;same thing as when called without arguments, and return true.&#10;&#10;When invoked with a timeout other than None, it will block for at&#10;most timeout seconds.  If acquire does not complete successfully in&#10;that interval, return false.  Return true otherwise.">
				<Param name="self" />
				<Param name="[blocking=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BoundedSemaphore.release" func="yes">
			<Overload retVal="" descr="Release a semaphore, incrementing the internal counter by one.&#10;&#10;When the counter is zero on entry and another thread is waiting for it&#10;to become larger than zero again, wake up that thread.&#10;&#10;If the number of releases exceeds the number of acquires,&#10;raise a ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BrokenBarrierError" func="yes">
			<Overload retVal="" descr="Unspecified run-time error.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BrokenBarrierError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.BrokenBarrierError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition" func="yes">
			<Overload retVal="" descr="Class that implements a condition variable.&#10;&#10;A condition variable allows one or more threads to wait until they are&#10;notified by another thread.&#10;&#10;If the lock argument is given and not None, it must be a Lock or RLock&#10;object, and it is used as the underlying lock. Otherwise, a new RLock object&#10;is created and used as the underlying lock.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition.notify" func="yes">
			<Overload retVal="" descr="Wake up one or more threads waiting on this condition, if any.&#10;&#10;If the calling thread has not acquired the lock when this method is&#10;called, a RuntimeError is raised.&#10;&#10;This method wakes up at most n of the threads waiting for the condition&#10;variable; it is a no-op if no threads are waiting.">
				<Param name="self" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition.notifyAll" func="yes">
			<Overload retVal="" descr="Wake up all threads waiting on this condition.&#10;&#10;If the calling thread has not acquired the lock when this method&#10;is called, a RuntimeError is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition.notify_all" func="yes">
			<Overload retVal="" descr="Wake up all threads waiting on this condition.&#10;&#10;If the calling thread has not acquired the lock when this method&#10;is called, a RuntimeError is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition.wait" func="yes">
			<Overload retVal="" descr="Wait until notified or until a timeout occurs.&#10;&#10;If the calling thread has not acquired the lock when this method is&#10;called, a RuntimeError is raised.&#10;&#10;This method releases the underlying lock, and then blocks until it is&#10;awakened by a notify() or notify_all() call for the same condition&#10;variable in another thread, or until the optional timeout occurs. Once&#10;awakened or timed out, it re-acquires the lock and returns.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof).&#10;&#10;When the underlying lock is an RLock, it is not released using its&#10;release() method, since this may not actually unlock the lock when it&#10;was acquired multiple times recursively. Instead, an internal interface&#10;of the RLock class is used, which really unlocks it even when it has&#10;been recursively acquired several times. Another internal interface is&#10;then used to restore the recursion level when the lock is reacquired.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Condition.wait_for" func="yes">
			<Overload retVal="" descr="Wait until a condition evaluates to True.&#10;&#10;predicate should be a callable which result will be interpreted as a&#10;boolean value.  A timeout may be provided giving the maximum time to&#10;wait.">
				<Param name="self" />
				<Param name="predicate" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event" func="yes">
			<Overload retVal="" descr="Class implementing event objects.&#10;&#10;Events manage a flag that can be set to true with the set() method and reset&#10;to false with the clear() method. The wait() method blocks until the flag is&#10;true.  The flag is initially false.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event.clear" func="yes">
			<Overload retVal="" descr="Reset the internal flag to false.&#10;&#10;Subsequently, threads calling wait() will block until set() is called to&#10;set the internal flag to true again.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event.isSet" func="yes">
			<Overload retVal="" descr="Return true if and only if the internal flag is true.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event.is_set" func="yes">
			<Overload retVal="" descr="Return true if and only if the internal flag is true.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event.set" func="yes">
			<Overload retVal="" descr="Set the internal flag to true.&#10;&#10;All threads waiting for it to become true are awakened. Threads&#10;that call wait() once the flag is true will not block at all.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Event.wait" func="yes">
			<Overload retVal="" descr="Block until the internal flag is true.&#10;&#10;If the internal flag is true on entry, return immediately. Otherwise,&#10;block until another thread calls set() to set the flag to true, or until&#10;the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof).&#10;&#10;This method returns the internal flag on exit, so it will always return&#10;True except if a timeout is given and the operation times out.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Lock" func="yes">
			<Overload retVal="" descr="Dummy implementation of _thread.allocate_lock().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.RLock" func="yes">
			<Overload retVal="" descr="Factory function that returns a new reentrant lock.&#10;&#10;A reentrant lock must be released by the thread that acquired it. Once a&#10;thread has acquired a reentrant lock, the same thread may acquire it again&#10;without blocking; the thread must release it once for each time it has&#10;acquired it.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Semaphore" func="yes">
			<Overload retVal="" descr="This class implements semaphore objects.&#10;&#10;Semaphores manage a counter representing the number of release() calls minus&#10;the number of acquire() calls, plus an initial value. The acquire() method&#10;blocks if necessary until it can return without making the counter&#10;negative. If not given, value defaults to 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Semaphore.acquire" func="yes">
			<Overload retVal="" descr="Acquire a semaphore, decrementing the internal counter by one.&#10;&#10;When invoked without arguments: if the internal counter is larger than&#10;zero on entry, decrement it by one and return immediately. If it is zero&#10;on entry, block, waiting until some other thread has called release() to&#10;make it larger than zero. This is done with proper interlocking so that&#10;if multiple acquire() calls are blocked, release() will wake exactly one&#10;of them up. The implementation may pick one at random, so the order in&#10;which blocked threads are awakened should not be relied on. There is no&#10;return value in this case.&#10;&#10;When invoked with blocking set to true, do the same thing as when called&#10;without arguments, and return true.&#10;&#10;When invoked with blocking set to false, do not block. If a call without&#10;an argument would block, return false immediately; otherwise, do the&#10;same thing as when called without arguments, and return true.&#10;&#10;When invoked with a timeout other than None, it will block for at&#10;most timeout seconds.  If acquire does not complete successfully in&#10;that interval, return false.  Return true otherwise.">
				<Param name="self" />
				<Param name="[blocking=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Semaphore.release" func="yes">
			<Overload retVal="" descr="Release a semaphore, incrementing the internal counter by one.&#10;&#10;When the counter is zero on entry and another thread is waiting for it&#10;to become larger than zero again, wake up that thread.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.TIMEOUT_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread" func="yes">
			<Overload retVal="" descr="A class that represents a thread of control.&#10;&#10;This class can be safely subclassed in a limited fashion. There are two ways&#10;to specify the activity: by passing a callable object to the constructor, or&#10;by overriding the run() method in a subclass.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.getName" />
		<KeyWord name="dummy_threading.Thread.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.isAlive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.isDaemon" />
		<KeyWord name="dummy_threading.Thread.is_alive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.join" func="yes">
			<Overload retVal="" descr="Wait until the thread terminates.&#10;&#10;This blocks the calling thread until the thread whose join() method is&#10;called terminates -- either normally or through an unhandled exception&#10;or until the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof). As join() always returns None, you must call&#10;isAlive() after join() to decide whether a timeout happened -- if the&#10;thread is still alive, the join() call timed out.&#10;&#10;When the timeout argument is not present or None, the operation will&#10;block until the thread terminates.&#10;&#10;A thread can be join()ed many times.&#10;&#10;join() raises a RuntimeError if an attempt is made to join the current&#10;thread as that would cause a deadlock. It is also an error to join() a&#10;thread before it has been started and attempts to do so raises the same&#10;exception.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.run" func="yes">
			<Overload retVal="" descr="Method representing the thread's activity.&#10;&#10;You may override this method in a subclass. The standard run() method&#10;invokes the callable object passed to the object's constructor as the&#10;target argument, if any, with sequential and keyword arguments taken&#10;from the args and kwargs arguments, respectively.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Thread.setDaemon" />
		<KeyWord name="dummy_threading.Thread.setName" />
		<KeyWord name="dummy_threading.Thread.start" func="yes">
			<Overload retVal="" descr="Start the thread's activity.&#10;&#10;It must be called at most once per thread object. It arranges for the&#10;object's run() method to be invoked in a separate thread of control.&#10;&#10;This method will raise a RuntimeError if called more than once on the&#10;same thread object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.ThreadError" func="yes">
			<Overload retVal="" descr="Unspecified run-time error.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.ThreadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.ThreadError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer" func="yes">
			<Overload retVal="" descr="Call a function after a specified number of seconds:&#10;&#10;t = Timer(30.0, f, args=None, kwargs=None)&#10;t.start()&#10;t.cancel()     # stop the timer's action if it's still waiting">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.cancel" func="yes">
			<Overload retVal="" descr="Stop the timer if it hasn't finished yet.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.getName" />
		<KeyWord name="dummy_threading.Timer.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.isAlive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.isDaemon" />
		<KeyWord name="dummy_threading.Timer.is_alive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.join" func="yes">
			<Overload retVal="" descr="Wait until the thread terminates.&#10;&#10;This blocks the calling thread until the thread whose join() method is&#10;called terminates -- either normally or through an unhandled exception&#10;or until the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof). As join() always returns None, you must call&#10;isAlive() after join() to decide whether a timeout happened -- if the&#10;thread is still alive, the join() call timed out.&#10;&#10;When the timeout argument is not present or None, the operation will&#10;block until the thread terminates.&#10;&#10;A thread can be join()ed many times.&#10;&#10;join() raises a RuntimeError if an attempt is made to join the current&#10;thread as that would cause a deadlock. It is also an error to join() a&#10;thread before it has been started and attempts to do so raises the same&#10;exception.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.Timer.run" />
		<KeyWord name="dummy_threading.Timer.setDaemon" />
		<KeyWord name="dummy_threading.Timer.setName" />
		<KeyWord name="dummy_threading.Timer.start" func="yes">
			<Overload retVal="" descr="Start the thread's activity.&#10;&#10;It must be called at most once per thread object. It arranges for the&#10;object's run() method to be invoked in a separate thread of control.&#10;&#10;This method will raise a RuntimeError if called more than once on the&#10;same thread object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.active_count" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.current_thread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.enumerate" func="yes">
			<Overload retVal="" descr="Return a list of all Thread objects currently alive.&#10;&#10;The list includes daemonic threads, dummy thread objects created by&#10;current_thread(), and the main thread. It excludes terminated threads and&#10;threads that have not yet been started.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.get_ident" func="yes">
			<Overload retVal="" descr="Dummy implementation of _thread.get_ident().&#10;&#10;Since this module should only be used when _threadmodule is not&#10;available, it is safe to assume that the current process is the&#10;only thread.  Thus a constant can be safely returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.local" />
		<KeyWord name="dummy_threading.main_thread" func="yes">
			<Overload retVal="" descr="Return the main thread object.&#10;&#10;In normal conditions, the main thread is the thread from which the&#10;Python interpreter was started.">
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.setprofile" func="yes">
			<Overload retVal="" descr="Set a profile function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.setprofile() for each thread, before its&#10;run() method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.settrace" func="yes">
			<Overload retVal="" descr="Set a trace function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.settrace() for each thread, before its run()&#10;method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="dummy_threading.stack_size" func="yes">
			<Overload retVal="" descr="Dummy implementation of _thread.stack_size().">
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="dump" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="dump_option_dicts" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="dump_options" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="dump_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="dumps" func="yes">
			<Overload retVal="" descr="Function of json">
			</Overload>
		</KeyWord>
		<KeyWord name="dup" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="dup2" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
        		<KeyWord name="east_asian_width" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="easy_install" func="yes">
			<Overload retVal="" descr="Run the EasyInstall command">
			</Overload>
		</KeyWord>
		<KeyWord name="effective" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="egg_name" func="yes">
			<Overload retVal="" descr="Function of pip.FrozenRequirement">
			</Overload>
		</KeyWord>
		<KeyWord name="ehlo" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="ehlo_or_helo_if_needed" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="elements" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="elif" />
		<KeyWord name="else" />
		<KeyWord name="email" func="yes">
			<Overload retVal="" descr="A package for parsing, handling, and generating email messages.">
			</Overload>
		</KeyWord>
		<KeyWord name="email.message_from_binary_file" func="yes">
			<Overload retVal="" descr="Read a binary file and parse its contents into a Message object model.&#10;&#10;Optional _class and strict are passed to the Parser constructor.">
				<Param name="fp" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="email.message_from_bytes" func="yes">
			<Overload retVal="" descr="Parse a bytes string into a Message object model.&#10;&#10;Optional _class and strict are passed to the Parser constructor.">
				<Param name="s" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="email.message_from_file" func="yes">
			<Overload retVal="" descr="Read a file and parse its contents into a Message object model.&#10;&#10;Optional _class and strict are passed to the Parser constructor.">
				<Param name="fp" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="email.message_from_string" func="yes">
			<Overload retVal="" descr="Parse a string into a Message object model.&#10;&#10;Optional _class and strict are passed to the Parser constructor.">
				<Param name="s" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="emit" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="empty" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="emptyline" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="enable" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_callback_tracebacks" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_interspersed_args" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_load_extension" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="enable_shared_cache" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="enablerlcompleter" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="encode" func="yes">
			<Overload retVal="" descr="S.encode(encoding='utf-8', errors='strict') -&gt; bytes&#10;&#10;Encode S using the codec registered for encoding. Default encoding&#10;is 'utf-8'. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="encode_base64" func="yes">
			<Overload retVal="" descr="Function of smtplib">
			</Overload>
		</KeyWord>
		<KeyWord name="encode_long" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="encodebytes" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="encodestring" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings" func="yes">
			<Overload retVal="" descr="Standard &quot;encodings&quot; Package&#10;&#10;    Standard Python encoding modules are stored in this package&#10;    directory.&#10;&#10;    Codec modules must have names corresponding to normalized encoding&#10;    names as defined in the normalize_encoding() function below, e.g.&#10;    'utf-8' must be implemented by the module 'utf_8.py'.&#10;&#10;    Each codec module must export the following interface:&#10;&#10;    * getregentry() -&gt; codecs.CodecInfo object&#10;    The getregentry() API must return a CodecInfo object with encoder, decoder,&#10;    incrementalencoder, incrementaldecoder, streamwriter and streamreader&#10;    atttributes which adhere to the Python Codec Interface Standard.&#10;&#10;    In addition, a module may optionally also define the following&#10;    APIs which are then used by the package's codec search function:&#10;&#10;    * getaliases() -&gt; sequence of encoding name strings to use as aliases&#10;&#10;    Alias names returned by getaliases() must be normalized encoding&#10;    names as defined by normalize_encoding().&#10;&#10;Written by Marc-Andre Lemburg (mal@lemburg.com).&#10;&#10;(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.CodecRegistryError" func="yes">
			<Overload retVal="" descr="Base class for lookup errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.CodecRegistryError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.CodecRegistryError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.normalize_encoding" func="yes">
			<Overload retVal="" descr="Normalize an encoding name.&#10;&#10;Normalization works as follows: all non-alphanumeric&#10;characters except the dot used for Python package names are&#10;collapsed and replaced with a single underscore, e.g. '  -;#'&#10;becomes '_'. Leading and trailing underscores are removed.&#10;&#10;Note that encoding names should be ASCII only; if they do use&#10;non-ASCII characters, these must be Latin-1 compatible.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="encodings.search_function" />
		<KeyWord name="end_paragraph" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="end_section" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_directories" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_directory" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_dirname" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_filename" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_finalized" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_fromlist" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_future" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_string" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_string_list" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="ensure_value" func="yes">
			<Overload retVal="" descr="Function of optparse.Values">
			</Overload>
		</KeyWord>
		<KeyWord name="ensurepip" />
		<KeyWord name="ensurepip.bootstrap" func="yes">
			<Overload retVal="" descr="Bootstrap pip into the current Python installation (or the given root&#10;directory).&#10;&#10;Note that calling this function will alter both sys.path and os.environ.">
			</Overload>
		</KeyWord>
		<KeyWord name="ensurepip.version" func="yes">
			<Overload retVal="" descr="Returns a string specifying the bundled version of pip.">
			</Overload>
		</KeyWord>
		<KeyWord name="enter" func="yes">
			<Overload retVal="" descr="Function of sched.scheduler">
			</Overload>
		</KeyWord>
		<KeyWord name="enterabs" func="yes">
			<Overload retVal="" descr="Function of sched.scheduler">
			</Overload>
		</KeyWord>
		<KeyWord name="enum" />
		<KeyWord name="enum.DynamicClassAttribute" func="yes">
			<Overload retVal="" descr="Route attribute access on a class to __getattr__.&#10;&#10;This is a descriptor, used to define attributes that act differently when&#10;accessed through an instance and through a class.  Instance access remains&#10;normal, but access to an attribute through a class will be routed to the&#10;class's __getattr__ method; this is done by raising AttributeError.&#10;&#10;This allows one to have properties active on an instance, and have virtual&#10;attributes on the class with the same name (see Enum for an example).">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.DynamicClassAttribute.deleter" />
		<KeyWord name="enum.DynamicClassAttribute.getter" />
		<KeyWord name="enum.DynamicClassAttribute.setter" />
		<KeyWord name="enum.Enum" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.EnumMeta" func="yes">
			<Overload retVal="" descr="Metaclass for Enum">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.EnumMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.Flag" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.IntEnum" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.IntFlag" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.MappingProxyType" />
		<KeyWord name="enum.MappingProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.MappingProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.MappingProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.MappingProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.MappingProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict" func="yes">
			<Overload retVal="" descr="Dictionary that remembers insertion order">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.clear" func="yes">
			<Overload retVal="" descr="od.clear() -&gt; None.  Remove all items from od.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.copy" func="yes">
			<Overload retVal="" descr="od.copy() -&gt; a shallow copy of od">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.fromkeys" func="yes">
			<Overload retVal="" descr="OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.&#10;If not specified, the value defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.move_to_end" func="yes">
			<Overload retVal="" descr="Move an existing element to the end (or beginning if last==False).&#10;&#10;Raises KeyError if the element does not exist.&#10;When last=True, acts like a fast version of self[key]=self.pop(key).">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.pop" func="yes">
			<Overload retVal="" descr="od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding&#10;value.  If key is not found, d is returned if given, otherwise KeyError&#10;is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.popitem" func="yes">
			<Overload retVal="" descr="Remove and return a (key, value) pair from the dictionary.&#10;&#10;Pairs are returned in LIFO order if last is true or FIFO order if false.">
				<Param name="self" />
				<Param name="[last=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.setdefault" func="yes">
			<Overload retVal="" descr="od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.OrderedDict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.auto" func="yes">
			<Overload retVal="" descr="Instances are replaced with an appropriate value in Enum class suites.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.auto.value" func="yes">
			<Overload retVal="" descr="(object)">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.reduce" func="yes">
			<Overload retVal="" descr="reduce(function, sequence[, initial]) -&gt; value&#10;&#10;Apply a function of two arguments cumulatively to the items of a sequence,&#10;from left to right, so as to reduce the sequence to a single value.&#10;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#10;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#10;of the sequence in the calculation, and serves as a default when the&#10;sequence is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="enum.unique" func="yes">
			<Overload retVal="" descr="Class decorator for enumerations ensuring unique member values.">
				<Param name="enumeration" />
			</Overload>
		</KeyWord>
		<KeyWord name="enum_certificates" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="enum_crls" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="enumerate" func="yes">
			<Overload retVal="" descr="enumerate(iterable[, start]) -&gt; iterator for index, value of iterable&#10;&#10;Return an enumerate object.  iterable must be another object that supports&#10;iteration.  The enumerate object yields pairs containing a count (from&#10;start, which defaults to zero) and a value yielded by the iterable argument.&#10;enumerate is useful for obtaining an indexed list:&#10;    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...">
			</Overload>
		</KeyWord>
		<KeyWord name="eof_received" func="yes">
			<Overload retVal="" descr="Function of asyncio.Protocol">
			</Overload>
		</KeyWord>
		<KeyWord name="eq" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="equal" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="error" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="error_leader" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="error_perm" func="yes">
			<Overload retVal="" descr="Function of ftplib.error_perm">
			</Overload>
		</KeyWord>
		<KeyWord name="error_proto" func="yes">
			<Overload retVal="" descr="Function of ftplib.error_proto">
			</Overload>
		</KeyWord>
		<KeyWord name="error_received" func="yes">
			<Overload retVal="" descr="Function of asyncio.DatagramProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="error_reply" func="yes">
			<Overload retVal="" descr="Function of ftplib.error_reply">
			</Overload>
		</KeyWord>
		<KeyWord name="error_temp" func="yes">
			<Overload retVal="" descr="Function of ftplib.error_temp">
			</Overload>
		</KeyWord>
		<KeyWord name="errprint" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="escape" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="escape_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="escape_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="eval" func="yes">
			<Overload retVal="" descr="Evaluate the given source in the context of globals and locals.&#10;&#10;The source may be a string representing a Python expression&#10;or a code object as returned by compile().&#10;The globals must be a dictionary and locals can be any mapping,&#10;defaulting to the current globals and locals.&#10;If only globals is given, locals defaults to it.">
				<Param name="source" />
				<Param name="globals" />
				<Param name="locals" />
			</Overload>
		</KeyWord>
		<KeyWord name="eval_print_amount" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="evaluate_marker" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="event" func="yes">
			<Overload retVal="" descr="Function of msilib.Control">
			</Overload>
		</KeyWord>
		<KeyWord name="except" />
		<KeyWord name="exception" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="exclude" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="exclude_from" func="yes">
			<Overload retVal="" descr="Function of setuptools.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="exclude_package" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="exec" func="yes">
			<Overload retVal="" descr="Execute the given source in the context of globals and locals.&#10;&#10;The source may be a string representing one or more Python statements&#10;or a code object as returned by compile().&#10;The globals must be a dictionary and locals can be any mapping,&#10;defaulting to the current globals and locals.&#10;If only globals is given, locals defaults to it.">
				<Param name="source" />
				<Param name="globals" />
				<Param name="locals" />
			</Overload>
		</KeyWord>
		<KeyWord name="execRcLines" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="exec_module" func="yes">
			<Overload retVal="" descr="Function of imp.SourcelessFileLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="execl" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execle" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execlp" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execlpe" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execsitecustomize" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="execusercustomize" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="execute" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="executemany" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="executescript" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="execv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execve" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execvp" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="execvpe" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="exists" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="exit" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="exp" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="expand_default" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="expand_prog_name" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="expand_template" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs(tabsize=8) -&gt; str&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="expanduser" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="expandvars" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="expect" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="expectedFailure" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="expn" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="expovariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="expunge" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="extend_path" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="extendleft" func="yes">
			<Overload retVal="" descr="Function of asynchat.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="extract" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="extract_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="extract_tb" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="extractall" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="extractfile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="extraction_error" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
        		<KeyWord name="f8" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="fail" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failIf" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failIfAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failIfEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnless" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnlessEqual" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="failUnlessRaises" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="fallback_getpass" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="fatal" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="fdopen" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="feature_is_included" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="feed" func="yes">
			<Overload retVal="" descr="Function of cgi.FeedParser">
			</Overload>
		</KeyWord>
		<KeyWord name="feed_data" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="feed_eof" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="fetch" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="fetch_build_egg" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="fetch_build_eggs" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="fetchall" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="fetchmany" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="fetchone" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="field_size_limit" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="file_module_function_of" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="file_ns_handler" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp" func="yes">
			<Overload retVal="" descr="Utilities for comparing files and directories.&#10;&#10;Classes:&#10;    dircmp&#10;&#10;Functions:&#10;    cmp(f1, f2, shallow=True) -&gt; int&#10;    cmpfiles(a, b, common) -&gt; ([], [], [])&#10;    clear_cache()">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.BUFSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.DEFAULT_IGNORES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.clear_cache" func="yes">
			<Overload retVal="" descr="Clear the filecmp cache.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.cmp" func="yes">
			<Overload retVal="" descr="Compare two files.&#10;&#10;Arguments:&#10;&#10;f1 -- First file name&#10;&#10;f2 -- Second file name&#10;&#10;shallow -- Just check stat signature (do not read the files).&#10;           defaults to True.&#10;&#10;Return value:&#10;&#10;True if the files are the same, False otherwise.&#10;&#10;This function uses a cache for past comparisons and the results,&#10;with cache entries invalidated if their stat information&#10;changes.  The cache may be cleared by calling clear_cache().">
				<Param name="f1" />
				<Param name="f2" />
				<Param name="[shallow=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.cmpfiles" func="yes">
			<Overload retVal="" descr="Compare common files in two directories.&#10;&#10;a, b -- directory names&#10;common -- list of file names found in both directories&#10;shallow -- if true, do comparison based solely on stat() information&#10;&#10;Returns a tuple of three lists:&#10;  files that compare equal&#10;  files that are different&#10;  filenames that aren't regular files.">
				<Param name="a" />
				<Param name="b" />
				<Param name="common" />
				<Param name="[shallow=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.demo" />
		<KeyWord name="filecmp.dircmp" func="yes">
			<Overload retVal="" descr="A class that manages the comparison of 2 directories.&#10;&#10;dircmp(a, b, ignore=None, hide=None)&#10;  A and B are directories.&#10;  IGNORE is a list of names to ignore,&#10;    defaults to DEFAULT_IGNORES.&#10;  HIDE is a list of names to hide,&#10;    defaults to [os.curdir, os.pardir].&#10;&#10;High level usage:&#10;  x = dircmp(dir1, dir2)&#10;  x.report() -&gt; prints a report on the differences between dir1 and dir2&#10;   or&#10;  x.report_partial_closure() -&gt; prints report on differences between dir1&#10;        and dir2, and reports on common immediate subdirectories.&#10;  x.report_full_closure() -&gt; like report_partial_closure,&#10;        but fully recursive.&#10;&#10;Attributes:&#10; left_list, right_list: The files in dir1 and dir2,&#10;    filtered by hide and ignore.&#10; common: a list of names in both dir1 and dir2.&#10; left_only, right_only: names only in dir1, dir2.&#10; common_dirs: subdirectories in both dir1 and dir2.&#10; common_files: files in both dir1 and dir2.&#10; common_funny: names in both dir1 and dir2 where the type differs between&#10;    dir1 and dir2, or the name is not stat-able.&#10; same_files: list of identical files.&#10; diff_files: list of filenames which differ.&#10; funny_files: list of files which could not be compared.&#10; subdirs: a dictionary of dircmp objects, keyed by names in common_dirs.">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.dircmp.methodmap" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="filecmp.dircmp.phase0" />
		<KeyWord name="filecmp.dircmp.phase1" />
		<KeyWord name="filecmp.dircmp.phase2" />
		<KeyWord name="filecmp.dircmp.phase3" />
		<KeyWord name="filecmp.dircmp.phase4" />
		<KeyWord name="filecmp.dircmp.phase4_closure" />
		<KeyWord name="filecmp.dircmp.report" />
		<KeyWord name="filecmp.dircmp.report_full_closure" />
		<KeyWord name="filecmp.dircmp.report_partial_closure" />
		<KeyWord name="filecmp.filterfalse" func="yes">
			<Overload retVal="" descr="filterfalse(function or None, sequence) --&gt; filterfalse object&#10;&#10;Return those items of sequence for which function(item) is false.&#10;If function is None, return the items that are false.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput" func="yes">
			<Overload retVal="" descr="Helper class to quickly write a loop over all standard input files.&#10;&#10;Typical use is:&#10;&#10;    import fileinput&#10;    for line in fileinput.input():&#10;        process(line)&#10;&#10;This iterates over the lines of all files listed in sys.argv[1:],&#10;defaulting to sys.stdin if the list is empty.  If a filename is '-' it&#10;is also replaced by sys.stdin.  To specify an alternative list of&#10;filenames, pass it as the argument to input().  A single file name is&#10;also allowed.&#10;&#10;Functions filename(), lineno() return the filename and cumulative line&#10;number of the line that has just been read; filelineno() returns its&#10;line number in the current file; isfirstline() returns true iff the&#10;line just read is the first line of its file; isstdin() returns true&#10;iff the line was read from sys.stdin.  Function nextfile() closes the&#10;current file so that the next iteration will read the first line from&#10;the next file (if any); lines not read from the file will not count&#10;towards the cumulative line count; the filename is not changed until&#10;after the first line of the next file has been read.  Function close()&#10;closes the sequence.&#10;&#10;Before any lines have been read, filename() returns None and both line&#10;numbers are zero; nextfile() has no effect.  After all lines have been&#10;read, filename() and the line number functions return the values&#10;pertaining to the last line read; nextfile() has no effect.&#10;&#10;All files are opened in text mode by default, you can override this by&#10;setting the mode parameter to input() or FileInput.__init__().&#10;If an I/O error occurs during opening or reading a file, the OSError&#10;exception is raised.&#10;&#10;If sys.stdin is used more than once, the second and further use will&#10;return no lines, except perhaps for interactive use, or if it has been&#10;explicitly reset (e.g. using sys.stdin.seek(0)).&#10;&#10;Empty files are opened and immediately closed; the only time their&#10;presence in the list of filenames is noticeable at all is when the&#10;last file opened is empty.&#10;&#10;It is possible that the last line of a file doesn't end in a newline&#10;character; otherwise lines are returned including the trailing&#10;newline.&#10;&#10;Class FileInput is the implementation; its methods filename(),&#10;lineno(), fileline(), isfirstline(), isstdin(), nextfile() and close()&#10;correspond to the functions in the module.  In addition it has a&#10;readline() method which returns the next input line, and a&#10;__getitem__() method which implements the sequence behavior.  The&#10;sequence must be accessed in strictly sequential order; sequence&#10;access and readline() cannot be mixed.&#10;&#10;Optional in-place filtering: if the keyword argument inplace=1 is&#10;passed to input() or to the FileInput constructor, the file is moved&#10;to a backup file and standard output is directed to the input file.&#10;This makes it possible to write a filter that rewrites its input file&#10;in place.  If the keyword argument backup=&quot;.&lt;some extension&gt;&quot; is also&#10;given, it specifies the extension for the backup file, and the backup&#10;file remains around; by default, the extension is &quot;.bak&quot; and it is&#10;deleted when the output file is closed.  In-place filtering is&#10;disabled when standard input is read.  XXX The current implementation&#10;does not work for MS-DOS 8+3 filesystems.&#10;&#10;XXX Possible additions:&#10;&#10;- optional getopt argument processing&#10;- isatty()&#10;- read(), read(size), even readlines()">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.FileInput" func="yes">
			<Overload retVal="" descr="FileInput([files[, inplace[, backup[, bufsize, [, mode[, openhook]]]]]])&#10;&#10;Class FileInput is the implementation of the module; its methods&#10;filename(), lineno(), fileline(), isfirstline(), isstdin(), fileno(),&#10;nextfile() and close() correspond to the functions of the same name&#10;in the module.&#10;In addition it has a readline() method which returns the next&#10;input line, and a __getitem__() method which implements the&#10;sequence behavior. The sequence must be accessed in strictly&#10;sequential order; random access and readline() cannot be mixed.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.FileInput.close" />
		<KeyWord name="fileinput.FileInput.filelineno" />
		<KeyWord name="fileinput.FileInput.filename" />
		<KeyWord name="fileinput.FileInput.fileno" />
		<KeyWord name="fileinput.FileInput.isfirstline" />
		<KeyWord name="fileinput.FileInput.isstdin" />
		<KeyWord name="fileinput.FileInput.lineno" />
		<KeyWord name="fileinput.FileInput.nextfile" />
		<KeyWord name="fileinput.FileInput.readline" />
		<KeyWord name="fileinput.close" func="yes">
			<Overload retVal="" descr="Close the sequence.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.filelineno" func="yes">
			<Overload retVal="" descr="Return the line number in the current file. Before the first line&#10;has been read, returns 0. After the last line of the last file has&#10;been read, returns the line number of that line within the file.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.filename" func="yes">
			<Overload retVal="" descr="Return the name of the file currently being read.&#10;Before the first line has been read, returns None.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.fileno" func="yes">
			<Overload retVal="" descr="Return the file number of the current file. When no file is currently&#10;opened, returns -1.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.hook_compressed" />
		<KeyWord name="fileinput.hook_encoded" func="yes">
			<Overload retVal="" descr=>
				<Param name="encoding" />
				<Param name="[errors=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.input" func="yes">
			<Overload retVal="" descr="Return an instance of the FileInput class, which can be iterated.&#10;&#10;The parameters are passed to the constructor of the FileInput class.&#10;The returned instance, in addition to being an iterator,&#10;keeps global state for the functions of this module,.">
				<Param name="[files=None" />
				<Param name="[inplace=False" />
				<Param name="[backup" />
				<Param name="[bufsize=0" />
				<Param name="[mode=r" />
				<Param name="[openhook=None]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.isfirstline" func="yes">
			<Overload retVal="" descr="Returns true the line just read is the first line of its file,&#10;otherwise returns false.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.isstdin" func="yes">
			<Overload retVal="" descr="Returns true if the last line was read from sys.stdin,&#10;otherwise returns false.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.lineno" func="yes">
			<Overload retVal="" descr="Return the cumulative line number of the line that has just been read.&#10;Before the first line has been read, returns 0. After the last line&#10;of the last file has been read, returns the line number of that line.">
			</Overload>
		</KeyWord>
		<KeyWord name="fileinput.nextfile" func="yes">
			<Overload retVal="" descr="Close the current file so that the next iteration will read the first&#10;line from the next file (if any); lines not read from the file will&#10;not count towards the cumulative line count. The filename is not&#10;changed until after the first line of the next file has been read.&#10;Before the first line has been read, this function has no effect;&#10;it cannot be used to skip the first file. After the last line of the&#10;last file has been read, this function has no effect.">
			</Overload>
		</KeyWord>
		<KeyWord name="filelineno" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="filelink" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="filemode" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="filename" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="fileno" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="fill" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="fill_rawq" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="filter" func="yes">
			<Overload retVal="" descr="filter(function or None, iterable) --&gt; filter object&#10;&#10;Return an iterator yielding those items of iterable for which function(item)&#10;is true. If function is None, return the items that are true.">
			</Overload>
		</KeyWord>
		<KeyWord name="filter_traces" func="yes">
			<Overload retVal="" descr="Function of tracemalloc.Snapshot">
			</Overload>
		</KeyWord>
		<KeyWord name="filterwarnings" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="finalize" func="yes">
			<Overload retVal="" descr="Function of weakref.finalize">
			</Overload>
		</KeyWord>
		<KeyWord name="finalize_options" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="finally" />
		<KeyWord name="find" func="yes">
			<Overload retVal="" descr="S.find(sub[, start[, end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="findCaller" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="findTestCases" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="find_all_submodules" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="find_class" func="yes">
			<Overload retVal="" descr="Function of pickle.Unpickler">
			</Overload>
		</KeyWord>
		<KeyWord name="find_config_files" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="find_distributions" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="find_eggs_in_zip" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="find_function" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="find_head_package" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="find_loader" func="yes">
			<Overload retVal="" descr="Function of importlib">
			</Overload>
		</KeyWord>
		<KeyWord name="find_longest_match" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="find_module" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="find_nothing" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="find_on_path" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="find_packages" func="yes">
			<Overload retVal="" descr="Function of setuptools">
			</Overload>
		</KeyWord>
		<KeyWord name="find_plugins" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.WorkingSet">
			</Overload>
		</KeyWord>
		<KeyWord name="find_prefix_at_end" func="yes">
			<Overload retVal="" descr="Function of asynchat">
			</Overload>
		</KeyWord>
		<KeyWord name="findall" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="finditer" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="findlabels" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="findlinestarts" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="findmatch" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="findparam" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="findsource" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="finish" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseRequestHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="finish_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="firstweekday" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="fix_flags" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="fix_missing_locations" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="fixup_namespace_packages" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="float" func="yes">
			<Overload retVal="" descr="float(x) -&gt; floating point number&#10;&#10;Convert a string or number to a floating point number, if possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="floordiv" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="flush" func="yes">
			<Overload retVal="" descr="Function of bz2.BZ2Compressor">
			</Overload>
		</KeyWord>
		<KeyWord name="flush_softspace" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="fma" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch" func="yes">
			<Overload retVal="" descr="Filename matching with shell patterns.&#10;&#10;fnmatch(FILENAME, PATTERN) matches according to the local convention.&#10;fnmatchcase(FILENAME, PATTERN) always takes case in account.&#10;&#10;The functions operate by translating the pattern into a regular&#10;expression.  They cache the compiled regular expressions for speed.&#10;&#10;The function translate(PATTERN) returns a regular expression&#10;corresponding to PATTERN.  (It does not compile it.)">
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.filter" func="yes">
			<Overload retVal="" descr="Return the subset of the list NAMES that match PAT.">
				<Param name="names" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.fnmatch" func="yes">
			<Overload retVal="" descr="Test whether FILENAME matches PATTERN.&#10;&#10;Patterns are Unix shell style:&#10;&#10;*       matches everything&#10;?       matches any single character&#10;[seq]   matches any character in seq&#10;[!seq]  matches any char not in seq&#10;&#10;An initial period in FILENAME is not special.&#10;Both FILENAME and PATTERN are first case-normalized&#10;if the operating system requires it.&#10;If you don't want this, use fnmatchcase(FILENAME, PATTERN).">
				<Param name="name" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.fnmatchcase" func="yes">
			<Overload retVal="" descr="Test whether FILENAME matches PATTERN, including case.&#10;&#10;This is a version of fnmatch() which doesn't case-normalize&#10;its arguments.">
				<Param name="name" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatch.translate" func="yes">
			<Overload retVal="" descr="Translate a shell PATTERN to a regular expression.&#10;&#10;There is no way to quote meta-characters.">
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="fnmatchcase" func="yes">
			<Overload retVal="" descr="Function of fnmatch">
			</Overload>
		</KeyWord>
		<KeyWord name="foo" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="for" />
		<KeyWord name="forget" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; str&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="formatException" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatFooter" func="yes">
			<Overload retVal="" descr="Function of logging.BufferingFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatHeader" func="yes">
			<Overload retVal="" descr="Function of logging.BufferingFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatMessage" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatStack" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="formatTime" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_counter" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_description" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_epilog" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_exc" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_exception" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_exception_only" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="format_failure" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="format_field" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_heading" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_help" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_letter" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_list" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_map" func="yes">
			<Overload retVal="" descr="S.format_map(mapping) -&gt; str&#10;&#10;Return a formatted version of S, using substitutions from mapping.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="format_option" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_option_help" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="format_option_strings" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_roman" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="format_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_stack_entry" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="format_string" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="format_tb" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="format_usage" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="format_witnesses" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="formatannotation" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="formatannotationrelativeto" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="formatargspec" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="formatargvalues" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="formatday" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatmonth" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatmonthname" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatstring" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter" func="yes">
			<Overload retVal="" descr="Generic output formatting.&#10;&#10;Formatter objects transform an abstract flow of formatting events into&#10;specific output events on writer objects. Formatters manage several stack&#10;structures to allow various properties of a writer object to be changed and&#10;restored; writers need not be able to handle relative changes nor any sort&#10;of ``change back'' operation. Specific writer properties which may be&#10;controlled via formatter objects are horizontal alignment, font, and left&#10;margin indentations. A mechanism is provided which supports providing&#10;arbitrary, non-exclusive style settings to a writer as well. Additional&#10;interfaces facilitate formatting events which are not reversible, such as&#10;paragraph separation.&#10;&#10;Writer objects encapsulate device interfaces. Abstract devices, such as&#10;file formats, are supported as well as physical devices. The provided&#10;implementations all work with abstract devices. The interface makes&#10;available mechanisms for setting the properties which formatter objects&#10;manage and inserting data into the output.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter" func="yes">
			<Overload retVal="" descr="The standard formatter.&#10;&#10;This implementation has demonstrated wide applicability to many writers,&#10;and may be used directly in most circumstances.  It has been used to&#10;implement a full-featured World Wide Web browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter.add_flowing_data" />
		<KeyWord name="formatter.AbstractFormatter.add_hor_rule" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter.add_label_data" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="format" />
				<Param name="counter" />
				<Param name="[blankline=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter.add_line_break" />
		<KeyWord name="formatter.AbstractFormatter.add_literal_data" />
		<KeyWord name="formatter.AbstractFormatter.assert_line_data" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[flag=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter.end_paragraph" />
		<KeyWord name="formatter.AbstractFormatter.flush_softspace" />
		<KeyWord name="formatter.AbstractFormatter.format_counter" />
		<KeyWord name="formatter.AbstractFormatter.format_letter" />
		<KeyWord name="formatter.AbstractFormatter.format_roman" />
		<KeyWord name="formatter.AbstractFormatter.pop_alignment" />
		<KeyWord name="formatter.AbstractFormatter.pop_font" />
		<KeyWord name="formatter.AbstractFormatter.pop_margin" />
		<KeyWord name="formatter.AbstractFormatter.pop_style" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractFormatter.push_alignment" />
		<KeyWord name="formatter.AbstractFormatter.push_font" />
		<KeyWord name="formatter.AbstractFormatter.push_margin" />
		<KeyWord name="formatter.AbstractFormatter.push_style" />
		<KeyWord name="formatter.AbstractFormatter.set_spacing" />
		<KeyWord name="formatter.AbstractWriter" func="yes">
			<Overload retVal="" descr="A writer which can be used in debugging formatters, but not much else.&#10;&#10;Each method simply announces itself by printing its name and&#10;arguments on standard output.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractWriter.flush" />
		<KeyWord name="formatter.AbstractWriter.new_alignment" />
		<KeyWord name="formatter.AbstractWriter.new_font" />
		<KeyWord name="formatter.AbstractWriter.new_margin" />
		<KeyWord name="formatter.AbstractWriter.new_spacing" />
		<KeyWord name="formatter.AbstractWriter.new_styles" />
		<KeyWord name="formatter.AbstractWriter.send_flowing_data" />
		<KeyWord name="formatter.AbstractWriter.send_hor_rule" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.AbstractWriter.send_label_data" />
		<KeyWord name="formatter.AbstractWriter.send_line_break" />
		<KeyWord name="formatter.AbstractWriter.send_literal_data" />
		<KeyWord name="formatter.AbstractWriter.send_paragraph" />
		<KeyWord name="formatter.DumbWriter" func="yes">
			<Overload retVal="" descr="Simple writer class which writes output on the file object passed in&#10;as the file parameter or, if file is omitted, on standard output.  The&#10;output is simply word-wrapped to the number of columns specified by&#10;the maxcol parameter.  This class is suitable for reflowing a sequence&#10;of paragraphs.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.DumbWriter.flush" />
		<KeyWord name="formatter.DumbWriter.new_alignment" />
		<KeyWord name="formatter.DumbWriter.new_font" />
		<KeyWord name="formatter.DumbWriter.new_margin" />
		<KeyWord name="formatter.DumbWriter.new_spacing" />
		<KeyWord name="formatter.DumbWriter.new_styles" />
		<KeyWord name="formatter.DumbWriter.reset" />
		<KeyWord name="formatter.DumbWriter.send_flowing_data" />
		<KeyWord name="formatter.DumbWriter.send_hor_rule" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.DumbWriter.send_label_data" />
		<KeyWord name="formatter.DumbWriter.send_line_break" />
		<KeyWord name="formatter.DumbWriter.send_literal_data" />
		<KeyWord name="formatter.DumbWriter.send_paragraph" />
		<KeyWord name="formatter.NullFormatter" func="yes">
			<Overload retVal="" descr="A formatter which does nothing.&#10;&#10;If the writer parameter is omitted, a NullWriter instance is created.&#10;No methods of the writer are called by NullFormatter instances.&#10;&#10;Implementations should inherit from this class if implementing a writer&#10;interface but don't need to inherit any implementation.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullFormatter.add_flowing_data" />
		<KeyWord name="formatter.NullFormatter.add_hor_rule" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullFormatter.add_label_data" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="format" />
				<Param name="counter" />
				<Param name="[blankline=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullFormatter.add_line_break" />
		<KeyWord name="formatter.NullFormatter.add_literal_data" />
		<KeyWord name="formatter.NullFormatter.assert_line_data" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[flag=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullFormatter.end_paragraph" />
		<KeyWord name="formatter.NullFormatter.flush_softspace" />
		<KeyWord name="formatter.NullFormatter.pop_alignment" />
		<KeyWord name="formatter.NullFormatter.pop_font" />
		<KeyWord name="formatter.NullFormatter.pop_margin" />
		<KeyWord name="formatter.NullFormatter.pop_style" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullFormatter.push_alignment" />
		<KeyWord name="formatter.NullFormatter.push_font" />
		<KeyWord name="formatter.NullFormatter.push_margin" />
		<KeyWord name="formatter.NullFormatter.push_style" />
		<KeyWord name="formatter.NullFormatter.set_spacing" />
		<KeyWord name="formatter.NullWriter" func="yes">
			<Overload retVal="" descr="Minimal writer interface to use in testing &amp; inheritance.&#10;&#10;A writer which only provides the interface definition; no actions are&#10;taken on any methods.  This should be the base class for all writers&#10;which do not need to inherit any implementation methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullWriter.flush" />
		<KeyWord name="formatter.NullWriter.new_alignment" />
		<KeyWord name="formatter.NullWriter.new_font" />
		<KeyWord name="formatter.NullWriter.new_margin" />
		<KeyWord name="formatter.NullWriter.new_spacing" />
		<KeyWord name="formatter.NullWriter.new_styles" />
		<KeyWord name="formatter.NullWriter.send_flowing_data" />
		<KeyWord name="formatter.NullWriter.send_hor_rule" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formatter.NullWriter.send_label_data" />
		<KeyWord name="formatter.NullWriter.send_line_break" />
		<KeyWord name="formatter.NullWriter.send_literal_data" />
		<KeyWord name="formatter.NullWriter.send_paragraph" />
		<KeyWord name="formatter.test" func="yes">
			<Overload retVal="" descr=>
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="formattree" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="formatvalue" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="formatwarning" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="formatweek" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatweekday" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatweekheader" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatyear" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="formatyearpage" func="yes">
			<Overload retVal="" descr="Function of calendar.HTMLCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="found_terminator" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions" func="yes">
			<Overload retVal="" descr="Fraction, infinite-precision, real numbers.">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal" func="yes">
			<Overload retVal="" descr="Construct a new Decimal object. 'value' can be an integer, string, tuple,&#10;or another Decimal object. If no value is given, return Decimal('0'). The&#10;context does not affect the conversion and is only passed to determine if&#10;the InvalidOperation trap is active.">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.adjusted" func="yes">
			<Overload retVal="" descr="Return the adjusted exponent of the number.  Defined as exp + digits - 1.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.as_integer_ratio" func="yes">
			<Overload retVal="" descr="Decimal.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;Decimal and with a positive denominator. The ratio is in lowest terms.&#10;Raise OverflowError on infinities and a ValueError on NaNs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.as_tuple" func="yes">
			<Overload retVal="" descr="Return a tuple representation of the number.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.canonical" func="yes">
			<Overload retVal="" descr="Return the canonical encoding of the argument.  Currently, the encoding&#10;of a Decimal instance is always canonical, so this operation returns its&#10;argument unchanged.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare" func="yes">
			<Overload retVal="" descr="Compare self to other.  Return a decimal value:&#10;&#10;a or b is a NaN ==&gt; Decimal('NaN')&#10;a &lt; b           ==&gt; Decimal('-1')&#10;a == b          ==&gt; Decimal('0')&#10;a &gt; b           ==&gt; Decimal('1')">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare_signal" func="yes">
			<Overload retVal="" descr="Identical to compare, except that all NaNs signal.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare_total" func="yes">
			<Overload retVal="" descr="Compare two operands using their abstract representation rather than&#10;their numerical value.  Similar to the compare() method, but the result&#10;gives a total ordering on Decimal instances.  Two Decimal instances with&#10;the same numeric value but different representations compare unequal&#10;in this ordering:&#10;&#10;    &gt;&gt;&gt; Decimal('12.0').compare_total(Decimal('12'))&#10;    Decimal('-1')&#10;&#10;Quiet and signaling NaNs are also included in the total ordering. The result&#10;of this function is Decimal('0') if both operands have the same representation,&#10;Decimal('-1') if the first operand is lower in the total order than the second,&#10;and Decimal('1') if the first operand is higher in the total order than the&#10;second operand. See the specification for details of the total order.&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compare two operands using their abstract representation rather than their&#10;value as in compare_total(), but ignoring the sign of each operand.&#10;&#10;x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()).&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.conjugate" func="yes">
			<Overload retVal="" descr="Return self.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.copy_abs" func="yes">
			<Overload retVal="" descr="Return the absolute value of the argument.  This operation is unaffected by&#10;context and is quiet: no flags are changed and no rounding is performed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.copy_negate" func="yes">
			<Overload retVal="" descr="Return the negation of the argument.  This operation is unaffected by context&#10;and is quiet: no flags are changed and no rounding is performed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.copy_sign" func="yes">
			<Overload retVal="" descr="Return a copy of the first operand with the sign set to be the same as the&#10;sign of the second operand. For example:&#10;&#10;    &gt;&gt;&gt; Decimal('2.3').copy_sign(Decimal('-1.5'))&#10;    Decimal('-2.3')&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.exp" func="yes">
			<Overload retVal="" descr="Return the value of the (natural) exponential function e**x at the given&#10;number.  The function always uses the ROUND_HALF_EVEN mode and the result&#10;is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.fma" func="yes">
			<Overload retVal="" descr="Fused multiply-add.  Return self*other+third with no rounding of the&#10;intermediate product self*other.&#10;&#10;    &gt;&gt;&gt; Decimal(2).fma(3, 5)&#10;    Decimal('11')">
				<Param name="self" />
				<Param name="other" />
				<Param name="third" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.from_float" func="yes">
			<Overload retVal="" descr="Class method that converts a float to a decimal number, exactly.&#10;Since 0.1 is not exactly representable in binary floating point,&#10;Decimal.from_float(0.1) is not the same as Decimal('0.1').&#10;&#10;    &gt;&gt;&gt; Decimal.from_float(0.1)&#10;    Decimal('0.1000000000000000055511151231257827021181583404541015625')&#10;    &gt;&gt;&gt; Decimal.from_float(float('nan'))&#10;    Decimal('NaN')&#10;    &gt;&gt;&gt; Decimal.from_float(float('inf'))&#10;    Decimal('Infinity')&#10;    &gt;&gt;&gt; Decimal.from_float(float('-inf'))&#10;    Decimal('-Infinity')">
				<Param name="type" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if the argument is canonical and False otherwise.  Currently,&#10;a Decimal instance is always canonical, so this operation always returns&#10;True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_finite" func="yes">
			<Overload retVal="" descr="Return True if the argument is a finite number, and False if the argument&#10;is infinite or a NaN.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if the argument is either positive or negative infinity and&#10;False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_nan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a (quiet or signaling) NaN and False&#10;otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_normal" func="yes">
			<Overload retVal="" descr="Return True if the argument is a normal finite non-zero number with an&#10;adjusted exponent greater than or equal to Emin. Return False if the&#10;argument is zero, subnormal, infinite or a NaN.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a quiet NaN, and False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_signed" func="yes">
			<Overload retVal="" descr="Return True if the argument has a negative sign and False otherwise.&#10;Note that both zeros and NaNs can carry signs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_snan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a signaling NaN and False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if the argument is subnormal, and False otherwise. A number is&#10;subnormal if it is non-zero, finite, and has an adjusted exponent less&#10;than Emin.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.is_zero" func="yes">
			<Overload retVal="" descr="Return True if the argument is a (positive or negative) zero and False&#10;otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.ln" func="yes">
			<Overload retVal="" descr="Return the natural (base e) logarithm of the operand. The function always&#10;uses the ROUND_HALF_EVEN mode and the result is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.log10" func="yes">
			<Overload retVal="" descr="Return the base ten logarithm of the operand. The function always uses the&#10;ROUND_HALF_EVEN mode and the result is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logb" func="yes">
			<Overload retVal="" descr="For a non-zero number, return the adjusted exponent of the operand as a&#10;Decimal instance.  If the operand is a zero, then Decimal('-Infinity') is&#10;returned and the DivisionByZero condition is raised. If the operand is&#10;an infinity then Decimal('Infinity') is returned.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_and" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'and' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_invert" func="yes">
			<Overload retVal="" descr="Return the digit-wise inversion of the (logical) operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_or" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'or' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.logical_xor" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'exclusive or' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.max" func="yes">
			<Overload retVal="" descr="Maximum of self and other.  If one operand is a quiet NaN and the other is&#10;numeric, the numeric operand is returned.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.max_mag" func="yes">
			<Overload retVal="" descr="Similar to the max() method, but the comparison is done using the absolute&#10;values of the operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.min" func="yes">
			<Overload retVal="" descr="Minimum of self and other. If one operand is a quiet NaN and the other is&#10;numeric, the numeric operand is returned.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.min_mag" func="yes">
			<Overload retVal="" descr="Similar to the min() method, but the comparison is done using the absolute&#10;values of the operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.next_minus" func="yes">
			<Overload retVal="" descr="Return the largest number representable in the given context (or in the&#10;current default context if no context is given) that is smaller than the&#10;given operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.next_plus" func="yes">
			<Overload retVal="" descr="Return the smallest number representable in the given context (or in the&#10;current default context if no context is given) that is larger than the&#10;given operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.next_toward" func="yes">
			<Overload retVal="" descr="If the two operands are unequal, return the number closest to the first&#10;operand in the direction of the second operand.  If both operands are&#10;numerically equal, return a copy of the first operand with the sign set&#10;to be the same as the sign of the second operand.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.normalize" func="yes">
			<Overload retVal="" descr="Normalize the number by stripping the rightmost trailing zeros and&#10;converting any result equal to Decimal('0') to Decimal('0e0').  Used&#10;for producing canonical values for members of an equivalence class.&#10;For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize&#10;to the equivalent value Decimal('32.1').">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.number_class" func="yes">
			<Overload retVal="" descr="Return a string describing the class of the operand.  The returned value&#10;is one of the following ten strings:&#10;&#10;    * '-Infinity', indicating that the operand is negative infinity.&#10;    * '-Normal', indicating that the operand is a negative normal number.&#10;    * '-Subnormal', indicating that the operand is negative and subnormal.&#10;    * '-Zero', indicating that the operand is a negative zero.&#10;    * '+Zero', indicating that the operand is a positive zero.&#10;    * '+Subnormal', indicating that the operand is positive and subnormal.&#10;    * '+Normal', indicating that the operand is a positive normal number.&#10;    * '+Infinity', indicating that the operand is positive infinity.&#10;    * 'NaN', indicating that the operand is a quiet NaN (Not a Number).&#10;    * 'sNaN', indicating that the operand is a signaling NaN.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.quantize" func="yes">
			<Overload retVal="" descr="Return a value equal to the first operand after rounding and having the&#10;exponent of the second operand.&#10;&#10;    &gt;&gt;&gt; Decimal('1.41421356').quantize(Decimal('1.000'))&#10;    Decimal('1.414')&#10;&#10;Unlike other operations, if the length of the coefficient after the quantize&#10;operation would be greater than precision, then an InvalidOperation is signaled.&#10;This guarantees that, unless there is an error condition, the quantized exponent&#10;is always equal to that of the right-hand operand.&#10;&#10;Also unlike other operations, quantize never signals Underflow, even if the&#10;result is subnormal and inexact.&#10;&#10;If the exponent of the second operand is larger than that of the first, then&#10;rounding may be necessary. In this case, the rounding mode is determined by the&#10;rounding argument if given, else by the given context argument; if neither&#10;argument is given, the rounding mode of the current thread's context is used.">
				<Param name="self" />
				<Param name="exp" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.radix" func="yes">
			<Overload retVal="" descr="Return Decimal(10), the radix (base) in which the Decimal class does&#10;all its arithmetic. Included for compatibility with the specification.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.remainder_near" func="yes">
			<Overload retVal="" descr="Return the remainder from dividing self by other.  This differs from&#10;self % other in that the sign of the remainder is chosen so as to minimize&#10;its absolute value. More precisely, the return value is self - n * other&#10;where n is the integer nearest to the exact value of self / other, and&#10;if two integers are equally near then the even one is chosen.&#10;&#10;If the result is zero then its sign will be the sign of self.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.rotate" func="yes">
			<Overload retVal="" descr="Return the result of rotating the digits of the first operand by an amount&#10;specified by the second operand.  The second operand must be an integer in&#10;the range -precision through precision. The absolute value of the second&#10;operand gives the number of places to rotate. If the second operand is&#10;positive then rotation is to the left; otherwise rotation is to the right.&#10;The coefficient of the first operand is padded on the left with zeros to&#10;length precision if necessary. The sign and exponent of the first operand are&#10;unchanged.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.same_quantum" func="yes">
			<Overload retVal="" descr="Test whether self and other have the same exponent or whether both are NaN.&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.scaleb" func="yes">
			<Overload retVal="" descr="Return the first operand with the exponent adjusted the second.  Equivalently,&#10;return the first operand multiplied by 10**other. The second operand must be&#10;an integer.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.shift" func="yes">
			<Overload retVal="" descr="Return the result of shifting the digits of the first operand by an amount&#10;specified by the second operand.  The second operand must be an integer in&#10;the range -precision through precision. The absolute value of the second&#10;operand gives the number of places to shift. If the second operand is&#10;positive, then the shift is to the left; otherwise the shift is to the&#10;right. Digits shifted into the coefficient are zeros. The sign and exponent&#10;of the first operand are unchanged.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.sqrt" func="yes">
			<Overload retVal="" descr="Return the square root of the argument to full precision. The result is&#10;correctly rounded using the ROUND_HALF_EVEN rounding mode.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_eng_string" func="yes">
			<Overload retVal="" descr="Convert to an engineering-type string.  Engineering notation has an exponent&#10;which is a multiple of 3, so there are up to 3 digits left of the decimal&#10;place. For example, Decimal('123E+1') is converted to Decimal('1.23E+3').&#10;&#10;The value of context.capitals determines whether the exponent sign is lower&#10;or upper case. Otherwise, the context does not affect the operation.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_integral" func="yes">
			<Overload retVal="" descr="Identical to the to_integral_value() method.  The to_integral() name has been&#10;kept for compatibility with older versions.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_integral_exact" func="yes">
			<Overload retVal="" descr="Round to the nearest integer, signaling Inexact or Rounded as appropriate if&#10;rounding occurs.  The rounding mode is determined by the rounding parameter&#10;if given, else by the given context. If neither parameter is given, then the&#10;rounding mode of the current default context is used.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Decimal.to_integral_value" func="yes">
			<Overload retVal="" descr="Round to the nearest integer without signaling Inexact or Rounded.  The&#10;rounding mode is determined by the rounding parameter if given, else by&#10;the given context. If neither parameter is given, then the rounding mode&#10;of the current default context is used.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.Fraction" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="fractions.gcd" func="yes">
			<Overload retVal="" descr="Calculate the Greatest Common Divisor of a and b.&#10;&#10;Unless b==0, the result will have the same sign as b (so that when&#10;b is divided by it, the result comes out positive).">
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="freeze_support" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="from" />
		<KeyWord name="fromBase64" func="yes">
			<Overload retVal="" descr="Function of plistlib.Data">
			</Overload>
		</KeyWord>
		<KeyWord name="fromFile" func="yes">
			<Overload retVal="" descr="Function of plistlib.Plist">
			</Overload>
		</KeyWord>
		<KeyWord name="from_builtin" func="yes">
			<Overload retVal="" descr="Function of inspect.Signature">
			</Overload>
		</KeyWord>
		<KeyWord name="from_bytes" func="yes">
			<Overload retVal="" descr="int.from_bytes(bytes, byteorder, *, signed=False) -&gt; int&#10;&#10;Return the integer represented by the given array of bytes.&#10;&#10;The bytes argument must be a bytes-like object (e.g. bytes or bytearray).&#10;&#10;The byteorder argument determines the byte order used to represent the&#10;integer.  If byteorder is 'big', the most significant byte is at the&#10;beginning of the byte array.  If byteorder is 'little', the most&#10;significant byte is at the end of the byte array.  To request the native&#10;byte order of the host system, use `sys.byteorder' as the byte order value.&#10;&#10;The signed keyword-only argument indicates whether two's complement is&#10;used to represent the integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="from_callable" func="yes">
			<Overload retVal="" descr="Function of inspect.Signature">
			</Overload>
		</KeyWord>
		<KeyWord name="from_dist" func="yes">
			<Overload retVal="" descr="Function of pip.FrozenRequirement">
			</Overload>
		</KeyWord>
		<KeyWord name="from_exception" func="yes">
			<Overload retVal="" descr="Function of traceback.TracebackException">
			</Overload>
		</KeyWord>
		<KeyWord name="from_file" func="yes">
			<Overload retVal="" descr="Function of zipfile.ZipInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="from_filename" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="from_float" func="yes">
			<Overload retVal="" descr="Function of decimal.Decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="from_function" func="yes">
			<Overload retVal="" descr="Function of inspect.Signature">
			</Overload>
		</KeyWord>
		<KeyWord name="from_iterable" func="yes">
			<Overload retVal="" descr="Function of statistics.chain">
			</Overload>
		</KeyWord>
		<KeyWord name="from_list" func="yes">
			<Overload retVal="" descr="Function of traceback.StackSummary">
			</Overload>
		</KeyWord>
		<KeyWord name="from_location" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="from_traceback" func="yes">
			<Overload retVal="" descr="Function of dis.Bytecode">
			</Overload>
		</KeyWord>
		<KeyWord name="frombuf" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="fromfd" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="fromhex" func="yes">
			<Overload retVal="" descr="float.fromhex(string) -&gt; float&#10;&#10;Create a floating-point number from a hexadecimal string.&#10;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#10;2047.984375&#10;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#10;-5e-324">
			</Overload>
		</KeyWord>
		<KeyWord name="fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="type" />
				<Param name="iterable" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="fromordinal" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="fromshare" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="fromtarfile" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="fromtimestamp" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="fromutc" func="yes">
			<Overload retVal="" descr="Function of datetime.timezone">
			</Overload>
		</KeyWord>
		<KeyWord name="frozenset" func="yes">
			<Overload retVal="" descr="frozenset() -&gt; empty frozenset object&#10;frozenset(iterable) -&gt; frozenset object&#10;&#10;Build an immutable unordered collection of unique elements.">
			</Overload>
		</KeyWord>
		<KeyWord name="fsdecode" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="fsencode" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="fspath" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="fstat" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="fsync" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="ftpcp" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib" func="yes">
			<Overload retVal="" descr="An FTP client class and some helper functions.&#10;&#10;Based on RFC 959: File Transfer Protocol (FTP), by J. Postel and J. Reynolds&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; from ftplib import FTP&#10;&gt;&gt;&gt; ftp = FTP('ftp.python.org') # connect to host, default port&#10;&gt;&gt;&gt; ftp.login() # default, i.e.: user anonymous, passwd anonymous@&#10;'230 Guest login ok, access restrictions apply.'&#10;&gt;&gt;&gt; ftp.retrlines('LIST') # list directory contents&#10;total 9&#10;drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .&#10;drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..&#10;drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin&#10;drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc&#10;d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming&#10;drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib&#10;drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub&#10;drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr&#10;-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg&#10;'226 Transfer complete.'&#10;&gt;&gt;&gt; ftp.quit()&#10;'221 Goodbye.'&#10;&gt;&gt;&gt;&#10;&#10;A nice test that reveals some of the network dialogue would be:&#10;python ftplib.py -d localhost -l -p -l">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.B_CRLF" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP" func="yes">
			<Overload retVal="" descr="An FTP client class.&#10;&#10;To create a connection, call the class using these arguments:&#10;        host, user, passwd, acct, timeout&#10;&#10;The first four arguments are all strings, and have default value ''.&#10;timeout must be numeric and defaults to None if not passed,&#10;meaning that no timeout will be set on any ftp socket(s)&#10;If a timeout is passed, then this is now the default timeout for all ftp&#10;socket operations for this instance.&#10;&#10;Then use self.connect() with optional host and port argument.&#10;&#10;To download a file, use ftp.retrlines('RETR ' + filename),&#10;or ftp.retrbinary() with slightly different arguments.&#10;To upload a file, use ftp.storlines() or ftp.storbinary(),&#10;which have an open file as argument (see their definitions&#10;below for details).&#10;The download/upload functions first issue appropriate TYPE&#10;and PORT or PASV commands.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.abort" func="yes">
			<Overload retVal="" descr="Abort a file transfer.  Uses out-of-band data.&#10;This does not follow the procedure from the RFC to send Telnet&#10;IP and Synch; that doesn't seem to work with the servers I've&#10;tried.  Instead, just send the ABOR command as OOB data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.acct" func="yes">
			<Overload retVal="" descr="Send new account name.">
				<Param name="self" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.close" func="yes">
			<Overload retVal="" descr="Close the connection without assuming anything about it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.connect" func="yes">
			<Overload retVal="" descr="Connect to host.  Arguments are:&#10;- host: hostname to connect to (string, default previous host)&#10;- port: port to connect to (integer, default previous port)&#10;- timeout: the timeout to set against the ftp socket(s)&#10;- source_address: a 2-tuple (host, port) for the socket to bind&#10;  to as its source address before connecting.">
				<Param name="self" />
				<Param name="[host" />
				<Param name="[port=0" />
				<Param name="[timeout=-999" />
				<Param name="[source_address=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.cwd" func="yes">
			<Overload retVal="" descr="Change to a directory.">
				<Param name="self" />
				<Param name="dirname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.debug" func="yes">
			<Overload retVal="" descr="Set the debugging level.&#10;The required argument level means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.delete" func="yes">
			<Overload retVal="" descr="Delete a file.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.dir" func="yes">
			<Overload retVal="" descr="List a directory in long form.&#10;By default list current directory to stdout.&#10;Optional last argument is callback function; all&#10;non-empty arguments before it are concatenated to the&#10;LIST command.  (This *should* only be used for a pathname.)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.getline" />
		<KeyWord name="ftplib.FTP.getmultiline" />
		<KeyWord name="ftplib.FTP.getresp" />
		<KeyWord name="ftplib.FTP.getwelcome" func="yes">
			<Overload retVal="" descr="Get the welcome message from the server.&#10;(this is read and squirreled away by connect())">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.login" func="yes">
			<Overload retVal="" descr="Login, default anonymous.">
				<Param name="self" />
				<Param name="[user" />
				<Param name="[passwd" />
				<Param name="[acct]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.makepasv" />
		<KeyWord name="ftplib.FTP.makeport" func="yes">
			<Overload retVal="" descr="Create a new socket and send a PORT command for it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.maxline" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.mkd" func="yes">
			<Overload retVal="" descr="Make a directory, return its full pathname.">
				<Param name="self" />
				<Param name="dirname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.mlsd" func="yes">
			<Overload retVal="" descr='List a directory in a standardized format by using MLSD&#10;command (RFC-3659). If path is omitted the current directory&#10;is assumed. "facts" is a list of strings representing the type&#10;of information desired (e.g. ["type", "size", "perm"]).&#10;&#10;Return a generator object yielding a tuple of two elements&#10;for every file found in path.&#10;First element is the file name, the second one is a dictionary&#10;including a variable number of "facts" depending on the server&#10;and whether "facts" argument has been provided.'>
				<Param name="self" />
				<Param name="[path" />
				<Param name="[facts=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.nlst" func="yes">
			<Overload retVal="" descr="Return a list of files in a given directory (default the current).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.ntransfercmd" func="yes">
			<Overload retVal="" descr="Initiate a transfer over the data connection.&#10;&#10;If the transfer is active, send a port command and the&#10;transfer command, and accept the connection.  If the server is&#10;passive, send a pasv command, connect to it, and start the&#10;transfer command.  Either way, return the socket for the&#10;connection and the expected size of the transfer.  The&#10;expected size may be None if it could not be determined.&#10;&#10;Optional `rest' argument can be a string that is sent as the&#10;argument to a REST command.  This is essentially a server&#10;marker used to tell the server to skip over any data up to the&#10;given marker.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[rest=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.passiveserver" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.port" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.putcmd" />
		<KeyWord name="ftplib.FTP.putline" />
		<KeyWord name="ftplib.FTP.pwd" func="yes">
			<Overload retVal="" descr="Return current working directory.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.quit" func="yes">
			<Overload retVal="" descr="Quit, and close the connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.rename" func="yes">
			<Overload retVal="" descr="Rename a file.">
				<Param name="self" />
				<Param name="fromname" />
				<Param name="toname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.retrbinary" func="yes">
			<Overload retVal="" descr="Retrieve data in binary mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A RETR command.&#10;  callback: A single parameter callable to be called on each&#10;            block of data read.&#10;  blocksize: The maximum number of bytes to read from the&#10;             socket at one time.  [default: 8192]&#10;  rest: Passed to transfercmd().  [default: None]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="callback" />
				<Param name="[blocksize=8192" />
				<Param name="[rest=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.retrlines" func="yes">
			<Overload retVal="" descr="Retrieve data in line mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A RETR, LIST, or NLST command.&#10;  callback: An optional single parameter callable that is called&#10;            for each line with the trailing CRLF stripped.&#10;            [default: print_line()]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[callback=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.rmd" func="yes">
			<Overload retVal="" descr="Remove a directory.">
				<Param name="self" />
				<Param name="dirname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.sanitize" />
		<KeyWord name="ftplib.FTP.sendcmd" func="yes">
			<Overload retVal="" descr="Send a command and return the response.">
				<Param name="self" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.sendeprt" func="yes">
			<Overload retVal="" descr="Send an EPRT command with the current host and the given port number.">
				<Param name="self" />
				<Param name="host" />
				<Param name="port" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.sendport" func="yes">
			<Overload retVal="" descr="Send a PORT command with the current host and the given&#10;port number.">
				<Param name="self" />
				<Param name="host" />
				<Param name="port" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debugging level.&#10;The required argument level means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.set_pasv" func="yes">
			<Overload retVal="" descr="Use passive or active mode for data transfers.&#10;With a false argument, use the normal PORT mode,&#10;With a true argument, use the PASV command.">
				<Param name="self" />
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.size" func="yes">
			<Overload retVal="" descr="Retrieve the size of a file.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.storbinary" func="yes">
			<Overload retVal="" descr="Store a file in binary mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A STOR command.&#10;  fp: A file-like object with a read(num_bytes) method.&#10;  blocksize: The maximum data size to read from fp and send over&#10;             the connection at once.  [default: 8192]&#10;  callback: An optional single parameter callable that is called on&#10;            each block of data after it is sent.  [default: None]&#10;  rest: Passed to transfercmd().  [default: None]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="fp" />
				<Param name="[blocksize=8192" />
				<Param name="[callback=None" />
				<Param name="[rest=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.storlines" func="yes">
			<Overload retVal="" descr="Store a file in line mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A STOR command.&#10;  fp: A file-like object with a readline() method.&#10;  callback: An optional single parameter callable that is called on&#10;            each line after it is sent.  [default: None]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="fp" />
				<Param name="[callback=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.transfercmd" func="yes">
			<Overload retVal="" descr="Like ntransfercmd() but returns only the socket.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[rest=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.voidcmd" func="yes">
			<Overload retVal="" descr="Send a command and expect a response beginning with '2'.">
				<Param name="self" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP.voidresp" func="yes">
			<Overload retVal="" descr="Expect a response beginning with '2'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS" func="yes">
			<Overload retVal="" descr="A FTP subclass which adds TLS support to FTP as described&#10;in RFC-4217.&#10;&#10;Connect as usual to port 21 implicitly securing the FTP control&#10;connection before authenticating.&#10;&#10;Securing the data connection requires user to explicitly ask&#10;for it by calling prot_p() method.&#10;&#10;Usage example:&#10;&gt;&gt;&gt; from ftplib import FTP_TLS&#10;&gt;&gt;&gt; ftps = FTP_TLS('ftp.python.org')&#10;&gt;&gt;&gt; ftps.login()  # login anonymously previously securing control channel&#10;'230 Guest login ok, access restrictions apply.'&#10;&gt;&gt;&gt; ftps.prot_p()  # switch to secure data connection&#10;'200 Protection level set to P'&#10;&gt;&gt;&gt; ftps.retrlines('LIST')  # list directory content securely&#10;total 9&#10;drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .&#10;drwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..&#10;drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin&#10;drwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc&#10;d-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming&#10;drwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib&#10;drwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub&#10;drwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr&#10;-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg&#10;'226 Transfer complete.'&#10;&gt;&gt;&gt; ftps.quit()&#10;'221 Goodbye.'&#10;&gt;&gt;&gt;">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.abort" func="yes">
			<Overload retVal="" descr="Abort a file transfer.  Uses out-of-band data.&#10;This does not follow the procedure from the RFC to send Telnet&#10;IP and Synch; that doesn't seem to work with the servers I've&#10;tried.  Instead, just send the ABOR command as OOB data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.acct" func="yes">
			<Overload retVal="" descr="Send new account name.">
				<Param name="self" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.auth" func="yes">
			<Overload retVal="" descr="Set up secure control connection by using TLS/SSL.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.ccc" func="yes">
			<Overload retVal="" descr="Switch back to a clear-text control connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.close" func="yes">
			<Overload retVal="" descr="Close the connection without assuming anything about it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.connect" func="yes">
			<Overload retVal="" descr="Connect to host.  Arguments are:&#10;- host: hostname to connect to (string, default previous host)&#10;- port: port to connect to (integer, default previous port)&#10;- timeout: the timeout to set against the ftp socket(s)&#10;- source_address: a 2-tuple (host, port) for the socket to bind&#10;  to as its source address before connecting.">
				<Param name="self" />
				<Param name="[host" />
				<Param name="[port=0" />
				<Param name="[timeout=-999" />
				<Param name="[source_address=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.cwd" func="yes">
			<Overload retVal="" descr="Change to a directory.">
				<Param name="self" />
				<Param name="dirname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.debug" func="yes">
			<Overload retVal="" descr="Set the debugging level.&#10;The required argument level means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.delete" func="yes">
			<Overload retVal="" descr="Delete a file.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.dir" func="yes">
			<Overload retVal="" descr="List a directory in long form.&#10;By default list current directory to stdout.&#10;Optional last argument is callback function; all&#10;non-empty arguments before it are concatenated to the&#10;LIST command.  (This *should* only be used for a pathname.)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.getline" />
		<KeyWord name="ftplib.FTP_TLS.getmultiline" />
		<KeyWord name="ftplib.FTP_TLS.getresp" />
		<KeyWord name="ftplib.FTP_TLS.getwelcome" func="yes">
			<Overload retVal="" descr="Get the welcome message from the server.&#10;(this is read and squirreled away by connect())">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.login" func="yes">
			<Overload retVal="" descr="Login, default anonymous.">
				<Param name="self" />
				<Param name="[user" />
				<Param name="[passwd" />
				<Param name="[acct" />
				<Param name="[secure=True]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.makepasv" />
		<KeyWord name="ftplib.FTP_TLS.makeport" func="yes">
			<Overload retVal="" descr="Create a new socket and send a PORT command for it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.maxline" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.mkd" func="yes">
			<Overload retVal="" descr="Make a directory, return its full pathname.">
				<Param name="self" />
				<Param name="dirname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.mlsd" func="yes">
			<Overload retVal="" descr='List a directory in a standardized format by using MLSD&#10;command (RFC-3659). If path is omitted the current directory&#10;is assumed. "facts" is a list of strings representing the type&#10;of information desired (e.g. ["type", "size", "perm"]).&#10;&#10;Return a generator object yielding a tuple of two elements&#10;for every file found in path.&#10;First element is the file name, the second one is a dictionary&#10;including a variable number of "facts" depending on the server&#10;and whether "facts" argument has been provided.'>
				<Param name="self" />
				<Param name="[path" />
				<Param name="[facts=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.nlst" func="yes">
			<Overload retVal="" descr="Return a list of files in a given directory (default the current).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.ntransfercmd" func="yes">
			<Overload retVal="" descr="Initiate a transfer over the data connection.&#10;&#10;If the transfer is active, send a port command and the&#10;transfer command, and accept the connection.  If the server is&#10;passive, send a pasv command, connect to it, and start the&#10;transfer command.  Either way, return the socket for the&#10;connection and the expected size of the transfer.  The&#10;expected size may be None if it could not be determined.&#10;&#10;Optional `rest' argument can be a string that is sent as the&#10;argument to a REST command.  This is essentially a server&#10;marker used to tell the server to skip over any data up to the&#10;given marker.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[rest=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.passiveserver" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.port" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.prot_c" func="yes">
			<Overload retVal="" descr="Set up clear text data connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.prot_p" func="yes">
			<Overload retVal="" descr="Set up secure data connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.putcmd" />
		<KeyWord name="ftplib.FTP_TLS.putline" />
		<KeyWord name="ftplib.FTP_TLS.pwd" func="yes">
			<Overload retVal="" descr="Return current working directory.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.quit" func="yes">
			<Overload retVal="" descr="Quit, and close the connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.rename" func="yes">
			<Overload retVal="" descr="Rename a file.">
				<Param name="self" />
				<Param name="fromname" />
				<Param name="toname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.retrbinary" func="yes">
			<Overload retVal="" descr="Retrieve data in binary mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A RETR command.&#10;  callback: A single parameter callable to be called on each&#10;            block of data read.&#10;  blocksize: The maximum number of bytes to read from the&#10;             socket at one time.  [default: 8192]&#10;  rest: Passed to transfercmd().  [default: None]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="callback" />
				<Param name="[blocksize=8192" />
				<Param name="[rest=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.retrlines" func="yes">
			<Overload retVal="" descr="Retrieve data in line mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A RETR, LIST, or NLST command.&#10;  callback: An optional single parameter callable that is called&#10;            for each line with the trailing CRLF stripped.&#10;            [default: print_line()]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[callback=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.rmd" func="yes">
			<Overload retVal="" descr="Remove a directory.">
				<Param name="self" />
				<Param name="dirname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.sanitize" />
		<KeyWord name="ftplib.FTP_TLS.sendcmd" func="yes">
			<Overload retVal="" descr="Send a command and return the response.">
				<Param name="self" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.sendeprt" func="yes">
			<Overload retVal="" descr="Send an EPRT command with the current host and the given port number.">
				<Param name="self" />
				<Param name="host" />
				<Param name="port" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.sendport" func="yes">
			<Overload retVal="" descr="Send a PORT command with the current host and the given&#10;port number.">
				<Param name="self" />
				<Param name="host" />
				<Param name="port" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debugging level.&#10;The required argument level means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.set_pasv" func="yes">
			<Overload retVal="" descr="Use passive or active mode for data transfers.&#10;With a false argument, use the normal PORT mode,&#10;With a true argument, use the PASV command.">
				<Param name="self" />
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.size" func="yes">
			<Overload retVal="" descr="Retrieve the size of a file.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.ssl_version" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.storbinary" func="yes">
			<Overload retVal="" descr="Store a file in binary mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A STOR command.&#10;  fp: A file-like object with a read(num_bytes) method.&#10;  blocksize: The maximum data size to read from fp and send over&#10;             the connection at once.  [default: 8192]&#10;  callback: An optional single parameter callable that is called on&#10;            each block of data after it is sent.  [default: None]&#10;  rest: Passed to transfercmd().  [default: None]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="fp" />
				<Param name="[blocksize=8192" />
				<Param name="[callback=None" />
				<Param name="[rest=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.storlines" func="yes">
			<Overload retVal="" descr="Store a file in line mode.  A new port is created for you.&#10;&#10;Args:&#10;  cmd: A STOR command.&#10;  fp: A file-like object with a readline() method.&#10;  callback: An optional single parameter callable that is called on&#10;            each line after it is sent.  [default: None]&#10;&#10;Returns:&#10;  The response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="fp" />
				<Param name="[callback=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.transfercmd" func="yes">
			<Overload retVal="" descr="Like ntransfercmd() but returns only the socket.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[rest=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.voidcmd" func="yes">
			<Overload retVal="" descr="Send a command and expect a response beginning with '2'.">
				<Param name="self" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.FTP_TLS.voidresp" func="yes">
			<Overload retVal="" descr="Expect a response beginning with '2'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.MAXLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.MSG_OOB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.all_errors" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_perm" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_perm.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_perm.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_proto" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_proto.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_proto.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_reply" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_reply.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_reply.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_temp" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_temp.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.error_temp.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.ftpcp" func="yes">
			<Overload retVal="" descr="Copy file from one FTP-instance to another.">
				<Param name="source" />
				<Param name="sourcename" />
				<Param name="target" />
				<Param name="[targetname" />
				<Param name="[type=I]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse150" func="yes">
			<Overload retVal="" descr="Parse the '150' response for a RETR request.&#10;Returns the expected transfer size or None; size is not guaranteed to&#10;be present in the 150 message.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse227" func="yes">
			<Overload retVal="" descr="Parse the '227' response for a PASV request.&#10;Raises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'&#10;Return ('host.addr.as.numbers', port#) tuple.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse229" func="yes">
			<Overload retVal="" descr="Parse the '229' response for an EPSV request.&#10;Raises error_proto if it does not contain '(|||port|)'&#10;Return ('host.addr.as.numbers', port#) tuple.">
				<Param name="resp" />
				<Param name="peer" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.parse257" func="yes">
			<Overload retVal="" descr="Parse the '257' response for a MKD or PWD request.&#10;This is a response to a MKD or PWD request: a directory name.&#10;Returns the directoryname in the 257 reply.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.print_line" func="yes">
			<Overload retVal="" descr="Default retrlines callback to print a line.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="ftplib.test" func="yes">
			<Overload retVal="" descr="Test program.&#10;Usage: ftp [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...&#10;&#10;-d dir&#10;-l list&#10;-p password">
			</Overload>
		</KeyWord>
		<KeyWord name="ftruncate" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="full" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="full_name" func="yes">
			<Overload retVal="" descr="Function of setuptools.Require">
			</Overload>
		</KeyWord>
		<KeyWord name="fullmatch" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="func_get_function_name" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="func_std_string" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="func_strip_path" func="yes">
			<Overload retVal="" descr="Function of pstats">
			</Overload>
		</KeyWord>
		<KeyWord name="functools" func="yes">
			<Overload retVal="" descr="functools.py - Tools for working with functions and callable objects">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.MappingProxyType" />
		<KeyWord name="functools.MappingProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.MappingProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.MappingProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.MappingProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.MappingProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.RLock" />
		<KeyWord name="functools.RLock.acquire" func="yes">
			<Overload retVal="" descr="acquire(blocking=True) -&gt; bool&#10;&#10;Lock the lock.  `blocking` indicates whether we should wait&#10;for the lock to be available or not.  If `blocking` is False&#10;and another thread holds the lock, the method will return False&#10;immediately.  If `blocking` is True and another thread holds&#10;the lock, the method will wait for the lock to be released,&#10;take it and then return True.&#10;(note: the blocking operation is interruptible.)&#10;&#10;In all other cases, the method will return True immediately.&#10;Precisely, if the current thread already holds the lock, its&#10;internal counter is simply incremented. If nobody holds the lock,&#10;the lock is taken and its internal counter initialized to 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.RLock.release" func="yes">
			<Overload retVal="" descr="release()&#10;&#10;Release the lock, allowing another thread that is blocked waiting for&#10;the lock to acquire the lock.  The lock must be in the locked state,&#10;and must be locked by the same thread that unlocks it; otherwise a&#10;`RuntimeError` is raised.&#10;&#10;Do note that if the lock was acquire()d several times in a row by the&#10;current thread, release() needs to be called as many times for the lock&#10;to be available for other threads.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.WRAPPER_ASSIGNMENTS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.WRAPPER_UPDATES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.WeakKeyDictionary" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.cmp_to_key" func="yes">
			<Overload retVal="" descr="Convert a cmp= function into a key= function.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.get_cache_token" func="yes">
			<Overload retVal="" descr="Returns the current ABC cache token.&#10;&#10;The token is an opaque object (supporting equality testing) identifying the&#10;current version of the ABC cache for virtual subclasses. The token changes&#10;with every call to ``register()`` on any ABC.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.lru_cache" func="yes">
			<Overload retVal="" descr="Least-recently-used cache decorator.&#10;&#10;If *maxsize* is set to None, the LRU features are disabled and the cache&#10;can grow without bound.&#10;&#10;If *typed* is True, arguments of different types will be cached separately.&#10;For example, f(3.0) and f(3) will be treated as distinct calls with&#10;distinct results.&#10;&#10;Arguments to the cached function must be hashable.&#10;&#10;View the cache statistics named tuple (hits, misses, maxsize, currsize)&#10;with f.cache_info().  Clear the cache and statistics with f.cache_clear().&#10;Access the underlying function with f.__wrapped__.&#10;&#10;See:  http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">
				<Param name="[maxsize=128" />
				<Param name="[typed=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial" func="yes">
			<Overload retVal="" descr="partial(func, *args, **keywords) - new function with partial application&#10;of the given arguments and keywords.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial.args" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial.func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partial.keywords" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.partialmethod" func="yes">
			<Overload retVal="" descr="Method descriptor with partial application of the given arguments&#10;and keywords.&#10;&#10;Supports wrapping existing descriptors and handles non-descriptor&#10;callables as instance methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.recursive_repr" func="yes">
			<Overload retVal="" descr="Decorator to make a repr function return fillvalue for a recursive call">
				<Param name="[fillvalue=...]" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.reduce" func="yes">
			<Overload retVal="" descr="reduce(function, sequence[, initial]) -&gt; value&#10;&#10;Apply a function of two arguments cumulatively to the items of a sequence,&#10;from left to right, so as to reduce the sequence to a single value.&#10;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#10;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#10;of the sequence in the calculation, and serves as a default when the&#10;sequence is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="functools.singledispatch" func="yes">
			<Overload retVal="" descr="Single-dispatch generic function decorator.&#10;&#10;Transforms a function into a generic function, which can have different&#10;behaviours depending upon the type of its first argument. The decorated&#10;function acts as the default implementation, and additional&#10;implementations can be registered using the register() attribute of the&#10;generic function.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.total_ordering" func="yes">
			<Overload retVal="" descr="Class decorator that fills in missing ordering methods">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.update_wrapper" func="yes">
			<Overload retVal="" descr="Update a wrapper function to look like the wrapped function&#10;&#10;wrapper is the function to be updated&#10;wrapped is the original function&#10;assigned is a tuple naming the attributes assigned directly&#10;from the wrapped function to the wrapper function (defaults to&#10;functools.WRAPPER_ASSIGNMENTS)&#10;updated is a tuple naming the attributes of the wrapper that&#10;are updated with the corresponding attribute from the wrapped&#10;function (defaults to functools.WRAPPER_UPDATES)">
				<Param name="wrapper" />
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="functools.wraps" func="yes">
			<Overload retVal="" descr="Decorator factory to apply update_wrapper() to a wrapper function&#10;&#10;Returns a decorator that invokes update_wrapper() with the decorated&#10;function as the wrapper argument and the arguments to wraps() as the&#10;remaining arguments. Default arguments are as for update_wrapper().&#10;This is a convenience function to simplify applying partial() to&#10;update_wrapper().">
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
        		<KeyWord name="gaierror" func="yes">
			<Overload retVal="" descr="Function of socket.gaierror">
			</Overload>
		</KeyWord>
		<KeyWord name="gammavariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="gather" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="gauss" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="gcd" func="yes">
			<Overload retVal="" descr="Function of fractions">
			</Overload>
		</KeyWord>
		<KeyWord name="ge" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="gen_id" func="yes">
			<Overload retVal="" descr="Function of msilib.CAB">
			</Overload>
		</KeyWord>
		<KeyWord name="gen_uuid" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete" func="yes">
			<Overload retVal="" descr="This program is free software: you can redistribute it and/or modify&#10;    it under the terms of the GNU General Public License as published by&#10;    the Free Software Foundation, either version 3 of the License, or&#10;    (at your option) any later version.&#10;&#10;    This program is distributed in the hope that it will be useful,&#10;    but WITHOUT ANY WARRANTY; without even the implied warranty of&#10;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#10;    GNU General Public License for more details.&#10;&#10;    You should have received a copy of the GNU General Public License&#10;    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.">
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete.generate_python_autocomplete" func="yes">
			<Overload retVal="" descr="Generates a xml to be used by Notepad++ for python autocompletion&#10;Keywords: (bool) namespace, &#10;(bool) private: to include namespaces (functions starting with two underscores) and private (starting with one underscore) functions&#10;(bool) no_builtin: to exclude builtin functions, &#10;(int) level: to go to a user-defined level of deepness in functions browsing (default=2)">
				<Param name="python_script" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete.getargspec" func="yes">
			<Overload retVal="" descr="Get the names and default values of a function's parameters.&#10;&#10;A tuple of four things is returned: (args, varargs, keywords, defaults).&#10;'args' is a list of the argument names, including keyword-only argument names.&#10;'varargs' and 'keywords' are the names of the * and ** parameters or None.&#10;'defaults' is an n-tuple of the default values of the last n parameters.&#10;&#10;This function is deprecated, as it does not support annotations or&#10;keyword-only parameters and will raise ValueError if either is present&#10;on the supplied callable.&#10;&#10;For a more structured introspection API, use inspect.signature() instead.&#10;&#10;Alternatively, use getfullargspec() for an API with a similar namedtuple&#10;based interface, but full support for annotations and keyword-only&#10;parameters.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete.getdoc" func="yes">
			<Overload retVal="" descr="Get the documentation string for an object.&#10;&#10;All tabs are expanded to spaces.  To clean up docstrings that are&#10;indented to line up with blocks of code, any whitespace than can be&#10;uniformly removed from the second line onwards is removed.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete.isroutine" func="yes">
			<Overload retVal="" descr="Return true if the object is any kind of function or method.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="generate_python_autocomplete.quoteattr" func="yes">
			<Overload retVal="" descr='Escape and quote an attribute value.&#10;&#10;Escape &amp;, &lt;, and &gt; in a string of data, then quote it for use as&#10;an attribute value.  The " character will be escaped as well, if&#10;necessary.&#10;&#10;You can escape other strings of data by passing a dictionary as&#10;the optional entities parameter.  The keys and values must all be&#10;strings; each key will be replaced with its corresponding value.'>
				<Param name="data" />
				<Param name="[entities={}]" />
			</Overload>
		</KeyWord>
		<KeyWord name="generate_tokens" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="generic_visit" func="yes">
			<Overload retVal="" descr="Function of ast.NodeTransformer">
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath" func="yes">
			<Overload retVal="" descr="Path operations common to more than one OS&#10;Do not use directly.  The OS specific modules import the appropriate&#10;functions from this module themselves.">
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.samefile" func="yes">
			<Overload retVal="" descr="Test whether two pathnames reference the same actual file">
				<Param name="f1" />
				<Param name="f2" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.sameopenfile" func="yes">
			<Overload retVal="" descr="Test whether two open file objects reference the same file">
				<Param name="fp1" />
				<Param name="fp2" />
			</Overload>
		</KeyWord>
		<KeyWord name="genericpath.samestat" func="yes">
			<Overload retVal="" descr="Test whether two stat buffers reference the same file">
				<Param name="s1" />
				<Param name="s2" />
			</Overload>
		</KeyWord>
		<KeyWord name="genops" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="geohash" func="yes">
			<Overload retVal="" descr="Function of antigravity">
			</Overload>
		</KeyWord>
		<KeyWord name="get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="getChild" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="getDescription" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="getLevelName" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getLogRecordFactory" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getLogger" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getLoggerClass" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="getMessage" func="yes">
			<Overload retVal="" descr="Function of logging.LogRecord">
			</Overload>
		</KeyWord>
		<KeyWord name="getName" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="getTestCaseNames" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="get_addr_spec" func="yes">
			<Overload retVal="" descr="Function of smtpd">
			</Overload>
		</KeyWord>
		<KeyWord name="get_all" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_all_breaks" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="get_all_start_methods" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="get_angle_addr" func="yes">
			<Overload retVal="" descr="Function of smtpd">
			</Overload>
		</KeyWord>
		<KeyWord name="get_archive_formats" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_boundary" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_bpbynumber" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="get_break" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="get_breaks" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="get_buf" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="get_buffer" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="get_build_platform" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_bytes" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_ca_certs" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="get_cache_path" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_cache_token" func="yes">
			<Overload retVal="" descr="Function of abc">
			</Overload>
		</KeyWord>
		<KeyWord name="get_channel_binding" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="get_charset" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_charsets" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_child_watcher" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="get_children" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_ciphers" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="get_class_members" func="yes">
			<Overload retVal="" descr="Function of rlcompleter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_close_matches" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="get_cmdline_options" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_code" func="yes">
			<Overload retVal="" descr="Function of imp.SourcelessFileLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="get_command_class" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_command_list" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_command_name" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="get_command_obj" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_command_packages" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_files" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_h_filename" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_section" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_var" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_config_vars" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_content_charset" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_content_disposition" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_content_maintype" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_content_subtype" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_content_type" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_context" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="get_data" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_date" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="get_debug" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default_cache" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default_type" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default_values" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_default_verify_paths" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_description" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="get_dialect" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="get_distribution" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_docstring" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="get_doctest" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_egg_cache_dir" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_entry_info" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_entry_map" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_environ_vars" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_errno" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="get_event_loop" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="get_event_loop_policy" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="get_examples" func="yes">
			<Overload retVal="" descr="Function of doctest.DocTestParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_exception_handler" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="get_exec_path" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="get_extra_info" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="get_field" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_file" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_file_breaks" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="get_filename" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_finalized_command" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="get_flags" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="get_folder" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="get_frees" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_from" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="get_frozen_object" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="get_globals" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_grouped_opcodes" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="get_handle_inheritable" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="get_id" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_ident" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="get_identifiers" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_importer" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_info" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="get_inheritable" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="get_installed_distributions" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="get_instructions" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="get_interpreter" func="yes">
			<Overload retVal="" descr="Function of zipapp">
			</Overload>
		</KeyWord>
		<KeyWord name="get_labels" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_last_error" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="get_line" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="get_lineno" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_loader" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_locals" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_logger" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="get_long_be" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_long_le" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_magic" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="get_makefile_filename" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_matching_blocks" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="get_message" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_metadata" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="get_metadata_lines" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="get_methods" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_mixed_type_key" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="get_msg" func="yes">
			<Overload retVal="" descr="Function of tabnanny.NannyNag">
			</Overload>
		</KeyWord>
		<KeyWord name="get_name" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="get_names" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="get_namespace" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="get_namespaces" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="get_nowait" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="get_object_traceback" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="get_opcodes" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="get_opt_string" func="yes">
			<Overload retVal="" descr="Function of optparse.Option">
			</Overload>
		</KeyWord>
		<KeyWord name="get_option" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="get_option_dict" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="get_option_group" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_param" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_parameters" func="yes">
			<Overload retVal="" descr="Function of symtable.Function">
			</Overload>
		</KeyWord>
		<KeyWord name="get_params" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_path" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_path_names" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_paths" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_payload" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_pid" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="get_pipe_transport" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="get_platform" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_position" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="get_print_list" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="get_prog" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="get_prog_name" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_protocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="get_protocol_name" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_provider" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_python_version" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.TCPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="get_resource_filename" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="get_resource_stream" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="get_resource_string" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="get_returncode" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="get_scheme_names" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="get_sequences" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="get_server_certificate" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_short_be" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_short_le" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="get_similar_commands" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="get_socket" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="get_sort_arg_defs" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="get_source" func="yes">
			<Overload retVal="" descr="Function of imp.SourcelessFileLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="get_stack" func="yes">
			<Overload retVal="" descr="Function of asyncio.Task">
			</Overload>
		</KeyWord>
		<KeyWord name="get_start_method" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="get_string" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="get_sub_commands" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="get_subdir" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="get_suffixes" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="get_summaries" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="get_supported_platform" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="get_symbols" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_tag" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="get_task_factory" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="get_terminal_size" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="get_terminator" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="get_token" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="get_top_level_stats" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="get_traceback_limit" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="get_traced_memory" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="get_tracemalloc_memory" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="get_type" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="get_type_hints" func="yes">
			<Overload retVal="" descr="Function of typing">
			</Overload>
		</KeyWord>
		<KeyWord name="get_unixfrom" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="get_unpack_formats" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="get_usage" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_value" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="get_version" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="get_visible" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="get_write_buffer_size" func="yes">
			<Overload retVal="" descr="Function of asyncio.Transport">
			</Overload>
		</KeyWord>
		<KeyWord name="getabsfile" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getacl" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="getaddrinfo" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getannotation" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="getargs" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getargspec" func="yes">
			<Overload retVal="" descr="Function of generate_python_autocomplete">
			</Overload>
		</KeyWord>
		<KeyWord name="getargvalues" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getatime" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getattr" func="yes">
			<Overload retVal="" descr="getattr(object, name[, default]) -&gt; value&#10;&#10;Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.&#10;When a default argument is given, it is returned when the attribute doesn't&#10;exist; without it, an exception is raised in that case.">
			</Overload>
		</KeyWord>
		<KeyWord name="getattr_static" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getblock" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getbuffer" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="getcallargs" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcapabilities" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="getcaps" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="getclasstree" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getclosurevars" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcomments" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcompname" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getcomptype" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getcontext" func="yes">
			<Overload retVal="" descr="Function of decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="getcoroutinelocals" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getcoroutinestate" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getctime" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getcwd" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getcwdb" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getdecoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getdefaultlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="getdefaulttimeout" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getdoc" func="yes">
			<Overload retVal="" descr="Function of generate_python_autocomplete">
			</Overload>
		</KeyWord>
		<KeyWord name="getdocloc" func="yes">
			<Overload retVal="" descr="Function of pydoc.Doc">
			</Overload>
		</KeyWord>
		<KeyWord name="getencoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getenv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getfile" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getfileinfo" func="yes">
			<Overload retVal="" descr="Function of binhex">
			</Overload>
		</KeyWord>
		<KeyWord name="getfirst" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="getfirstweekday" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="getfp" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getfqdn" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getframeinfo" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getframerate" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getfullargspec" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getgeneratorlocals" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getgeneratorstate" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostbyaddr" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostbyname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostbyname_ex" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="gethostname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getincrementaldecoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getincrementalencoder" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getinfo" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="getinnerframes" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getitem" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="getline" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="getlineno" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getlines" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="getlist" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="getlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="getlogin" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getmark" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getmarkers" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getmember" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="getmembers" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmodule" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmodulename" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmro" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getmtime" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getmultiline" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="getname" func="yes">
			<Overload retVal="" descr="Function of aifc.Chunk">
			</Overload>
		</KeyWord>
		<KeyWord name="getnameinfo" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getnames" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="getnchannels" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getnframes" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getnode" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt" func="yes">
			<Overload retVal="" descr="Parser for command line options.&#10;&#10;This module helps scripts to parse the command line arguments in&#10;sys.argv.  It supports the same conventions as the Unix getopt()&#10;function (including the special meanings of arguments of the form `-'&#10;and `--').  Long options similar to those supported by GNU software&#10;may be used as well via an optional third argument.  This module&#10;provides two functions and an exception:&#10;&#10;getopt() -- Parse command line options&#10;gnu_getopt() -- Like getopt(), but allow option and non-option arguments&#10;to be intermixed.&#10;GetoptError -- exception (class) raised with 'opt' attribute, which is the&#10;option involved with the exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.GetoptError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.GetoptError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.GetoptError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.do_longs" />
		<KeyWord name="getopt.do_shorts" />
		<KeyWord name="getopt.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.getopt" func="yes">
			<Overload retVal="" descr="getopt(args, options[, long_options]) -&gt; opts, args&#10;&#10;Parses command line options and parameter list.  args is the&#10;argument list to be parsed, without the leading reference to the&#10;running program.  Typically, this means &quot;sys.argv[1:]&quot;.  shortopts&#10;is the string of option letters that the script wants to&#10;recognize, with options that require an argument followed by a&#10;colon (i.e., the same format that Unix getopt() uses).  If&#10;specified, longopts is a list of strings with the names of the&#10;long options which should be supported.  The leading '--'&#10;characters should not be included in the option name.  Options&#10;which require an argument should be followed by an equal sign&#10;('=').&#10;&#10;The return value consists of two elements: the first is a list of&#10;(option, value) pairs; the second is the list of program arguments&#10;left after the option list was stripped (this is a trailing slice&#10;of the first argument).  Each option-and-value pair returned has&#10;the option as its first element, prefixed with a hyphen (e.g.,&#10;'-x'), and the option argument as its second element, or an empty&#10;string if the option has no argument.  The options occur in the&#10;list in the same order in which they were found, thus allowing&#10;multiple occurrences.  Long and short options may be mixed.">
				<Param name="args" />
				<Param name="shortopts" />
				<Param name="[longopts=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.gnu_getopt" func="yes">
			<Overload retVal="" descr="getopt(args, options[, long_options]) -&gt; opts, args&#10;&#10;This function works like getopt(), except that GNU style scanning&#10;mode is used by default. This means that option and non-option&#10;arguments may be intermixed. The getopt() function stops&#10;processing options as soon as a non-option argument is&#10;encountered.&#10;&#10;If the first character of the option string is `+', or if the&#10;environment variable POSIXLY_CORRECT is set, then option&#10;processing stops as soon as a non-option argument is encountered.">
				<Param name="args" />
				<Param name="shortopts" />
				<Param name="[longopts=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getopt.long_has_args" />
		<KeyWord name="getopt.short_has_arg" />
		<KeyWord name="getouterframes" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getoutput" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="getpager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="getparams" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass" func="yes">
			<Overload retVal="" descr="Utilities to get a password and/or the current user name.&#10;&#10;getpass(prompt[, stream]) - Prompt for a password, with echo turned off.&#10;getuser() - Get the user name from the environment or password database.&#10;&#10;GetPassWarning - This UserWarning is issued when getpass() cannot prevent&#10;                 echoing of the password contents while reading.&#10;&#10;On Windows, the msvcrt module will be used.">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.GetPassWarning" func="yes">
			<Overload retVal="" descr="Base class for warnings generated by user code.">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.GetPassWarning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.GetPassWarning.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.fallback_getpass" func="yes">
			<Overload retVal="" descr=>
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.getpass" func="yes">
			<Overload retVal="" descr="Prompt for password with echo off, using Windows getch().">
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.getuser" func="yes">
			<Overload retVal="" descr="Get the username from the environment or password database.&#10;&#10;First try various environment variables, then the password&#10;database.  This works on Windows as long as USERNAME is set.">
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.unix_getpass" func="yes">
			<Overload retVal="" descr="Prompt for a password, with echo turned off.&#10;&#10;Args:&#10;  prompt: Written on stream to ask for the input.  Default: 'Password: '&#10;  stream: A writable file object to display the prompt.  Defaults to&#10;          the tty.  If no tty is available defaults to sys.stderr.&#10;Returns:&#10;  The seKr3t input.&#10;Raises:&#10;  EOFError: If our input tty or stdin was closed.&#10;  GetPassWarning: When we were unable to turn echo off on the input.&#10;&#10;Always restores terminal settings before returning.">
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpass.win_getpass" func="yes">
			<Overload retVal="" descr="Prompt for password with echo off, using Windows getch().">
				<Param name="[prompt=Password: " />
				<Param name="[stream=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="getpeercert" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="getpeername" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="getpid" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getppid" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="getpreferredencoding" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="getprotobyname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getquota" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="getquotaroot" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="getrandbits" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="getreader" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="getreply" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="getresp" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="getsampwidth" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="getservbyname" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getservbyport" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="getsignal" func="yes">
			<Overload retVal="" descr="Function of signal">
			</Overload>
		</KeyWord>
		<KeyWord name="getsitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="getsize" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="getsockname" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="getsockopt" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="getsource" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getsourcefile" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getsourcelines" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="getstate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="getstats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="getstatusoutput" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="gettarinfo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="gettempdir" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="gettempdirb" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="gettempprefix" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="gettempprefixb" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="getter" func="yes">
			<Overload retVal="" descr="Descriptor to change the getter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext" func="yes">
			<Overload retVal="" descr="Internationalization and localization support.&#10;&#10;This module provides internationalization (I18N) and localization (L10N)&#10;support for your Python programs by providing an interface to the GNU gettext&#10;message catalog library.&#10;&#10;I18N refers to the operation by which a program is made aware of multiple&#10;languages.  L10N refers to the adaptation of your program, once&#10;internationalized, to the local language and cultural habits.">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.Catalog" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[languages=None" />
				<Param name="[class_=None" />
				<Param name="[fallback=False" />
				<Param name="[codeset=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.ENOENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.GNUTranslations" />
		<KeyWord name="gettext.GNUTranslations.BE_MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.GNUTranslations.LE_MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.GNUTranslations.VERSIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.GNUTranslations.add_fallback" />
		<KeyWord name="gettext.GNUTranslations.charset" />
		<KeyWord name="gettext.GNUTranslations.gettext" />
		<KeyWord name="gettext.GNUTranslations.info" />
		<KeyWord name="gettext.GNUTranslations.install" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[names=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.GNUTranslations.lgettext" />
		<KeyWord name="gettext.GNUTranslations.lngettext" />
		<KeyWord name="gettext.GNUTranslations.ngettext" />
		<KeyWord name="gettext.GNUTranslations.output_charset" />
		<KeyWord name="gettext.GNUTranslations.set_output_charset" />
		<KeyWord name="gettext.NullTranslations" />
		<KeyWord name="gettext.NullTranslations.add_fallback" />
		<KeyWord name="gettext.NullTranslations.charset" />
		<KeyWord name="gettext.NullTranslations.gettext" />
		<KeyWord name="gettext.NullTranslations.info" />
		<KeyWord name="gettext.NullTranslations.install" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[names=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.NullTranslations.lgettext" />
		<KeyWord name="gettext.NullTranslations.lngettext" />
		<KeyWord name="gettext.NullTranslations.ngettext" />
		<KeyWord name="gettext.NullTranslations.output_charset" />
		<KeyWord name="gettext.NullTranslations.set_output_charset" />
		<KeyWord name="gettext.bind_textdomain_codeset" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[codeset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.bindtextdomain" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.c2py" func="yes">
			<Overload retVal="" descr="Gets a C expression as used in PO files for plural forms and returns a&#10;Python function that implements an equivalent expression.">
				<Param name="plural" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.dgettext" />
		<KeyWord name="gettext.dngettext" />
		<KeyWord name="gettext.find" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[languages=None" />
				<Param name="[all=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.gettext" />
		<KeyWord name="gettext.install" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[codeset=None" />
				<Param name="[names=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.ldgettext" />
		<KeyWord name="gettext.ldngettext" />
		<KeyWord name="gettext.lgettext" />
		<KeyWord name="gettext.lngettext" />
		<KeyWord name="gettext.ngettext" />
		<KeyWord name="gettext.textdomain" func="yes">
			<Overload retVal="" descr=>
				<Param name="[domain=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettext.translation" func="yes">
			<Overload retVal="" descr=>
				<Param name="domain" />
				<Param name="[localedir=None" />
				<Param name="[languages=None" />
				<Param name="[class_=None" />
				<Param name="[fallback=False" />
				<Param name="[codeset=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gettimeout" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="getuntil" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Tokenizer">
			</Overload>
		</KeyWord>
		<KeyWord name="getuser" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="getuserbase" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="getusersitepackages" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="getvalue" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="getweakrefcount" func="yes">
			<Overload retVal="" descr="Function of weakref">
			</Overload>
		</KeyWord>
		<KeyWord name="getweakrefs" func="yes">
			<Overload retVal="" descr="Function of weakref">
			</Overload>
		</KeyWord>
		<KeyWord name="getwelcome" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="getwhile" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Tokenizer">
			</Overload>
		</KeyWord>
		<KeyWord name="getwidth" func="yes">
			<Overload retVal="" descr="Function of sre_parse.SubPattern">
			</Overload>
		</KeyWord>
		<KeyWord name="getwriter" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="glob" func="yes">
			<Overload retVal="" descr="Filename globbing utility.">
			</Overload>
		</KeyWord>
		<KeyWord name="glob.escape" func="yes">
			<Overload retVal="" descr="Escape all special characters.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="glob.glob" func="yes">
			<Overload retVal="" descr="Return a list of paths matching a pathname pattern.&#10;&#10;The pattern may contain simple shell-style wildcards a la&#10;fnmatch. However, unlike fnmatch, filenames starting with a&#10;dot are special cases that are not matched by '*' and '?'&#10;patterns.&#10;&#10;If recursive is true, the pattern '**' will match any files and&#10;zero or more directories and subdirectories.">
			</Overload>
		</KeyWord>
		<KeyWord name="glob.glob0" />
		<KeyWord name="glob.glob1" />
		<KeyWord name="glob.has_magic" />
		<KeyWord name="glob.iglob" func="yes">
			<Overload retVal="" descr="Return an iterator which yields the paths matching a pathname pattern.&#10;&#10;The pattern may contain simple shell-style wildcards a la&#10;fnmatch. However, unlike fnmatch, filenames starting with a&#10;dot are special cases that are not matched by '*' and '?'&#10;patterns.&#10;&#10;If recursive is true, the pattern '**' will match any files and&#10;zero or more directories and subdirectories.">
			</Overload>
		</KeyWord>
		<KeyWord name="glob.magic_check" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="glob.magic_check_bytes" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="glob0" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="glob1" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="global" />
		<KeyWord name="global_matches" func="yes">
			<Overload retVal="" descr="Function of rlcompleter.Completer">
			</Overload>
		</KeyWord>
		<KeyWord name="globals" func="yes">
			<Overload retVal="" descr="Return the dictionary containing the current scope's global variables.&#10;&#10;NOTE: Updates to this dictionary *will* affect name lookups in the current&#10;global scope and vice-versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="globaltrace_countfuncs" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="globaltrace_lt" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="globaltrace_trackcallers" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="gnu_getopt" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="grey" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="group" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="gt" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="guess_all_extensions" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="guess_extension" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="guess_type" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip" func="yes">
			<Overload retVal="" descr="Functions that read and write gzipped files.&#10;&#10;The user of the file doesn't have to worry about the compression,&#10;but random access is not allowed.">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FCOMMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FEXTRA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FHCRC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FNAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.FTEXT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.GzipFile" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.WRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.compress" func="yes">
			<Overload retVal="" descr="Compress data in one shot and return the compressed string.&#10;Optional argument is the compression level, in range of 0-9.">
				<Param name="data" />
				<Param name="[compresslevel=9]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.decompress" func="yes">
			<Overload retVal="" descr="Decompress a gzip compressed string in one shot.&#10;Return the decompressed string.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.open" func="yes">
			<Overload retVal="" descr='Open a gzip-compressed file in binary or text mode.&#10;&#10;The filename argument can be an actual filename (a str or bytes object), or&#10;an existing file object to read from or write to.&#10;&#10;The mode argument can be "r", "rb", "w", "wb", "x", "xb", "a" or "ab" for&#10;binary mode, or "rt", "wt", "xt" or "at" for text mode. The default mode is&#10;"rb", and the default compresslevel is 9.&#10;&#10;For binary mode, this function is equivalent to the GzipFile constructor:&#10;GzipFile(filename, mode, compresslevel). In this case, the encoding, errors&#10;and newline arguments must not be provided.&#10;&#10;For text mode, a GzipFile object is created, and wrapped in an&#10;io.TextIOWrapper instance with the specified encoding, error handling&#10;behavior, and line ending(s).'>
				<Param name="filename" />
				<Param name="[mode=rb" />
				<Param name="[compresslevel=9" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="gzip.write32u" />
		<KeyWord name="gzopen" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
        		<KeyWord name="handle" func="yes">
			<Overload retVal="" descr="Function of cgitb.Hook">
			</Overload>
		</KeyWord>
		<KeyWord name="handleError" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_accept" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_accepted" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_close" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_command_def" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_connect" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_connect_event" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_display_options" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_error" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_expt" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_expt_event" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_read" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_read_event" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_timeout" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_write" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handle_write_event" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="handler" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="harmonic_mean" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="hasHandlers" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="has_c_libraries" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_children" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="has_contents_for" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_data_files" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_exec" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="has_ext_modules" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_extn" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="has_header" func="yes">
			<Overload retVal="" descr="Function of csv.Sniffer">
			</Overload>
		</KeyWord>
		<KeyWord name="has_headers" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_magic" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="has_metadata" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="has_modules" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_option" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="has_pure_modules" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_resource" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="has_scripts" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="has_version" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="hasattr" func="yes">
			<Overload retVal="" descr="Return whether the object has an attribute with the given name.&#10;&#10;This is done by calling getattr(obj, name) and catching AttributeError.">
				<Param name="obj" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="hash" func="yes">
			<Overload retVal="" descr="Return the hash value for the given object.&#10;&#10;Two objects that compare equal must also have the same hash value, but the&#10;reverse is not necessarily true.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib" func="yes">
			<Overload retVal="" descr="hashlib module - A common interface to many hash functions.&#10;&#10;new(name, data=b'', **kwargs) - returns a new hash object implementing the&#10;                                given hash function; initializing the hash&#10;                                using the given binary data.&#10;&#10;Named constructor functions are also available, these are faster&#10;than using new(name):&#10;&#10;md5(), sha1(), sha224(), sha256(), sha384(), sha512(), blake2b(), blake2s(),&#10;sha3_224, sha3_256, sha3_384, sha3_512, shake_128, and shake_256.&#10;&#10;More algorithms may be available on your platform but the above are guaranteed&#10;to exist.  See the algorithms_guaranteed and algorithms_available attributes&#10;to find out what algorithm names can be passed to new().&#10;&#10;NOTE: If you want the adler32 or crc32 hash functions they are available in&#10;the zlib module.&#10;&#10;Choose your hash function wisely.  Some have known collision weaknesses.&#10;sha384 and sha512 will be slow on 32 bit platforms.&#10;&#10;Hash objects have these methods:&#10; - update(arg): Update the hash object with the bytes in arg. Repeated calls&#10;                are equivalent to a single call with the concatenation of all&#10;                the arguments.&#10; - digest():    Return the digest of the bytes passed to the update() method&#10;                so far.&#10; - hexdigest(): Like digest() except the digest is returned as a unicode&#10;                object of double length, containing only hexadecimal digits.&#10; - copy():      Return a copy (clone) of the hash object. This can be used to&#10;                efficiently compute the digests of strings that share a common&#10;                initial substring.&#10;&#10;For example, to obtain the digest of the string 'Nobody inspects the&#10;spammish repetition':&#10;&#10;    &gt;&gt;&gt; import hashlib&#10;    &gt;&gt;&gt; m = hashlib.md5()&#10;    &gt;&gt;&gt; m.update(b&quot;Nobody inspects&quot;)&#10;    &gt;&gt;&gt; m.update(b&quot; the spammish repetition&quot;)&#10;    &gt;&gt;&gt; m.digest()&#10;    b'\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'&#10;&#10;More condensed:&#10;&#10;    &gt;&gt;&gt; hashlib.sha224(b&quot;Nobody inspects the spammish repetition&quot;).hexdigest()&#10;    'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.algorithms_available" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.algorithms_guaranteed" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b" func="yes">
			<Overload retVal="" descr="Return a new BLAKE2b hash object.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.MAX_DIGEST_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.MAX_KEY_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.PERSON_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.SALT_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2b.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s" func="yes">
			<Overload retVal="" descr="Return a new BLAKE2s hash object.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.MAX_DIGEST_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.MAX_KEY_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.PERSON_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.SALT_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.blake2s.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.md5" func="yes">
			<Overload retVal="" descr="Returns a md5 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.new" func="yes">
			<Overload retVal="" descr="new(name, data=b'') - Return a new hashing object using the named algorithm;&#10;optionally initialized with data (which must be bytes).">
				<Param name="name" />
				<Param name="[data=b''" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.pbkdf2_hmac" func="yes">
			<Overload retVal="" descr="pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None) -&gt; key&#10;&#10;Password based key derivation function 2 (PKCS #5 v2.0) with HMAC as&#10;pseudorandom function.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha1" func="yes">
			<Overload retVal="" descr="Returns a sha1 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha224" func="yes">
			<Overload retVal="" descr="Returns a sha224 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha256" func="yes">
			<Overload retVal="" descr="Returns a sha256 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha384" func="yes">
			<Overload retVal="" descr="Returns a sha384 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224" func="yes">
			<Overload retVal="" descr="Return a new SHA3 hash object with a hashbit length of 28 bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_224.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256" func="yes">
			<Overload retVal="" descr="sha3_256([string]) -&gt; SHA3 object&#10;&#10;Return a new SHA3 hash object with a hashbit length of 32 bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_256.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384" func="yes">
			<Overload retVal="" descr="sha3_384([string]) -&gt; SHA3 object&#10;&#10;Return a new SHA3 hash object with a hashbit length of 48 bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_384.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512" func="yes">
			<Overload retVal="" descr="sha3_512([string]) -&gt; SHA3 object&#10;&#10;Return a new SHA3 hash object with a hashbit length of 64 bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha3_512.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.sha512" func="yes">
			<Overload retVal="" descr="Returns a sha512 hash object; optionally initialized with a string">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128" func="yes">
			<Overload retVal="" descr="shake_128([string]) -&gt; SHAKE object&#10;&#10;Return a new SHAKE hash object.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_128.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256" func="yes">
			<Overload retVal="" descr="shake_256([string]) -&gt; SHAKE object&#10;&#10;Return a new SHAKE hash object.">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.block_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.copy" func="yes">
			<Overload retVal="" descr="Return a copy of the hash object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.digest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of binary data.">
				<Param name="self" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.digest_size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.hexdigest" func="yes">
			<Overload retVal="" descr="Return the digest value as a string of hexadecimal digits.">
				<Param name="self" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="hashlib.shake_256.update" func="yes">
			<Overload retVal="" descr="Update this hash object's state with the provided string.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="head" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="heading" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="heapify" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heappop" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heappush" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heappushpop" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq" func="yes">
			<Overload retVal="" descr="Heap queue algorithm (a.k.a. priority queue).&#10;&#10;Heaps are arrays for which a[k] &lt;= a[2*k+1] and a[k] &lt;= a[2*k+2] for&#10;all k, counting elements from 0.  For the sake of comparison,&#10;non-existing elements are considered to be infinite.  The interesting&#10;property of a heap is that a[0] is always its smallest element.&#10;&#10;Usage:&#10;&#10;heap = []            # creates an empty heap&#10;heappush(heap, item) # pushes a new item on the heap&#10;item = heappop(heap) # pops the smallest item from the heap&#10;item = heap[0]       # smallest item on the heap without popping it&#10;heapify(x)           # transforms list into a heap, in-place, in linear time&#10;item = heapreplace(heap, item) # pops and returns smallest item, and adds&#10;                               # new item; the heap size is unchanged&#10;&#10;Our API differs from textbook heap algorithms as follows:&#10;&#10;- We use 0-based indexing.  This makes the relationship between the&#10;  index for a node and the indexes for its children slightly less&#10;  obvious, but is more suitable since Python uses 0-based indexing.&#10;&#10;- Our heappop() method returns the smallest item, not the largest.&#10;&#10;These two make it possible to view the heap as a regular Python list&#10;without surprises: heap[0] is the smallest item, and heap.sort()&#10;maintains the heap invariant!">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heapify" func="yes">
			<Overload retVal="" descr="Transform list into a heap, in-place, in O(len(heap)) time.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heappop" func="yes">
			<Overload retVal="" descr="Pop the smallest item off the heap, maintaining the heap invariant.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heappush" func="yes">
			<Overload retVal="" descr="heappush(heap, item) -&gt; None. Push item onto heap, maintaining the heap invariant.">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heappushpop" func="yes">
			<Overload retVal="" descr="heappushpop(heap, item) -&gt; value. Push item on the heap, then pop and return the smallest item&#10;from the heap. The combined action runs more efficiently than&#10;heappush() followed by a separate call to heappop().">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.heapreplace" func="yes">
			<Overload retVal="" descr="heapreplace(heap, item) -&gt; value. Pop and return the current smallest value, and add the new item.&#10;&#10;This is more efficient than heappop() followed by heappush(), and can be&#10;more appropriate when using a fixed-size heap.  Note that the value&#10;returned may be larger than item!  That constrains reasonable uses of&#10;this routine unless written as part of a conditional replacement:&#10;&#10;    if item &gt; heap[0]:&#10;        item = heapreplace(heap, item)">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.merge" func="yes">
			<Overload retVal="" descr="Merge multiple sorted inputs into a single sorted output.&#10;&#10;Similar to sorted(itertools.chain(*iterables)) but returns a generator,&#10;does not pull the data into memory all at once, and assumes that each of&#10;the input streams is already sorted (smallest to largest).&#10;&#10;&gt;&gt;&gt; list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))&#10;[0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]&#10;&#10;If *key* is not None, applies a key function to each element to determine&#10;its sort order.&#10;&#10;&gt;&gt;&gt; list(merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))&#10;['dog', 'cat', 'fish', 'horse', 'kangaroo']">
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.nlargest" func="yes">
			<Overload retVal="" descr="Find the n largest elements in a dataset.&#10;&#10;Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]">
				<Param name="n" />
				<Param name="iterable" />
				<Param name="[key=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="heapq.nsmallest" func="yes">
			<Overload retVal="" descr="Find the n smallest elements in a dataset.&#10;&#10;Equivalent to:  sorted(iterable, key=key)[:n]">
				<Param name="n" />
				<Param name="iterable" />
				<Param name="[key=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="heapreplace" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="helo" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="help" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="help_exec" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="help_pdb" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="herror" func="yes">
			<Overload retVal="" descr="Function of socket.herror">
			</Overload>
		</KeyWord>
		<KeyWord name="hex" func="yes">
			<Overload retVal="" descr="Return the data in the buffer as a string of hexadecimal numbers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hexbin" func="yes">
			<Overload retVal="" descr="Function of binhex">
			</Overload>
		</KeyWord>
		<KeyWord name="hexdigest" func="yes">
			<Overload retVal="" descr="Function of hashlib.blake2b">
			</Overload>
		</KeyWord>
		<KeyWord name="hls_to_rgb" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac" func="yes">
			<Overload retVal="" descr="HMAC (Keyed-Hashing for Message Authentication) Python module.&#10;&#10;Implements the HMAC algorithm as described by RFC 2104.">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC" func="yes">
			<Overload retVal="" descr="RFC 2104 HMAC class.  Also complies with RFC 4231.&#10;&#10;This supports the API for Cryptographic Hash Functions (PEP 247).">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC.blocksize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC.copy" func="yes">
			<Overload retVal="" descr="Return a separate copy of this hashing object.&#10;&#10;An update to this copy won't affect the original object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC.digest" func="yes">
			<Overload retVal="" descr="Return the hash value of this hashing object.&#10;&#10;This returns a string containing 8-bit data.  The object is&#10;not altered in any way by this function; you can continue&#10;updating the object after calling this function.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC.hexdigest" func="yes">
			<Overload retVal="" descr="Like digest(), but returns a string of hexadecimal digits instead.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.HMAC.update" func="yes">
			<Overload retVal="" descr="Update this hashing object with the string msg.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.compare_digest" func="yes">
			<Overload retVal="" descr="compare_digest(a, b) -&gt; bool&#10;&#10;Return 'a == b'.  This function uses an approach designed to prevent&#10;timing analysis, making it appropriate for cryptography.&#10;a and b must both be of the same type: either str (ASCII only),&#10;or any bytes-like object.&#10;&#10;Note: If a and b are of different lengths, or if an error occurs,&#10;a timing attack could theoretically reveal information about the&#10;types and lengths of a and b--but not their values.">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.new" func="yes">
			<Overload retVal="" descr="Create a new hashing object and return it.&#10;&#10;key: The starting key for the hash.&#10;msg: if available, will immediately be hashed into the object's starting&#10;state.&#10;&#10;You can now feed arbitrary strings into the object using its update()&#10;method, and can ask for the hash value at any time by calling its digest()&#10;method.">
				<Param name="key" />
				<Param name="[msg=None" />
				<Param name="[digestmod=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.trans_36" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="hmac.trans_5C" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="home" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="hook_compressed" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="hook_encoded" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="hosts" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="hsv_to_rgb" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="html" func="yes">
			<Overload retVal="" descr="General functions for HTML manipulation.">
			</Overload>
		</KeyWord>
		<KeyWord name="html.escape" func="yes">
			<Overload retVal="" descr="Replace special characters &quot;&amp;&quot;, &quot;&lt;&quot; and &quot;&gt;&quot; to HTML-safe sequences.&#10;If the optional flag quote is true (the default), the quotation mark&#10;characters, both double quote (&quot;) and single quote (') characters are also&#10;translated.">
				<Param name="s" />
				<Param name="[quote=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="html.unescape" func="yes">
			<Overload retVal="" descr="Convert all named and numeric character references (e.g. &amp;gt;, &amp;#62;,&#10;&amp;x3e;) in the string s to the corresponding unicode characters.&#10;This function uses the rules defined by the HTML 5 standard&#10;for both valid and invalid character references, and the list of&#10;HTML 5 named character references defined in html.entities.html5.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="htonl" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="htons" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="http" />
		<KeyWord name="http.HTTPStatus" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="http.IntEnum" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
        		<KeyWord name="iadd" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="iand" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="iconcat" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="id" func="yes">
			<Overload retVal="" descr="Return the identity of an object.&#10;&#10;This is guaranteed to be unique among simultaneously existing objects.&#10;(CPython uses the object's memory address.)">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="if" />
		<KeyWord name="ifloordiv" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="iglob" func="yes">
			<Overload retVal="" descr="Function of glob">
			</Overload>
		</KeyWord>
		<KeyWord name="ignore_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="ignore_patterns" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="ihave" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
        <KeyWord name="ilshift" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib" func="yes">
			<Overload retVal="" descr="IMAP4 client.&#10;&#10;Based on RFC 2060.&#10;&#10;Public class:           IMAP4&#10;Public variable:        Debug&#10;Public functions:       Internaldate2tuple&#10;                        Int2AP&#10;                        ParseFlags&#10;                        Time2Internaldate">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.AllowedVersions" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.CRLF" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Commands" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Continuation" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.DEFAULT_BUFFER_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
        <KeyWord name="imaplib.Flags" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.HAVE_SSL" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
        <KeyWord name="imaplib.IMAP4" func="yes">
			<Overload retVal="" descr="IMAP4 client class.&#10;&#10;Instantiate with: IMAP4([host[, port]])&#10;&#10;        host - host's name (default: localhost);&#10;        port - port number (default: standard IMAP4 port).&#10;&#10;All IMAP4rev1 commands are supported by methods of the same&#10;name (in lower-case).&#10;&#10;All arguments to commands are converted to strings, except for&#10;AUTHENTICATE, and the last argument to APPEND which is passed as&#10;an IMAP4 literal.  If necessary (the string contains any&#10;non-printing characters or white-space and isn't enclosed with&#10;either parentheses or double quotes) each string is quoted.&#10;However, the 'password' argument to the LOGIN command is always&#10;quoted.  If you want to avoid having an argument string quoted&#10;(eg: the 'flags' argument to STORE) then enclose the string in&#10;parentheses (eg: &quot;(\Deleted)&quot;).&#10;&#10;Each command returns a tuple: (type, [data, ...]) where 'type'&#10;is usually 'OK' or 'NO', and 'data' is either the text from the&#10;tagged response, or untagged results from command. Each 'data'&#10;is either a string, or a tuple. If a tuple, then the first part&#10;is the header of the response, and the second part contains&#10;the data (ie: 'literal' value).&#10;&#10;Errors raise the exception class &lt;instance&gt;.error(&quot;&lt;reason&gt;&quot;).&#10;IMAP4 server errors raise &lt;instance&gt;.abort(&quot;&lt;reason&gt;&quot;),&#10;which is a sub-class of 'error'. Mailbox status changes&#10;from READ-WRITE to READ-ONLY raise the exception class&#10;&lt;instance&gt;.readonly(&quot;&lt;reason&gt;&quot;), which is a sub-class of 'abort'.&#10;&#10;&quot;error&quot; exceptions imply a program error.&#10;&quot;abort&quot; exceptions imply the connection should be reset, and&#10;        the command re-tried.&#10;&quot;readonly&quot; exceptions imply the command should be re-tried.&#10;&#10;Note: to use this module, you must read the RFCs pertaining to the&#10;IMAP4 protocol, as the semantics of the arguments to each IMAP4&#10;command are left to the invoker, not to mention the results. Also,&#10;most IMAP servers implement a sub-set of the commands available here.">
			</Overload>
		</KeyWord>
        		<KeyWord name="imaplib.IMAP4.abort" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.append" func="yes">
			<Overload retVal="" descr="Append message to named mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.append(mailbox, flags, date_time, message)&#10;&#10;        All args except `message' can be None.">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="flags" />
				<Param name="date_time" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.authenticate" func="yes">
			<Overload retVal="" descr="Authenticate command - requires response processing.&#10;&#10;'mechanism' specifies which authentication mechanism is to&#10;be used - it must appear in &lt;instance&gt;.capabilities in the&#10;form AUTH=&lt;mechanism&gt;.&#10;&#10;'authobject' must be a callable object:&#10;&#10;        data = authobject(response)&#10;&#10;It will be called to process server continuation responses; the&#10;response argument it is passed will be a bytes.  It should return bytes&#10;data that will be base64 encoded and sent to the server.  It should&#10;return None if the client abort response '*' should be sent instead.">
				<Param name="self" />
				<Param name="mechanism" />
				<Param name="authobject" />
			</Overload>
		</KeyWord>
        		<KeyWord name="imaplib.IMAP4.capability" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.capability()&#10;Fetch capabilities list from server.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.check" func="yes">
			<Overload retVal="" descr="Checkpoint mailbox on server.&#10;&#10;(typ, [data]) = &lt;instance&gt;.check()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.close" func="yes">
			<Overload retVal="" descr="Close currently selected mailbox.&#10;&#10;Deleted messages are removed from writable mailbox.&#10;This is the recommended command before 'LOGOUT'.&#10;&#10;(typ, [data]) = &lt;instance&gt;.close()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.copy" func="yes">
			<Overload retVal="" descr="Copy 'message_set' messages onto end of 'new_mailbox'.&#10;&#10;(typ, [data]) = &lt;instance&gt;.copy(message_set, new_mailbox)">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="new_mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.create" func="yes">
			<Overload retVal="" descr="Create new mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.create(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.delete" func="yes">
			<Overload retVal="" descr="Delete old mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.delete(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.deleteacl" func="yes">
			<Overload retVal="" descr="Delete the ACLs (remove any rights) set for who on mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.deleteacl(mailbox, who)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="who" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.enable" func="yes">
			<Overload retVal="" descr="Send an RFC5161 enable string to the server.&#10;&#10;(typ, [data]) = &lt;intance&gt;.enable(capability)">
				<Param name="self" />
				<Param name="capability" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.expunge" func="yes">
			<Overload retVal="" descr="Permanently remove deleted items from selected mailbox.&#10;&#10;Generates 'EXPUNGE' response for each deleted message.&#10;&#10;(typ, [data]) = &lt;instance&gt;.expunge()&#10;&#10;'data' is list of 'EXPUNGE'd message numbers in order received.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.fetch" func="yes">
			<Overload retVal="" descr="Fetch (parts of) messages.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.fetch(message_set, message_parts)&#10;&#10;'message_parts' should be a string of selected parts&#10;enclosed in parentheses, eg: &quot;(UID BODY[TEXT])&quot;.&#10;&#10;'data' are tuples of message part envelope and data.">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="message_parts" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.getacl" func="yes">
			<Overload retVal="" descr="Get the ACLs for a mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.getacl(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
        <KeyWord name="imaplib.IMAP4.getannotation" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.getannotation(mailbox, entry, attribute)&#10;Retrieve ANNOTATIONs.">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="entry" />
				<Param name="attribute" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.getquota" func="yes">
			<Overload retVal="" descr="Get the quota root's resource usage and limits.&#10;&#10;Part of the IMAP4 QUOTA extension defined in rfc2087.&#10;&#10;(typ, [data]) = &lt;instance&gt;.getquota(root)">
				<Param name="self" />
				<Param name="root" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.getquotaroot" func="yes">
			<Overload retVal="" descr="Get the list of quota roots for the named mailbox.&#10;&#10;(typ, [[QUOTAROOT responses...], [QUOTA responses]]) = &lt;instance&gt;.getquotaroot(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
				<KeyWord name="imaplib.IMAP4.list" func="yes">
			<Overload retVal="" descr="List mailbox names in directory matching pattern.&#10;&#10;(typ, [data]) = &lt;instance&gt;.list(directory='&quot;&quot;', pattern='*')&#10;&#10;'data' is list of LIST responses.">
				<Param name="self" />
				<Param name="[directory=" />
				<Param name="[pattern=*]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.login" func="yes">
			<Overload retVal="" descr="Identify client using plaintext password.&#10;&#10;(typ, [data]) = &lt;instance&gt;.login(user, password)&#10;&#10;NB: 'password' will be quoted.">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.login_cram_md5" func="yes">
			<Overload retVal="" descr="Force use of CRAM-MD5 authentication.&#10;&#10;(typ, [data]) = &lt;instance&gt;.login_cram_md5(user, password)">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.logout" func="yes">
			<Overload retVal="" descr="Shutdown connection to server.&#10;&#10;(typ, [data]) = &lt;instance&gt;.logout()&#10;&#10;Returns server 'BYE' response.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.lsub" func="yes">
			<Overload retVal="" descr="List 'subscribed' mailbox names in directory matching pattern.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.lsub(directory='&quot;&quot;', pattern='*')&#10;&#10;'data' are tuples of message part envelope and data.">
				<Param name="self" />
				<Param name="[directory=" />
				<Param name="[pattern=*]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.myrights" func="yes">
			<Overload retVal="" descr="Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).&#10;&#10;(typ, [data]) = &lt;instance&gt;.myrights(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.namespace" func="yes">
			<Overload retVal="" descr="Returns IMAP namespaces ala rfc2342&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.namespace()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.noop" func="yes">
			<Overload retVal="" descr="Send NOOP command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.noop()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.open" func="yes">
			<Overload retVal="" descr='Setup connection to remote server on "host:port"&#10;    (default: localhost:standard IMAP4 port).&#10;This connection will be used by the routines:&#10;    read, readline, send, shutdown.'>
				<Param name="self" />
				<Param name="[host" />
				<Param name="[port=143]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.partial" func="yes">
			<Overload retVal="" descr="Fetch truncated part of a message.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.partial(message_num, message_part, start, length)&#10;&#10;'data' is tuple of message part envelope and data.">
				<Param name="self" />
				<Param name="message_num" />
				<Param name="message_part" />
				<Param name="start" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.print_log" />
		<KeyWord name="imaplib.IMAP4.proxyauth" func="yes">
			<Overload retVal="" descr="Assume authentication as &quot;user&quot;.&#10;&#10;Allows an authorised administrator to proxy into any user's&#10;mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.proxyauth(user)">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.read" func="yes">
			<Overload retVal="" descr="Read 'size' bytes from remote.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.readline" func="yes">
			<Overload retVal="" descr="Read line from remote.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.readonly" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.recent" func="yes">
			<Overload retVal="" descr="Return most recent 'RECENT' responses if any exist,&#10;else prompt server for an update using the 'NOOP' command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.recent()&#10;&#10;'data' is None if no new messages,&#10;else list of RECENT responses, most recent last.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.rename" func="yes">
			<Overload retVal="" descr="Rename old mailbox name to new.&#10;&#10;(typ, [data]) = &lt;instance&gt;.rename(oldmailbox, newmailbox)">
				<Param name="self" />
				<Param name="oldmailbox" />
				<Param name="newmailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.response" func="yes">
			<Overload retVal="" descr="Return data for response 'code' if received, or None.&#10;&#10;Old value for response 'code' is cleared.&#10;&#10;(code, [data]) = &lt;instance&gt;.response(code)">
				<Param name="self" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.search" func="yes">
			<Overload retVal="" descr="Search mailbox for matching messages.&#10;&#10;(typ, [data]) = &lt;instance&gt;.search(charset, criterion, ...)&#10;&#10;'data' is space separated list of matching message numbers.&#10;If UTF8 is enabled, charset MUST be None.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.select" func="yes">
			<Overload retVal="" descr="Select a mailbox.&#10;&#10;Flush all untagged responses.&#10;&#10;(typ, [data]) = &lt;instance&gt;.select(mailbox='INBOX', readonly=False)&#10;&#10;'data' is count of messages in mailbox ('EXISTS' response).&#10;&#10;Mandated responses are ('FLAGS', 'EXISTS', 'RECENT', 'UIDVALIDITY'), so&#10;other responses should be obtained via &lt;instance&gt;.response('FLAGS') etc.">
				<Param name="self" />
				<Param name="[mailbox=INBOX" />
				<Param name="[readonly=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.send" func="yes">
			<Overload retVal="" descr="Send data to remote.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.setacl" func="yes">
			<Overload retVal="" descr="Set a mailbox acl.&#10;&#10;(typ, [data]) = &lt;instance&gt;.setacl(mailbox, who, what)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="who" />
				<Param name="what" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.setannotation" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.setannotation(mailbox[, entry, attribute]+)&#10;Set ANNOTATIONs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.setquota" func="yes">
			<Overload retVal="" descr="Set the quota root's resource limits.&#10;&#10;(typ, [data]) = &lt;instance&gt;.setquota(root, limits)">
				<Param name="self" />
				<Param name="root" />
				<Param name="limits" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.shutdown" func="yes">
			<Overload retVal="" descr='Close I/O established in "open".'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.socket" func="yes">
			<Overload retVal="" descr="Return socket instance used to connect to IMAP4 server.&#10;&#10;socket = &lt;instance&gt;.socket()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.sort" func="yes">
			<Overload retVal="" descr="IMAP4rev1 extension SORT command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.sort(sort_criteria, charset, search_criteria, ...)">
				<Param name="self" />
				<Param name="sort_criteria" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.starttls" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[ssl_context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.status" func="yes">
			<Overload retVal="" descr="Request named status conditions for mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.status(mailbox, names)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="names" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.store" func="yes">
			<Overload retVal="" descr="Alters flag dispositions for messages in mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.store(message_set, command, flags)">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="command" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.subscribe" func="yes">
			<Overload retVal="" descr="Subscribe to new mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.subscribe(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.thread" func="yes">
			<Overload retVal="" descr="IMAPrev1 extension THREAD command.&#10;&#10;(type, [data]) = &lt;instance&gt;.thread(threading_algorithm, charset, search_criteria, ...)">
				<Param name="self" />
				<Param name="threading_algorithm" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.uid" func="yes">
			<Overload retVal="" descr="Execute &quot;command arg ...&quot; with messages identified by UID,&#10;        rather than message number.&#10;&#10;(typ, [data]) = &lt;instance&gt;.uid(command, arg1, arg2, ...)&#10;&#10;Returns response appropriate to 'command'.">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.unsubscribe" func="yes">
			<Overload retVal="" descr="Unsubscribe from old mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.unsubscribe(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4.xatom" func="yes">
			<Overload retVal="" descr="Allow simple extension commands&#10;        notified by server in CAPABILITY response.&#10;&#10;Assumes command is legal in current state.&#10;&#10;(typ, [data]) = &lt;instance&gt;.xatom(name, arg, ...)&#10;&#10;Returns response appropriate to extension command `name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL" func="yes">
			<Overload retVal="" descr="IMAP4 client class over SSL connection&#10;&#10;Instantiate with: IMAP4_SSL([host[, port[, keyfile[, certfile[, ssl_context]]]]])&#10;&#10;        host - host's name (default: localhost);&#10;        port - port number (default: standard IMAP4 SSL port);&#10;        keyfile - PEM formatted file that contains your private key (default: None);&#10;        certfile - PEM formatted certificate chain file (default: None);&#10;        ssl_context - a SSLContext object that contains your certificate chain&#10;                      and private key (default: None)&#10;        Note: if ssl_context is provided, then parameters keyfile or&#10;        certfile should not be set otherwise ValueError is raised.&#10;&#10;for more documentation see the docstring of the parent class IMAP4.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.abort" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.append" func="yes">
			<Overload retVal="" descr="Append message to named mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.append(mailbox, flags, date_time, message)&#10;&#10;        All args except `message' can be None.">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="flags" />
				<Param name="date_time" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.authenticate" func="yes">
			<Overload retVal="" descr="Authenticate command - requires response processing.&#10;&#10;'mechanism' specifies which authentication mechanism is to&#10;be used - it must appear in &lt;instance&gt;.capabilities in the&#10;form AUTH=&lt;mechanism&gt;.&#10;&#10;'authobject' must be a callable object:&#10;&#10;        data = authobject(response)&#10;&#10;It will be called to process server continuation responses; the&#10;response argument it is passed will be a bytes.  It should return bytes&#10;data that will be base64 encoded and sent to the server.  It should&#10;return None if the client abort response '*' should be sent instead.">
				<Param name="self" />
				<Param name="mechanism" />
				<Param name="authobject" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.capability" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.capability()&#10;Fetch capabilities list from server.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.check" func="yes">
			<Overload retVal="" descr="Checkpoint mailbox on server.&#10;&#10;(typ, [data]) = &lt;instance&gt;.check()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.close" func="yes">
			<Overload retVal="" descr="Close currently selected mailbox.&#10;&#10;Deleted messages are removed from writable mailbox.&#10;This is the recommended command before 'LOGOUT'.&#10;&#10;(typ, [data]) = &lt;instance&gt;.close()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.copy" func="yes">
			<Overload retVal="" descr="Copy 'message_set' messages onto end of 'new_mailbox'.&#10;&#10;(typ, [data]) = &lt;instance&gt;.copy(message_set, new_mailbox)">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="new_mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.create" func="yes">
			<Overload retVal="" descr="Create new mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.create(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.delete" func="yes">
			<Overload retVal="" descr="Delete old mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.delete(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.deleteacl" func="yes">
			<Overload retVal="" descr="Delete the ACLs (remove any rights) set for who on mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.deleteacl(mailbox, who)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="who" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.enable" func="yes">
			<Overload retVal="" descr="Send an RFC5161 enable string to the server.&#10;&#10;(typ, [data]) = &lt;intance&gt;.enable(capability)">
				<Param name="self" />
				<Param name="capability" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.expunge" func="yes">
			<Overload retVal="" descr="Permanently remove deleted items from selected mailbox.&#10;&#10;Generates 'EXPUNGE' response for each deleted message.&#10;&#10;(typ, [data]) = &lt;instance&gt;.expunge()&#10;&#10;'data' is list of 'EXPUNGE'd message numbers in order received.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.fetch" func="yes">
			<Overload retVal="" descr="Fetch (parts of) messages.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.fetch(message_set, message_parts)&#10;&#10;'message_parts' should be a string of selected parts&#10;enclosed in parentheses, eg: &quot;(UID BODY[TEXT])&quot;.&#10;&#10;'data' are tuples of message part envelope and data.">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="message_parts" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.getacl" func="yes">
			<Overload retVal="" descr="Get the ACLs for a mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.getacl(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.getannotation" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.getannotation(mailbox, entry, attribute)&#10;Retrieve ANNOTATIONs.">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="entry" />
				<Param name="attribute" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.getquota" func="yes">
			<Overload retVal="" descr="Get the quota root's resource usage and limits.&#10;&#10;Part of the IMAP4 QUOTA extension defined in rfc2087.&#10;&#10;(typ, [data]) = &lt;instance&gt;.getquota(root)">
				<Param name="self" />
				<Param name="root" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.getquotaroot" func="yes">
			<Overload retVal="" descr="Get the list of quota roots for the named mailbox.&#10;&#10;(typ, [[QUOTAROOT responses...], [QUOTA responses]]) = &lt;instance&gt;.getquotaroot(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.list" func="yes">
			<Overload retVal="" descr="List mailbox names in directory matching pattern.&#10;&#10;(typ, [data]) = &lt;instance&gt;.list(directory='&quot;&quot;', pattern='*')&#10;&#10;'data' is list of LIST responses.">
				<Param name="self" />
				<Param name="[directory=" />
				<Param name="[pattern=*]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.login" func="yes">
			<Overload retVal="" descr="Identify client using plaintext password.&#10;&#10;(typ, [data]) = &lt;instance&gt;.login(user, password)&#10;&#10;NB: 'password' will be quoted.">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.login_cram_md5" func="yes">
			<Overload retVal="" descr="Force use of CRAM-MD5 authentication.&#10;&#10;(typ, [data]) = &lt;instance&gt;.login_cram_md5(user, password)">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.logout" func="yes">
			<Overload retVal="" descr="Shutdown connection to server.&#10;&#10;(typ, [data]) = &lt;instance&gt;.logout()&#10;&#10;Returns server 'BYE' response.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.lsub" func="yes">
			<Overload retVal="" descr="List 'subscribed' mailbox names in directory matching pattern.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.lsub(directory='&quot;&quot;', pattern='*')&#10;&#10;'data' are tuples of message part envelope and data.">
				<Param name="self" />
				<Param name="[directory=" />
				<Param name="[pattern=*]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.myrights" func="yes">
			<Overload retVal="" descr="Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).&#10;&#10;(typ, [data]) = &lt;instance&gt;.myrights(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.namespace" func="yes">
			<Overload retVal="" descr="Returns IMAP namespaces ala rfc2342&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.namespace()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.noop" func="yes">
			<Overload retVal="" descr="Send NOOP command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.noop()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.open" func="yes">
			<Overload retVal="" descr='Setup connection to remote server on "host:port".&#10;    (default: localhost:standard IMAP4 SSL port).&#10;This connection will be used by the routines:&#10;    read, readline, send, shutdown.'>
				<Param name="self" />
				<Param name="[host" />
				<Param name="[port=993]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.partial" func="yes">
			<Overload retVal="" descr="Fetch truncated part of a message.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.partial(message_num, message_part, start, length)&#10;&#10;'data' is tuple of message part envelope and data.">
				<Param name="self" />
				<Param name="message_num" />
				<Param name="message_part" />
				<Param name="start" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.print_log" />
		<KeyWord name="imaplib.IMAP4_SSL.proxyauth" func="yes">
			<Overload retVal="" descr="Assume authentication as &quot;user&quot;.&#10;&#10;Allows an authorised administrator to proxy into any user's&#10;mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.proxyauth(user)">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.read" func="yes">
			<Overload retVal="" descr="Read 'size' bytes from remote.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.readline" func="yes">
			<Overload retVal="" descr="Read line from remote.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.readonly" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.recent" func="yes">
			<Overload retVal="" descr="Return most recent 'RECENT' responses if any exist,&#10;else prompt server for an update using the 'NOOP' command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.recent()&#10;&#10;'data' is None if no new messages,&#10;else list of RECENT responses, most recent last.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.rename" func="yes">
			<Overload retVal="" descr="Rename old mailbox name to new.&#10;&#10;(typ, [data]) = &lt;instance&gt;.rename(oldmailbox, newmailbox)">
				<Param name="self" />
				<Param name="oldmailbox" />
				<Param name="newmailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.response" func="yes">
			<Overload retVal="" descr="Return data for response 'code' if received, or None.&#10;&#10;Old value for response 'code' is cleared.&#10;&#10;(code, [data]) = &lt;instance&gt;.response(code)">
				<Param name="self" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.search" func="yes">
			<Overload retVal="" descr="Search mailbox for matching messages.&#10;&#10;(typ, [data]) = &lt;instance&gt;.search(charset, criterion, ...)&#10;&#10;'data' is space separated list of matching message numbers.&#10;If UTF8 is enabled, charset MUST be None.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.select" func="yes">
			<Overload retVal="" descr="Select a mailbox.&#10;&#10;Flush all untagged responses.&#10;&#10;(typ, [data]) = &lt;instance&gt;.select(mailbox='INBOX', readonly=False)&#10;&#10;'data' is count of messages in mailbox ('EXISTS' response).&#10;&#10;Mandated responses are ('FLAGS', 'EXISTS', 'RECENT', 'UIDVALIDITY'), so&#10;other responses should be obtained via &lt;instance&gt;.response('FLAGS') etc.">
				<Param name="self" />
				<Param name="[mailbox=INBOX" />
				<Param name="[readonly=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.send" func="yes">
			<Overload retVal="" descr="Send data to remote.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.setacl" func="yes">
			<Overload retVal="" descr="Set a mailbox acl.&#10;&#10;(typ, [data]) = &lt;instance&gt;.setacl(mailbox, who, what)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="who" />
				<Param name="what" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.setannotation" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.setannotation(mailbox[, entry, attribute]+)&#10;Set ANNOTATIONs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.setquota" func="yes">
			<Overload retVal="" descr="Set the quota root's resource limits.&#10;&#10;(typ, [data]) = &lt;instance&gt;.setquota(root, limits)">
				<Param name="self" />
				<Param name="root" />
				<Param name="limits" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.shutdown" func="yes">
			<Overload retVal="" descr='Close I/O established in "open".'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.socket" func="yes">
			<Overload retVal="" descr="Return socket instance used to connect to IMAP4 server.&#10;&#10;socket = &lt;instance&gt;.socket()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.sort" func="yes">
			<Overload retVal="" descr="IMAP4rev1 extension SORT command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.sort(sort_criteria, charset, search_criteria, ...)">
				<Param name="self" />
				<Param name="sort_criteria" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.starttls" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[ssl_context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.status" func="yes">
			<Overload retVal="" descr="Request named status conditions for mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.status(mailbox, names)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="names" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.store" func="yes">
			<Overload retVal="" descr="Alters flag dispositions for messages in mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.store(message_set, command, flags)">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="command" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.subscribe" func="yes">
			<Overload retVal="" descr="Subscribe to new mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.subscribe(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.thread" func="yes">
			<Overload retVal="" descr="IMAPrev1 extension THREAD command.&#10;&#10;(type, [data]) = &lt;instance&gt;.thread(threading_algorithm, charset, search_criteria, ...)">
				<Param name="self" />
				<Param name="threading_algorithm" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.uid" func="yes">
			<Overload retVal="" descr="Execute &quot;command arg ...&quot; with messages identified by UID,&#10;        rather than message number.&#10;&#10;(typ, [data]) = &lt;instance&gt;.uid(command, arg1, arg2, ...)&#10;&#10;Returns response appropriate to 'command'.">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.unsubscribe" func="yes">
			<Overload retVal="" descr="Unsubscribe from old mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.unsubscribe(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL.xatom" func="yes">
			<Overload retVal="" descr="Allow simple extension commands&#10;        notified by server in CAPABILITY response.&#10;&#10;Assumes command is legal in current state.&#10;&#10;(typ, [data]) = &lt;instance&gt;.xatom(name, arg, ...)&#10;&#10;Returns response appropriate to extension command `name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream" func="yes">
			<Overload retVal="" descr='IMAP4 client class over a stream&#10;&#10;Instantiate with: IMAP4_stream(command)&#10;&#10;        "command" - a string that can be passed to subprocess.Popen()&#10;&#10;for more documentation see the docstring of the parent class IMAP4.'>
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.abort" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.append" func="yes">
			<Overload retVal="" descr="Append message to named mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.append(mailbox, flags, date_time, message)&#10;&#10;        All args except `message' can be None.">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="flags" />
				<Param name="date_time" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.authenticate" func="yes">
			<Overload retVal="" descr="Authenticate command - requires response processing.&#10;&#10;'mechanism' specifies which authentication mechanism is to&#10;be used - it must appear in &lt;instance&gt;.capabilities in the&#10;form AUTH=&lt;mechanism&gt;.&#10;&#10;'authobject' must be a callable object:&#10;&#10;        data = authobject(response)&#10;&#10;It will be called to process server continuation responses; the&#10;response argument it is passed will be a bytes.  It should return bytes&#10;data that will be base64 encoded and sent to the server.  It should&#10;return None if the client abort response '*' should be sent instead.">
				<Param name="self" />
				<Param name="mechanism" />
				<Param name="authobject" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.capability" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.capability()&#10;Fetch capabilities list from server.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.check" func="yes">
			<Overload retVal="" descr="Checkpoint mailbox on server.&#10;&#10;(typ, [data]) = &lt;instance&gt;.check()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.close" func="yes">
			<Overload retVal="" descr="Close currently selected mailbox.&#10;&#10;Deleted messages are removed from writable mailbox.&#10;This is the recommended command before 'LOGOUT'.&#10;&#10;(typ, [data]) = &lt;instance&gt;.close()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.copy" func="yes">
			<Overload retVal="" descr="Copy 'message_set' messages onto end of 'new_mailbox'.&#10;&#10;(typ, [data]) = &lt;instance&gt;.copy(message_set, new_mailbox)">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="new_mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.create" func="yes">
			<Overload retVal="" descr="Create new mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.create(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.delete" func="yes">
			<Overload retVal="" descr="Delete old mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.delete(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.deleteacl" func="yes">
			<Overload retVal="" descr="Delete the ACLs (remove any rights) set for who on mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.deleteacl(mailbox, who)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="who" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.enable" func="yes">
			<Overload retVal="" descr="Send an RFC5161 enable string to the server.&#10;&#10;(typ, [data]) = &lt;intance&gt;.enable(capability)">
				<Param name="self" />
				<Param name="capability" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.expunge" func="yes">
			<Overload retVal="" descr="Permanently remove deleted items from selected mailbox.&#10;&#10;Generates 'EXPUNGE' response for each deleted message.&#10;&#10;(typ, [data]) = &lt;instance&gt;.expunge()&#10;&#10;'data' is list of 'EXPUNGE'd message numbers in order received.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.fetch" func="yes">
			<Overload retVal="" descr="Fetch (parts of) messages.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.fetch(message_set, message_parts)&#10;&#10;'message_parts' should be a string of selected parts&#10;enclosed in parentheses, eg: &quot;(UID BODY[TEXT])&quot;.&#10;&#10;'data' are tuples of message part envelope and data.">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="message_parts" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.getacl" func="yes">
			<Overload retVal="" descr="Get the ACLs for a mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.getacl(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.getannotation" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.getannotation(mailbox, entry, attribute)&#10;Retrieve ANNOTATIONs.">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="entry" />
				<Param name="attribute" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.getquota" func="yes">
			<Overload retVal="" descr="Get the quota root's resource usage and limits.&#10;&#10;Part of the IMAP4 QUOTA extension defined in rfc2087.&#10;&#10;(typ, [data]) = &lt;instance&gt;.getquota(root)">
				<Param name="self" />
				<Param name="root" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.getquotaroot" func="yes">
			<Overload retVal="" descr="Get the list of quota roots for the named mailbox.&#10;&#10;(typ, [[QUOTAROOT responses...], [QUOTA responses]]) = &lt;instance&gt;.getquotaroot(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.list" func="yes">
			<Overload retVal="" descr="List mailbox names in directory matching pattern.&#10;&#10;(typ, [data]) = &lt;instance&gt;.list(directory='&quot;&quot;', pattern='*')&#10;&#10;'data' is list of LIST responses.">
				<Param name="self" />
				<Param name="[directory=" />
				<Param name="[pattern=*]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.login" func="yes">
			<Overload retVal="" descr="Identify client using plaintext password.&#10;&#10;(typ, [data]) = &lt;instance&gt;.login(user, password)&#10;&#10;NB: 'password' will be quoted.">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.login_cram_md5" func="yes">
			<Overload retVal="" descr="Force use of CRAM-MD5 authentication.&#10;&#10;(typ, [data]) = &lt;instance&gt;.login_cram_md5(user, password)">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.logout" func="yes">
			<Overload retVal="" descr="Shutdown connection to server.&#10;&#10;(typ, [data]) = &lt;instance&gt;.logout()&#10;&#10;Returns server 'BYE' response.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.lsub" func="yes">
			<Overload retVal="" descr="List 'subscribed' mailbox names in directory matching pattern.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.lsub(directory='&quot;&quot;', pattern='*')&#10;&#10;'data' are tuples of message part envelope and data.">
				<Param name="self" />
				<Param name="[directory=" />
				<Param name="[pattern=*]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.myrights" func="yes">
			<Overload retVal="" descr="Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).&#10;&#10;(typ, [data]) = &lt;instance&gt;.myrights(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.namespace" func="yes">
			<Overload retVal="" descr="Returns IMAP namespaces ala rfc2342&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.namespace()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.noop" func="yes">
			<Overload retVal="" descr="Send NOOP command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.noop()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.open" func="yes">
			<Overload retVal="" descr="Setup a stream connection.&#10;This connection will be used by the routines:&#10;    read, readline, send, shutdown.">
				<Param name="self" />
				<Param name="[host=None" />
				<Param name="[port=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.partial" func="yes">
			<Overload retVal="" descr="Fetch truncated part of a message.&#10;&#10;(typ, [data, ...]) = &lt;instance&gt;.partial(message_num, message_part, start, length)&#10;&#10;'data' is tuple of message part envelope and data.">
				<Param name="self" />
				<Param name="message_num" />
				<Param name="message_part" />
				<Param name="start" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.print_log" />
		<KeyWord name="imaplib.IMAP4_stream.proxyauth" func="yes">
			<Overload retVal="" descr="Assume authentication as &quot;user&quot;.&#10;&#10;Allows an authorised administrator to proxy into any user's&#10;mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.proxyauth(user)">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.read" func="yes">
			<Overload retVal="" descr="Read 'size' bytes from remote.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.readline" func="yes">
			<Overload retVal="" descr="Read line from remote.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.readonly" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.recent" func="yes">
			<Overload retVal="" descr="Return most recent 'RECENT' responses if any exist,&#10;else prompt server for an update using the 'NOOP' command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.recent()&#10;&#10;'data' is None if no new messages,&#10;else list of RECENT responses, most recent last.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.rename" func="yes">
			<Overload retVal="" descr="Rename old mailbox name to new.&#10;&#10;(typ, [data]) = &lt;instance&gt;.rename(oldmailbox, newmailbox)">
				<Param name="self" />
				<Param name="oldmailbox" />
				<Param name="newmailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.response" func="yes">
			<Overload retVal="" descr="Return data for response 'code' if received, or None.&#10;&#10;Old value for response 'code' is cleared.&#10;&#10;(code, [data]) = &lt;instance&gt;.response(code)">
				<Param name="self" />
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.search" func="yes">
			<Overload retVal="" descr="Search mailbox for matching messages.&#10;&#10;(typ, [data]) = &lt;instance&gt;.search(charset, criterion, ...)&#10;&#10;'data' is space separated list of matching message numbers.&#10;If UTF8 is enabled, charset MUST be None.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.select" func="yes">
			<Overload retVal="" descr="Select a mailbox.&#10;&#10;Flush all untagged responses.&#10;&#10;(typ, [data]) = &lt;instance&gt;.select(mailbox='INBOX', readonly=False)&#10;&#10;'data' is count of messages in mailbox ('EXISTS' response).&#10;&#10;Mandated responses are ('FLAGS', 'EXISTS', 'RECENT', 'UIDVALIDITY'), so&#10;other responses should be obtained via &lt;instance&gt;.response('FLAGS') etc.">
				<Param name="self" />
				<Param name="[mailbox=INBOX" />
				<Param name="[readonly=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.send" func="yes">
			<Overload retVal="" descr="Send data to remote.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.setacl" func="yes">
			<Overload retVal="" descr="Set a mailbox acl.&#10;&#10;(typ, [data]) = &lt;instance&gt;.setacl(mailbox, who, what)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="who" />
				<Param name="what" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.setannotation" func="yes">
			<Overload retVal="" descr="(typ, [data]) = &lt;instance&gt;.setannotation(mailbox[, entry, attribute]+)&#10;Set ANNOTATIONs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.setquota" func="yes">
			<Overload retVal="" descr="Set the quota root's resource limits.&#10;&#10;(typ, [data]) = &lt;instance&gt;.setquota(root, limits)">
				<Param name="self" />
				<Param name="root" />
				<Param name="limits" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.shutdown" func="yes">
			<Overload retVal="" descr='Close I/O established in "open".'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.socket" func="yes">
			<Overload retVal="" descr="Return socket instance used to connect to IMAP4 server.&#10;&#10;socket = &lt;instance&gt;.socket()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.sort" func="yes">
			<Overload retVal="" descr="IMAP4rev1 extension SORT command.&#10;&#10;(typ, [data]) = &lt;instance&gt;.sort(sort_criteria, charset, search_criteria, ...)">
				<Param name="self" />
				<Param name="sort_criteria" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.starttls" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[ssl_context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.status" func="yes">
			<Overload retVal="" descr="Request named status conditions for mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.status(mailbox, names)">
				<Param name="self" />
				<Param name="mailbox" />
				<Param name="names" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.store" func="yes">
			<Overload retVal="" descr="Alters flag dispositions for messages in mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.store(message_set, command, flags)">
				<Param name="self" />
				<Param name="message_set" />
				<Param name="command" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.subscribe" func="yes">
			<Overload retVal="" descr="Subscribe to new mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.subscribe(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.thread" func="yes">
			<Overload retVal="" descr="IMAPrev1 extension THREAD command.&#10;&#10;(type, [data]) = &lt;instance&gt;.thread(threading_algorithm, charset, search_criteria, ...)">
				<Param name="self" />
				<Param name="threading_algorithm" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.uid" func="yes">
			<Overload retVal="" descr="Execute &quot;command arg ...&quot; with messages identified by UID,&#10;        rather than message number.&#10;&#10;(typ, [data]) = &lt;instance&gt;.uid(command, arg1, arg2, ...)&#10;&#10;Returns response appropriate to 'command'.">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.unsubscribe" func="yes">
			<Overload retVal="" descr="Unsubscribe from old mailbox.&#10;&#10;(typ, [data]) = &lt;instance&gt;.unsubscribe(mailbox)">
				<Param name="self" />
				<Param name="mailbox" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.IMAP4_stream.xatom" func="yes">
			<Overload retVal="" descr="Allow simple extension commands&#10;        notified by server in CAPABILITY response.&#10;&#10;Assumes command is legal in current state.&#10;&#10;(typ, [data]) = &lt;instance&gt;.xatom(name, arg, ...)&#10;&#10;Returns response appropriate to extension command `name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Int2AP" func="yes">
			<Overload retVal="" descr="Convert integer to A-P string representation.">
				<Param name="num" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.InternalDate" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Internaldate2tuple" func="yes">
			<Overload retVal="" descr="Parse an IMAP4 INTERNALDATE string.&#10;&#10;Return corresponding local time.  The return value is a&#10;time.struct_time tuple or None if the string has wrong format.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Literal" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.MapCRLF" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Mon2num" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Months" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.ParseFlags" func="yes">
			<Overload retVal="" descr="Convert IMAP4 flags response to python tuple.">
				<Param name="resp" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Response_code" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Time2Internaldate" func="yes">
			<Overload retVal="" descr="Convert date_time to IMAP4 INTERNALDATE representation.&#10;&#10;Return string in form: '&quot;DD-Mmm-YYYY HH:MM:SS +HHMM&quot;'.  The&#10;date_time argument can be a number (int or float) representing&#10;seconds since epoch (as returned by time.time()), a 9-tuple&#10;representing local time, an instance of time.struct_time (as&#10;returned by time.localtime()), an aware datetime instance or a&#10;double-quoted string.  In the last case, it is assumed to already&#10;be in the correct format.">
				<Param name="date_time" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Untagged_response" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.Untagged_status" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime" func="yes">
			<Overload retVal="" descr="datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])&#10;&#10;The year, month and day arguments are required. tzinfo may be None, or an&#10;instance of a tzinfo subclass. The remaining arguments may be ints.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.astimezone" func="yes">
			<Overload retVal="" descr="tz -&gt; convert to local time in new timezone tz">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.combine" func="yes">
			<Overload retVal="" descr="date, time -&gt; datetime with same date and time fields">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.date" func="yes">
			<Overload retVal="" descr="Return date object with same year, month and day.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.fold" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp[, tz] -&gt; tz's local time from POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.isoformat" func="yes">
			<Overload retVal="" descr="[sep] -&gt; string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].&#10;sep is used to separate the year from the time, and defaults to 'T'.&#10;timespec specifies what components of the time to include (allowed values are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds', and 'microseconds').">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.max" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.min" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.now" func="yes">
			<Overload retVal="" descr="Returns new datetime object representing current time local to tz.&#10;&#10;  tz&#10;    Timezone object.&#10;&#10;If no tz is specified, uses local timezone.">
				<Param name="type" />
				<Param name="[tz=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.replace" func="yes">
			<Overload retVal="" descr="Return datetime with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.strptime" func="yes">
			<Overload retVal="" descr="string, format -&gt; new datetime parsed from a string (like time.strptime()).">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.time" func="yes">
			<Overload retVal="" descr="Return time object with same time but with tzinfo=None.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.timestamp" func="yes">
			<Overload retVal="" descr="Return POSIX timestamp as float.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.timetz" func="yes">
			<Overload retVal="" descr="Return time object with same time and tzinfo.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.utcfromtimestamp" func="yes">
			<Overload retVal="" descr="Construct a naive UTC datetime from a POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.utcnow" func="yes">
			<Overload retVal="" descr="Return a new datetime representing UTC day and time.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.utctimetuple" func="yes">
			<Overload retVal="" descr="Return UTC time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.datetime.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta" func="yes">
			<Overload retVal="" descr="Difference between two datetime values.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.days" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.max" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.microseconds" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.min" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.seconds" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timedelta.total_seconds" func="yes">
			<Overload retVal="" descr="Total seconds in the duration.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone" func="yes">
			<Overload retVal="" descr="Fixed offset from UTC implementation of tzinfo.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.dst" func="yes">
			<Overload retVal="" descr="Return None.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.fromutc" func="yes">
			<Overload retVal="" descr="datetime in UTC -&gt; datetime in local time.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.max" func="yes">
			<Overload retVal="" descr="(timezone)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.min" func="yes">
			<Overload retVal="" descr="(timezone)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.tzname" func="yes">
			<Overload retVal="" descr="If name is specified when timezone is created, returns the name.  Otherwise returns offset as 'UTC(+|-)HH:MM'.">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.utc" func="yes">
			<Overload retVal="" descr="(timezone)">
			</Overload>
		</KeyWord>
		<KeyWord name="imaplib.timezone.utcoffset" func="yes">
			<Overload retVal="" descr="Return fixed offset.">
			</Overload>
		</KeyWord>
		<KeyWord name="imatmul" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr" func="yes">
			<Overload retVal="" descr="Recognize image file formats based on their first few bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.PathLike" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test" />
		<KeyWord name="imghdr.test_bmp" />
		<KeyWord name="imghdr.test_exr" />
		<KeyWord name="imghdr.test_gif" func="yes">
			<Overload retVal="" descr="GIF ('87 and '89 variants)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_jpeg" func="yes">
			<Overload retVal="" descr="JPEG data in JFIF or Exif format">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_pbm" func="yes">
			<Overload retVal="" descr="PBM (portable bitmap)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_pgm" func="yes">
			<Overload retVal="" descr="PGM (portable graymap)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_png" />
		<KeyWord name="imghdr.test_ppm" func="yes">
			<Overload retVal="" descr="PPM (portable pixmap)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_rast" func="yes">
			<Overload retVal="" descr="Sun raster file">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_rgb" func="yes">
			<Overload retVal="" descr="SGI image library">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_tiff" func="yes">
			<Overload retVal="" descr="TIFF (can be in Motorola or Intel byte order)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.test_webp" />
		<KeyWord name="imghdr.test_xbm" func="yes">
			<Overload retVal="" descr="X bitmap (X10 or X11)">
				<Param name="h" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.testall" />
		<KeyWord name="imghdr.tests" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="imghdr.what" func="yes">
			<Overload retVal="" descr=>
				<Param name="file" />
				<Param name="[h=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imod" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="imp" func="yes">
			<Overload retVal="" descr="This module provides the components needed to build your own __import__&#10;function.  Undocumented functions are obsolete.&#10;&#10;In most cases it is preferred you consider using the importlib module's&#10;functionality over this module.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.C_BUILTIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.C_EXTENSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.IMP_HOOK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.NullImporter" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Null import object.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.NullImporter.find_module" func="yes">
			<Overload retVal="" descr="Always returns None.">
				<Param name="self" />
				<Param name="fullname" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.PKG_DIRECTORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.PY_CODERESOURCE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.PY_COMPILED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.PY_FROZEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.PY_RESOURCE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.PY_SOURCE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader" func="yes">
			<Overload retVal="" descr="Loader which handles sourceless file imports.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.create_module" func="yes">
			<Overload retVal="" descr="Use default semantics for module creation.">
				<Param name="self" />
				<Param name="spec" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.exec_module" func="yes">
			<Overload retVal="" descr="Execute the module.">
				<Param name="self" />
				<Param name="module" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.get_code" />
		<KeyWord name="imp.SourcelessFileLoader.get_data" func="yes">
			<Overload retVal="" descr="Return the data from path as raw bytes.">
				<Param name="self" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.get_filename" func="yes">
			<Overload retVal="" descr="Return the path to the source file as found by the finder.">
				<Param name="self" />
				<Param name="[name=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.get_source" func="yes">
			<Overload retVal="" descr="Return None as there is no source code.">
				<Param name="self" />
				<Param name="fullname" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.is_package" func="yes">
			<Overload retVal="" descr="Concrete implementation of InspectLoader.is_package by checking if&#10;the path returned by get_filename has a filename of '__init__.py'.">
				<Param name="self" />
				<Param name="fullname" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.SourcelessFileLoader.load_module" func="yes">
			<Overload retVal="" descr="Load a module from a file.&#10;&#10;This method is deprecated.  Use exec_module() instead.">
				<Param name="self" />
				<Param name="[name=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.acquire_lock" func="yes">
			<Overload retVal="" descr="Acquires the interpreter's import lock for the current thread.&#10;&#10;This lock should be used by import hooks to ensure thread-safety when importing&#10;modules. On platforms without threads, this function does nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.cache_from_source" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Given the path to a .py file, return the path to its .pyc file.&#10;&#10;The .py file does not need to exist; this simply returns the path to the&#10;.pyc file calculated as if the .py file were imported.&#10;&#10;If debug_override is not None, then it must be a boolean and is used in&#10;place of sys.flags.optimize.&#10;&#10;If sys.implementation.cache_tag is None then NotImplementedError is raised.">
				<Param name="path" />
				<Param name="[debug_override=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.create_dynamic" func="yes">
			<Overload retVal="" descr="Create an extension module.">
				<Param name="spec" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.find_module" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Search for a module.&#10;&#10;If path is omitted or None, search for a built-in, frozen or special&#10;module and continue search in sys.path. The module name cannot&#10;contain '.'; to search for a submodule of a package, pass the&#10;submodule name and the package's __path__.">
				<Param name="name" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.get_frozen_object" func="yes">
			<Overload retVal="" descr="Create a code object for a frozen module.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.get_magic" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Return the magic number for .pyc files.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.get_suffixes" func="yes">
			<Overload retVal="" descr="**DEPRECATED**">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.get_tag" func="yes">
			<Overload retVal="" descr="Return the magic tag for .pyc files.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.init_builtin" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Load and return a built-in module by name, or None is such module doesn't&#10;exist">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.init_frozen" func="yes">
			<Overload retVal="" descr="Initializes a frozen module.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.is_builtin" func="yes">
			<Overload retVal="" descr="Returns True if the module name corresponds to a built-in module.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.is_frozen" func="yes">
			<Overload retVal="" descr="Returns True if the module name corresponds to a frozen module.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.is_frozen_package" func="yes">
			<Overload retVal="" descr="Returns True if the module name is of a frozen package.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.load_compiled" func="yes">
			<Overload retVal="" descr="**DEPRECATED**">
				<Param name="name" />
				<Param name="pathname" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.load_dynamic" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Load an extension module.">
				<Param name="name" />
				<Param name="path" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.load_module" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Load a module, given information returned by find_module().&#10;&#10;The module name must include the full package name, if any.">
				<Param name="name" />
				<Param name="file" />
				<Param name="filename" />
				<Param name="details" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.load_package" func="yes">
			<Overload retVal="" descr="**DEPRECATED**">
				<Param name="name" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.load_source" func="yes">
			<Overload retVal="" descr=>
				<Param name="name" />
				<Param name="pathname" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.lock_held" func="yes">
			<Overload retVal="" descr="Return True if the import lock is currently held, else False.&#10;&#10;On platforms without threads, return False.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.new_module" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Create a new module.&#10;&#10;The module is not entered into sys.modules.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.release_lock" func="yes">
			<Overload retVal="" descr="Release the interpreter's import lock.&#10;&#10;On platforms without threads, this function does nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="imp.reload" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Reload the module and return it.&#10;&#10;The module must have been successfully imported before.">
				<Param name="module" />
			</Overload>
		</KeyWord>
		<KeyWord name="imp.source_from_cache" func="yes">
			<Overload retVal="" descr="**DEPRECATED**&#10;&#10;Given the path to a .pyc. file, return the path to its .py file.&#10;&#10;The .pyc file does not need to exist; this simply returns the path to&#10;the .py file calculated to correspond to the .pyc file.  If path does&#10;not conform to PEP 3147 format, ValueError will be raised. If&#10;sys.implementation.cache_tag is None then NotImplementedError is raised.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="import" />
		<KeyWord name="import_hook" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="import_module" func="yes">
			<Overload retVal="" descr="Function of importlib">
			</Overload>
		</KeyWord>
		<KeyWord name="importfile" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="importlib" func="yes">
			<Overload retVal="" descr="A pure Python implementation of import.">
			</Overload>
		</KeyWord>
		<KeyWord name="importlib.find_loader" func="yes">
			<Overload retVal="" descr="Return the loader for the specified module.&#10;&#10;This is a backward-compatible wrapper around find_spec().&#10;&#10;This function is deprecated in favor of importlib.util.find_spec().">
				<Param name="name" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="importlib.import_module" func="yes">
			<Overload retVal="" descr="Import a module.&#10;&#10;The 'package' argument is required when performing a relative import. It&#10;specifies the package to use as the anchor point from which to resolve the&#10;relative import to an absolute import.">
				<Param name="name" />
				<Param name="[package=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="importlib.invalidate_caches" func="yes">
			<Overload retVal="" descr="Call the invalidate_caches() method on all meta path finders stored in&#10;sys.meta_path (where implemented).">
			</Overload>
		</KeyWord>
		<KeyWord name="importlib.reload" func="yes">
			<Overload retVal="" descr="Reload the module and return it.&#10;&#10;The module must have been successfully imported before.">
				<Param name="module" />
			</Overload>
		</KeyWord>
		<KeyWord name="imul" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="in" />
		<KeyWord name="in_table_a1" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_b1" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c11" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c11_c12" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c12" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c21" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c21_c22" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c22" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c3" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c4" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c5" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c6" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c7" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c8" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_c9" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_d1" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="in_table_d2" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="include" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="include_binary" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="include_by_default" func="yes">
			<Overload retVal="" descr="Function of setuptools.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="include_feature" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="include_in" func="yes">
			<Overload retVal="" descr="Function of setuptools.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="increment_lineno" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="indent" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="indent_level" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="indent_lines" func="yes">
			<Overload retVal="" descr="Function of pip.UpdatingDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="indentsize" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="indexOf" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="indices" func="yes">
			<Overload retVal="" descr="S.indices(len) -&gt; (start, stop, stride)&#10;&#10;Assuming a sequence of length len, calculate the start and stop&#10;indices, and the stride length of the extended slice described by&#10;S. Out of bounds indices are clipped in a manner consistent with the&#10;handling of normal slices.">
			</Overload>
		</KeyWord>
		<KeyWord name="inet_aton" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="inet_ntoa" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="inet_ntop" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="inet_pton" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="info" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="infolist" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="init" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="init_builtin" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="init_database" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="init_frozen" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="initfp" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="initialize_options" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="initiate_send" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="initlog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="inode" func="yes">
			<Overload retVal="" descr="Function of os.DirEntry">
			</Overload>
		</KeyWord>
		<KeyWord name="input" func="yes">
			<Overload retVal="" descr="Read a string from standard input.  The trailing newline is stripped.&#10;&#10;The prompt string, if given, is printed to standard output without a&#10;trailing newline before reading input.&#10;&#10;If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.&#10;On *nix systems, readline is used if available.">
				<Param name="prompt" />
			</Overload>
		</KeyWord>
		<KeyWord name="insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="insert_on" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="insert_option_group" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="insort" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="insort_left" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="insort_right" func="yes">
			<Overload retVal="" descr="Function of bisect">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect" func="yes">
			<Overload retVal="" descr="Get useful information from live Python objects.&#10;&#10;This module encapsulates the interface provided by the internal special&#10;attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.&#10;It also provides some help for examining source code and class layout.&#10;&#10;Here are some of the useful functions provided by this module:&#10;&#10;    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),&#10;        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),&#10;        isroutine() - check object types&#10;    getmembers() - get members of an object that satisfy a given condition&#10;&#10;    getfile(), getsourcefile(), getsource() - find an object's source code&#10;    getdoc(), getcomments() - get documentation on an object&#10;    getmodule() - determine the module that an object came from&#10;    getclasstree() - arrange classes so as to represent their hierarchy&#10;&#10;    getargvalues(), getcallargs() - get info about function arguments&#10;    getfullargspec() - same, with support for Python 3 features&#10;    formatargspec(), formatargvalues() - format an argument spec&#10;    getouterframes(), getinnerframes() - get info about frames&#10;    currentframe() - get the current stack frame&#10;    stack(), trace() - get info about frames on the stack or in a traceback&#10;&#10;    signature() - get a Signature object for the callable">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo" func="yes">
			<Overload retVal="" descr="ArgInfo(args, varargs, keywords, locals)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.keywords" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.locals" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgInfo.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec" func="yes">
			<Overload retVal="" descr="ArgSpec(args, varargs, keywords, defaults)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.defaults" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.keywords" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ArgSpec.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments" func="yes">
			<Overload retVal="" descr="Arguments(args, varargs, varkw)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Arguments.varkw" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute" func="yes">
			<Overload retVal="" descr="Attribute(name, kind, defining_class, object)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.defining_class" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.kind" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Attribute.object" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BlockFinder" func="yes">
			<Overload retVal="" descr="Provide a tokeneater() method to detect the end of a code block.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BlockFinder.tokeneater" />
		<KeyWord name="inspect.BoundArguments" func="yes">
			<Overload retVal="" descr="Result of `Signature.bind` call.  Holds the mapping of arguments&#10;to the function's parameters.&#10;&#10;Has the following public attributes:&#10;&#10;* arguments : OrderedDict&#10;    An ordered mutable mapping of parameters' names to arguments' values.&#10;    Does not contain arguments' default values.&#10;* signature : Signature&#10;    The Signature object that created this instance.&#10;* args : tuple&#10;    Tuple of positional arguments values.&#10;* kwargs : dict&#10;    Dict of keyword arguments values.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BoundArguments.apply_defaults" func="yes">
			<Overload retVal="" descr="Set default values for missing arguments.&#10;&#10;For variable-positional arguments (*args) the default is an&#10;empty tuple.&#10;&#10;For variable-keyword arguments (**kwargs) the default is an&#10;empty dict.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BoundArguments.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BoundArguments.arguments" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BoundArguments.kwargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.BoundArguments.signature" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CORO_CLOSED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CORO_CREATED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CORO_RUNNING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CORO_SUSPENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_ASYNC_GENERATOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_COROUTINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_GENERATOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_ITERABLE_COROUTINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_NESTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_NEWLOCALS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_NOFREE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_OPTIMIZED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_VARARGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.CO_VARKEYWORDS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars" func="yes">
			<Overload retVal="" descr="ClosureVars(nonlocals, globals, builtins, unbound)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars.builtins" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars.globals" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars.nonlocals" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ClosureVars.unbound" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.EndOfBlock" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.EndOfBlock.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.EndOfBlock.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo" func="yes">
			<Overload retVal="" descr="FrameInfo(frame, filename, lineno, function, code_context, index)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.code_context" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.filename" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.frame" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.function" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.index" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FrameInfo.lineno" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec" func="yes">
			<Overload retVal="" descr="FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.annotations" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.args" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.defaults" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.kwonlyargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.kwonlydefaults" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.varargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.FullArgSpec.varkw" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.GEN_CLOSED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.GEN_CREATED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.GEN_RUNNING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.GEN_SUSPENDED" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict" func="yes">
			<Overload retVal="" descr="Dictionary that remembers insertion order">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.clear" func="yes">
			<Overload retVal="" descr="od.clear() -&gt; None.  Remove all items from od.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.copy" func="yes">
			<Overload retVal="" descr="od.copy() -&gt; a shallow copy of od">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.fromkeys" func="yes">
			<Overload retVal="" descr="OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.&#10;If not specified, the value defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.move_to_end" func="yes">
			<Overload retVal="" descr="Move an existing element to the end (or beginning if last==False).&#10;&#10;Raises KeyError if the element does not exist.&#10;When last=True, acts like a fast version of self[key]=self.pop(key).">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.pop" func="yes">
			<Overload retVal="" descr="od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding&#10;value.  If key is not found, d is returned if given, otherwise KeyError&#10;is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.popitem" func="yes">
			<Overload retVal="" descr="Remove and return a (key, value) pair from the dictionary.&#10;&#10;Pairs are returned in LIFO order if last is true or FIFO order if false.">
				<Param name="self" />
				<Param name="[last=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.setdefault" func="yes">
			<Overload retVal="" descr="od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.OrderedDict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter" func="yes">
			<Overload retVal="" descr="Represents a parameter in a function signature.&#10;&#10;Has the following public attributes:&#10;&#10;* name : str&#10;    The name of the parameter as a string.&#10;* default : object&#10;    The default value for the parameter if specified.  If the&#10;    parameter has no default value, this attribute is set to&#10;    `Parameter.empty`.&#10;* annotation&#10;    The annotation for the parameter if specified.  If the&#10;    parameter has no annotation, this attribute is set to&#10;    `Parameter.empty`.&#10;* kind : str&#10;    Describes how argument values are bound to the parameter.&#10;    Possible values: `Parameter.POSITIONAL_ONLY`,&#10;    `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,&#10;    `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.KEYWORD_ONLY" func="yes">
			<Overload retVal="" descr="(_ParameterKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.POSITIONAL_OR_KEYWORD" func="yes">
			<Overload retVal="" descr="(_ParameterKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.VAR_KEYWORD" func="yes">
			<Overload retVal="" descr="(_ParameterKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.VAR_POSITIONAL" func="yes">
			<Overload retVal="" descr="(_ParameterKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.annotation" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.default" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.empty" func="yes">
			<Overload retVal="" descr="Marker object for Signature.empty and Parameter.empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.kind" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Parameter.replace" func="yes">
			<Overload retVal="" descr="Creates a customized copy of the Parameter.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature" func="yes">
			<Overload retVal="" descr="A Signature object represents the overall signature of a function.&#10;It stores a Parameter object for each parameter accepted by the&#10;function, as well as information specific to the function itself.&#10;&#10;A Signature object has the following public attributes and methods:&#10;&#10;* parameters : OrderedDict&#10;    An ordered mapping of parameters' names to the corresponding&#10;    Parameter objects (keyword-only arguments are in the same order&#10;    as listed in `code.co_varnames`).&#10;* return_annotation : object&#10;    The annotation for the return type of the function if specified.&#10;    If the function has no annotation for its return type, this&#10;    attribute is set to `Signature.empty`.&#10;* bind(*args, **kwargs) -&gt; BoundArguments&#10;    Creates a mapping from positional and keyword arguments to&#10;    parameters.&#10;* bind_partial(*args, **kwargs) -&gt; BoundArguments&#10;    Creates a partial mapping from positional and keyword arguments&#10;    to parameters (simulating 'functools.partial' behavior.)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.bind" func="yes">
			<Overload retVal="" descr="Get a BoundArguments object, that maps the passed `args`&#10;and `kwargs` to the function's signature.  Raises `TypeError`&#10;if the passed arguments can not be bound.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.bind_partial" func="yes">
			<Overload retVal="" descr="Get a BoundArguments object, that partially maps the&#10;passed `args` and `kwargs` to the function's signature.&#10;Raises `TypeError` if the passed arguments can not be bound.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.empty" func="yes">
			<Overload retVal="" descr="Marker object for Signature.empty and Parameter.empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.from_builtin" func="yes">
			<Overload retVal="" descr="Constructs Signature for the given builtin function.">
				<Param name="cls" />
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.from_callable" func="yes">
			<Overload retVal="" descr="Constructs Signature for the given callable object.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.from_function" func="yes">
			<Overload retVal="" descr="Constructs Signature for the given python function.">
				<Param name="cls" />
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.parameters" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.replace" func="yes">
			<Overload retVal="" descr="Creates a customized copy of the Signature.&#10;Pass 'parameters' and/or 'return_annotation' arguments&#10;to override them in the new copy.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Signature.return_annotation" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.TPFLAGS_IS_ABSTRACT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback" func="yes">
			<Overload retVal="" descr="Traceback(filename, lineno, function, code_context, index)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.code_context" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.filename" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.function" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.index" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.Traceback.lineno" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.attrgetter" func="yes">
			<Overload retVal="" descr="attrgetter(attr, ...) --&gt; attrgetter object&#10;&#10;Return a callable object that fetches the given attribute(s) from its operand.&#10;After f = attrgetter('name'), the call f(r) returns r.name.&#10;After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).&#10;After h = attrgetter('name.first', 'name.last'), the call h(r) returns&#10;(r.name.first, r.name.last).">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.classify_class_attrs" func="yes">
			<Overload retVal="" descr="Return list of attribute-descriptor tuples.&#10;&#10;For each name in dir(cls), the return list contains a 4-tuple&#10;with these elements:&#10;&#10;    0. The name (a string).&#10;&#10;    1. The kind of attribute this is, one of these strings:&#10;           'class method'    created via classmethod()&#10;           'static method'   created via staticmethod()&#10;           'property'        created via property()&#10;           'method'          any other flavor of method or descriptor&#10;           'data'            not a method&#10;&#10;    2. The class which defined this attribute (a class).&#10;&#10;    3. The object as obtained by calling getattr; if this fails, or if the&#10;       resulting object does not live anywhere in the class' mro (including&#10;       metaclasses) then the object is looked up in the defining class's&#10;       dict (found by walking the mro).&#10;&#10;If one of the items in dir(cls) is stored in the metaclass it will now&#10;be discovered and not have None be listed as the class in which it was&#10;defined.  Any items whose home class cannot be discovered are skipped.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.cleandoc" func="yes">
			<Overload retVal="" descr="Clean up indentation from docstrings.&#10;&#10;Any whitespace that can be uniformly removed from the second line&#10;onwards is removed.">
				<Param name="doc" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.currentframe" func="yes">
			<Overload retVal="" descr="Return the frame of the caller or None if this is not possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.findsource" func="yes">
			<Overload retVal="" descr="Return the entire source file and starting line number for an object.&#10;&#10;The argument may be a module, class, method, function, traceback, frame,&#10;or code object.  The source code is returned as a list of all the lines&#10;in the file and the line number indexes a line in that list.  An OSError&#10;is raised if the source code cannot be retrieved.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.formatannotation" func="yes">
			<Overload retVal="" descr=>
				<Param name="annotation" />
				<Param name="[base_module=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.formatannotationrelativeto" />
		<KeyWord name="inspect.formatargspec" func="yes">
			<Overload retVal="" descr="Format an argument spec from the values returned by getfullargspec.&#10;&#10;The first seven arguments are (args, varargs, varkw, defaults,&#10;kwonlyargs, kwonlydefaults, annotations).  The other five arguments&#10;are the corresponding optional formatting functions that are called to&#10;turn names and values into strings.  The last argument is an optional&#10;function to format the sequence of arguments.">
				<Param name="args" />
				<Param name="[varargs=None" />
				<Param name="[varkw=None" />
				<Param name="[defaults=None" />
				<Param name="[kwonlyargs=()" />
				<Param name="[kwonlydefaults={}" />
				<Param name="[annotations={}" />
				<Param name="[formatarg=<class 'str'>" />
				<Param name="[formatvarargs=<function <lambda> at 0x02E3BCD8>" />
				<Param name="[formatvarkw=<function <lambda> at 0x02E3BD20>" />
				<Param name="[formatvalue=<function <lambda> at 0x02E3BD68>" />
				<Param name="[formatreturns=<function <lambda> at 0x02E3BDB0>" />
				<Param name="[formatannotation=<function formatannotation at 0x02E3B468>]]]]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.formatargvalues" func="yes">
			<Overload retVal="" descr="Format an argument spec from the 4 values returned by getargvalues.&#10;&#10;The first four arguments are (args, varargs, varkw, locals).  The&#10;next four arguments are the corresponding optional formatting functions&#10;that are called to turn names and values into strings.  The ninth&#10;argument is an optional function to format the sequence of arguments.">
				<Param name="args" />
				<Param name="varargs" />
				<Param name="varkw" />
				<Param name="locals" />
				<Param name="[formatarg=<class 'str'>" />
				<Param name="[formatvarargs=<function <lambda> at 0x02E3BE40>" />
				<Param name="[formatvarkw=<function <lambda> at 0x02E3BE88>" />
				<Param name="[formatvalue=<function <lambda> at 0x02E3BED0>]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getabsfile" func="yes">
			<Overload retVal="" descr="Return an absolute path to the source or compiled file for an object.&#10;&#10;The idea is for each object to have a unique origin, so this routine&#10;normalizes the result as much as possible.">
				<Param name="object" />
				<Param name="[_filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getargs" func="yes">
			<Overload retVal="" descr="Get information about the arguments accepted by a code object.&#10;&#10;Three things are returned: (args, varargs, varkw), where&#10;'args' is the list of argument names. Keyword-only arguments are&#10;appended. 'varargs' and 'varkw' are the names of the * and **&#10;arguments or None.">
				<Param name="co" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getargspec" func="yes">
			<Overload retVal="" descr="Get the names and default values of a function's parameters.&#10;&#10;A tuple of four things is returned: (args, varargs, keywords, defaults).&#10;'args' is a list of the argument names, including keyword-only argument names.&#10;'varargs' and 'keywords' are the names of the * and ** parameters or None.&#10;'defaults' is an n-tuple of the default values of the last n parameters.&#10;&#10;This function is deprecated, as it does not support annotations or&#10;keyword-only parameters and will raise ValueError if either is present&#10;on the supplied callable.&#10;&#10;For a more structured introspection API, use inspect.signature() instead.&#10;&#10;Alternatively, use getfullargspec() for an API with a similar namedtuple&#10;based interface, but full support for annotations and keyword-only&#10;parameters.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getargvalues" func="yes">
			<Overload retVal="" descr="Get information about arguments passed into a particular frame.&#10;&#10;A tuple of four things is returned: (args, varargs, varkw, locals).&#10;'args' is a list of the argument names.&#10;'varargs' and 'varkw' are the names of the * and ** arguments or None.&#10;'locals' is the locals dictionary of the given frame.">
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getattr_static" func="yes">
			<Overload retVal="" descr="Retrieve attributes without triggering dynamic lookup via the&#10;descriptor protocol,  __getattr__ or __getattribute__.&#10;&#10;Note: this function may not be able to retrieve all attributes&#10;that getattr can fetch (like dynamically created attributes)&#10;and may find attributes that getattr can't (like descriptors&#10;that raise AttributeError). It can also return descriptor objects&#10;instead of instance members in some cases. See the&#10;documentation for details.">
				<Param name="obj" />
				<Param name="attr" />
				<Param name="[default=<object object at 0x02AC96E8>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getblock" func="yes">
			<Overload retVal="" descr="Extract the block of code at the top of the given list of lines.">
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getcallargs" func="yes">
			<Overload retVal="" descr="Get the mapping of arguments to values.&#10;&#10;A dict is returned, with keys the function argument names (including the&#10;names of the * and ** arguments, if any), and values the respective bound&#10;values from 'positional' and 'named'.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getclasstree" func="yes">
			<Overload retVal="" descr="Arrange the given list of classes into a hierarchy of nested lists.&#10;&#10;Where a nested list appears, it contains classes derived from the class&#10;whose entry immediately precedes the list.  Each entry is a 2-tuple&#10;containing a class and a tuple of its base classes.  If the 'unique'&#10;argument is true, exactly one entry appears in the returned structure&#10;for each class in the given list.  Otherwise, classes using multiple&#10;inheritance and their descendants will appear multiple times.">
				<Param name="classes" />
				<Param name="[unique=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getclosurevars" func="yes">
			<Overload retVal="" descr="Get the mapping of free variables to their current values.&#10;&#10;Returns a named tuple of dicts mapping the current nonlocal, global&#10;and builtin references as seen by the body of the function. A final&#10;set of unbound names that could not be resolved is also provided.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getcomments" func="yes">
			<Overload retVal="" descr="Get lines of comments immediately preceding an object's source code.&#10;&#10;Returns None when source can't be found.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getcoroutinelocals" func="yes">
			<Overload retVal="" descr="Get the mapping of coroutine local variables to their current values.&#10;&#10;A dict is returned, with the keys the local variable names and values the&#10;bound values.">
				<Param name="coroutine" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getcoroutinestate" func="yes">
			<Overload retVal="" descr="Get current state of a coroutine object.&#10;&#10;Possible states are:&#10;  CORO_CREATED: Waiting to start execution.&#10;  CORO_RUNNING: Currently being executed by the interpreter.&#10;  CORO_SUSPENDED: Currently suspended at an await expression.&#10;  CORO_CLOSED: Execution has completed.">
				<Param name="coroutine" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getdoc" func="yes">
			<Overload retVal="" descr="Get the documentation string for an object.&#10;&#10;All tabs are expanded to spaces.  To clean up docstrings that are&#10;indented to line up with blocks of code, any whitespace than can be&#10;uniformly removed from the second line onwards is removed.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getfile" func="yes">
			<Overload retVal="" descr="Work out which source or compiled file an object was defined in.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getframeinfo" func="yes">
			<Overload retVal="" descr="Get information about a frame or traceback object.&#10;&#10;A tuple of five things is returned: the filename, the line number of&#10;the current line, the function name, a list of lines of context from&#10;the source code, and the index of the current line within that list.&#10;The optional second argument specifies the number of lines of context&#10;to return, which are centered around the current line.">
				<Param name="frame" />
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getfullargspec" func="yes">
			<Overload retVal="" descr="Get the names and default values of a callable object's parameters.&#10;&#10;A tuple of seven things is returned:&#10;(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).&#10;'args' is a list of the parameter names.&#10;'varargs' and 'varkw' are the names of the * and ** parameters or None.&#10;'defaults' is an n-tuple of the default values of the last n parameters.&#10;'kwonlyargs' is a list of keyword-only parameter names.&#10;'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.&#10;'annotations' is a dictionary mapping parameter names to annotations.&#10;&#10;Notable differences from inspect.signature():&#10;  - the &quot;self&quot; parameter is always reported, even for bound methods&#10;  - wrapper chains defined by __wrapped__ *not* unwrapped automatically">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getgeneratorlocals" func="yes">
			<Overload retVal="" descr="Get the mapping of generator local variables to their current values.&#10;&#10;A dict is returned, with the keys the local variable names and values the&#10;bound values.">
				<Param name="generator" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getgeneratorstate" func="yes">
			<Overload retVal="" descr="Get current state of a generator-iterator.&#10;&#10;Possible states are:&#10;  GEN_CREATED: Waiting to start execution.&#10;  GEN_RUNNING: Currently being executed by the interpreter.&#10;  GEN_SUSPENDED: Currently suspended at a yield expression.&#10;  GEN_CLOSED: Execution has completed.">
				<Param name="generator" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getinnerframes" func="yes">
			<Overload retVal="" descr="Get a list of records for a traceback's frame and all lower frames.&#10;&#10;Each record contains a frame object, filename, line number, function&#10;name, a list of lines of context, and index within the context.">
				<Param name="tb" />
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getlineno" func="yes">
			<Overload retVal="" descr="Get the line number from a frame object, allowing for optimization.">
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmembers" func="yes">
			<Overload retVal="" descr="Return all members of an object as (name, value) pairs sorted by name.&#10;Optionally, only return members that satisfy a given predicate.">
				<Param name="object" />
				<Param name="[predicate=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmodule" func="yes">
			<Overload retVal="" descr="Return the module an object was defined in, or None if not found.">
				<Param name="object" />
				<Param name="[_filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmodulename" func="yes">
			<Overload retVal="" descr="Return the module name for a given file, or None.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getmro" func="yes">
			<Overload retVal="" descr="Return tuple of base classes (including cls) in method resolution order.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getouterframes" func="yes">
			<Overload retVal="" descr="Get a list of records for a frame and all higher (calling) frames.&#10;&#10;Each record contains a frame object, filename, line number, function&#10;name, a list of lines of context, and index within the context.">
				<Param name="frame" />
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getsource" func="yes">
			<Overload retVal="" descr="Return the text of the source code for an object.&#10;&#10;The argument may be a module, class, method, function, traceback, frame,&#10;or code object.  The source code is returned as a single string.  An&#10;OSError is raised if the source code cannot be retrieved.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getsourcefile" func="yes">
			<Overload retVal="" descr="Return the filename that can be used to locate an object's source.&#10;Return None if no way can be identified to get the source.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.getsourcelines" func="yes">
			<Overload retVal="" descr="Return a list of source lines and starting line number for an object.&#10;&#10;The argument may be a module, class, method, function, traceback, frame,&#10;or code object.  The source code is returned as a list of the lines&#10;corresponding to the object and the line number indicates where in the&#10;original source file the first line of code was found.  An OSError is&#10;raised if the source code cannot be retrieved.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.indentsize" func="yes">
			<Overload retVal="" descr="Return the indent size, in spaces, at the start of a line of text.">
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isabstract" func="yes">
			<Overload retVal="" descr="Return true if the object is an abstract base class (ABC).">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isasyncgen" func="yes">
			<Overload retVal="" descr="Return true if the object is an asynchronous generator.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isasyncgenfunction" func="yes">
			<Overload retVal="" descr='Return true if the object is an asynchronous generator function.&#10;&#10;Asynchronous generator functions are defined with "async def"&#10;syntax and have "yield" expressions in their body.'>
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isawaitable" func="yes">
			<Overload retVal="" descr="Return true if object can be passed to an ``await`` expression.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isbuiltin" func="yes">
			<Overload retVal="" descr="Return true if the object is a built-in function or method.&#10;&#10;Built-in functions and methods provide these attributes:&#10;    __doc__         documentation string&#10;    __name__        original name of this function or method&#10;    __self__        instance to which a method is bound, or None">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isclass" func="yes">
			<Overload retVal="" descr="Return true if the object is a class.&#10;&#10;Class objects provide these attributes:&#10;    __doc__         documentation string&#10;    __module__      name of module in which this class was defined">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.iscode" func="yes">
			<Overload retVal="" descr="Return true if the object is a code object.&#10;&#10;Code objects provide these attributes:&#10;    co_argcount         number of arguments (not including *, ** args&#10;                        or keyword only arguments)&#10;    co_code             string of raw compiled bytecode&#10;    co_cellvars         tuple of names of cell variables&#10;    co_consts           tuple of constants used in the bytecode&#10;    co_filename         name of file in which this code object was created&#10;    co_firstlineno      number of first line in Python source code&#10;    co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg&#10;                        | 16=nested | 32=generator | 64=nofree | 128=coroutine&#10;                        | 256=iterable_coroutine | 512=async_generator&#10;    co_freevars         tuple of names of free variables&#10;    co_kwonlyargcount   number of keyword only arguments (not including ** arg)&#10;    co_lnotab           encoded mapping of line numbers to bytecode indices&#10;    co_name             name with which this code object was defined&#10;    co_names            tuple of names of local variables&#10;    co_nlocals          number of local variables&#10;    co_stacksize        virtual machine stack space required&#10;    co_varnames         tuple of names of arguments and local variables">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.iscoroutine" func="yes">
			<Overload retVal="" descr="Return true if the object is a coroutine.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.iscoroutinefunction" func="yes">
			<Overload retVal="" descr='Return true if the object is a coroutine function.&#10;&#10;Coroutine functions are defined with "async def" syntax.'>
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isdatadescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a data descriptor.&#10;&#10;Data descriptors have both a __get__ and a __set__ attribute.  Examples are&#10;properties (defined in Python) and getsets and members (defined in C).&#10;Typically, data descriptors will also have __name__ and __doc__ attributes&#10;(properties, getsets, and members have both of these attributes), but this&#10;is not guaranteed.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isframe" func="yes">
			<Overload retVal="" descr="Return true if the object is a frame object.&#10;&#10;Frame objects provide these attributes:&#10;    f_back          next outer frame object (this frame's caller)&#10;    f_builtins      built-in namespace seen by this frame&#10;    f_code          code object being executed in this frame&#10;    f_globals       global namespace seen by this frame&#10;    f_lasti         index of last attempted instruction in bytecode&#10;    f_lineno        current line number in Python source code&#10;    f_locals        local namespace seen by this frame&#10;    f_trace         tracing function for this frame, or None">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isfunction" func="yes">
			<Overload retVal="" descr="Return true if the object is a user-defined function.&#10;&#10;Function objects provide these attributes:&#10;    __doc__         documentation string&#10;    __name__        name with which this function was defined&#10;    __code__        code object containing compiled function bytecode&#10;    __defaults__    tuple of any default values for arguments&#10;    __globals__     global namespace in which this function was defined&#10;    __annotations__ dict of parameter annotations&#10;    __kwdefaults__  dict of keyword only parameters with defaults">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isgenerator" func="yes">
			<Overload retVal="" descr='Return true if the object is a generator.&#10;&#10;Generator objects provide these attributes:&#10;    __iter__        defined to support iteration over container&#10;    close           raises a new GeneratorExit exception inside the&#10;                    generator to terminate the iteration&#10;    gi_code         code object&#10;    gi_frame        frame object or possibly None once the generator has&#10;                    been exhausted&#10;    gi_running      set to 1 when generator is executing, 0 otherwise&#10;    next            return the next item from the container&#10;    send            resumes the generator and "sends" a value that becomes&#10;                    the result of the current yield-expression&#10;    throw           used to raise an exception inside the generator'>
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isgeneratorfunction" func="yes">
			<Overload retVal="" descr="Return true if the object is a user-defined generator function.&#10;&#10;Generator function objects provide the same attributes as functions.&#10;See help(isfunction) for a list of attributes.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isgetsetdescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a getset descriptor.&#10;&#10;getset descriptors are specialized descriptors defined in extension&#10;modules.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismemberdescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a member descriptor.&#10;&#10;Member descriptors are specialized descriptors defined in extension&#10;modules.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismethod" func="yes">
			<Overload retVal="" descr="Return true if the object is an instance method.&#10;&#10;Instance method objects provide these attributes:&#10;    __doc__         documentation string&#10;    __name__        name with which this method was defined&#10;    __func__        function object containing implementation of method&#10;    __self__        instance to which this method is bound">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismethoddescriptor" func="yes">
			<Overload retVal="" descr="Return true if the object is a method descriptor.&#10;&#10;But not if ismethod() or isclass() or isfunction() are true.&#10;&#10;This is new in Python 2.2, and, for example, is true of int.__add__.&#10;An object passing this test has a __get__ attribute but not a __set__&#10;attribute, but beyond that the set of attributes varies.  __name__ is&#10;usually sensible, and __doc__ often is.&#10;&#10;Methods implemented via descriptors that also pass one of the other&#10;tests return false from the ismethoddescriptor() test, simply because&#10;the other tests promise more -- you can, e.g., count on having the&#10;__func__ attribute (etc) when an object passes ismethod().">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.ismodule" func="yes">
			<Overload retVal="" descr="Return true if the object is a module.&#10;&#10;Module objects provide these attributes:&#10;    __cached__      pathname to byte compiled file&#10;    __doc__         documentation string&#10;    __file__        filename (missing for built-in modules)">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.isroutine" func="yes">
			<Overload retVal="" descr="Return true if the object is any kind of function or method.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.istraceback" func="yes">
			<Overload retVal="" descr="Return true if the object is a traceback.&#10;&#10;Traceback objects provide these attributes:&#10;    tb_frame        frame object at this level&#10;    tb_lasti        index of last attempted instruction in bytecode&#10;    tb_lineno       current line number in Python source code&#10;    tb_next         next inner traceback object (called by this level)">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.k" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.mod_dict" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.signature" func="yes">
			<Overload retVal="" descr="Get a signature object for the passed callable.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.stack" func="yes">
			<Overload retVal="" descr="Return a list of records for the stack above the caller's frame.">
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.trace" func="yes">
			<Overload retVal="" descr="Return a list of records for the stack below the current exception.">
				<Param name="[context=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.unwrap" func="yes">
			<Overload retVal="" descr="Get the object wrapped by *func*.&#10;&#10;Follows the chain of :attr:`__wrapped__` attributes returning the last&#10;object in the chain.&#10;&#10;*stop* is an optional callback accepting an object in the wrapper chain&#10;as its sole argument that allows the unwrapping to be terminated early if&#10;the callback returns a true value. If the callback never returns a true&#10;value, the last object in the chain is returned as usual. For example,&#10;:func:`signature` uses this to stop unwrapping if any object in the&#10;chain has a ``__signature__`` attribute defined.&#10;&#10;:exc:`ValueError` is raised if a cycle is encountered.">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.v" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="inspect.walktree" func="yes">
			<Overload retVal="" descr="Recursive helper function for getclasstree().">
				<Param name="classes" />
				<Param name="children" />
				<Param name="parent" />
			</Overload>
		</KeyWord>
		<KeyWord name="install" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="installHandler" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="install_scripts" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="int" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; integer&#10;int(x, base=10) -&gt; integer&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is a number, return x.__int__().  For floating point&#10;numbers, this truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string,&#10;bytes, or bytearray instance representing an integer literal in the&#10;given base.  The literal can be preceded by '+' or '-' and be surrounded&#10;by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.&#10;Base 0 means to interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="interact" func="yes">
			<Overload retVal="" descr="Function of code">
			</Overload>
		</KeyWord>
		<KeyWord name="interaction" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="interrupt" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="intersection" func="yes">
			<Overload retVal="" descr="Return the intersection of two sets as a new set.&#10;&#10;(i.e. all elements that are in both sets.)">
			</Overload>
		</KeyWord>
		<KeyWord name="intersection_update" func="yes">
			<Overload retVal="" descr="Update a set with the intersection of itself and another.">
			</Overload>
		</KeyWord>
		<KeyWord name="intro" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="inv" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="invalid_marker" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="invalidate_caches" func="yes">
			<Overload retVal="" descr="Function of importlib">
			</Overload>
		</KeyWord>
		<KeyWord name="invert" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="io" func="yes">
			<Overload retVal="" descr="The io module provides the Python interfaces to stream handling. The&#10;builtin open function is defined in this module.&#10;&#10;At the top of the I/O hierarchy is the abstract base class IOBase. It&#10;defines the basic interface to a stream. Note, however, that there is no&#10;separation between reading and writing to streams; implementations are&#10;allowed to raise an OSError if they do not support a given operation.&#10;&#10;Extending IOBase is RawIOBase which deals simply with the reading and&#10;writing of raw bytes to a stream. FileIO subclasses RawIOBase to provide&#10;an interface to OS files.&#10;&#10;BufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its&#10;subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer&#10;streams that are readable, writable, and both respectively.&#10;BufferedRandom provides a buffered interface to random access&#10;streams. BytesIO is a simple stream of in-memory bytes.&#10;&#10;Another IOBase subclass, TextIOBase, deals with the encoding and decoding&#10;of streams into text. TextIOWrapper, which extends it, is a buffered text&#10;interface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO&#10;is an in-memory stream for text.&#10;&#10;Argument names are not part of the specification, and only the arguments&#10;of open() are intended to be used as keyword arguments.&#10;&#10;data:&#10;&#10;DEFAULT_BUFFER_SIZE&#10;&#10;   An int containing the default buffer size used by the module's buffered&#10;   I/O classes. open() uses the file's blksize (as obtained by os.stat) if&#10;   possible.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError" func="yes">
			<Overload retVal="" descr="I/O operation would block.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BlockingIOError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair" func="yes">
			<Overload retVal="" descr="A buffered reader and writer object together.&#10;&#10;A buffered reader object and buffered writer object put together to&#10;form a sequential IO object that can read and write. This is typically&#10;used with a socket or two-way pipe.&#10;&#10;reader and writer are RawIOBase objects that are readable and&#10;writeable respectively. If the buffer_size is omitted it defaults to&#10;DEFAULT_BUFFER_SIZE.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.peek" />
		<KeyWord name="io.BufferedRWPair.read" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes.&#10;&#10;If the argument is omitted, None, or negative, reads and&#10;returns all data until EOF.&#10;&#10;If the argument is positive, and the underlying raw stream is&#10;not 'interactive', multiple raw reads may be issued to satisfy&#10;the byte count (unless EOF is reached first).  But for&#10;interactive raw streams (as well as sockets and pipes), at most&#10;one raw read will be issued, and a short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.&#10;&#10;Returns None if the underlying raw stream was open in non-blocking&#10;mode and no data is available at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.read1" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes, with at most one read() call&#10;to the underlying raw stream. A short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.readinto" />
		<KeyWord name="io.BufferedRWPair.readinto1" />
		<KeyWord name="io.BufferedRWPair.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If size is specified, at most size bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.write" func="yes">
			<Overload retVal="" descr="Write the given buffer to the IO stream.&#10;&#10;Returns the number of bytes written, which is always the length of b&#10;in bytes.&#10;&#10;Raises BlockingIOError if the buffer is full and the&#10;underlying raw stream cannot accept more data at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRWPair.writelines" />
		<KeyWord name="io.BufferedRandom" func="yes">
			<Overload retVal="" descr="A buffered interface to random access streams.&#10;&#10;The constructor creates a reader and writer for a seekable stream,&#10;raw, given in the first argument. If the buffer_size is omitted it&#10;defaults to DEFAULT_BUFFER_SIZE.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.peek" />
		<KeyWord name="io.BufferedRandom.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.read" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes.&#10;&#10;If the argument is omitted, None, or negative, reads and&#10;returns all data until EOF.&#10;&#10;If the argument is positive, and the underlying raw stream is&#10;not 'interactive', multiple raw reads may be issued to satisfy&#10;the byte count (unless EOF is reached first).  But for&#10;interactive raw streams (as well as sockets and pipes), at most&#10;one raw read will be issued, and a short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.&#10;&#10;Returns None if the underlying raw stream was open in non-blocking&#10;mode and no data is available at the moment.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.read1" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes, with at most one read() call&#10;to the underlying raw stream. A short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.readinto" />
		<KeyWord name="io.BufferedRandom.readinto1" />
		<KeyWord name="io.BufferedRandom.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If size is specified, at most size bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="target" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.write" func="yes">
			<Overload retVal="" descr="Write the given buffer to the IO stream.&#10;&#10;Returns the number of bytes written, which is always the length of b&#10;in bytes.&#10;&#10;Raises BlockingIOError if the buffer is full and the&#10;underlying raw stream cannot accept more data at the moment.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedRandom.writelines" />
		<KeyWord name="io.BufferedReader" func="yes">
			<Overload retVal="" descr="Create a new buffered reader using the given readable raw IO object.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.peek" />
		<KeyWord name="io.BufferedReader.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.read" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes.&#10;&#10;If the argument is omitted, None, or negative, reads and&#10;returns all data until EOF.&#10;&#10;If the argument is positive, and the underlying raw stream is&#10;not 'interactive', multiple raw reads may be issued to satisfy&#10;the byte count (unless EOF is reached first).  But for&#10;interactive raw streams (as well as sockets and pipes), at most&#10;one raw read will be issued, and a short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.&#10;&#10;Returns None if the underlying raw stream was open in non-blocking&#10;mode and no data is available at the moment.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.read1" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes, with at most one read() call&#10;to the underlying raw stream. A short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.readinto" />
		<KeyWord name="io.BufferedReader.readinto1" />
		<KeyWord name="io.BufferedReader.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If size is specified, at most size bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="target" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.write" func="yes">
			<Overload retVal="" descr="Write the given buffer to the IO stream.&#10;&#10;Returns the number of bytes written, which is always the length of b&#10;in bytes.&#10;&#10;Raises BlockingIOError if the buffer is full and the&#10;underlying raw stream cannot accept more data at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedReader.writelines" />
		<KeyWord name="io.BufferedWriter" func="yes">
			<Overload retVal="" descr="A buffer for a writeable sequential RawIO object.&#10;&#10;The constructor creates a BufferedWriter for the given writeable raw&#10;stream. If the buffer_size is not given, it defaults to&#10;DEFAULT_BUFFER_SIZE.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.read" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes.&#10;&#10;If the argument is omitted, None, or negative, reads and&#10;returns all data until EOF.&#10;&#10;If the argument is positive, and the underlying raw stream is&#10;not 'interactive', multiple raw reads may be issued to satisfy&#10;the byte count (unless EOF is reached first).  But for&#10;interactive raw streams (as well as sockets and pipes), at most&#10;one raw read will be issued, and a short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.&#10;&#10;Returns None if the underlying raw stream was open in non-blocking&#10;mode and no data is available at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.read1" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes, with at most one read() call&#10;to the underlying raw stream. A short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.readinto" />
		<KeyWord name="io.BufferedWriter.readinto1" />
		<KeyWord name="io.BufferedWriter.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If size is specified, at most size bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="target" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.write" func="yes">
			<Overload retVal="" descr="Write the given buffer to the IO stream.&#10;&#10;Returns the number of bytes written, which is always the length of b&#10;in bytes.&#10;&#10;Raises BlockingIOError if the buffer is full and the&#10;underlying raw stream cannot accept more data at the moment.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BufferedWriter.writelines" />
		<KeyWord name="io.BytesIO" func="yes">
			<Overload retVal="" descr="Buffered I/O implementation using an in-memory bytes buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.close" func="yes">
			<Overload retVal="" descr="Disable all I/O operations.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.flush" func="yes">
			<Overload retVal="" descr="Does nothing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.getbuffer" func="yes">
			<Overload retVal="" descr="Get a read-write view over the contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.isatty" func="yes">
			<Overload retVal="" descr="Always returns False.&#10;&#10;BytesIO objects are not connected to a TTY-like device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.read1" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readinto" func="yes">
			<Overload retVal="" descr="Read bytes into buffer.&#10;&#10;Returns number of bytes read (0 for EOF), or None if the object&#10;is set not to block and has no data to read.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readinto1" />
		<KeyWord name="io.BytesIO.readline" func="yes">
			<Overload retVal="" descr="Next line from the file, as a bytes object.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.readlines" func="yes">
			<Overload retVal="" descr="List of bytes objects, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to byte offset pos relative to position indicated by whence:&#10;     0  Start of stream (the default).  pos should be &gt;= 0;&#10;     1  Current position - pos may be negative;&#10;     2  End of stream - pos usually negative.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.tell" func="yes">
			<Overload retVal="" descr="Current file position, an integer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is unchanged.  Returns the new size.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.write" func="yes">
			<Overload retVal="" descr="Write bytes to file.&#10;&#10;Return the number of bytes written.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.BytesIO.writelines" func="yes">
			<Overload retVal="" descr="Write lines to the file.&#10;&#10;Note that newlines are not added.  lines can be any iterable object&#10;producing bytes-like objects. This is equivalent to calling write() for&#10;each element.">
				<Param name="self" />
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.DEFAULT_BUFFER_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO" func="yes">
			<Overload retVal="" descr="Open a file.&#10;&#10;The mode can be 'r' (default), 'w', 'x' or 'a' for reading,&#10;writing, exclusive creation or appending.  The file will be created if it&#10;doesn't exist when opened for writing or appending; it will be truncated&#10;when opened for writing.  A FileExistsError will be raised if it already&#10;exists when opened for creating. Opening a file for creating implies&#10;writing so this mode behaves in a similar way to 'w'.Add a '+' to the mode&#10;to allow simultaneous reading and writing. A custom opener can be used by&#10;passing a callable as *opener*. The underlying file descriptor for the file&#10;object is then obtained by calling opener with (*name*, *flags*).&#10;*opener* must return an open file descriptor (passing os.open as *opener*&#10;results in functionality similar to passing None).">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.close" func="yes">
			<Overload retVal="" descr="Close the file.&#10;&#10;A closed file cannot be used for further I/O operations.  close() may be&#10;called more than once without error.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.closefd" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.fileno" func="yes">
			<Overload retVal="" descr="Return the underlying file descriptor (an integer).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.isatty" func="yes">
			<Overload retVal="" descr="True if the file is connected to a TTY device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as bytes.&#10;&#10;Only makes one system call, so less data may be returned than requested.&#10;In non-blocking mode, returns None if no data is available.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readable" func="yes">
			<Overload retVal="" descr="True if file was opened in a read mode.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readall" func="yes">
			<Overload retVal="" descr="Read all data from the file, returned as bytes.&#10;&#10;In non-blocking mode, returns as much as is immediately available,&#10;or None if no data is available.  Return an empty bytes object at EOF.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readinto" func="yes">
			<Overload retVal="" descr="Same as RawIOBase.readinto().">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If size is specified, at most size bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.seek" func="yes">
			<Overload retVal="" descr="Move to new file position and return the file position.&#10;&#10;Argument offset is a byte count.  Optional argument whence defaults to&#10;SEEK_SET or 0 (offset from start of file, offset should be &gt;= 0); other values&#10;are SEEK_CUR or 1 (move relative to current position, positive or negative),&#10;and SEEK_END or 2 (move relative to end of file, usually negative, although&#10;many platforms allow seeking beyond the end of a file).&#10;&#10;Note that not all file objects are seekable.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.seekable" func="yes">
			<Overload retVal="" descr="True if file supports random-access.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.tell" func="yes">
			<Overload retVal="" descr="Current file position.&#10;&#10;Can raise OSError for non seekable files.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate the file to at most size bytes and return the truncated size.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is changed to the value of size.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.writable" func="yes">
			<Overload retVal="" descr="True if file was opened in a write mode.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.write" func="yes">
			<Overload retVal="" descr="Write buffer b to file, return number of bytes written.&#10;&#10;Only makes one system call, so not all of the data may be written.&#10;The number of bytes actually written is returned.  In non-blocking mode,&#10;returns None if the write would block.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.FileIO.writelines" />
		<KeyWord name="io.IOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder" func="yes">
			<Overload retVal="" descr="Codec used when reading a file in universal newlines mode.&#10;&#10;It wraps another incremental decoder, translating \r\n and \r into \n.&#10;It also records the types of newlines encountered.  When used with&#10;translate=False, it ensures that the newline sequence is returned in&#10;one piece. When used with decoder=None, it expects unicode strings as&#10;decode input and translates newlines without first invoking an external&#10;decoder.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder.decode" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="input" />
				<Param name="[final=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder.getstate" />
		<KeyWord name="io.IncrementalNewlineDecoder.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.IncrementalNewlineDecoder.reset" />
		<KeyWord name="io.IncrementalNewlineDecoder.setstate" />
		<KeyWord name="io.OpenWrapper" func="yes">
			<Overload retVal="" descr="Open file and return a stream.  Raise IOError upon failure.&#10;&#10;file is either a text or byte string giving the name (and the path&#10;if the file isn't in the current working directory) of the file to&#10;be opened or an integer file descriptor of the file to be&#10;wrapped. (If a file descriptor is given, it is closed when the&#10;returned I/O object is closed, unless closefd is set to False.)&#10;&#10;mode is an optional string that specifies the mode in which the file&#10;is opened. It defaults to 'r' which means open for reading in text&#10;mode.  Other common values are 'w' for writing (truncating the file if&#10;it already exists), 'x' for creating and writing to a new file, and&#10;'a' for appending (which on some Unix systems, means that all writes&#10;append to the end of the file regardless of the current seek position).&#10;In text mode, if encoding is not specified the encoding used is platform&#10;dependent: locale.getpreferredencoding(False) is called to get the&#10;current locale encoding. (For reading and writing raw bytes use binary&#10;mode and leave encoding unspecified.) The available modes are:&#10;&#10;========= ===============================================================&#10;Character Meaning&#10;--------- ---------------------------------------------------------------&#10;'r'       open for reading (default)&#10;'w'       open for writing, truncating the file first&#10;'x'       create a new file and open it for writing&#10;'a'       open for writing, appending to the end of the file if it exists&#10;'b'       binary mode&#10;'t'       text mode (default)&#10;'+'       open a disk file for updating (reading and writing)&#10;'U'       universal newline mode (deprecated)&#10;========= ===============================================================&#10;&#10;The default mode is 'rt' (open for reading text). For binary random&#10;access, the mode 'w+b' opens and truncates the file to 0 bytes, while&#10;'r+b' opens the file without truncation. The 'x' mode implies 'w' and&#10;raises an `FileExistsError` if the file already exists.&#10;&#10;Python distinguishes between files opened in binary and text modes,&#10;even when the underlying operating system doesn't. Files opened in&#10;binary mode (appending 'b' to the mode argument) return contents as&#10;bytes objects without any decoding. In text mode (the default, or when&#10;'t' is appended to the mode argument), the contents of the file are&#10;returned as strings, the bytes having been first decoded using a&#10;platform-dependent encoding or using the specified encoding if given.&#10;&#10;'U' mode is deprecated and will raise an exception in future versions&#10;of Python.  It has no effect in Python 3.  Use newline to control&#10;universal newlines mode.&#10;&#10;buffering is an optional integer used to set the buffering policy.&#10;Pass 0 to switch buffering off (only allowed in binary mode), 1 to select&#10;line buffering (only usable in text mode), and an integer &gt; 1 to indicate&#10;the size of a fixed-size chunk buffer.  When no buffering argument is&#10;given, the default buffering policy works as follows:&#10;&#10;* Binary files are buffered in fixed-size chunks; the size of the buffer&#10;  is chosen using a heuristic trying to determine the underlying device's&#10;  &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.&#10;  On many systems, the buffer will typically be 4096 or 8192 bytes long.&#10;&#10;* &quot;Interactive&quot; text files (files for which isatty() returns True)&#10;  use line buffering.  Other text files use the policy described above&#10;  for binary files.&#10;&#10;encoding is the name of the encoding used to decode or encode the&#10;file. This should only be used in text mode. The default encoding is&#10;platform dependent, but any encoding supported by Python can be&#10;passed.  See the codecs module for the list of supported encodings.&#10;&#10;errors is an optional string that specifies how encoding errors are to&#10;be handled---this argument should not be used in binary mode. Pass&#10;'strict' to raise a ValueError exception if there is an encoding error&#10;(the default of None has the same effect), or pass 'ignore' to ignore&#10;errors. (Note that ignoring encoding errors can lead to data loss.)&#10;See the documentation for codecs.register or run 'help(codecs.Codec)'&#10;for a list of the permitted encoding error strings.&#10;&#10;newline controls how universal newlines works (it only applies to text&#10;mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as&#10;follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If closefd is False, the underlying file descriptor will be kept open&#10;when the file is closed. This does not work when a file name is given&#10;and must be True in that case.&#10;&#10;A custom opener can be used by passing a callable as *opener*. The&#10;underlying file descriptor for the file object is then obtained by&#10;calling *opener* with (*file*, *flags*). *opener* must return an open&#10;file descriptor (passing os.open as *opener* results in functionality&#10;similar to passing None).&#10;&#10;open() returns a file object whose type depends on the mode, and&#10;through which the standard file operations such as reading and writing&#10;are performed. When open() is used to open a file in a text mode ('w',&#10;'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open&#10;a file in a binary mode, the returned class varies: in read binary&#10;mode, it returns a BufferedReader; in write binary and append binary&#10;modes, it returns a BufferedWriter, and in read/write mode, it returns&#10;a BufferedRandom.&#10;&#10;It is also possible to use a string or bytearray as a file for both&#10;reading and writing. For strings StringIO can be used like a file&#10;opened in a text mode, and for bytes a BytesIO can be used like a file&#10;opened in a binary mode.">
				<Param name="file" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None" />
				<Param name="[closefd=True" />
				<Param name="[opener=None]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.RawIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.SEEK_CUR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.SEEK_END" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO" func="yes">
			<Overload retVal="" descr="Text I/O implementation using an in-memory buffer.&#10;&#10;The initial_value argument sets the value of object.  The newline&#10;argument is like the one of TextIOWrapper's constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.close" func="yes">
			<Overload retVal="" descr="Close the IO object.&#10;&#10;Attempting any further operation after the object is closed&#10;will raise a ValueError.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.encoding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.line_buffering" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.read" func="yes">
			<Overload retVal="" descr="Read at most size characters, returned as a string.&#10;&#10;If the argument is negative or omitted, read until EOF&#10;is reached. Return an empty string at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to character offset pos relative to position indicated by whence:&#10;    0  Start of stream (the default).  pos should be &gt;= 0;&#10;    1  Current position - pos must be 0;&#10;    2  End of stream - pos must be 0.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.tell" func="yes">
			<Overload retVal="" descr="Tell the current file position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate size to pos.&#10;&#10;The pos argument defaults to the current file position, as&#10;returned by tell().  The current file position is unchanged.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.write" func="yes">
			<Overload retVal="" descr="Write string to file.&#10;&#10;Returns the number of characters written, which is always equal to&#10;the length of the string.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.StringIO.writelines" />
		<KeyWord name="io.TextIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper" func="yes">
			<Overload retVal="" descr="Character and line based layer over a BufferedIOBase object, buffer.&#10;&#10;encoding gives the name of the encoding that the stream will be&#10;decoded or encoded with. It defaults to locale.getpreferredencoding(False).&#10;&#10;errors determines the strictness of encoding and decoding (see&#10;help(codecs.Codec) or the documentation for codecs.register) and&#10;defaults to &quot;strict&quot;.&#10;&#10;newline controls how line endings are handled. It can be None, '',&#10;'\n', '\r', and '\r\n'.  It works as follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If line_buffering is True, a call to flush is implied when a call to&#10;write contains a newline character.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.buffer" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.line_buffering" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.read" func="yes">
			<Overload retVal="" descr="Read at most n characters from stream.&#10;&#10;Read from underlying buffer until we have n characters or we hit EOF.&#10;If n is negative or omitted, read until EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="cookie" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.write" func="yes">
			<Overload retVal="" descr="Write string to stream.&#10;Returns the number of characters written (which is always equal to&#10;the length of the string).">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="io.TextIOWrapper.writelines" />
		<KeyWord name="io.UnsupportedOperation" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="io.UnsupportedOperation.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="io.open" func="yes">
			<Overload retVal="" descr="Open file and return a stream.  Raise IOError upon failure.&#10;&#10;file is either a text or byte string giving the name (and the path&#10;if the file isn't in the current working directory) of the file to&#10;be opened or an integer file descriptor of the file to be&#10;wrapped. (If a file descriptor is given, it is closed when the&#10;returned I/O object is closed, unless closefd is set to False.)&#10;&#10;mode is an optional string that specifies the mode in which the file&#10;is opened. It defaults to 'r' which means open for reading in text&#10;mode.  Other common values are 'w' for writing (truncating the file if&#10;it already exists), 'x' for creating and writing to a new file, and&#10;'a' for appending (which on some Unix systems, means that all writes&#10;append to the end of the file regardless of the current seek position).&#10;In text mode, if encoding is not specified the encoding used is platform&#10;dependent: locale.getpreferredencoding(False) is called to get the&#10;current locale encoding. (For reading and writing raw bytes use binary&#10;mode and leave encoding unspecified.) The available modes are:&#10;&#10;========= ===============================================================&#10;Character Meaning&#10;--------- ---------------------------------------------------------------&#10;'r'       open for reading (default)&#10;'w'       open for writing, truncating the file first&#10;'x'       create a new file and open it for writing&#10;'a'       open for writing, appending to the end of the file if it exists&#10;'b'       binary mode&#10;'t'       text mode (default)&#10;'+'       open a disk file for updating (reading and writing)&#10;'U'       universal newline mode (deprecated)&#10;========= ===============================================================&#10;&#10;The default mode is 'rt' (open for reading text). For binary random&#10;access, the mode 'w+b' opens and truncates the file to 0 bytes, while&#10;'r+b' opens the file without truncation. The 'x' mode implies 'w' and&#10;raises an `FileExistsError` if the file already exists.&#10;&#10;Python distinguishes between files opened in binary and text modes,&#10;even when the underlying operating system doesn't. Files opened in&#10;binary mode (appending 'b' to the mode argument) return contents as&#10;bytes objects without any decoding. In text mode (the default, or when&#10;'t' is appended to the mode argument), the contents of the file are&#10;returned as strings, the bytes having been first decoded using a&#10;platform-dependent encoding or using the specified encoding if given.&#10;&#10;'U' mode is deprecated and will raise an exception in future versions&#10;of Python.  It has no effect in Python 3.  Use newline to control&#10;universal newlines mode.&#10;&#10;buffering is an optional integer used to set the buffering policy.&#10;Pass 0 to switch buffering off (only allowed in binary mode), 1 to select&#10;line buffering (only usable in text mode), and an integer &gt; 1 to indicate&#10;the size of a fixed-size chunk buffer.  When no buffering argument is&#10;given, the default buffering policy works as follows:&#10;&#10;* Binary files are buffered in fixed-size chunks; the size of the buffer&#10;  is chosen using a heuristic trying to determine the underlying device's&#10;  &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.&#10;  On many systems, the buffer will typically be 4096 or 8192 bytes long.&#10;&#10;* &quot;Interactive&quot; text files (files for which isatty() returns True)&#10;  use line buffering.  Other text files use the policy described above&#10;  for binary files.&#10;&#10;encoding is the name of the encoding used to decode or encode the&#10;file. This should only be used in text mode. The default encoding is&#10;platform dependent, but any encoding supported by Python can be&#10;passed.  See the codecs module for the list of supported encodings.&#10;&#10;errors is an optional string that specifies how encoding errors are to&#10;be handled---this argument should not be used in binary mode. Pass&#10;'strict' to raise a ValueError exception if there is an encoding error&#10;(the default of None has the same effect), or pass 'ignore' to ignore&#10;errors. (Note that ignoring encoding errors can lead to data loss.)&#10;See the documentation for codecs.register or run 'help(codecs.Codec)'&#10;for a list of the permitted encoding error strings.&#10;&#10;newline controls how universal newlines works (it only applies to text&#10;mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as&#10;follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If closefd is False, the underlying file descriptor will be kept open&#10;when the file is closed. This does not work when a file name is given&#10;and must be True in that case.&#10;&#10;A custom opener can be used by passing a callable as *opener*. The&#10;underlying file descriptor for the file object is then obtained by&#10;calling *opener* with (*file*, *flags*). *opener* must return an open&#10;file descriptor (passing os.open as *opener* results in functionality&#10;similar to passing None).&#10;&#10;open() returns a file object whose type depends on the mode, and&#10;through which the standard file operations such as reading and writing&#10;are performed. When open() is used to open a file in a text mode ('w',&#10;'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open&#10;a file in a binary mode, the returned class varies: in read binary&#10;mode, it returns a BufferedReader; in write binary and append binary&#10;modes, it returns a BufferedWriter, and in read/write mode, it returns&#10;a BufferedRandom.&#10;&#10;It is also possible to use a string or bytearray as a file for both&#10;reading and writing. For strings StringIO can be used like a file&#10;opened in a text mode, and for bytes a BytesIO can be used like a file&#10;opened in a binary mode.">
				<Param name="file" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None" />
				<Param name="[closefd=True" />
				<Param name="[opener=None]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ioctl" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="ior" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="ip_address" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="ip_interface" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="ip_network" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress" func="yes">
			<Overload retVal="" descr="A fast, lightweight IPv4/IPv6 manipulation library in Python.&#10;&#10;This library is used to create/poke/manipulate IPv4 and IPv6 addresses&#10;and networks.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.AddressValueError" func="yes">
			<Overload retVal="" descr="A Value Error related to the address.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.AddressValueError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.AddressValueError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPV4LENGTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPV6LENGTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address" func="yes">
			<Overload retVal="" descr="Represent and manipulate single IPv4 Addresses.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.compressed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.exploded" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_global" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_link_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_loopback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_multicast" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_private" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_reserved" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.is_unspecified" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.max_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.packed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.reverse_pointer" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Address.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface" func="yes">
			<Overload retVal="" descr="Represent and manipulate single IPv4 Addresses.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.compressed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.exploded" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.ip" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_global" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_link_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_loopback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_multicast" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_private" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_reserved" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.is_unspecified" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.max_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.packed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.reverse_pointer" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.with_hostmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.with_netmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Interface.with_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network" func="yes">
			<Overload retVal="" descr="This class represents and manipulates 32-bit IPv4 network + addresses..&#10;&#10;Attributes: [examples for IPv4Network('192.0.2.0/27')]&#10;    .network_address: IPv4Address('192.0.2.0')&#10;    .hostmask: IPv4Address('0.0.0.31')&#10;    .broadcast_address: IPv4Address('192.0.2.32')&#10;    .netmask: IPv4Address('255.255.255.224')&#10;    .prefixlen: 27">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.address_exclude" func="yes">
			<Overload retVal="" descr="Remove an address from a larger block.&#10;&#10;For example:&#10;&#10;    addr1 = ip_network('192.0.2.0/28')&#10;    addr2 = ip_network('192.0.2.1/32')&#10;    list(addr1.address_exclude(addr2)) =&#10;        [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),&#10;         IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]&#10;&#10;or IPv6:&#10;&#10;    addr1 = ip_network('2001:db8::1/32')&#10;    addr2 = ip_network('2001:db8::1/128')&#10;    list(addr1.address_exclude(addr2)) =&#10;        [ip_network('2001:db8::1/128'),&#10;         ip_network('2001:db8::2/127'),&#10;         ip_network('2001:db8::4/126'),&#10;         ip_network('2001:db8::8/125'),&#10;         ...&#10;         ip_network('2001:db8:8000::/33')]&#10;&#10;Args:&#10;    other: An IPv4Network or IPv6Network object of the same type.&#10;&#10;Returns:&#10;    An iterator of the IPv(4|6)Network objects which is self&#10;    minus other.&#10;&#10;Raises:&#10;    TypeError: If self and other are of differing address&#10;      versions, or if other is not a network object.&#10;    ValueError: If other is not completely contained by self.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.broadcast_address" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.compare_networks" func="yes">
			<Overload retVal="" descr="Compare two IP objects.&#10;&#10;This is only concerned about the comparison of the integer&#10;representation of the network addresses.  This means that the&#10;host bits aren't considered at all in this method.  If you want&#10;to compare host bits, you can easily enough do a&#10;'HostA._ip &lt; HostB._ip'&#10;&#10;Args:&#10;    other: An IP object.&#10;&#10;Returns:&#10;    If the IP versions of self and other are the same, returns:&#10;&#10;    -1 if self &lt; other:&#10;      eg: IPv4Network('192.0.2.0/25') &lt; IPv4Network('192.0.2.128/25')&#10;      IPv6Network('2001:db8::1000/124') &lt;&#10;          IPv6Network('2001:db8::2000/124')&#10;    0 if self == other&#10;      eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')&#10;      IPv6Network('2001:db8::1000/124') ==&#10;          IPv6Network('2001:db8::1000/124')&#10;    1 if self &gt; other&#10;      eg: IPv4Network('192.0.2.128/25') &gt; IPv4Network('192.0.2.0/25')&#10;          IPv6Network('2001:db8::2000/124') &gt;&#10;              IPv6Network('2001:db8::1000/124')&#10;&#10;  Raises:&#10;      TypeError if the IP versions are different.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.compressed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.exploded" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.hostmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.hosts" func="yes">
			<Overload retVal="" descr="Generate Iterator over usable hosts in a network.&#10;&#10;This is like __iter__ except it doesn't return the network&#10;or broadcast addresses.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_global" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_link_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_loopback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_multicast" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_private" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_reserved" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.is_unspecified" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.max_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.num_addresses" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.overlaps" func="yes">
			<Overload retVal="" descr="Tell if self is partly contained in other.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.reverse_pointer" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.subnets" func="yes">
			<Overload retVal="" descr="The subnets which join to make the current subnet.&#10;&#10;In the case that self contains only one IP&#10;(self._prefixlen == 32 for IPv4 or self._prefixlen == 128&#10;for IPv6), yield an iterator with just ourself.&#10;&#10;Args:&#10;    prefixlen_diff: An integer, the amount the prefix length&#10;      should be increased by. This should not be set if&#10;      new_prefix is also set.&#10;    new_prefix: The desired new prefix length. This must be a&#10;      larger number (smaller prefix) than the existing prefix.&#10;      This should not be set if prefixlen_diff is also set.&#10;&#10;Returns:&#10;    An iterator of IPv(4|6) objects.&#10;&#10;Raises:&#10;    ValueError: The prefixlen_diff is too small or too large.&#10;        OR&#10;    prefixlen_diff and new_prefix are both set or new_prefix&#10;      is a smaller number than the current prefix (smaller&#10;      number means a larger network)">
				<Param name="self" />
				<Param name="[prefixlen_diff=1" />
				<Param name="[new_prefix=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.supernet" func="yes">
			<Overload retVal="" descr="The supernet containing the current network.&#10;&#10;Args:&#10;    prefixlen_diff: An integer, the amount the prefix length of&#10;      the network should be decreased by.  For example, given a&#10;      /24 network and a prefixlen_diff of 3, a supernet with a&#10;      /21 netmask is returned.&#10;&#10;Returns:&#10;    An IPv4 network object.&#10;&#10;Raises:&#10;    ValueError: If self.prefixlen - prefixlen_diff &lt; 0. I.e., you have&#10;      a negative prefix length.&#10;        OR&#10;    If prefixlen_diff and new_prefix are both set or new_prefix is a&#10;      larger number than the current prefix (larger number means a&#10;      smaller network)">
				<Param name="self" />
				<Param name="[prefixlen_diff=1" />
				<Param name="[new_prefix=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.with_hostmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.with_netmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv4Network.with_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address" func="yes">
			<Overload retVal="" descr="Represent and manipulate single IPv6 Addresses.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.compressed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.exploded" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.ipv4_mapped" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_global" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_link_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_loopback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_multicast" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_private" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_reserved" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_site_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.is_unspecified" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.max_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.packed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.reverse_pointer" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.sixtofour" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.teredo" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Address.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface" func="yes">
			<Overload retVal="" descr="Represent and manipulate single IPv6 Addresses.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.compressed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.exploded" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.ip" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.ipv4_mapped" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_global" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_link_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_loopback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_multicast" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_private" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_reserved" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_site_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.is_unspecified" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.max_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.packed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.reverse_pointer" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.sixtofour" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.teredo" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.with_hostmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.with_netmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Interface.with_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network" func="yes">
			<Overload retVal="" descr="This class represents and manipulates 128-bit IPv6 networks.&#10;&#10;Attributes: [examples for IPv6('2001:db8::1000/124')]&#10;    .network_address: IPv6Address('2001:db8::1000')&#10;    .hostmask: IPv6Address('::f')&#10;    .broadcast_address: IPv6Address('2001:db8::100f')&#10;    .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0')&#10;    .prefixlen: 124">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.address_exclude" func="yes">
			<Overload retVal="" descr="Remove an address from a larger block.&#10;&#10;For example:&#10;&#10;    addr1 = ip_network('192.0.2.0/28')&#10;    addr2 = ip_network('192.0.2.1/32')&#10;    list(addr1.address_exclude(addr2)) =&#10;        [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),&#10;         IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]&#10;&#10;or IPv6:&#10;&#10;    addr1 = ip_network('2001:db8::1/32')&#10;    addr2 = ip_network('2001:db8::1/128')&#10;    list(addr1.address_exclude(addr2)) =&#10;        [ip_network('2001:db8::1/128'),&#10;         ip_network('2001:db8::2/127'),&#10;         ip_network('2001:db8::4/126'),&#10;         ip_network('2001:db8::8/125'),&#10;         ...&#10;         ip_network('2001:db8:8000::/33')]&#10;&#10;Args:&#10;    other: An IPv4Network or IPv6Network object of the same type.&#10;&#10;Returns:&#10;    An iterator of the IPv(4|6)Network objects which is self&#10;    minus other.&#10;&#10;Raises:&#10;    TypeError: If self and other are of differing address&#10;      versions, or if other is not a network object.&#10;    ValueError: If other is not completely contained by self.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.broadcast_address" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.compare_networks" func="yes">
			<Overload retVal="" descr="Compare two IP objects.&#10;&#10;This is only concerned about the comparison of the integer&#10;representation of the network addresses.  This means that the&#10;host bits aren't considered at all in this method.  If you want&#10;to compare host bits, you can easily enough do a&#10;'HostA._ip &lt; HostB._ip'&#10;&#10;Args:&#10;    other: An IP object.&#10;&#10;Returns:&#10;    If the IP versions of self and other are the same, returns:&#10;&#10;    -1 if self &lt; other:&#10;      eg: IPv4Network('192.0.2.0/25') &lt; IPv4Network('192.0.2.128/25')&#10;      IPv6Network('2001:db8::1000/124') &lt;&#10;          IPv6Network('2001:db8::2000/124')&#10;    0 if self == other&#10;      eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')&#10;      IPv6Network('2001:db8::1000/124') ==&#10;          IPv6Network('2001:db8::1000/124')&#10;    1 if self &gt; other&#10;      eg: IPv4Network('192.0.2.128/25') &gt; IPv4Network('192.0.2.0/25')&#10;          IPv6Network('2001:db8::2000/124') &gt;&#10;              IPv6Network('2001:db8::1000/124')&#10;&#10;  Raises:&#10;      TypeError if the IP versions are different.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.compressed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.exploded" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.hostmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.hosts" func="yes">
			<Overload retVal="" descr="Generate Iterator over usable hosts in a network.&#10;&#10;This is like __iter__ except it doesn't return the&#10;Subnet-Router anycast address.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_global" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_link_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_loopback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_multicast" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_private" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_reserved" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_site_local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.is_unspecified" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.max_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.num_addresses" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.overlaps" func="yes">
			<Overload retVal="" descr="Tell if self is partly contained in other.">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.reverse_pointer" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.subnets" func="yes">
			<Overload retVal="" descr="The subnets which join to make the current subnet.&#10;&#10;In the case that self contains only one IP&#10;(self._prefixlen == 32 for IPv4 or self._prefixlen == 128&#10;for IPv6), yield an iterator with just ourself.&#10;&#10;Args:&#10;    prefixlen_diff: An integer, the amount the prefix length&#10;      should be increased by. This should not be set if&#10;      new_prefix is also set.&#10;    new_prefix: The desired new prefix length. This must be a&#10;      larger number (smaller prefix) than the existing prefix.&#10;      This should not be set if prefixlen_diff is also set.&#10;&#10;Returns:&#10;    An iterator of IPv(4|6) objects.&#10;&#10;Raises:&#10;    ValueError: The prefixlen_diff is too small or too large.&#10;        OR&#10;    prefixlen_diff and new_prefix are both set or new_prefix&#10;      is a smaller number than the current prefix (smaller&#10;      number means a larger network)">
				<Param name="self" />
				<Param name="[prefixlen_diff=1" />
				<Param name="[new_prefix=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.supernet" func="yes">
			<Overload retVal="" descr="The supernet containing the current network.&#10;&#10;Args:&#10;    prefixlen_diff: An integer, the amount the prefix length of&#10;      the network should be decreased by.  For example, given a&#10;      /24 network and a prefixlen_diff of 3, a supernet with a&#10;      /21 netmask is returned.&#10;&#10;Returns:&#10;    An IPv4 network object.&#10;&#10;Raises:&#10;    ValueError: If self.prefixlen - prefixlen_diff &lt; 0. I.e., you have&#10;      a negative prefix length.&#10;        OR&#10;    If prefixlen_diff and new_prefix are both set or new_prefix is a&#10;      larger number than the current prefix (larger number means a&#10;      smaller network)">
				<Param name="self" />
				<Param name="[prefixlen_diff=1" />
				<Param name="[new_prefix=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.with_hostmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.with_netmask" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.IPv6Network.with_prefixlen" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.NetmaskValueError" func="yes">
			<Overload retVal="" descr="A Value Error related to the netmask.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.NetmaskValueError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.NetmaskValueError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.collapse_addresses" func="yes">
			<Overload retVal="" descr="Collapse a list of IP objects.&#10;&#10;Example:&#10;    collapse_addresses([IPv4Network('192.0.2.0/25'),&#10;                        IPv4Network('192.0.2.128/25')]) -&gt;&#10;                       [IPv4Network('192.0.2.0/24')]&#10;&#10;Args:&#10;    addresses: An iterator of IPv4Network or IPv6Network objects.&#10;&#10;Returns:&#10;    An iterator of the collapsed IPv(4|6)Network objects.&#10;&#10;Raises:&#10;    TypeError: If passed a list of mixed version objects.">
				<Param name="addresses" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.get_mixed_type_key" func="yes">
			<Overload retVal="" descr="Return a key suitable for sorting between networks and addresses.&#10;&#10;Address and Network objects are not sortable by default; they're&#10;fundamentally different so the expression&#10;&#10;    IPv4Address('192.0.2.0') &lt;= IPv4Network('192.0.2.0/24')&#10;&#10;doesn't make any sense.  There are some times however, where you may wish&#10;to have ipaddress sort these for you anyway. If you need to do this, you&#10;can use this function as the key= argument to sorted().&#10;&#10;Args:&#10;  obj: either a Network or Address object.&#10;Returns:&#10;  appropriate key.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.ip_address" func="yes">
			<Overload retVal="" descr="Take an IP string/int and return an object of the correct type.&#10;&#10;Args:&#10;    address: A string or integer, the IP address.  Either IPv4 or&#10;      IPv6 addresses may be supplied; integers less than 2**32 will&#10;      be considered to be IPv4 by default.&#10;&#10;Returns:&#10;    An IPv4Address or IPv6Address object.&#10;&#10;Raises:&#10;    ValueError: if the *address* passed isn't either a v4 or a v6&#10;      address">
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.ip_interface" func="yes">
			<Overload retVal="" descr="Take an IP string/int and return an object of the correct type.&#10;&#10;Args:&#10;    address: A string or integer, the IP address.  Either IPv4 or&#10;      IPv6 addresses may be supplied; integers less than 2**32 will&#10;      be considered to be IPv4 by default.&#10;&#10;Returns:&#10;    An IPv4Interface or IPv6Interface object.&#10;&#10;Raises:&#10;    ValueError: if the string passed isn't either a v4 or a v6&#10;      address.&#10;&#10;Notes:&#10;    The IPv?Interface classes describe an Address on a particular&#10;    Network, so they're basically a combination of both the Address&#10;    and Network classes.">
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.ip_network" func="yes">
			<Overload retVal="" descr="Take an IP string/int and return an object of the correct type.&#10;&#10;Args:&#10;    address: A string or integer, the IP network.  Either IPv4 or&#10;      IPv6 networks may be supplied; integers less than 2**32 will&#10;      be considered to be IPv4 by default.&#10;&#10;Returns:&#10;    An IPv4Network or IPv6Network object.&#10;&#10;Raises:&#10;    ValueError: if the string passed isn't either a v4 or a v6&#10;      address. Or if the network has host bits set.">
				<Param name="address" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.summarize_address_range" func="yes">
			<Overload retVal="" descr="Summarize a network range given the first and last IP addresses.&#10;&#10;Example:&#10;    &gt;&gt;&gt; list(summarize_address_range(IPv4Address('192.0.2.0'),&#10;    ...                              IPv4Address('192.0.2.130')))&#10;    ...                                #doctest: +NORMALIZE_WHITESPACE&#10;    [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'),&#10;     IPv4Network('192.0.2.130/32')]&#10;&#10;Args:&#10;    first: the first IPv4Address or IPv6Address in the range.&#10;    last: the last IPv4Address or IPv6Address in the range.&#10;&#10;Returns:&#10;    An iterator of the summarized IPv(4|6) network objects.&#10;&#10;Raise:&#10;    TypeError:&#10;        If the first and last objects are not IP addresses.&#10;        If the first and last objects are not the same version.&#10;    ValueError:&#10;        If the last object is not greater than the first.&#10;        If the version of the first address is not 4 or 6.">
				<Param name="first" />
				<Param name="last" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.v4_int_to_packed" func="yes">
			<Overload retVal="" descr="Represent an address as 4 packed bytes in network (big-endian) order.&#10;&#10;Args:&#10;    address: An integer representation of an IPv4 IP address.&#10;&#10;Returns:&#10;    The integer address packed as 4 bytes in network (big-endian) order.&#10;&#10;Raises:&#10;    ValueError: If the integer is negative or too large to be an&#10;      IPv4 IP address.">
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipaddress.v6_int_to_packed" func="yes">
			<Overload retVal="" descr="Represent an address as 16 packed bytes in network (big-endian) order.&#10;&#10;Args:&#10;    address: An integer representation of an IPv6 IP address.&#10;&#10;Returns:&#10;    The integer address packed as 16 bytes in network (big-endian) order.">
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="ipow" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="irshift" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="is" />
		<KeyWord name="isAlive" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="isDaemon" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="isEnabledFor" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="isSet" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Event">
			</Overload>
		</KeyWord>
		<KeyWord name="is_absolute" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="is_alive" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="is_annotated" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_assigned" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_block_device" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="is_builtin" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="is_canonical" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_char_device" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="is_check_supported" func="yes">
			<Overload retVal="" descr="Function of lzma">
			</Overload>
		</KeyWord>
		<KeyWord name="is_closed" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="is_closing" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="is_current" func="yes">
			<Overload retVal="" descr="Function of setuptools.Require">
			</Overload>
		</KeyWord>
		<KeyWord name="is_declared_global" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_dir" func="yes">
			<Overload retVal="" descr="Function of os.DirEntry">
			</Overload>
		</KeyWord>
		<KeyWord name="is_fifo" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="is_file" func="yes">
			<Overload retVal="" descr="Function of os.DirEntry">
			</Overload>
		</KeyWord>
		<KeyWord name="is_finite" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_free" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_frozen" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="is_frozen_package" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="is_global" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_ignored_filename" func="yes">
			<Overload retVal="" descr="Function of trace.CoverageResults">
			</Overload>
		</KeyWord>
		<KeyWord name="is_imported" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_infinite" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_integer" func="yes">
			<Overload retVal="" descr="Return True if the float is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="is_local" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_multipart" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="is_namespace" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_nan" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_nested" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="is_normal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_not" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="is_optimized" func="yes">
			<Overload retVal="" descr="Function of symtable.Class">
			</Overload>
		</KeyWord>
		<KeyWord name="is_package" func="yes">
			<Overload retVal="" descr="Function of imp.SourcelessFileLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="is_parameter" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_present" func="yes">
			<Overload retVal="" descr="Function of setuptools.Require">
			</Overload>
		</KeyWord>
		<KeyWord name="is_pure" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="is_python_build" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="is_qnan" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_referenced" func="yes">
			<Overload retVal="" descr="Function of symtable.Symbol">
			</Overload>
		</KeyWord>
		<KeyWord name="is_reserved" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="is_running" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="is_set" func="yes">
			<Overload retVal="" descr="Function of asyncio.Event">
			</Overload>
		</KeyWord>
		<KeyWord name="is_signed" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_skipped_module" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="is_snan" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_socket" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="is_subnormal" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_symlink" func="yes">
			<Overload retVal="" descr="Function of os.DirEntry">
			</Overload>
		</KeyWord>
		<KeyWord name="is_tarfile" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="is_tracing" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="is_zero" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="is_zipfile" func="yes">
			<Overload retVal="" descr="Function of zipfile">
			</Overload>
		</KeyWord>
		<KeyWord name="isabs" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isabstract" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isasyncgen" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isasyncgenfunction" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isatty" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="isawaitable" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isblk" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isbuiltin" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ischr" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isclass" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="iscode" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="iscoroutine" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="iscoroutinefunction" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="isdata" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="isdatadescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isdev" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isdir" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isdisjoint" func="yes">
			<Overload retVal="" descr="Return True if two sets have a null intersection.">
			</Overload>
		</KeyWord>
		<KeyWord name="isfifo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isfile" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isfirstline" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="isframe" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isfunction" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isfuture" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="isgenerator" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isgeneratorfunction" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isgetsetdescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ishex" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="isidentifier" func="yes">
			<Overload retVal="" descr='S.isidentifier() -&gt; bool&#10;&#10;Return True if S is a valid identifier according&#10;to the language definition.&#10;&#10;Use keyword.iskeyword() to test for reserved identifiers&#10;such as "def" and "class".'>
			</Overload>
		</KeyWord>
		<KeyWord name="isinstance" func="yes">
			<Overload retVal="" descr="Return whether an object is an instance of a class or of a subclass thereof.&#10;&#10;A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to&#10;check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)&#10;or ...`` etc.">
				<Param name="obj" />
				<Param name="class_or_tuple" />
			</Overload>
		</KeyWord>
		<KeyWord name="iskeyword" func="yes">
			<Overload retVal="" descr="Function of keyword">
			</Overload>
		</KeyWord>
		<KeyWord name="isleap" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="islink" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="islnk" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="ismemberdescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismethod" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismethoddescriptor" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismodule" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="ismount" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isocalendar" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="isoformat" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="isoweekday" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="ispackage" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="ispath" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="isprintable" func="yes">
			<Overload retVal="" descr="S.isprintable() -&gt; bool&#10;&#10;Return True if all characters in S are considered&#10;printable in repr() or S is empty, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="isreadable" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="isrecursive" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="isreg" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isroutine" func="yes">
			<Overload retVal="" descr="Function of generate_python_autocomplete">
			</Overload>
		</KeyWord>
		<KeyWord name="isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="issparse" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="isstdin" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="isstring" func="yes">
			<Overload retVal="" descr="Function of sre_compile">
			</Overload>
		</KeyWord>
		<KeyWord name="issubclass" func="yes">
			<Overload retVal="" descr="Return whether 'cls' is a derived from another class or is the same class.&#10;&#10;A tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to&#10;check against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)&#10;or ...`` etc.">
				<Param name="cls" />
				<Param name="class_or_tuple" />
			</Overload>
		</KeyWord>
		<KeyWord name="issubset" func="yes">
			<Overload retVal="" descr="Report whether another set contains this set.">
			</Overload>
		</KeyWord>
		<KeyWord name="issue_warning" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="issuperset" func="yes">
			<Overload retVal="" descr="Report whether this set contains another set.">
			</Overload>
		</KeyWord>
		<KeyWord name="issym" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="istraceback" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="isub" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="iter" func="yes">
			<Overload retVal="" descr="iter(iterable) -&gt; iterator&#10;iter(callable, sentinel) -&gt; iterator&#10;&#10;Get an iterator from an object.  In the first form, the argument must&#10;supply its own iterator, or be a sequence.&#10;In the second form, the callable is called until it returns the sentinel.">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_child_nodes" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_distribution_names" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_entry_points" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_fields" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_importer_modules" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_importers" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_modules" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_unpack" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="iter_zipimport_modules" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="iterdecode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="iterdir" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="iterdump" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="iterencode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="iteritems" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="iterkeys" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="itermonthdates" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itermonthdays" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itermonthdays2" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itervalues" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="iterweekdays" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="itn" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="itruediv" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="ixor" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="java_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; str&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="joinpath" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="json" func="yes">
			<Overload retVal="" descr="JSON (JavaScript Object Notation) &lt;http://json.org&gt; is a subset of&#10;JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data&#10;interchange format.&#10;&#10;:mod:`json` exposes an API familiar to users of the standard library&#10;:mod:`marshal` and :mod:`pickle` modules.  It is derived from a&#10;version of the externally maintained simplejson library.&#10;&#10;Encoding basic Python object hierarchies::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])&#10;    '[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1.0, 2]}]'&#10;    &gt;&gt;&gt; print(json.dumps(&quot;\&quot;foo\bar&quot;))&#10;    &quot;\&quot;foo\bar&quot;&#10;    &gt;&gt;&gt; print(json.dumps('\u1234'))&#10;    &quot;\u1234&quot;&#10;    &gt;&gt;&gt; print(json.dumps('\\'))&#10;    &quot;\\&quot;&#10;    &gt;&gt;&gt; print(json.dumps({&quot;c&quot;: 0, &quot;b&quot;: 0, &quot;a&quot;: 0}, sort_keys=True))&#10;    {&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0}&#10;    &gt;&gt;&gt; from io import StringIO&#10;    &gt;&gt;&gt; io = StringIO()&#10;    &gt;&gt;&gt; json.dump(['streaming API'], io)&#10;    &gt;&gt;&gt; io.getvalue()&#10;    '[&quot;streaming API&quot;]'&#10;&#10;Compact encoding::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; from collections import OrderedDict&#10;    &gt;&gt;&gt; mydict = OrderedDict([('4', 5), ('6', 7)])&#10;    &gt;&gt;&gt; json.dumps([1,2,3,mydict], separators=(',', ':'))&#10;    '[1,2,3,{&quot;4&quot;:5,&quot;6&quot;:7}]'&#10;&#10;Pretty printing::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))&#10;    {&#10;        &quot;4&quot;: 5,&#10;        &quot;6&quot;: 7&#10;    }&#10;&#10;Decoding JSON::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; obj = ['foo', {'bar': ['baz', None, 1.0, 2]}]&#10;    &gt;&gt;&gt; json.loads('[&quot;foo&quot;, {&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]}]') == obj&#10;    True&#10;    &gt;&gt;&gt; json.loads('&quot;\\&quot;foo\\bar&quot;') == '&quot;foo\x08ar'&#10;    True&#10;    &gt;&gt;&gt; from io import StringIO&#10;    &gt;&gt;&gt; io = StringIO('[&quot;streaming API&quot;]')&#10;    &gt;&gt;&gt; json.load(io)[0] == 'streaming API'&#10;    True&#10;&#10;Specializing JSON object decoding::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; def as_complex(dct):&#10;    ...     if '__complex__' in dct:&#10;    ...         return complex(dct['real'], dct['imag'])&#10;    ...     return dct&#10;    ...&#10;    &gt;&gt;&gt; json.loads('{&quot;__complex__&quot;: true, &quot;real&quot;: 1, &quot;imag&quot;: 2}',&#10;    ...     object_hook=as_complex)&#10;    (1+2j)&#10;    &gt;&gt;&gt; from decimal import Decimal&#10;    &gt;&gt;&gt; json.loads('1.1', parse_float=Decimal) == Decimal('1.1')&#10;    True&#10;&#10;Specializing JSON object encoding::&#10;&#10;    &gt;&gt;&gt; import json&#10;    &gt;&gt;&gt; def encode_complex(obj):&#10;    ...     if isinstance(obj, complex):&#10;    ...         return [obj.real, obj.imag]&#10;    ...     raise TypeError(repr(obj) + &quot; is not JSON serializable&quot;)&#10;    ...&#10;    &gt;&gt;&gt; json.dumps(2 + 1j, default=encode_complex)&#10;    '[2.0, 1.0]'&#10;    &gt;&gt;&gt; json.JSONEncoder(default=encode_complex).encode(2 + 1j)&#10;    '[2.0, 1.0]'&#10;    &gt;&gt;&gt; ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))&#10;    '[2.0, 1.0]'&#10;&#10;&#10;Using json.tool from the shell to validate and pretty-print::&#10;&#10;    $ echo '{&quot;json&quot;:&quot;obj&quot;}' | python -m json.tool&#10;    {&#10;        &quot;json&quot;: &quot;obj&quot;&#10;    }&#10;    $ echo '{ 1.2:3.4}' | python -m json.tool&#10;    Expecting property name enclosed in double quotes: line 1 column 3 (char 2)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecodeError" func="yes">
			<Overload retVal="" descr="Subclass of ValueError with the following additional properties:&#10;&#10;msg: The unformatted error message&#10;doc: The JSON document being parsed&#10;pos: The start index of doc where parsing failed&#10;lineno: The line corresponding to pos&#10;colno: The column corresponding to pos">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecodeError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecodeError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecoder" func="yes">
			<Overload retVal="" descr="Simple JSON &lt;http://json.org&gt; decoder&#10;&#10;Performs the following translations in decoding by default:&#10;&#10;+---------------+-------------------+&#10;| JSON          | Python            |&#10;+===============+===================+&#10;| object        | dict              |&#10;+---------------+-------------------+&#10;| array         | list              |&#10;+---------------+-------------------+&#10;| string        | str               |&#10;+---------------+-------------------+&#10;| number (int)  | int               |&#10;+---------------+-------------------+&#10;| number (real) | float             |&#10;+---------------+-------------------+&#10;| true          | True              |&#10;+---------------+-------------------+&#10;| false         | False             |&#10;+---------------+-------------------+&#10;| null          | None              |&#10;+---------------+-------------------+&#10;&#10;It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as&#10;their corresponding ``float`` values, which is outside the JSON spec.">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecoder.decode" func="yes">
			<Overload retVal="" descr="Return the Python representation of ``s`` (a ``str`` instance&#10;containing a JSON document).">
				<Param name="self" />
				<Param name="s" />
				<Param name="[_w=<built-in method match of _sre.SRE_Pattern object at 0x037D3020>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONDecoder.raw_decode" func="yes">
			<Overload retVal="" descr="Decode a JSON document from ``s`` (a ``str`` beginning with&#10;a JSON document) and return a 2-tuple of the Python&#10;representation and the index in ``s`` where the document ended.&#10;&#10;This can be used to decode a JSON document from a string that may&#10;have extraneous data at the end.">
				<Param name="self" />
				<Param name="s" />
				<Param name="[idx=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder" func="yes">
			<Overload retVal="" descr="Extensible JSON &lt;http://json.org&gt; encoder for Python data structures.&#10;&#10;Supports the following objects and types by default:&#10;&#10;+-------------------+---------------+&#10;| Python            | JSON          |&#10;+===================+===============+&#10;| dict              | object        |&#10;+-------------------+---------------+&#10;| list, tuple       | array         |&#10;+-------------------+---------------+&#10;| str               | string        |&#10;+-------------------+---------------+&#10;| int, float        | number        |&#10;+-------------------+---------------+&#10;| True              | true          |&#10;+-------------------+---------------+&#10;| False             | false         |&#10;+-------------------+---------------+&#10;| None              | null          |&#10;+-------------------+---------------+&#10;&#10;To extend this to recognize other objects, subclass and implement a&#10;``.default()`` method with another method that returns a serializable&#10;object for ``o`` if possible, otherwise it should call the superclass&#10;implementation (to raise ``TypeError``).">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.default" func="yes">
			<Overload retVal="" descr="Implement this method in a subclass such that it returns&#10;a serializable object for ``o``, or calls the base implementation&#10;(to raise a ``TypeError``).&#10;&#10;For example, to support arbitrary iterators, you could&#10;implement default like this::&#10;&#10;    def default(self, o):&#10;        try:&#10;            iterable = iter(o)&#10;        except TypeError:&#10;            pass&#10;        else:&#10;            return list(iterable)&#10;        # Let the base class default method raise the TypeError&#10;        return JSONEncoder.default(self, o)">
				<Param name="self" />
				<Param name="o" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.encode" func="yes">
			<Overload retVal="" descr="Return a JSON string representation of a Python data structure.&#10;&#10;&gt;&gt;&gt; from json.encoder import JSONEncoder&#10;&gt;&gt;&gt; JSONEncoder().encode({&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]})&#10;'{&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]}'">
				<Param name="self" />
				<Param name="o" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.item_separator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.iterencode" func="yes">
			<Overload retVal="" descr="Encode the given object and yield each string&#10;representation as available.&#10;&#10;For example::&#10;&#10;    for chunk in JSONEncoder().iterencode(bigobject):&#10;        mysocket.write(chunk)">
				<Param name="self" />
				<Param name="o" />
				<Param name="[_one_shot=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="json.JSONEncoder.key_separator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="json.detect_encoding" />
		<KeyWord name="json.dump" func="yes">
			<Overload retVal="" descr="Serialize ``obj`` as a JSON formatted stream to ``fp`` (a&#10;``.write()``-supporting file-like object).&#10;&#10;If ``skipkeys`` is true then ``dict`` keys that are not basic types&#10;(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped&#10;instead of raising a ``TypeError``.&#10;&#10;If ``ensure_ascii`` is false, then the strings written to ``fp`` can&#10;contain non-ASCII characters if they appear in strings contained in&#10;``obj``. Otherwise, all such characters are escaped in JSON strings.&#10;&#10;If ``check_circular`` is false, then the circular reference check&#10;for container types will be skipped and a circular reference will&#10;result in an ``OverflowError`` (or worse).&#10;&#10;If ``allow_nan`` is false, then it will be a ``ValueError`` to&#10;serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)&#10;in strict compliance of the JSON specification, instead of using the&#10;JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).&#10;&#10;If ``indent`` is a non-negative integer, then JSON array elements and&#10;object members will be pretty-printed with that indent level. An indent&#10;level of 0 will only insert newlines. ``None`` is the most compact&#10;representation.&#10;&#10;If specified, ``separators`` should be an ``(item_separator, key_separator)``&#10;tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and&#10;``(',', ': ')`` otherwise.  To get the most compact JSON representation,&#10;you should specify ``(',', ':')`` to eliminate whitespace.&#10;&#10;``default(obj)`` is a function that should return a serializable version&#10;of obj or raise TypeError. The default simply raises TypeError.&#10;&#10;If *sort_keys* is true (default: ``False``), then the output of&#10;dictionaries will be sorted by key.&#10;&#10;To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the&#10;``.default()`` method to serialize additional types), specify it with&#10;the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="json.dumps" func="yes">
			<Overload retVal="" descr="Serialize ``obj`` to a JSON formatted ``str``.&#10;&#10;If ``skipkeys`` is true then ``dict`` keys that are not basic types&#10;(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped&#10;instead of raising a ``TypeError``.&#10;&#10;If ``ensure_ascii`` is false, then the return value can contain non-ASCII&#10;characters if they appear in strings contained in ``obj``. Otherwise, all&#10;such characters are escaped in JSON strings.&#10;&#10;If ``check_circular`` is false, then the circular reference check&#10;for container types will be skipped and a circular reference will&#10;result in an ``OverflowError`` (or worse).&#10;&#10;If ``allow_nan`` is false, then it will be a ``ValueError`` to&#10;serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in&#10;strict compliance of the JSON specification, instead of using the&#10;JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).&#10;&#10;If ``indent`` is a non-negative integer, then JSON array elements and&#10;object members will be pretty-printed with that indent level. An indent&#10;level of 0 will only insert newlines. ``None`` is the most compact&#10;representation.&#10;&#10;If specified, ``separators`` should be an ``(item_separator, key_separator)``&#10;tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and&#10;``(',', ': ')`` otherwise.  To get the most compact JSON representation,&#10;you should specify ``(',', ':')`` to eliminate whitespace.&#10;&#10;``default(obj)`` is a function that should return a serializable version&#10;of obj or raise TypeError. The default simply raises TypeError.&#10;&#10;If *sort_keys* is true (default: ``False``), then the output of&#10;dictionaries will be sorted by key.&#10;&#10;To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the&#10;``.default()`` method to serialize additional types), specify it with&#10;the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="json.load" func="yes">
			<Overload retVal="" descr="Deserialize ``fp`` (a ``.read()``-supporting file-like object containing&#10;a JSON document) to a Python object.&#10;&#10;``object_hook`` is an optional function that will be called with the&#10;result of any object literal decode (a ``dict``). The return value of&#10;``object_hook`` will be used instead of the ``dict``. This feature&#10;can be used to implement custom decoders (e.g. JSON-RPC class hinting).&#10;&#10;``object_pairs_hook`` is an optional function that will be called with the&#10;result of any object literal decoded with an ordered list of pairs.  The&#10;return value of ``object_pairs_hook`` will be used instead of the ``dict``.&#10;This feature can be used to implement custom decoders that rely on the&#10;order that the key and value pairs are decoded (for example,&#10;collections.OrderedDict will remember the order of insertion). If&#10;``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.&#10;&#10;To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``&#10;kwarg; otherwise ``JSONDecoder`` is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="json.loads" func="yes">
			<Overload retVal="" descr="Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance&#10;containing a JSON document) to a Python object.&#10;&#10;``object_hook`` is an optional function that will be called with the&#10;result of any object literal decode (a ``dict``). The return value of&#10;``object_hook`` will be used instead of the ``dict``. This feature&#10;can be used to implement custom decoders (e.g. JSON-RPC class hinting).&#10;&#10;``object_pairs_hook`` is an optional function that will be called with the&#10;result of any object literal decoded with an ordered list of pairs.  The&#10;return value of ``object_pairs_hook`` will be used instead of the ``dict``.&#10;This feature can be used to implement custom decoders that rely on the&#10;order that the key and value pairs are decoded (for example,&#10;collections.OrderedDict will remember the order of insertion). If&#10;``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.&#10;&#10;``parse_float``, if specified, will be called with the string&#10;of every JSON float to be decoded. By default this is equivalent to&#10;float(num_str). This can be used to use another datatype or parser&#10;for JSON floats (e.g. decimal.Decimal).&#10;&#10;``parse_int``, if specified, will be called with the string&#10;of every JSON int to be decoded. By default this is equivalent to&#10;int(num_str). This can be used to use another datatype or parser&#10;for JSON integers (e.g. float).&#10;&#10;``parse_constant``, if specified, will be called with one of the&#10;following strings: -Infinity, Infinity, NaN.&#10;This can be used to raise an exception if invalid JSON numbers&#10;are encountered.&#10;&#10;To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``&#10;kwarg; otherwise ``JSONDecoder`` is used.&#10;&#10;The ``encoding`` argument is ignored and deprecated.">
			</Overload>
		</KeyWord>
		<KeyWord name="keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword" func="yes">
			<Overload retVal="" descr="Keywords (from &quot;graminit.c&quot;)&#10;&#10;This file is automatically generated; please don't muck it up!&#10;&#10;To update the symbols in this file, 'cd' to the top directory of&#10;the python source tree after building the interpreter and run:&#10;&#10;    ./python Lib/keyword.py">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword.iskeyword" func="yes">
			<Overload retVal="" descr="x.__contains__(y) &lt;==&gt; y in x.">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword.kwlist" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="keyword.main" />
		<KeyWord name="kill" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="label" func="yes">
			<Overload retVal="" descr="Function of cProfile">
			</Overload>
		</KeyWord>
		<KeyWord name="lambda" />
		<KeyWord name="last" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="lasti2lineno" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="latin_1_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="latin_1_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="lazycache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="lchmod" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="ldgettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="ldngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="le" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="leapdays" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="len" func="yes">
			<Overload retVal="" descr="Return the number of items in a container.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="length_hint" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="less" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="lexists" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="lgettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="lib2to3" />
		<KeyWord name="libc_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="line" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache" func="yes">
			<Overload retVal="" descr="Cache lines from Python source files.&#10;&#10;This is intended to read lines from modules imported -- hence if a filename&#10;is not found, it will look down the module search path for a file by&#10;that name.">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.cache" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.checkcache" func="yes">
			<Overload retVal="" descr="Discard cache entries that are out of date.&#10;(This is not checked upon each call!)">
				<Param name="[filename=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.clearcache" func="yes">
			<Overload retVal="" descr="Clear the cache entirely.">
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.getline" func="yes">
			<Overload retVal="" descr=>
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[module_globals=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.getlines" func="yes">
			<Overload retVal="" descr="Get the lines for a Python source file from the cache.&#10;Update the cache if it doesn't contain an entry for this file already.">
				<Param name="filename" />
				<Param name="[module_globals=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.lazycache" func="yes">
			<Overload retVal="" descr="Seed the cache for filename with module_globals.&#10;&#10;The module loader will be asked for the source only when getlines is&#10;called, not immediately.&#10;&#10;If there is an entry in the cache already, it is not altered.&#10;&#10;:return: True if a lazy load is registered in the cache,&#10;    otherwise False. To register such a load a module loader with a&#10;    get_source method must be found, the filename must be a cachable&#10;    filename, and the filename must not be already cached.">
				<Param name="filename" />
				<Param name="module_globals" />
			</Overload>
		</KeyWord>
		<KeyWord name="linecache.updatecache" func="yes">
			<Overload retVal="" descr="Update a cache entry and return its list of lines.&#10;If something's wrong, print a message, discard the cache entry,&#10;and return an empty list.">
				<Param name="filename" />
				<Param name="[module_globals=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="lineinfo" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="lineno" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="lineno_sort_key" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="link" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="linux_distribution" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="list" func="yes">
			<Overload retVal="" descr="list() -&gt; new empty list&#10;list(iterable) -&gt; new list initialized from iterable's items">
			</Overload>
		</KeyWord>
		<KeyWord name="list2cmdline" func="yes">
			<Overload retVal="" descr="Function of subprocess">
			</Overload>
		</KeyWord>
		<KeyWord name="list_dialects" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="list_folders" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="listdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="listen" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="listener" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="listkeywords" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="listmailcapfiles" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="listmodules" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="listsymbols" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="listtopics" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="literal_eval" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; str&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="ln" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="lngettext" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="load" func="yes">
			<Overload retVal="" descr="Function of json">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromModule" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromName" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromNames" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="loadTestsFromTestCase" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="load_cert_chain" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="load_compiled" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="load_default_certs" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="load_dh_params" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="load_dynamic" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="load_entry_point" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="load_extension" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="load_file" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="load_module" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="load_package" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="load_source" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="load_stats" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="load_tail" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="load_tests" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="load_verify_locations" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="loads" func="yes">
			<Overload retVal="" descr="Function of json">
			</Overload>
		</KeyWord>
		<KeyWord name="localcontext" func="yes">
			<Overload retVal="" descr="Function of decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="locale" func="yes">
			<Overload retVal="" descr="Locale support module.&#10;&#10;The module provides low-level access to the C lib's locale APIs and adds high&#10;level number formatting APIs as well as a locale aliasing engine to complement&#10;these.&#10;&#10;The aliasing engine includes support for many commonly used locale names and&#10;maps them to values suitable for passing to the C lib's setlocale() function. It&#10;also includes default encodings for all supported locale names.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.CHAR_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_COLLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_CTYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_MONETARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_NUMERIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.LC_TIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.atof" func="yes">
			<Overload retVal="" descr="Parses a string as a float according to the locale settings.">
				<Param name="string" />
				<Param name="[func=<class 'float'>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.atoi" func="yes">
			<Overload retVal="" descr="Converts a string to an integer according to the locale settings.">
				<Param name="string" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.currency" func="yes">
			<Overload retVal="" descr="Formats val according to the currency settings&#10;in the current locale.">
				<Param name="val" />
				<Param name="[symbol=True" />
				<Param name="[grouping=False" />
				<Param name="[international=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.delocalize" func="yes">
			<Overload retVal="" descr="Parses a string as a normalized number according to the locale settings.">
				<Param name="string" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.format" func="yes">
			<Overload retVal="" descr="Returns the locale-aware substitution of a %? specifier&#10;(percent).&#10;&#10;additional is for format strings which contain one or more&#10;'*' modifiers.">
				<Param name="percent" />
				<Param name="value" />
				<Param name="[grouping=False" />
				<Param name="[monetary=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.format_string" func="yes">
			<Overload retVal="" descr="Formats a string in the same way that the % formatting would use,&#10;but takes the current locale into account.&#10;Grouping is applied if the third parameter is true.">
				<Param name="f" />
				<Param name="val" />
				<Param name="[grouping=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.getdefaultlocale" func="yes">
			<Overload retVal="" descr="Tries to determine the default locale settings and returns&#10;them as tuple (language code, encoding).&#10;&#10;According to POSIX, a program which has not called&#10;setlocale(LC_ALL, &quot;&quot;) runs using the portable 'C' locale.&#10;Calling setlocale(LC_ALL, &quot;&quot;) lets it use the default locale as&#10;defined by the LANG variable. Since we don't want to interfere&#10;with the current locale setting we thus emulate the behavior&#10;in the way described above.&#10;&#10;To maintain compatibility with other platforms, not only the&#10;LANG variable is tested, but a list of variables given as&#10;envvars parameter. The first found to be defined will be&#10;used. envvars defaults to the search path used in GNU gettext;&#10;it must always contain the variable name 'LANG'.&#10;&#10;Except for the code 'C', the language code corresponds to RFC&#10;1766.  code and encoding can be None in case the values cannot&#10;be determined.">
				<Param name="[envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE')]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.getlocale" func="yes">
			<Overload retVal="" descr="Returns the current setting for the given locale category as&#10;tuple (language code, encoding).&#10;&#10;category may be one of the LC_* value except LC_ALL. It&#10;defaults to LC_CTYPE.&#10;&#10;Except for the code 'C', the language code corresponds to RFC&#10;1766.  code and encoding can be None in case the values cannot&#10;be determined.">
				<Param name="[category=2]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.getpreferredencoding" func="yes">
			<Overload retVal="" descr="Return the charset that the user is likely using.">
				<Param name="[do_setlocale=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.k" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.locale_alias" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.locale_encoding_alias" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.localeconv" func="yes">
			<Overload retVal="" descr="() -&gt; dict. Returns numeric and monetary locale-specific parameters.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.normalize" func="yes">
			<Overload retVal="" descr="Returns a normalized locale code for the given locale&#10;name.&#10;&#10;The returned locale code is formatted for use with&#10;setlocale().&#10;&#10;If normalization fails, the original name is returned&#10;unchanged.&#10;&#10;If the given encoding is not known, the function defaults to&#10;the default encoding for the locale code just like setlocale()&#10;does.">
				<Param name="localename" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.resetlocale" func="yes">
			<Overload retVal="" descr="Sets the locale for category to the default setting.&#10;&#10;The default setting is determined by calling&#10;getdefaultlocale(). category defaults to LC_ALL.">
				<Param name="[category=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.setlocale" func="yes">
			<Overload retVal="" descr="Set the locale for the given category.  The locale can be&#10;a string, an iterable of two strings (language code and encoding),&#10;or None.&#10;&#10;Iterables are converted to strings using the locale aliasing&#10;engine.  Locale strings are passed directly to the C lib.&#10;&#10;category may be given as one of the LC_* values.">
				<Param name="category" />
				<Param name="[locale=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.str" func="yes">
			<Overload retVal="" descr="Convert float to string, taking the locale into account.">
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="locale.strcoll" func="yes">
			<Overload retVal="" descr="string,string -&gt; int. Compares two strings according to the locale.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.strxfrm" func="yes">
			<Overload retVal="" descr="strxfrm(string) -&gt; string.&#10;&#10;Return a string that can be used as a key for locale-aware comparisons.">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.v" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="locale.windows_locale" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="localeconv" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="locals" func="yes">
			<Overload retVal="" descr="Return a dictionary containing the current scope's local variables.&#10;&#10;NOTE: Whether or not updates to this dictionary will affect name lookups in&#10;the local scope and vice-versa is *implementation dependent* and not&#10;covered by any backwards compatibility guarantees.">
			</Overload>
		</KeyWord>
		<KeyWord name="localtrace_count" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="localtrace_trace" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="localtrace_trace_and_count" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="locate" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="lock" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="lock_held" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="locked" func="yes">
			<Overload retVal="" descr="Function of asyncio.BoundedSemaphore">
			</Overload>
		</KeyWord>
		<KeyWord name="log" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="log10" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="log_info" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="log_to_stderr" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="logb" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="logging" func="yes">
			<Overload retVal="" descr="Logging package for Python. Based on PEP 282 and comments thereto in&#10;comp.lang.python.&#10;&#10;Copyright (C) 2001-2016 Vinay Sajip. All Rights Reserved.&#10;&#10;To use, simply 'import logging' and log away!">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BASIC_FORMAT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter" func="yes">
			<Overload retVal="" descr="A formatter suitable for formatting a number of records.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter.format" func="yes">
			<Overload retVal="" descr="Format the specified records and return the result as a string.">
				<Param name="self" />
				<Param name="records" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter.formatFooter" func="yes">
			<Overload retVal="" descr="Return the footer string for the specified records.">
				<Param name="self" />
				<Param name="records" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.BufferingFormatter.formatHeader" func="yes">
			<Overload retVal="" descr="Return the header string for the specified records.">
				<Param name="self" />
				<Param name="records" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.CRITICAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FATAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler" func="yes">
			<Overload retVal="" descr="A handler class which writes formatted logging records to disk files.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.close" func="yes">
			<Overload retVal="" descr="Closes the stream.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.emit" func="yes">
			<Overload retVal="" descr="Emit a record.&#10;&#10;If the stream was not opened because 'delay' was specified in the&#10;constructor, open it before calling the superclass's emit.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.flush" func="yes">
			<Overload retVal="" descr="Flushes the stream.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.get_name" />
		<KeyWord name="logging.FileHandler.handle" func="yes">
			<Overload retVal="" descr="Conditionally emit the specified logging record.&#10;&#10;Emission depends on filters which may have been added to the handler.&#10;Wrap the actual emission of the record with acquisition/release of&#10;the I/O thread lock. Returns whether the filter passed the record for&#10;emission.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.  level must be an int or a str.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.FileHandler.set_name" />
		<KeyWord name="logging.FileHandler.terminator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filter" func="yes">
			<Overload retVal="" descr='Filter instances are used to perform arbitrary filtering of LogRecords.&#10;&#10;Loggers and Handlers can optionally use Filter instances to filter&#10;records as desired. The base filter class only allows events which are&#10;below a certain point in the logger hierarchy. For example, a filter&#10;initialized with "A.B" will allow events logged by loggers "A.B",&#10;"A.B.C", "A.B.C.D", "A.B.D" etc. but not "A.BB", "B.A.B" etc. If&#10;initialized with the empty string, all events are passed.'>
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filter.filter" func="yes">
			<Overload retVal="" descr="Determine if the specified record is to be logged.&#10;&#10;Is the specified record to be logged? Returns 0 for no, nonzero for&#10;yes. If deemed appropriate, the record may be modified in-place.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer" func="yes">
			<Overload retVal="" descr="A base class for loggers and handlers which allows them to share&#10;common code.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Filterer.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter" func="yes">
			<Overload retVal="" descr="Formatter instances are used to convert a LogRecord to text.&#10;&#10;Formatters need to know how a LogRecord is constructed. They are&#10;responsible for converting a LogRecord to (usually) a string which can&#10;be interpreted by either a human or an external system. The base Formatter&#10;allows a formatting string to be specified. If none is supplied, the&#10;default value of &quot;%s(message)&quot; is used.&#10;&#10;The Formatter can be initialized with a format string which makes use of&#10;knowledge of the LogRecord attributes - e.g. the default value mentioned&#10;above makes use of the fact that the user's message and arguments are pre-&#10;formatted into a LogRecord's message attribute. Currently, the useful&#10;attributes in a LogRecord are described by:&#10;&#10;%(name)s            Name of the logger (logging channel)&#10;%(levelno)s         Numeric logging level for the message (DEBUG, INFO,&#10;                    WARNING, ERROR, CRITICAL)&#10;%(levelname)s       Text logging level for the message (&quot;DEBUG&quot;, &quot;INFO&quot;,&#10;                    &quot;WARNING&quot;, &quot;ERROR&quot;, &quot;CRITICAL&quot;)&#10;%(pathname)s        Full pathname of the source file where the logging&#10;                    call was issued (if available)&#10;%(filename)s        Filename portion of pathname&#10;%(module)s          Module (name portion of filename)&#10;%(lineno)d          Source line number where the logging call was issued&#10;                    (if available)&#10;%(funcName)s        Function name&#10;%(created)f         Time when the LogRecord was created (time.time()&#10;                    return value)&#10;%(asctime)s         Textual time when the LogRecord was created&#10;%(msecs)d           Millisecond portion of the creation time&#10;%(relativeCreated)d Time in milliseconds when the LogRecord was created,&#10;                    relative to the time the logging module was loaded&#10;                    (typically at application startup time)&#10;%(thread)d          Thread ID (if available)&#10;%(threadName)s      Thread name (if available)&#10;%(process)d         Process ID (if available)&#10;%(message)s         The result of record.getMessage(), computed just as&#10;                    the record is emitted">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.converter" func="yes">
			<Overload retVal="" descr="localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,&#10;                          tm_sec,tm_wday,tm_yday,tm_isdst)&#10;&#10;Convert seconds since the Epoch to a time tuple expressing local time.&#10;When 'seconds' is not passed in, convert the current time instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.default_msec_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.default_time_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.format" func="yes">
			<Overload retVal="" descr="Format the specified record as text.&#10;&#10;The record's attribute dictionary is used as the operand to a&#10;string formatting operation which yields the returned string.&#10;Before formatting the dictionary, a couple of preparatory steps&#10;are carried out. The message attribute of the record is computed&#10;using LogRecord.getMessage(). If the formatting string uses the&#10;time (as determined by a call to usesTime(), formatTime() is&#10;called to format the event time. If there is exception information,&#10;it is formatted using formatException() and appended to the message.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.formatException" func="yes">
			<Overload retVal="" descr="Format and return the specified exception information as a string.&#10;&#10;This default implementation just uses&#10;traceback.print_exception()">
				<Param name="self" />
				<Param name="ei" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.formatMessage" />
		<KeyWord name="logging.Formatter.formatStack" func="yes">
			<Overload retVal="" descr="This method is provided as an extension point for specialized&#10;formatting of stack information.&#10;&#10;The input data is a string as returned from a call to&#10;:func:`traceback.print_stack`, but with the last trailing newline&#10;removed.&#10;&#10;The base implementation just returns the value passed in.">
				<Param name="self" />
				<Param name="stack_info" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.formatTime" func="yes">
			<Overload retVal="" descr="Return the creation time of the specified LogRecord as formatted text.&#10;&#10;This method should be called from format() by a formatter which&#10;wants to make use of a formatted time. This method can be overridden&#10;in formatters to provide for any specific requirement, but the&#10;basic behaviour is as follows: if datefmt (a string) is specified,&#10;it is used with time.strftime() to format the creation time of the&#10;record. Otherwise, the ISO8601 format is used. The resulting&#10;string is returned. This function uses a user-configurable function&#10;to convert the creation time to a tuple. By default, time.localtime()&#10;is used; to change this for a particular formatter instance, set the&#10;'converter' attribute to a function with the same signature as&#10;time.localtime() or time.gmtime(). To change it for all formatters,&#10;for example if you want all logging times to be shown in GMT,&#10;set the 'converter' attribute in the Formatter class.">
				<Param name="self" />
				<Param name="record" />
				<Param name="[datefmt=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Formatter.usesTime" func="yes">
			<Overload retVal="" descr="Check if the format uses the creation time of the record.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler" func="yes">
			<Overload retVal="" descr="Handler instances dispatch logging events to specific destinations.&#10;&#10;The base handler class. Acts as a placeholder which defines the Handler&#10;interface. Handlers can optionally use Formatter instances to format&#10;records as desired. By default, no formatter is specified; in this case,&#10;the 'raw' message as determined by record.message is logged.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.close" func="yes">
			<Overload retVal="" descr="Tidy up any resources used by the handler.&#10;&#10;This version removes the handler from an internal map of handlers,&#10;_handlers, which is used for handler lookup by name. Subclasses&#10;should ensure that this gets called from overridden close()&#10;methods.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.emit" func="yes">
			<Overload retVal="" descr="Do whatever it takes to actually log the specified logging record.&#10;&#10;This version is intended to be implemented by subclasses and so&#10;raises a NotImplementedError.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.flush" func="yes">
			<Overload retVal="" descr="Ensure all logging output has been flushed.&#10;&#10;This version does nothing and is intended to be implemented by&#10;subclasses.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.get_name" />
		<KeyWord name="logging.Handler.handle" func="yes">
			<Overload retVal="" descr="Conditionally emit the specified logging record.&#10;&#10;Emission depends on filters which may have been added to the handler.&#10;Wrap the actual emission of the record with acquisition/release of&#10;the I/O thread lock. Returns whether the filter passed the record for&#10;emission.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.  level must be an int or a str.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Handler.set_name" />
		<KeyWord name="logging.INFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LogRecord" func="yes">
			<Overload retVal="" descr="A LogRecord instance represents an event being logged.&#10;&#10;LogRecord instances are created every time something is logged. They&#10;contain all the information pertinent to the event being logged. The&#10;main information passed in is in msg and args, which are combined&#10;using str(msg) % args to create the message field of the record. The&#10;record also includes information such as when the record was created,&#10;the source line where the logging call was made, and any exception&#10;information to be logged.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LogRecord.getMessage" func="yes">
			<Overload retVal="" descr="Return the message for this LogRecord.&#10;&#10;Return the message for this LogRecord after merging any user-supplied&#10;arguments with the message.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger" func="yes">
			<Overload retVal="" descr='Instances of the Logger class represent a single logging channel. A&#10;"logging channel" indicates an area of an application. Exactly how an&#10;"area" is defined is up to the application developer. Since an&#10;application can have any number of areas, logging channels are identified&#10;by a unique string. Application areas can be nested (e.g. an area&#10;of "input processing" might include sub-areas "read CSV files", "read&#10;XLS files" and "read Gnumeric files"). To cater for this natural nesting,&#10;channel names are organized into a namespace hierarchy where levels are&#10;separated by periods, much like the Java or Python package namespace. So&#10;in the instance given above, channel names might be "input" for the upper&#10;level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.&#10;There is no arbitrary limit to the depth of nesting.'>
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.addHandler" func="yes">
			<Overload retVal="" descr="Add the specified handler to this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.callHandlers" func="yes">
			<Overload retVal="" descr='Pass a record to all relevant handlers.&#10;&#10;Loop through all handlers for this logger and its parents in the&#10;logger hierarchy. If no handler was found, output a one-off error&#10;message to sys.stderr. Stop searching up the hierarchy whenever a&#10;logger with the "propagate" attribute set to zero is found - that&#10;will be the last logger whose handlers are called.'>
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.critical" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.debug" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'DEBUG'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.debug(&quot;Houston, we have a %s&quot;, &quot;thorny problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.error" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'ERROR'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.error(&quot;Houston, we have a %s&quot;, &quot;major problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.exception" func="yes">
			<Overload retVal="" descr="Convenience method for logging an ERROR with exception information.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.fatal" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.findCaller" func="yes">
			<Overload retVal="" descr="Find the stack frame of the caller so that we can note the source&#10;file name, line number and function name.">
				<Param name="self" />
				<Param name="[stack_info=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.getChild" func="yes">
			<Overload retVal="" descr="Get a logger which is a descendant to this one.&#10;&#10;This is a convenience method, such that&#10;&#10;logging.getLogger('abc').getChild('def.ghi')&#10;&#10;is the same as&#10;&#10;logging.getLogger('abc.def.ghi')&#10;&#10;It's useful, for example, when the parent logger is named using&#10;__name__ rather than a literal string.">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Get the effective level for this logger.&#10;&#10;Loop through this logger and its parents in the logger hierarchy,&#10;looking for a non-zero logging level. Return the first one found.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.handle" func="yes">
			<Overload retVal="" descr="Call the handlers for the specified record.&#10;&#10;This method is used for unpickled records received from a socket, as&#10;well as those created locally. Logger-level filtering is applied.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.hasHandlers" func="yes">
			<Overload retVal="" descr='See if this logger has any handlers configured.&#10;&#10;Loop through all handlers for this logger and its parents in the&#10;logger hierarchy. Return True if a handler was found, else False.&#10;Stop searching up the hierarchy whenever a logger with the "propagate"&#10;attribute set to zero is found - that will be the last logger which&#10;is checked for the existence of handlers.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.info" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'INFO'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.info(&quot;Houston, we have a %s&quot;, &quot;interesting problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.isEnabledFor" func="yes">
			<Overload retVal="" descr="Is this logger enabled for level 'level'?">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.log" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with the integer severity 'level'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.log(level, &quot;We have a %s&quot;, &quot;mysterious problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.makeRecord" func="yes">
			<Overload retVal="" descr="A factory method which can be overridden in subclasses to create&#10;specialized LogRecords.">
				<Param name="self" />
				<Param name="name" />
				<Param name="level" />
				<Param name="fn" />
				<Param name="lno" />
				<Param name="msg" />
				<Param name="args" />
				<Param name="exc_info" />
				<Param name="[func=None" />
				<Param name="[extra=None" />
				<Param name="[sinfo=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.manager" func="yes">
			<Overload retVal="" descr="(Manager)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.removeHandler" func="yes">
			<Overload retVal="" descr="Remove the specified handler from this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.root" func="yes">
			<Overload retVal="" descr="(RootLogger)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this logger.  level must be an int or a str.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.warn" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Logger.warning" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'WARNING'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter" func="yes">
			<Overload retVal="" descr="An adapter for loggers which makes it easier to specify contextual&#10;information in logging output.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.critical" func="yes">
			<Overload retVal="" descr="Delegate a critical call to the underlying logger.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.debug" func="yes">
			<Overload retVal="" descr="Delegate a debug call to the underlying logger.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.error" func="yes">
			<Overload retVal="" descr="Delegate an error call to the underlying logger.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.exception" func="yes">
			<Overload retVal="" descr="Delegate an exception call to the underlying logger.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Get the effective level for the underlying logger.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.hasHandlers" func="yes">
			<Overload retVal="" descr="See if the underlying logger has any handlers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.info" func="yes">
			<Overload retVal="" descr="Delegate an info call to the underlying logger.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.isEnabledFor" func="yes">
			<Overload retVal="" descr="Is this logger enabled for level 'level'?">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.log" func="yes">
			<Overload retVal="" descr="Delegate a log call to the underlying logger, after adding&#10;contextual information from this adapter instance.">
				<Param name="self" />
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.manager" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.process" func="yes">
			<Overload retVal="" descr="Process the logging message and keyword arguments passed in to&#10;a logging call to insert contextual information. You can either&#10;manipulate the message itself, the keyword args or both. Return&#10;the message and kwargs modified (or not) to suit your needs.&#10;&#10;Normally, you'll only need to override this one method in a&#10;LoggerAdapter subclass for your specific needs.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="kwargs" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.setLevel" func="yes">
			<Overload retVal="" descr="Set the specified level on the underlying logger.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.warn" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.LoggerAdapter.warning" func="yes">
			<Overload retVal="" descr="Delegate a warning call to the underlying logger.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager" func="yes">
			<Overload retVal="" descr="There is [under normal circumstances] just one Manager instance, which&#10;holds the hierarchy of loggers.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager.getLogger" func="yes">
			<Overload retVal="" descr="Get a logger with the specified name (channel name), creating it&#10;if it doesn't yet exist. This name is a dot-separated hierarchical&#10;name, such as &quot;a&quot;, &quot;a.b&quot;, &quot;a.b.c&quot; or similar.&#10;&#10;If a PlaceHolder existed for the specified name [i.e. the logger&#10;didn't exist but a child of it did], replace it with the created&#10;logger and fix up the parent/child references which pointed to the&#10;placeholder to now point to the logger.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager.setLogRecordFactory" func="yes">
			<Overload retVal="" descr="Set the factory to be used when instantiating a log record with this&#10;Manager.">
				<Param name="self" />
				<Param name="factory" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.Manager.setLoggerClass" func="yes">
			<Overload retVal="" descr="Set the class to be used when instantiating a logger with this Manager.">
				<Param name="self" />
				<Param name="klass" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler" func="yes">
			<Overload retVal="" descr="This handler does nothing. It's intended to be used to avoid the&#10;&quot;No handlers could be found for logger XXX&quot; one-off warning. This is&#10;important for library code, which may contain code to log events. If a user&#10;of the library does not configure logging, the one-off warning might be&#10;produced; to avoid this, the library developer simply needs to instantiate&#10;a NullHandler and add it to the top-level logger of the library module or&#10;package.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.close" func="yes">
			<Overload retVal="" descr="Tidy up any resources used by the handler.&#10;&#10;This version removes the handler from an internal map of handlers,&#10;_handlers, which is used for handler lookup by name. Subclasses&#10;should ensure that this gets called from overridden close()&#10;methods.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.emit" func="yes">
			<Overload retVal="" descr="Stub.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.flush" func="yes">
			<Overload retVal="" descr="Ensure all logging output has been flushed.&#10;&#10;This version does nothing and is intended to be implemented by&#10;subclasses.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.get_name" />
		<KeyWord name="logging.NullHandler.handle" func="yes">
			<Overload retVal="" descr="Stub.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.  level must be an int or a str.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.NullHandler.set_name" />
		<KeyWord name="logging.PercentStyle" />
		<KeyWord name="logging.PercentStyle.asctime_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.PercentStyle.asctime_search" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.PercentStyle.default_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.PercentStyle.format" />
		<KeyWord name="logging.PercentStyle.usesTime" />
		<KeyWord name="logging.PlaceHolder" func="yes">
			<Overload retVal="" descr="PlaceHolder instances are used in the Manager logger hierarchy to take&#10;the place of nodes for which no loggers have been defined. This class is&#10;intended for internal use only and not as part of the public API.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.PlaceHolder.append" func="yes">
			<Overload retVal="" descr="Add the specified logger as a child of this placeholder.">
				<Param name="self" />
				<Param name="alogger" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger" func="yes">
			<Overload retVal="" descr="A root logger is not that different to any other logger, except that&#10;it must have a logging level and there is only one instance of it in&#10;the hierarchy.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.addHandler" func="yes">
			<Overload retVal="" descr="Add the specified handler to this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.callHandlers" func="yes">
			<Overload retVal="" descr='Pass a record to all relevant handlers.&#10;&#10;Loop through all handlers for this logger and its parents in the&#10;logger hierarchy. If no handler was found, output a one-off error&#10;message to sys.stderr. Stop searching up the hierarchy whenever a&#10;logger with the "propagate" attribute set to zero is found - that&#10;will be the last logger whose handlers are called.'>
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.critical" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.debug" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'DEBUG'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.debug(&quot;Houston, we have a %s&quot;, &quot;thorny problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.error" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'ERROR'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.error(&quot;Houston, we have a %s&quot;, &quot;major problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.exception" func="yes">
			<Overload retVal="" descr="Convenience method for logging an ERROR with exception information.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.fatal" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'CRITICAL'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.critical(&quot;Houston, we have a %s&quot;, &quot;major disaster&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.findCaller" func="yes">
			<Overload retVal="" descr="Find the stack frame of the caller so that we can note the source&#10;file name, line number and function name.">
				<Param name="self" />
				<Param name="[stack_info=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.getChild" func="yes">
			<Overload retVal="" descr="Get a logger which is a descendant to this one.&#10;&#10;This is a convenience method, such that&#10;&#10;logging.getLogger('abc').getChild('def.ghi')&#10;&#10;is the same as&#10;&#10;logging.getLogger('abc.def.ghi')&#10;&#10;It's useful, for example, when the parent logger is named using&#10;__name__ rather than a literal string.">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.getEffectiveLevel" func="yes">
			<Overload retVal="" descr="Get the effective level for this logger.&#10;&#10;Loop through this logger and its parents in the logger hierarchy,&#10;looking for a non-zero logging level. Return the first one found.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.handle" func="yes">
			<Overload retVal="" descr="Call the handlers for the specified record.&#10;&#10;This method is used for unpickled records received from a socket, as&#10;well as those created locally. Logger-level filtering is applied.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.hasHandlers" func="yes">
			<Overload retVal="" descr='See if this logger has any handlers configured.&#10;&#10;Loop through all handlers for this logger and its parents in the&#10;logger hierarchy. Return True if a handler was found, else False.&#10;Stop searching up the hierarchy whenever a logger with the "propagate"&#10;attribute set to zero is found - that will be the last logger which&#10;is checked for the existence of handlers.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.info" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'INFO'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.info(&quot;Houston, we have a %s&quot;, &quot;interesting problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.isEnabledFor" func="yes">
			<Overload retVal="" descr="Is this logger enabled for level 'level'?">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.log" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with the integer severity 'level'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.log(level, &quot;We have a %s&quot;, &quot;mysterious problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.makeRecord" func="yes">
			<Overload retVal="" descr="A factory method which can be overridden in subclasses to create&#10;specialized LogRecords.">
				<Param name="self" />
				<Param name="name" />
				<Param name="level" />
				<Param name="fn" />
				<Param name="lno" />
				<Param name="msg" />
				<Param name="args" />
				<Param name="exc_info" />
				<Param name="[func=None" />
				<Param name="[extra=None" />
				<Param name="[sinfo=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.manager" func="yes">
			<Overload retVal="" descr="(Manager)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.removeHandler" func="yes">
			<Overload retVal="" descr="Remove the specified handler from this logger.">
				<Param name="self" />
				<Param name="hdlr" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.root" func="yes">
			<Overload retVal="" descr="(RootLogger)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this logger.  level must be an int or a str.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.warn" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.RootLogger.warning" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with severity 'WARNING'.&#10;&#10;To pass exception information, use the keyword argument exc_info with&#10;a true value, e.g.&#10;&#10;logger.warning(&quot;Houston, we have a %s&quot;, &quot;bit of a problem&quot;, exc_info=1)">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StrFormatStyle" />
		<KeyWord name="logging.StrFormatStyle.asctime_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StrFormatStyle.asctime_search" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StrFormatStyle.default_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StrFormatStyle.format" />
		<KeyWord name="logging.StrFormatStyle.usesTime" />
		<KeyWord name="logging.StreamHandler" func="yes">
			<Overload retVal="" descr="A handler class which writes logging records, appropriately formatted,&#10;to a stream. Note that this class does not close the stream, as&#10;sys.stdout or sys.stderr may be used.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.acquire" func="yes">
			<Overload retVal="" descr="Acquire the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.addFilter" func="yes">
			<Overload retVal="" descr="Add the specified filter to this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.close" func="yes">
			<Overload retVal="" descr="Tidy up any resources used by the handler.&#10;&#10;This version removes the handler from an internal map of handlers,&#10;_handlers, which is used for handler lookup by name. Subclasses&#10;should ensure that this gets called from overridden close()&#10;methods.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.createLock" func="yes">
			<Overload retVal="" descr="Acquire a thread lock for serializing access to the underlying I/O.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.emit" func="yes">
			<Overload retVal="" descr="Emit a record.&#10;&#10;If a formatter is specified, it is used to format the record.&#10;The record is then written to the stream with a trailing newline.  If&#10;exception information is present, it is formatted using&#10;traceback.print_exception and appended to the stream.  If the stream&#10;has an 'encoding' attribute, it is used to determine how to do the&#10;output to the stream.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.filter" func="yes">
			<Overload retVal="" descr="Determine if a record is loggable by consulting all the filters.&#10;&#10;The default is to allow the record to be logged; any filter can veto&#10;this and the record is then dropped. Returns a zero value if a record&#10;is to be dropped, else non-zero.&#10;&#10;.. versionchanged:: 3.2&#10;&#10;   Allow filters to be just callables.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.flush" func="yes">
			<Overload retVal="" descr="Flushes the stream.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.format" func="yes">
			<Overload retVal="" descr="Format the specified record.&#10;&#10;If a formatter is set, use it. Otherwise, use the default formatter&#10;for the module.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.get_name" />
		<KeyWord name="logging.StreamHandler.handle" func="yes">
			<Overload retVal="" descr="Conditionally emit the specified logging record.&#10;&#10;Emission depends on filters which may have been added to the handler.&#10;Wrap the actual emission of the record with acquisition/release of&#10;the I/O thread lock. Returns whether the filter passed the record for&#10;emission.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.handleError" func="yes">
			<Overload retVal="" descr="Handle errors which occur during an emit() call.&#10;&#10;This method should be called from handlers when an exception is&#10;encountered during an emit() call. If raiseExceptions is false,&#10;exceptions get silently ignored. This is what is mostly wanted&#10;for a logging system - most users will not care about errors in&#10;the logging system, they are more interested in application errors.&#10;You could, however, replace this with a custom handler if you wish.&#10;The record which was being processed is passed in to this method.">
				<Param name="self" />
				<Param name="record" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.release" func="yes">
			<Overload retVal="" descr="Release the I/O thread lock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.removeFilter" func="yes">
			<Overload retVal="" descr="Remove the specified filter from this handler.">
				<Param name="self" />
				<Param name="filter" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.setFormatter" func="yes">
			<Overload retVal="" descr="Set the formatter for this handler.">
				<Param name="self" />
				<Param name="fmt" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.setLevel" func="yes">
			<Overload retVal="" descr="Set the logging level of this handler.  level must be an int or a str.">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StreamHandler.set_name" />
		<KeyWord name="logging.StreamHandler.terminator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StringTemplateStyle" />
		<KeyWord name="logging.StringTemplateStyle.asctime_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StringTemplateStyle.asctime_search" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StringTemplateStyle.default_format" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.StringTemplateStyle.format" />
		<KeyWord name="logging.StringTemplateStyle.usesTime" />
		<KeyWord name="logging.Template" func="yes">
			<Overload retVal="" descr="(_TemplateMetaclass)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.WARN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.WARNING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.addLevelName" func="yes">
			<Overload retVal="" descr="Associate 'levelName' with 'level'.&#10;&#10;This is used when converting levels to text during message formatting.">
				<Param name="level" />
				<Param name="levelName" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.basicConfig" func="yes">
			<Overload retVal="" descr="Do basic configuration for the logging system.&#10;&#10;This function does nothing if the root logger already has handlers&#10;configured. It is a convenience method intended for use by simple scripts&#10;to do one-shot configuration of the logging package.&#10;&#10;The default behaviour is to create a StreamHandler which writes to&#10;sys.stderr, set a formatter using the BASIC_FORMAT format string, and&#10;add the handler to the root logger.&#10;&#10;A number of optional keyword arguments may be specified, which can alter&#10;the default behaviour.&#10;&#10;filename  Specifies that a FileHandler be created, using the specified&#10;          filename, rather than a StreamHandler.&#10;filemode  Specifies the mode to open the file, if filename is specified&#10;          (if filemode is unspecified, it defaults to 'a').&#10;format    Use the specified format string for the handler.&#10;datefmt   Use the specified date/time format.&#10;style     If a format string is specified, use this to specify the&#10;          type of format string (possible values '%', '{', '$', for&#10;          %-formatting, :meth:`str.format` and :class:`string.Template`&#10;          - defaults to '%').&#10;level     Set the root logger level to the specified level.&#10;stream    Use the specified stream to initialize the StreamHandler. Note&#10;          that this argument is incompatible with 'filename' - if both&#10;          are present, 'stream' is ignored.&#10;handlers  If specified, this should be an iterable of already created&#10;          handlers, which will be added to the root handler. Any handler&#10;          in the list which does not have a formatter assigned will be&#10;          assigned the formatter created in this function.&#10;&#10;Note that you could specify a stream created using open(filename, mode)&#10;rather than passing the filename and mode in. However, it should be&#10;remembered that StreamHandler does not close its stream (since it may be&#10;using sys.stdout or sys.stderr), whereas FileHandler closes its stream&#10;when the handler is closed.&#10;&#10;.. versionchanged:: 3.2&#10;   Added the ``style`` parameter.&#10;&#10;.. versionchanged:: 3.3&#10;   Added the ``handlers`` parameter. A ``ValueError`` is now thrown for&#10;   incompatible arguments (e.g. ``handlers`` specified together with&#10;   ``filename``/``filemode``, or ``filename``/``filemode`` specified&#10;   together with ``stream``, or ``handlers`` specified together with&#10;   ``stream``.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.captureWarnings" func="yes">
			<Overload retVal="" descr="If capture is true, redirect all warnings to the logging package.&#10;If capture is False, ensure that warnings are not redirected to logging&#10;but to their original destinations.">
				<Param name="capture" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.critical" func="yes">
			<Overload retVal="" descr="Log a message with severity 'CRITICAL' on the root logger. If the logger&#10;has no handlers, call basicConfig() to add a console handler with a&#10;pre-defined format.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.currentframe" />
		<KeyWord name="logging.debug" func="yes">
			<Overload retVal="" descr="Log a message with severity 'DEBUG' on the root logger. If the logger has&#10;no handlers, call basicConfig() to add a console handler with a pre-defined&#10;format.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.disable" func="yes">
			<Overload retVal="" descr="Disable all logging calls of severity 'level' and below.">
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.error" func="yes">
			<Overload retVal="" descr="Log a message with severity 'ERROR' on the root logger. If the logger has&#10;no handlers, call basicConfig() to add a console handler with a pre-defined&#10;format.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.exception" func="yes">
			<Overload retVal="" descr="Log a message with severity 'ERROR' on the root logger, with exception&#10;information. If the logger has no handlers, basicConfig() is called to add&#10;a console handler with a pre-defined format.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.fatal" func="yes">
			<Overload retVal="" descr="Log a message with severity 'CRITICAL' on the root logger. If the logger&#10;has no handlers, call basicConfig() to add a console handler with a&#10;pre-defined format.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLevelName" func="yes">
			<Overload retVal="" descr="Return the textual representation of logging level 'level'.&#10;&#10;If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,&#10;INFO, DEBUG) then you get the corresponding string. If you have&#10;associated levels with names using addLevelName then the name you have&#10;associated with 'level' is returned.&#10;&#10;If a numeric value corresponding to one of the defined levels is passed&#10;in, the corresponding string representation is returned.&#10;&#10;Otherwise, the string &quot;Level %s&quot; % level is returned.">
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLogRecordFactory" func="yes">
			<Overload retVal="" descr="Return the factory to be used when instantiating a log record.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLogger" func="yes">
			<Overload retVal="" descr="Return a logger with the specified name, creating it if necessary.&#10;&#10;If no name is specified, return the root logger.">
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.getLoggerClass" func="yes">
			<Overload retVal="" descr="Return the class to be used when instantiating a logger.">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.info" func="yes">
			<Overload retVal="" descr="Log a message with severity 'INFO' on the root logger. If the logger has&#10;no handlers, call basicConfig() to add a console handler with a pre-defined&#10;format.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.lastResort" func="yes">
			<Overload retVal="" descr="(_StderrHandler)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.log" func="yes">
			<Overload retVal="" descr="Log 'msg % args' with the integer severity 'level' on the root logger. If&#10;the logger has no handlers, call basicConfig() to add a console handler&#10;with a pre-defined format.">
				<Param name="level" />
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.logMultiprocessing" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.logProcesses" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.logThreads" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.makeLogRecord" func="yes">
			<Overload retVal="" descr="Make a LogRecord whose attributes are defined by the specified dictionary,&#10;This function is useful for converting a logging event received over&#10;a socket connection (which is sent as a dictionary) into a LogRecord&#10;instance.">
				<Param name="dict" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.raiseExceptions" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.root" func="yes">
			<Overload retVal="" descr="(RootLogger)">
			</Overload>
		</KeyWord>
		<KeyWord name="logging.setLogRecordFactory" func="yes">
			<Overload retVal="" descr="Set the factory to be used when instantiating a log record.&#10;&#10;:param factory: A callable which will be called to instantiate&#10;a log record.">
				<Param name="factory" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.setLoggerClass" func="yes">
			<Overload retVal="" descr="Set the class to be used when instantiating a logger. The class should&#10;define __init__() such that only a name argument is required, and the&#10;__init__() should call Logger.__init__()">
				<Param name="klass" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.shutdown" func="yes">
			<Overload retVal="" descr="Perform any cleanup actions in the logging system (e.g. flushing&#10;buffers).&#10;&#10;Should be called at application exit.">
				<Param name="[handlerList=[<weakref at 0x031C7810; to '_StderrHandler' at 0x031C17F0>, <weakref at 0x04068960; to 'NullHandler' at 0x04092D70>, <weakref at 0x04068390; to 'NullHandler' at 0x04092DB0>, <weakref at 0x043CE9F0; to 'NullHandler' at 0x043CAE10>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.warn" func="yes">
			<Overload retVal="" descr=>
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logging.warning" func="yes">
			<Overload retVal="" descr="Log a message with severity 'WARNING' on the root logger. If the logger has&#10;no handlers, call basicConfig() to add a console handler with a pre-defined&#10;format.">
				<Param name="msg" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="logical_and" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="logical_invert" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="logical_or" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="logical_xor" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="login" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="login_cram_md5" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="lognormvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="logout" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="long_has_args" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="longest_run_of_spaces" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="lookup" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="lookup_error" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="lookupmodule" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="loop" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; str&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="lru_cache" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="lseek" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="lshift" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="lstat" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="lsub" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="lt" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma" func="yes">
			<Overload retVal="" descr="Interface to the liblzma compression library.&#10;&#10;This module provides a class for reading and writing compressed files,&#10;classes for incremental (de)compression, and convenience functions for&#10;one-shot (de)compression.&#10;&#10;These classes and functions support both the XZ and legacy LZMA&#10;container formats, as well as raw compressed data streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.CHECK_CRC32" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.CHECK_CRC64" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.CHECK_ID_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.CHECK_SHA256" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.CHECK_UNKNOWN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_ARM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_ARMTHUMB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_DELTA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_IA64" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_LZMA1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_LZMA2" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_POWERPC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_SPARC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FILTER_X86" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FORMAT_ALONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FORMAT_RAW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.FORMAT_XZ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMACompressor" func="yes">
			<Overload retVal="" descr="LZMACompressor(format=FORMAT_XZ, check=-1, preset=None, filters=None)&#10;&#10;Create a compressor object for compressing data incrementally.&#10;&#10;format specifies the container format to use for the output. This can&#10;be FORMAT_XZ (default), FORMAT_ALONE, or FORMAT_RAW.&#10;&#10;check specifies the integrity check to use. For FORMAT_XZ, the default&#10;is CHECK_CRC64. FORMAT_ALONE and FORMAT_RAW do not suport integrity&#10;checks; for these formats, check must be omitted, or be CHECK_NONE.&#10;&#10;The settings used by the compressor can be specified either as a&#10;preset compression level (with the 'preset' argument), or in detail&#10;as a custom filter chain (with the 'filters' argument). For FORMAT_XZ&#10;and FORMAT_ALONE, the default is to use the PRESET_DEFAULT preset&#10;level. For FORMAT_RAW, the caller must always specify a filter chain;&#10;the raw compressor does not support preset compression levels.&#10;&#10;preset (if provided) should be an integer in the range 0-9, optionally&#10;OR-ed with the constant PRESET_EXTREME.&#10;&#10;filters (if provided) should be a sequence of dicts. Each dict should&#10;have an entry for &quot;id&quot; indicating the ID of the filter, plus&#10;additional entries for options to the filter.&#10;&#10;For one-shot compression, use the compress() function instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMACompressor.compress" func="yes">
			<Overload retVal="" descr="Provide data to the compressor object.&#10;&#10;Returns a chunk of compressed data if possible, or b'' otherwise.&#10;&#10;When you have finished providing data to the compressor, call the&#10;flush() method to finish the compression process.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMACompressor.flush" func="yes">
			<Overload retVal="" descr="Finish the compression process.&#10;&#10;Returns the compressed data left in internal buffers.&#10;&#10;The compressor object may not be used after this method is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMADecompressor" func="yes">
			<Overload retVal="" descr="Create a decompressor object for decompressing data incrementally.&#10;&#10;  format&#10;    Specifies the container format of the input stream.  If this is&#10;    FORMAT_AUTO (the default), the decompressor will automatically detect&#10;    whether the input is FORMAT_XZ or FORMAT_ALONE.  Streams created with&#10;    FORMAT_RAW cannot be autodetected.&#10;  memlimit&#10;    Limit the amount of memory used by the decompressor.  This will cause&#10;    decompression to fail if the input cannot be decompressed within the&#10;    given limit.&#10;  filters&#10;    A custom filter chain.  This argument is required for FORMAT_RAW, and&#10;    not accepted with any other format.  When provided, this should be a&#10;    sequence of dicts, each indicating the ID and options for a single&#10;    filter.&#10;&#10;For one-shot decompression, use the decompress() function instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMADecompressor.check" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMADecompressor.decompress" func="yes">
			<Overload retVal="" descr="Decompress *data*, returning uncompressed data as bytes.&#10;&#10;If *max_length* is nonnegative, returns at most *max_length* bytes of&#10;decompressed data. If this limit is reached and further output can be&#10;produced, *self.needs_input* will be set to ``False``. In this case, the next&#10;call to *decompress()* may provide *data* as b'' to obtain more of the output.&#10;&#10;If all of the input data was decompressed and returned (either because this&#10;was less than *max_length* bytes, or because *max_length* was negative),&#10;*self.needs_input* will be set to True.&#10;&#10;Attempting to decompress data after the end of stream is reached raises an&#10;EOFError.  Any data found after the end of the stream is ignored and saved in&#10;the unused_data attribute.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[max_length=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMADecompressor.eof" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMADecompressor.needs_input" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMADecompressor.unused_data" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMAError" func="yes">
			<Overload retVal="" descr="Call to liblzma failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMAError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMAError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.LZMAFile" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MF_BT2" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MF_BT3" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MF_BT4" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MF_HC3" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MF_HC4" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MODE_FAST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.MODE_NORMAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.PRESET_DEFAULT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.PRESET_EXTREME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.compress" func="yes">
			<Overload retVal="" descr="Compress a block of data.&#10;&#10;Refer to LZMACompressor's docstring for a description of the&#10;optional arguments *format*, *check*, *preset* and *filters*.&#10;&#10;For incremental compression, use an LZMACompressor instead.">
				<Param name="data" />
				<Param name="[format=1" />
				<Param name="[check=-1" />
				<Param name="[preset=None" />
				<Param name="[filters=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.decompress" func="yes">
			<Overload retVal="" descr="Decompress a block of data.&#10;&#10;Refer to LZMADecompressor's docstring for a description of the&#10;optional arguments *format*, *check* and *filters*.&#10;&#10;For incremental decompression, use an LZMADecompressor instead.">
				<Param name="data" />
				<Param name="[format=0" />
				<Param name="[memlimit=None" />
				<Param name="[filters=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.is_check_supported" func="yes">
			<Overload retVal="" descr="Test whether the given integrity check is supported.&#10;&#10;Always returns True for CHECK_NONE and CHECK_CRC32.">
				<Param name="check_id" />
			</Overload>
		</KeyWord>
		<KeyWord name="lzma.open" func="yes">
			<Overload retVal="" descr='Open an LZMA-compressed file in binary or text mode.&#10;&#10;filename can be either an actual file name (given as a str, bytes,&#10;or PathLike object), in which case the named file is opened, or it&#10;can be an existing file object to read from or write to.&#10;&#10;The mode argument can be "r", "rb" (default), "w", "wb", "x", "xb",&#10;"a", or "ab" for binary mode, or "rt", "wt", "xt", or "at" for text&#10;mode.&#10;&#10;The format, check, preset and filters arguments specify the&#10;compression settings, as for LZMACompressor, LZMADecompressor and&#10;LZMAFile.&#10;&#10;For binary mode, this function is equivalent to the LZMAFile&#10;constructor: LZMAFile(filename, mode, ...). In this case, the&#10;encoding, errors and newline arguments must not be provided.&#10;&#10;For text mode, an LZMAFile object is created, and wrapped in an&#10;io.TextIOWrapper instance with the specified encoding, error&#10;handling behavior, and line ending(s).'>
			</Overload>
		</KeyWord>
		<KeyWord name="mac_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="machine" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath" func="yes">
			<Overload retVal="" descr="Pathname and path-related operations for the Macintosh.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_ARCHIVE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_COMPRESSED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_DEVICE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_DIRECTORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_ENCRYPTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_HIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_INTEGRITY_STREAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_NORMAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_NO_SCRUB_DATA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_OFFLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_READONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_REPARSE_POINT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_SPARSE_FILE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_SYSTEM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_TEMPORARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.FILE_ATTRIBUTE_VIRTUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_ARCHIVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.SF_SNAPSHOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_ATIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_CTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_DEV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_GID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_INO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_MTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_NLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ST_UID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ENFMT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFBLK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFCHR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFDIR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFIFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFLNK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFMT" func="yes">
			<Overload retVal="" descr="Return the portion of the file's mode that describes the file type.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFREG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IFSOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IMODE" func="yes">
			<Overload retVal="" descr="Return the portion of the file's mode that can be set by os.chmod().">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IROTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRWXG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRWXO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IRWXU" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISBLK" func="yes">
			<Overload retVal="" descr="S_ISBLK(mode) -&gt; bool&#10;&#10;Return True if mode is from a block special device file.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISCHR" func="yes">
			<Overload retVal="" descr="S_ISCHR(mode) -&gt; bool&#10;&#10;Return True if mode is from a character special device file.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISDIR" func="yes">
			<Overload retVal="" descr="S_ISDIR(mode) -&gt; bool&#10;&#10;Return True if mode is from a directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISDOOR" func="yes">
			<Overload retVal="" descr="S_ISDOOR(mode) -&gt; bool&#10;&#10;Return True if mode is from a door.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISFIFO" func="yes">
			<Overload retVal="" descr="S_ISFIFO(mode) -&gt; bool&#10;&#10;Return True if mode is from a FIFO (named pipe).">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISGID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISLNK" func="yes">
			<Overload retVal="" descr="S_ISLNK(mode) -&gt; bool&#10;&#10;Return True if mode is from a symbolic link.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISPORT" func="yes">
			<Overload retVal="" descr="S_ISPORT(mode) -&gt; bool&#10;&#10;Return True if mode is from an event port.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISREG" func="yes">
			<Overload retVal="" descr="S_ISREG(mode) -&gt; bool&#10;&#10;Return True if mode is from a regular file.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISSOCK" func="yes">
			<Overload retVal="" descr="S_ISSOCK(mode) -&gt; bool&#10;&#10;Return True if mode is from a socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISUID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISVTX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_ISWHT" func="yes">
			<Overload retVal="" descr="S_ISWHT(mode) -&gt; bool&#10;&#10;Return True if mode is from a whiteout.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IWUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IXGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IXOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.S_IXUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_COMPRESSED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_HIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_NODUMP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.UF_OPAQUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.abspath" func="yes">
			<Overload retVal="" descr="Return an absolute path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.basename" />
		<KeyWord name="macpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.dirname" />
		<KeyWord name="macpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.expanduser" func="yes">
			<Overload retVal="" descr="Dummy to retain interface-compatibility with other operating systems.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.expandvars" func="yes">
			<Overload retVal="" descr="Dummy to retain interface-compatibility with other operating systems.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.filemode" func="yes">
			<Overload retVal="" descr="Convert a file's mode to a string of the form '-rwxrwxrwx'">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.isabs" func="yes">
			<Overload retVal="" descr="Return true if a path is absolute.&#10;On the Mac, relative paths begin with a colon,&#10;but as a special case, paths with no colons at all are also relative.&#10;Anything else is absolute (the string up to the first colon is the&#10;volume name).">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.islink" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to a symbolic link.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.ismount" />
		<KeyWord name="macpath.join" />
		<KeyWord name="macpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns True for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.norm_error" func="yes">
			<Overload retVal="" descr="Path cannot be normalized">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.norm_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.norm_error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.normcase" />
		<KeyWord name="macpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize a pathname.  Will return the same result for&#10;equivalent paths.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.realpath" />
		<KeyWord name="macpath.samefile" func="yes">
			<Overload retVal="" descr="Test whether two pathnames reference the same actual file">
				<Param name="f1" />
				<Param name="f2" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.sameopenfile" func="yes">
			<Overload retVal="" descr="Test whether two open file objects reference the same file">
				<Param name="fp1" />
				<Param name="fp2" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.samestat" func="yes">
			<Overload retVal="" descr="Test whether two stat buffers reference the same file">
				<Param name="s1" />
				<Param name="s2" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.split" func="yes">
			<Overload retVal="" descr="Split a pathname into two parts: the directory leading up to the final&#10;bit, and the basename (the filename, without colons, in that directory).&#10;The result (s, t) is such that join(s, t) yields the original argument.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.splitdrive" func="yes">
			<Overload retVal="" descr="Split a pathname into a drive specification and the rest of the&#10;path.  Useful on DOS/Windows/NT; on the Mac, the drive is always&#10;empty (don't use the volume name -- it doesn't have the same&#10;syntactic and semantic oddities as DOS drive letters, such as there&#10;being a separate current directory per drive).">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="macpath.supports_unicode_filenames" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="macurl2path" func="yes">
			<Overload retVal="" descr="Macintosh-specific module for conversion between pathnames and URLs.&#10;&#10;Do not import directly; use urllib instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="macurl2path.pathname2url" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a file system path to a relative URL&#10;of the 'file' scheme; not recommended for general use.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="macurl2path.url2pathname" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a relative URL of the 'file' scheme&#10;to a file system path; not recommended for general use.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="mail" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox" func="yes">
			<Overload retVal="" descr="Read/write support for Maildir, mbox, MH, Babyl, and MMDF mailboxes.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl" func="yes">
			<Overload retVal="" descr="An Rmail-style Babyl mailbox.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.add" func="yes">
			<Overload retVal="" descr="Add message and return assigned key.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.clear" func="yes">
			<Overload retVal="" descr="Delete all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.close" func="yes">
			<Overload retVal="" descr="Flush and close the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.discard" func="yes">
			<Overload retVal="" descr="If the keyed message exists, remove it.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.flush" func="yes">
			<Overload retVal="" descr="Write any pending changes to disk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.get" func="yes">
			<Overload retVal="" descr="Return the keyed message, or default if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.get_bytes" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.get_file" func="yes">
			<Overload retVal="" descr="Return a file-like representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.get_labels" func="yes">
			<Overload retVal="" descr="Return a list of user-defined labels in the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.get_message" func="yes">
			<Overload retVal="" descr="Return a Message representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.get_string" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.&#10;&#10;Uses email.message.Message to create a 7bit clean string&#10;representation of the message.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.items" func="yes">
			<Overload retVal="" descr="Return a list of (key, message) tuples. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.iteritems" func="yes">
			<Overload retVal="" descr="Return an iterator over (key, message) tuples.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.iterkeys" func="yes">
			<Overload retVal="" descr="Return an iterator over keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.itervalues" func="yes">
			<Overload retVal="" descr="Return an iterator over all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.keys" func="yes">
			<Overload retVal="" descr="Return a list of keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.lock" func="yes">
			<Overload retVal="" descr="Lock the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.pop" func="yes">
			<Overload retVal="" descr="Delete the keyed message and return it, or default.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.popitem" func="yes">
			<Overload retVal="" descr="Delete an arbitrary (key, message) pair and return it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.remove" func="yes">
			<Overload retVal="" descr="Remove the keyed message; raise KeyError if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.unlock" func="yes">
			<Overload retVal="" descr="Unlock the mailbox if it is locked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.update" func="yes">
			<Overload retVal="" descr="Change the messages that correspond to certain keys.">
				<Param name="self" />
				<Param name="[arg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Babyl.values" func="yes">
			<Overload retVal="" descr="Return a list of messages. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage" func="yes">
			<Overload retVal="" descr="Message with Babyl-specific properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fuballer.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fuballer.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.add_label" func="yes">
			<Overload retVal="" descr="Add label to list of labels on the message.">
				<Param name="self" />
				<Param name="label" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_labels" func="yes">
			<Overload retVal="" descr="Return a list of labels on the message.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.get_unixfrom" />
		<KeyWord name="mailbox.BabylMessage.get_visible" func="yes">
			<Overload retVal="" descr="Return a Message representation of visible headers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.remove_label" func="yes">
			<Overload retVal="" descr="Remove label from the list of labels on the message.">
				<Param name="self" />
				<Param name="label" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_labels" func="yes">
			<Overload retVal="" descr="Set the list of labels on the message.">
				<Param name="self" />
				<Param name="labels" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.set_unixfrom" />
		<KeyWord name="mailbox.BabylMessage.set_visible" func="yes">
			<Overload retVal="" descr="Set the Message representation of visible headers.">
				<Param name="self" />
				<Param name="visible" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.update_visible" func="yes">
			<Overload retVal="" descr="Update and/or sensibly generate a set of visible headers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.BabylMessage.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Error" func="yes">
			<Overload retVal="" descr="Raised for module-specific errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.ExternalClashError" func="yes">
			<Overload retVal="" descr="Another process caused an action to fail.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.ExternalClashError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.ExternalClashError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.FormatError" func="yes">
			<Overload retVal="" descr="A file appears to have an invalid format.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.FormatError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.FormatError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH" func="yes">
			<Overload retVal="" descr="An MH mailbox.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.add" func="yes">
			<Overload retVal="" descr="Add message and return assigned key.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.add_folder" func="yes">
			<Overload retVal="" descr="Create a folder and return an MH instance representing it.">
				<Param name="self" />
				<Param name="folder" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.clear" func="yes">
			<Overload retVal="" descr="Delete all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.close" func="yes">
			<Overload retVal="" descr="Flush and close the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.discard" func="yes">
			<Overload retVal="" descr="If the keyed message exists, remove it.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.flush" func="yes">
			<Overload retVal="" descr="Write any pending changes to the disk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get" func="yes">
			<Overload retVal="" descr="Return the keyed message, or default if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get_bytes" func="yes">
			<Overload retVal="" descr="Return a bytes representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get_file" func="yes">
			<Overload retVal="" descr="Return a file-like representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get_folder" func="yes">
			<Overload retVal="" descr="Return an MH instance for the named folder.">
				<Param name="self" />
				<Param name="folder" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get_message" func="yes">
			<Overload retVal="" descr="Return a Message representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get_sequences" func="yes">
			<Overload retVal="" descr="Return a name-to-key-list dictionary to define each sequence.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.get_string" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.&#10;&#10;Uses email.message.Message to create a 7bit clean string&#10;representation of the message.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.items" func="yes">
			<Overload retVal="" descr="Return a list of (key, message) tuples. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.iteritems" func="yes">
			<Overload retVal="" descr="Return an iterator over (key, message) tuples.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.iterkeys" func="yes">
			<Overload retVal="" descr="Return an iterator over keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.itervalues" func="yes">
			<Overload retVal="" descr="Return an iterator over all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.keys" func="yes">
			<Overload retVal="" descr="Return a list of keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.list_folders" func="yes">
			<Overload retVal="" descr="Return a list of folder names.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.lock" func="yes">
			<Overload retVal="" descr="Lock the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.pack" func="yes">
			<Overload retVal="" descr="Re-name messages to eliminate numbering gaps. Invalidates keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.pop" func="yes">
			<Overload retVal="" descr="Delete the keyed message and return it, or default.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.popitem" func="yes">
			<Overload retVal="" descr="Delete an arbitrary (key, message) pair and return it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.remove" func="yes">
			<Overload retVal="" descr="Remove the keyed message; raise KeyError if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.remove_folder" func="yes">
			<Overload retVal="" descr="Delete the named folder, which must be empty.">
				<Param name="self" />
				<Param name="folder" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.set_sequences" func="yes">
			<Overload retVal="" descr="Set sequences using the given name-to-key-list dictionary.">
				<Param name="self" />
				<Param name="sequences" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.unlock" func="yes">
			<Overload retVal="" descr="Unlock the mailbox if it is locked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.update" func="yes">
			<Overload retVal="" descr="Change the messages that correspond to certain keys.">
				<Param name="self" />
				<Param name="[arg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MH.values" func="yes">
			<Overload retVal="" descr="Return a list of messages. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage" func="yes">
			<Overload retVal="" descr="Message with MH-specific properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fuballer.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fuballer.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.add_sequence" func="yes">
			<Overload retVal="" descr="Add sequence to list of sequences including the message.">
				<Param name="self" />
				<Param name="sequence" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_sequences" func="yes">
			<Overload retVal="" descr="Return a list of sequences that include the message.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.get_unixfrom" />
		<KeyWord name="mailbox.MHMessage.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.remove_sequence" func="yes">
			<Overload retVal="" descr="Remove sequence from the list of sequences including the message.">
				<Param name="self" />
				<Param name="sequence" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_sequences" func="yes">
			<Overload retVal="" descr="Set the list of sequences that include the message.">
				<Param name="self" />
				<Param name="sequences" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.set_unixfrom" />
		<KeyWord name="mailbox.MHMessage.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MHMessage.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF" func="yes">
			<Overload retVal="" descr="An MMDF mailbox.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.add" func="yes">
			<Overload retVal="" descr="Add message and return assigned key.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.clear" func="yes">
			<Overload retVal="" descr="Delete all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.close" func="yes">
			<Overload retVal="" descr="Flush and close the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.discard" func="yes">
			<Overload retVal="" descr="If the keyed message exists, remove it.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.flush" func="yes">
			<Overload retVal="" descr="Write any pending changes to disk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.get" func="yes">
			<Overload retVal="" descr="Return the keyed message, or default if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.get_bytes" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[from_=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.get_file" func="yes">
			<Overload retVal="" descr="Return a file-like representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[from_=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.get_message" func="yes">
			<Overload retVal="" descr="Return a Message representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.get_string" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[from_=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.items" func="yes">
			<Overload retVal="" descr="Return a list of (key, message) tuples. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.iteritems" func="yes">
			<Overload retVal="" descr="Return an iterator over (key, message) tuples.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.iterkeys" func="yes">
			<Overload retVal="" descr="Return an iterator over keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.itervalues" func="yes">
			<Overload retVal="" descr="Return an iterator over all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.keys" func="yes">
			<Overload retVal="" descr="Return a list of keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.lock" func="yes">
			<Overload retVal="" descr="Lock the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.pop" func="yes">
			<Overload retVal="" descr="Delete the keyed message and return it, or default.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.popitem" func="yes">
			<Overload retVal="" descr="Delete an arbitrary (key, message) pair and return it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.remove" func="yes">
			<Overload retVal="" descr="Remove the keyed message; raise KeyError if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.unlock" func="yes">
			<Overload retVal="" descr="Unlock the mailbox if it is locked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.update" func="yes">
			<Overload retVal="" descr="Change the messages that correspond to certain keys.">
				<Param name="self" />
				<Param name="[arg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDF.values" func="yes">
			<Overload retVal="" descr="Return a list of messages. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage" func="yes">
			<Overload retVal="" descr="Message with MMDF-specific properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.add_flag" func="yes">
			<Overload retVal="" descr="Set the given flag(s) without changing others.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fuballer.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fuballer.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_flags" func="yes">
			<Overload retVal="" descr="Return as a string the flags that are set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_from" func="yes">
			<Overload retVal="" descr='Return contents of "From " line.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.get_unixfrom" />
		<KeyWord name="mailbox.MMDFMessage.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.remove_flag" func="yes">
			<Overload retVal="" descr="Unset the given string flag(s) without changing others.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_flags" func="yes">
			<Overload retVal="" descr="Set the given flags and unset all others.">
				<Param name="self" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_from" func="yes">
			<Overload retVal="" descr='Set "From " line, formatting and appending time_ if specified.'>
				<Param name="self" />
				<Param name="from_" />
				<Param name="[time_=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.set_unixfrom" />
		<KeyWord name="mailbox.MMDFMessage.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MMDFMessage.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox" func="yes">
			<Overload retVal="" descr="A group of messages in a particular place.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.add" func="yes">
			<Overload retVal="" descr="Add message and return assigned key.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.clear" func="yes">
			<Overload retVal="" descr="Delete all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.close" func="yes">
			<Overload retVal="" descr="Flush and close the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.discard" func="yes">
			<Overload retVal="" descr="If the keyed message exists, remove it.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.flush" func="yes">
			<Overload retVal="" descr="Write any pending changes to the disk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.get" func="yes">
			<Overload retVal="" descr="Return the keyed message, or default if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.get_bytes" func="yes">
			<Overload retVal="" descr="Return a byte string representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.get_file" func="yes">
			<Overload retVal="" descr="Return a file-like representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.get_message" func="yes">
			<Overload retVal="" descr="Return a Message representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.get_string" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.&#10;&#10;Uses email.message.Message to create a 7bit clean string&#10;representation of the message.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.items" func="yes">
			<Overload retVal="" descr="Return a list of (key, message) tuples. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.iteritems" func="yes">
			<Overload retVal="" descr="Return an iterator over (key, message) tuples.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.iterkeys" func="yes">
			<Overload retVal="" descr="Return an iterator over keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.itervalues" func="yes">
			<Overload retVal="" descr="Return an iterator over all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.keys" func="yes">
			<Overload retVal="" descr="Return a list of keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.lock" func="yes">
			<Overload retVal="" descr="Lock the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.pop" func="yes">
			<Overload retVal="" descr="Delete the keyed message and return it, or default.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.popitem" func="yes">
			<Overload retVal="" descr="Delete an arbitrary (key, message) pair and return it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.remove" func="yes">
			<Overload retVal="" descr="Remove the keyed message; raise KeyError if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.unlock" func="yes">
			<Overload retVal="" descr="Unlock the mailbox if it is locked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.update" func="yes">
			<Overload retVal="" descr="Change the messages that correspond to certain keys.">
				<Param name="self" />
				<Param name="[arg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Mailbox.values" func="yes">
			<Overload retVal="" descr="Return a list of messages. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir" func="yes">
			<Overload retVal="" descr="A qmail-style Maildir mailbox.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.add" func="yes">
			<Overload retVal="" descr="Add message and return assigned key.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.add_folder" func="yes">
			<Overload retVal="" descr="Create a folder and return a Maildir instance representing it.">
				<Param name="self" />
				<Param name="folder" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.clean" func="yes">
			<Overload retVal="" descr='Delete old files in "tmp".'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.clear" func="yes">
			<Overload retVal="" descr="Delete all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.close" func="yes">
			<Overload retVal="" descr="Flush and close the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.colon" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.discard" func="yes">
			<Overload retVal="" descr="If the keyed message exists, remove it.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.flush" func="yes">
			<Overload retVal="" descr="Write any pending changes to disk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.get" func="yes">
			<Overload retVal="" descr="Return the keyed message, or default if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.get_bytes" func="yes">
			<Overload retVal="" descr="Return a bytes representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.get_file" func="yes">
			<Overload retVal="" descr="Return a file-like representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.get_folder" func="yes">
			<Overload retVal="" descr="Return a Maildir instance for the named folder.">
				<Param name="self" />
				<Param name="folder" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.get_message" func="yes">
			<Overload retVal="" descr="Return a Message representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.get_string" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.&#10;&#10;Uses email.message.Message to create a 7bit clean string&#10;representation of the message.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.items" func="yes">
			<Overload retVal="" descr="Return a list of (key, message) tuples. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.iteritems" func="yes">
			<Overload retVal="" descr="Return an iterator over (key, message) tuples.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.iterkeys" func="yes">
			<Overload retVal="" descr="Return an iterator over keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.itervalues" func="yes">
			<Overload retVal="" descr="Return an iterator over all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.keys" func="yes">
			<Overload retVal="" descr="Return a list of keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.list_folders" func="yes">
			<Overload retVal="" descr="Return a list of folder names.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.lock" func="yes">
			<Overload retVal="" descr="Lock the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.next" func="yes">
			<Overload retVal="" descr="Return the next message in a one-time iteration.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.pop" func="yes">
			<Overload retVal="" descr="Delete the keyed message and return it, or default.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.popitem" func="yes">
			<Overload retVal="" descr="Delete an arbitrary (key, message) pair and return it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.remove" func="yes">
			<Overload retVal="" descr="Remove the keyed message; raise KeyError if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.remove_folder" func="yes">
			<Overload retVal="" descr="Delete the named folder, which must be empty.">
				<Param name="self" />
				<Param name="folder" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.unlock" func="yes">
			<Overload retVal="" descr="Unlock the mailbox if it is locked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.update" func="yes">
			<Overload retVal="" descr="Change the messages that correspond to certain keys.">
				<Param name="self" />
				<Param name="[arg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Maildir.values" func="yes">
			<Overload retVal="" descr="Return a list of messages. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage" func="yes">
			<Overload retVal="" descr="Message with Maildir-specific properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.add_flag" func="yes">
			<Overload retVal="" descr="Set the given flag(s) without changing others.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fuballer.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fuballer.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_date" func="yes">
			<Overload retVal="" descr="Return delivery date of message, in seconds since the epoch.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_flags" func="yes">
			<Overload retVal="" descr="Return as a string the flags that are set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_info" func="yes">
			<Overload retVal="" descr="Get the message's &quot;info&quot; as a string.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_subdir" func="yes">
			<Overload retVal="" descr="Return 'new' or 'cur'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.get_unixfrom" />
		<KeyWord name="mailbox.MaildirMessage.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.remove_flag" func="yes">
			<Overload retVal="" descr="Unset the given string flag(s) without changing others.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_date" func="yes">
			<Overload retVal="" descr="Set delivery date of message, in seconds since the epoch.">
				<Param name="self" />
				<Param name="date" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_flags" func="yes">
			<Overload retVal="" descr="Set the given flags and unset all others.">
				<Param name="self" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_info" func="yes">
			<Overload retVal="" descr="Set the message's &quot;info&quot; string.">
				<Param name="self" />
				<Param name="info" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_subdir" func="yes">
			<Overload retVal="" descr="Set subdir to 'new' or 'cur'.">
				<Param name="self" />
				<Param name="subdir" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.set_unixfrom" />
		<KeyWord name="mailbox.MaildirMessage.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.MaildirMessage.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message" func="yes">
			<Overload retVal="" descr="Message with mailbox-format-specific properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fuballer.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fuballer.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.get_unixfrom" />
		<KeyWord name="mailbox.Message.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.set_unixfrom" />
		<KeyWord name="mailbox.Message.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.Message.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NoSuchMailboxError" func="yes">
			<Overload retVal="" descr="The specified mailbox does not exist and won't be created.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NoSuchMailboxError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NoSuchMailboxError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NotEmptyError" func="yes">
			<Overload retVal="" descr="The specified mailbox is not empty and deletion was requested.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NotEmptyError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.NotEmptyError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.linesep" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox" func="yes">
			<Overload retVal="" descr="A classic mbox mailbox.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.add" func="yes">
			<Overload retVal="" descr="Add message and return assigned key.">
				<Param name="self" />
				<Param name="message" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.clear" func="yes">
			<Overload retVal="" descr="Delete all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.close" func="yes">
			<Overload retVal="" descr="Flush and close the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.discard" func="yes">
			<Overload retVal="" descr="If the keyed message exists, remove it.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.flush" func="yes">
			<Overload retVal="" descr="Write any pending changes to disk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.get" func="yes">
			<Overload retVal="" descr="Return the keyed message, or default if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.get_bytes" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[from_=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.get_file" func="yes">
			<Overload retVal="" descr="Return a file-like representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[from_=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.get_message" func="yes">
			<Overload retVal="" descr="Return a Message representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.get_string" func="yes">
			<Overload retVal="" descr="Return a string representation or raise a KeyError.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[from_=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.items" func="yes">
			<Overload retVal="" descr="Return a list of (key, message) tuples. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.iteritems" func="yes">
			<Overload retVal="" descr="Return an iterator over (key, message) tuples.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.iterkeys" func="yes">
			<Overload retVal="" descr="Return an iterator over keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.itervalues" func="yes">
			<Overload retVal="" descr="Return an iterator over all messages.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.keys" func="yes">
			<Overload retVal="" descr="Return a list of keys.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.lock" func="yes">
			<Overload retVal="" descr="Lock the mailbox.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.pop" func="yes">
			<Overload retVal="" descr="Delete the keyed message and return it, or default.">
				<Param name="self" />
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.popitem" func="yes">
			<Overload retVal="" descr="Delete an arbitrary (key, message) pair and return it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.remove" func="yes">
			<Overload retVal="" descr="Remove the keyed message; raise KeyError if it doesn't exist.">
				<Param name="self" />
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.unlock" func="yes">
			<Overload retVal="" descr="Unlock the mailbox if it is locked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.update" func="yes">
			<Overload retVal="" descr="Change the messages that correspond to certain keys.">
				<Param name="self" />
				<Param name="[arg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mbox.values" func="yes">
			<Overload retVal="" descr="Return a list of messages. Memory intensive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage" func="yes">
			<Overload retVal="" descr="Message with mbox-specific properties.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.add_flag" func="yes">
			<Overload retVal="" descr="Set the given flag(s) without changing others.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.add_header" func="yes">
			<Overload retVal="" descr="Extended header setting.&#10;&#10;name is the header field to add.  keyword arguments can be used to set&#10;additional parameters for the header field, with underscores converted&#10;to dashes.  Normally the parameter will be added as key=&quot;value&quot; unless&#10;value is None, in which case only the key will be added.  If a&#10;parameter value contains non-ASCII characters it can be specified as a&#10;three-tuple of (charset, language, value), in which case it will be&#10;encoded according to RFC2231 rules.  Otherwise it will be encoded using&#10;the utf-8 charset and a language of ''.&#10;&#10;Examples:&#10;&#10;msg.add_header('content-disposition', 'attachment', filename='bud.gif')&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename=('utf-8', '', Fuballer.ppt'))&#10;msg.add_header('content-disposition', 'attachment',&#10;               filename='Fuballer.ppt'))">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.as_bytes" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a bytes object.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  'policy' is passed to the BytesGenerator instance used to&#10;serialize the message; if not specified the policy associated with&#10;the message instance is used.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[policy=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.as_string" func="yes">
			<Overload retVal="" descr="Return the entire formatted message as a string.&#10;&#10;Optional 'unixfrom', when true, means include the Unix From_ envelope&#10;header.  For backward compatibility reasons, if maxheaderlen is&#10;not specified it defaults to 0, so you must override it explicitly&#10;if you want a different maxheaderlen.  'policy' is passed to the&#10;Generator instance used to serialize the mesasge; if it is not&#10;specified the policy associated with the message instance is used.&#10;&#10;If the message object contains binary data that is not encoded&#10;according to RFC standards, the non-compliant data will be replaced by&#10;unicode &quot;unknown character&quot; code points.">
				<Param name="self" />
				<Param name="[unixfrom=False" />
				<Param name="[maxheaderlen=0" />
				<Param name="[policy=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.attach" func="yes">
			<Overload retVal="" descr="Add the given payload to the current payload.&#10;&#10;The current payload will always be a list of objects after this method&#10;is called.  If you want to set the payload to a scalar object, use&#10;set_payload() instead.">
				<Param name="self" />
				<Param name="payload" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.del_param" func="yes">
			<Overload retVal="" descr="Remove the given parameter completely from the Content-Type header.&#10;&#10;The header will be re-written in place without the parameter or its&#10;value. All values will be quoted as necessary unless requote is&#10;False.  Optional header specifies an alternative to the Content-Type&#10;header.">
				<Param name="self" />
				<Param name="param" />
				<Param name="[header=content-type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get" func="yes">
			<Overload retVal="" descr="Get a header value.&#10;&#10;Like __getitem__() but return failobj instead of None when the field&#10;is missing.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_all" func="yes">
			<Overload retVal="" descr="Return a list of all the values for the named field.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, and may contain duplicates.  Any fields deleted and&#10;re-inserted are always appended to the header list.&#10;&#10;If no such fields exist, failobj is returned (defaults to None).">
				<Param name="self" />
				<Param name="name" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_boundary" func="yes">
			<Overload retVal="" descr="Return the boundary associated with the payload if present.&#10;&#10;The boundary is extracted from the Content-Type header's `boundary'&#10;parameter, and it is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_charset" func="yes">
			<Overload retVal="" descr="Return the Charset instance associated with the message's payload.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_charsets" func="yes">
			<Overload retVal="" descr="Return a list containing the charset(s) used in this message.&#10;&#10;The returned list of items describes the Content-Type headers'&#10;charset parameter for this message and all the subparts in its&#10;payload.&#10;&#10;Each item will either be a string (the value of the charset parameter&#10;in the Content-Type header of that part) or the value of the&#10;'failobj' parameter (defaults to None), if the part does not have a&#10;main MIME type of &quot;text&quot;, or the charset is not defined.&#10;&#10;The list will contain one string for each part of the message, plus&#10;one for the container message (i.e. self), so that a non-multipart&#10;message will still return a list of length 1.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_content_charset" func="yes">
			<Overload retVal="" descr="Return the charset parameter of the Content-Type header.&#10;&#10;The returned string is always coerced to lower case.  If there is no&#10;Content-Type header, or if that header has no charset parameter,&#10;failobj is returned.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_content_disposition" func="yes">
			<Overload retVal="" descr="Return the message's content-disposition if it exists, or None.&#10;&#10;The return values can be either 'inline', 'attachment' or None&#10;according to the rfc2183.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_content_maintype" func="yes">
			<Overload retVal="" descr="Return the message's main content type.&#10;&#10;This is the `maintype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_content_subtype" func="yes">
			<Overload retVal="" descr="Returns the message's sub-content type.&#10;&#10;This is the `subtype' part of the string returned by&#10;get_content_type().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_content_type" func="yes">
			<Overload retVal="" descr="Return the message's content type.&#10;&#10;The returned string is coerced to lower case of the form&#10;`maintype/subtype'.  If there was no Content-Type header in the&#10;message, the default type as given by get_default_type() will be&#10;returned.  Since according to RFC 2045, messages always have a default&#10;type this will always return a value.&#10;&#10;RFC 2045 defines a message's default type to be text/plain unless it&#10;appears inside a multipart/digest container, in which case it would be&#10;message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_default_type" func="yes">
			<Overload retVal="" descr="Return the `default' content type.&#10;&#10;Most messages have a default content type of text/plain, except for&#10;messages that are subparts of multipart/digest containers.  Such&#10;subparts have a default content type of message/rfc822.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_filename" func="yes">
			<Overload retVal="" descr="Return the filename associated with the payload if present.&#10;&#10;The filename is extracted from the Content-Disposition header's&#10;`filename' parameter, and it is unquoted.  If that header is missing&#10;the `filename' parameter, this method falls back to looking for the&#10;`name' parameter.">
				<Param name="self" />
				<Param name="[failobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_flags" func="yes">
			<Overload retVal="" descr="Return as a string the flags that are set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_from" func="yes">
			<Overload retVal="" descr='Return contents of "From " line.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_param" func="yes">
			<Overload retVal="" descr="Return the parameter value if found in the Content-Type header.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header, or the Content-Type header has no such parameter.  Optional&#10;header is the header to search instead of Content-Type.&#10;&#10;Parameter keys are always compared case insensitively.  The return&#10;value can either be a string, or a 3-tuple if the parameter was RFC&#10;2231 encoded.  When it's a 3-tuple, the elements of the value are of&#10;the form (CHARSET, LANGUAGE, VALUE).  Note that both CHARSET and&#10;LANGUAGE can be None, in which case you should consider VALUE to be&#10;encoded in the us-ascii charset.  You can usually ignore LANGUAGE.&#10;The parameter value (either the returned string, or the VALUE item in&#10;the 3-tuple) is always unquoted, unless unquote is set to False.&#10;&#10;If your application doesn't care whether the parameter was RFC 2231&#10;encoded, it can turn the return value into a string as follows:&#10;&#10;    rawparam = msg.get_param('foo')&#10;    param = email.utils.collapse_rfc2231_value(rawparam)">
				<Param name="self" />
				<Param name="param" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_params" func="yes">
			<Overload retVal="" descr="Return the message's Content-Type parameters, as a list.&#10;&#10;The elements of the returned list are 2-tuples of key/value pairs, as&#10;split on the `=' sign.  The left hand side of the `=' is the key,&#10;while the right hand side is the value.  If there is no `=' sign in&#10;the parameter the value is the empty string.  The value is as&#10;described in the get_param() method.&#10;&#10;Optional failobj is the object to return if there is no Content-Type&#10;header.  Optional header is the header to search instead of&#10;Content-Type.  If unquote is True, the value is unquoted.">
				<Param name="self" />
				<Param name="[failobj=None" />
				<Param name="[header=content-type" />
				<Param name="[unquote=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_payload" func="yes">
			<Overload retVal="" descr="Return a reference to the payload.&#10;&#10;The payload will either be a list object or a string.  If you mutate&#10;the list object, you modify the message's payload in place.  Optional&#10;i returns that index into the payload.&#10;&#10;Optional decode is a flag indicating whether the payload should be&#10;decoded or not, according to the Content-Transfer-Encoding header&#10;(default is False).&#10;&#10;When True and the message is not a multipart, the payload will be&#10;decoded if this header's value is `quoted-printable' or `base64'.  If&#10;some other encoding is used, or the header is missing, or if the&#10;payload has bogus data (i.e. bogus base64 or uuencoded data), the&#10;payload is returned as-is.&#10;&#10;If the message is a multipart and the decode flag is True, then None&#10;is returned.">
				<Param name="self" />
				<Param name="[i=None" />
				<Param name="[decode=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.get_unixfrom" />
		<KeyWord name="mailbox.mboxMessage.is_multipart" func="yes">
			<Overload retVal="" descr="Return True if the message consists of multiple parts.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.items" func="yes">
			<Overload retVal="" descr="Get all the message's header fields and values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.keys" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header field names.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.raw_items" func="yes">
			<Overload retVal="" descr='Return the (name, value) header pairs without modification.&#10;&#10;This is an "internal" API, intended only for use by a generator.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.remove_flag" func="yes">
			<Overload retVal="" descr="Unset the given string flag(s) without changing others.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.replace_header" func="yes">
			<Overload retVal="" descr="Replace a header.&#10;&#10;Replace the first matching header found in the message, retaining&#10;header order and case.  If no matching header was found, a KeyError is&#10;raised.">
				<Param name="self" />
				<Param name="_name" />
				<Param name="_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_boundary" func="yes">
			<Overload retVal="" descr="Set the boundary parameter in Content-Type to 'boundary'.&#10;&#10;This is subtly different than deleting the Content-Type header and&#10;adding a new one with a new boundary parameter via add_header().  The&#10;main difference is that using the set_boundary() method preserves the&#10;order of the Content-Type header in the original message.&#10;&#10;HeaderParseError is raised if the message has no Content-Type header.">
				<Param name="self" />
				<Param name="boundary" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_charset" func="yes">
			<Overload retVal="" descr="Set the charset of the payload to a given character set.&#10;&#10;charset can be a Charset instance, a string naming a character set, or&#10;None.  If it is a string it will be converted to a Charset instance.&#10;If charset is None, the charset parameter will be removed from the&#10;Content-Type field.  Anything else will generate a TypeError.&#10;&#10;The message will be assumed to be of type text/* encoded with&#10;charset.input_charset.  It will be converted to charset.output_charset&#10;and encoded properly, if needed, when generating the plain text&#10;representation of the message.  MIME headers (MIME-Version,&#10;Content-Type, Content-Transfer-Encoding) will be added as needed.">
				<Param name="self" />
				<Param name="charset" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_default_type" func="yes">
			<Overload retVal="" descr="Set the `default' content type.&#10;&#10;ctype should be either &quot;text/plain&quot; or &quot;message/rfc822&quot;, although this&#10;is not enforced.  The default content type is not stored in the&#10;Content-Type header.">
				<Param name="self" />
				<Param name="ctype" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_flags" func="yes">
			<Overload retVal="" descr="Set the given flags and unset all others.">
				<Param name="self" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_from" func="yes">
			<Overload retVal="" descr='Set "From " line, formatting and appending time_ if specified.'>
				<Param name="self" />
				<Param name="from_" />
				<Param name="[time_=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_param" func="yes">
			<Overload retVal="" descr='Set a parameter in the Content-Type header.&#10;&#10;If the parameter already exists in the header, its value will be&#10;replaced with the new value.&#10;&#10;If header is Content-Type and has not yet been defined for this&#10;message, it will be set to "text/plain" and the new parameter and&#10;value will be appended as per RFC 2045.&#10;&#10;An alternate header can be specified in the header argument, and all&#10;parameters will be quoted as necessary unless requote is False.&#10;&#10;If charset is specified, the parameter will be encoded according to RFC&#10;2231.  Optional language specifies the RFC 2231 language, defaulting&#10;to the empty string.  Both charset and language should be strings.'>
				<Param name="self" />
				<Param name="param" />
				<Param name="value" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True" />
				<Param name="[charset=None" />
				<Param name="[language" />
				<Param name="[replace=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_payload" func="yes">
			<Overload retVal="" descr="Set the payload to the given value.&#10;&#10;Optional charset sets the message's default character set.  See&#10;set_charset() for details.">
				<Param name="self" />
				<Param name="payload" />
				<Param name="[charset=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_raw" func="yes">
			<Overload retVal="" descr='Store name and value in the model without modification.&#10;&#10;This is an "internal" API, intended only for use by a parser.'>
				<Param name="self" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_type" func="yes">
			<Overload retVal="" descr="Set the main type and subtype for the Content-Type header.&#10;&#10;type must be a string in the form &quot;maintype/subtype&quot;, otherwise a&#10;ValueError is raised.&#10;&#10;This method replaces the Content-Type header, keeping all the&#10;parameters in place.  If requote is False, this leaves the existing&#10;header's quoting as is.  Otherwise, the parameters will be quoted (the&#10;default).&#10;&#10;An alternative header can be specified in the header argument.  When&#10;the Content-Type header is set, we'll always also add a MIME-Version&#10;header.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[header=Content-Type" />
				<Param name="[requote=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.set_unixfrom" />
		<KeyWord name="mailbox.mboxMessage.values" func="yes">
			<Overload retVal="" descr="Return a list of all the message's header values.&#10;&#10;These will be sorted in the order they appeared in the original&#10;message, or were added to the message, and may contain duplicates.&#10;Any fields deleted and re-inserted are always appended to the header&#10;list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailbox.mboxMessage.walk" func="yes">
			<Overload retVal="" descr="Walk over the message tree, yielding each subpart.&#10;&#10;The walk is performed in depth-first order.  This method is a&#10;generator.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap" func="yes">
			<Overload retVal="" descr="Mailcap file handling.  See RFC 1524.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.findmatch" func="yes">
			<Overload retVal="" descr="Find a match for a mailcap entry.&#10;&#10;Return a tuple containing the command line, and the mailcap entry&#10;used; (None, None) if no match is found.  This may invoke the&#10;'test' command of several matching entries before deciding which&#10;entry to use.">
				<Param name="caps" />
				<Param name="MIMEtype" />
				<Param name="[key=view" />
				<Param name="[filename=/dev/null" />
				<Param name="[plist=[]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.findparam" />
		<KeyWord name="mailcap.getcaps" func="yes">
			<Overload retVal="" descr="Return a dictionary containing the mailcap database.&#10;&#10;The dictionary maps a MIME type (in all lowercase, e.g. 'text/plain')&#10;to a list of dictionaries corresponding to mailcap entries.  The list&#10;collects all the entries for that MIME type from all available mailcap&#10;files.  Each dictionary contains key-value pairs for that MIME type,&#10;where the viewing command is stored with the key &quot;view&quot;.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.lineno_sort_key" />
		<KeyWord name="mailcap.listmailcapfiles" func="yes">
			<Overload retVal="" descr="Return a list of all mailcap files found on the system.">
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.lookup" func="yes">
			<Overload retVal="" descr=>
				<Param name="caps" />
				<Param name="MIMEtype" />
				<Param name="[key=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.parsefield" func="yes">
			<Overload retVal="" descr="Separate one key-value pair in a mailcap entry.">
				<Param name="line" />
				<Param name="i" />
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.parseline" func="yes">
			<Overload retVal="" descr='Parse one entry in a mailcap file and return a dictionary.&#10;&#10;The viewing command is stored as the value with the key "view",&#10;and the rest of the fields produce key-value pairs in the dict.'>
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.readmailcapfile" func="yes">
			<Overload retVal="" descr="Read a mailcap file and return a dictionary keyed by MIME type.">
				<Param name="fp" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.show" />
		<KeyWord name="mailcap.subst" func="yes">
			<Overload retVal="" descr=>
				<Param name="field" />
				<Param name="MIMEtype" />
				<Param name="filename" />
				<Param name="[plist=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mailcap.test" />
		<KeyWord name="main" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="main_thread" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="makeLogRecord" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="makeRecord" func="yes">
			<Overload retVal="" descr="Function of logging.Logger">
			</Overload>
		</KeyWord>
		<KeyWord name="makeSuite" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="make_archive" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="make_encoding_map" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="make_file" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="make_id" func="yes">
			<Overload retVal="" descr="Function of msilib">
			</Overload>
		</KeyWord>
		<KeyWord name="make_identity_dict" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="make_option" func="yes">
			<Overload retVal="" descr="Function of optparse.make_option">
			</Overload>
		</KeyWord>
		<KeyWord name="make_short" func="yes">
			<Overload retVal="" descr="Function of msilib.Directory">
			</Overload>
		</KeyWord>
		<KeyWord name="make_table" func="yes">
			<Overload retVal="" descr="Function of difflib.HtmlDiff">
			</Overload>
		</KeyWord>
		<KeyWord name="makedev" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makedir" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makedirs" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="makefifo" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makefile" func="yes">
			<Overload retVal="" descr="Function of socket.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="makelink" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="makepasv" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="makepath" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="makepipeline" func="yes">
			<Overload retVal="" descr="Function of pipes">
			</Overload>
		</KeyWord>
		<KeyWord name="makeport" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="maketrans" func="yes">
			<Overload retVal="" descr="Return a translation table usable for str.translate().&#10;&#10;If there is only one argument, it must be a dictionary mapping Unicode&#10;ordinals (integers) or characters to Unicode ordinals, strings or None.&#10;Character keys will be then converted to ordinals.&#10;If there are two arguments, they must be strings of equal length, and&#10;in the resulting dictionary, each character in x will be mapped to the&#10;character at the same position in y. If there is a third argument, it&#10;must be a string, whose characters will be mapped to None in the result.">
				<Param name="x" />
				<Param name="y" />
				<Param name="z" />
			</Overload>
		</KeyWord>
		<KeyWord name="makeunknown" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="map" func="yes">
			<Overload retVal="" descr="map(func, *iterables) --&gt; map object&#10;&#10;Make an iterator that computes the function using arguments from&#10;each of the iterables.  Stops when the shortest iterable is exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="map_table_b2" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="map_table_b3" func="yes">
			<Overload retVal="" descr="Function of stringprep">
			</Overload>
		</KeyWord>
		<KeyWord name="mapping" func="yes">
			<Overload retVal="" descr="Function of msilib.Control">
			</Overload>
		</KeyWord>
		<KeyWord name="markup" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="match" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="match_hostname" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="matmul" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="max" func="yes">
			<Overload retVal="" descr="max(iterable, *[, default=obj, key=func]) -&gt; value&#10;max(arg1, arg2, *args, *[, key=func]) -&gt; value&#10;&#10;With a single iterable argument, return its biggest item. The&#10;default keyword-only argument specifies an object to return if&#10;the provided iterable is empty.&#10;With two or more arguments, return the largest argument.">
			</Overload>
		</KeyWord>
		<KeyWord name="max_mag" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="maybe" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="mbcs_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="mbcs_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="mbox" func="yes">
			<Overload retVal="" descr="Function of mailbox.mbox">
			</Overload>
		</KeyWord>
		<KeyWord name="mboxMessage" func="yes">
			<Overload retVal="" descr="Function of mailbox.mboxMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="md5" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="mean" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="median" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="median_grouped" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="median_high" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="median_low" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="memoryview" func="yes">
			<Overload retVal="" descr="Create a new memoryview object which references the given object.">
			</Overload>
		</KeyWord>
		<KeyWord name="merge" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="message" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="message_from_binary_file" func="yes">
			<Overload retVal="" descr="Function of email">
			</Overload>
		</KeyWord>
		<KeyWord name="message_from_bytes" func="yes">
			<Overload retVal="" descr="Function of email">
			</Overload>
		</KeyWord>
		<KeyWord name="message_from_file" func="yes">
			<Overload retVal="" descr="Function of email">
			</Overload>
		</KeyWord>
		<KeyWord name="message_from_string" func="yes">
			<Overload retVal="" descr="Function of email">
			</Overload>
		</KeyWord>
		<KeyWord name="metadata_isdir" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="metadata_listdir" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DefaultProvider">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes" func="yes">
			<Overload retVal="" descr="Guess the MIME type of a file.&#10;&#10;This module defines two useful functions:&#10;&#10;guess_type(url, strict=True) -- guess the MIME type and encoding of a URL.&#10;&#10;guess_extension(type, strict=True) -- guess the extension for a given MIME type.&#10;&#10;It also contains the following, for tuning the behavior:&#10;&#10;Data:&#10;&#10;knownfiles -- list of files to parse&#10;inited -- flag set when init() has been called&#10;suffix_map -- dictionary mapping suffixes to suffixes&#10;encodings_map -- dictionary mapping suffixes to encodings&#10;types_map -- dictionary mapping suffixes to types&#10;&#10;Functions:&#10;&#10;init([files]) -- parse a list of files, default knownfiles (on Windows, the&#10;  default values are taken from the registry)&#10;read_mime_types(file) -- parse one file, return a dictionary or None">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes" func="yes">
			<Overload retVal="" descr="MIME-types datastore.&#10;&#10;This datastore can handle information from mime.types-style files&#10;and supports basic determination of MIME type from a filename or&#10;URL, and can guess a reasonable extension given a MIME type.">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.add_type" func="yes">
			<Overload retVal="" descr="Add a mapping between a type and an extension.&#10;&#10;When the extension is already known, the new&#10;type will replace the old one. When the type&#10;is already known the extension will be added&#10;to the list of known extensions.&#10;&#10;If strict is true, information will be added to&#10;list of standard types, else to the list of non-standard&#10;types.">
				<Param name="self" />
				<Param name="type" />
				<Param name="ext" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.guess_all_extensions" func="yes">
			<Overload retVal="" descr="Guess the extensions for a file based on its MIME type.&#10;&#10;Return value is a list of strings giving the possible filename&#10;extensions, including the leading dot ('.').  The extension is not&#10;guaranteed to have been associated with any particular data stream,&#10;but would be mapped to the MIME type `type' by guess_type().&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.guess_extension" func="yes">
			<Overload retVal="" descr="Guess the extension for a file based on its MIME type.&#10;&#10;Return value is a string giving a filename extension,&#10;including the leading dot ('.').  The extension is not&#10;guaranteed to have been associated with any particular data&#10;stream, but would be mapped to the MIME type `type' by&#10;guess_type().  If no extension can be guessed for `type', None&#10;is returned.&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="self" />
				<Param name="type" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.guess_type" func="yes">
			<Overload retVal="" descr="Guess the type of a file based on its URL.&#10;&#10;Return value is a tuple (type, encoding) where type is None if&#10;the type can't be guessed (no or unknown suffix) or a string&#10;of the form type/subtype, usable for a MIME Content-type&#10;header; and encoding is None for no encoding or the name of&#10;the program used to encode (e.g. compress or gzip).  The&#10;mappings are table driven.  Encoding suffixes are case&#10;sensitive; type suffixes are first tried case sensitive, then&#10;case insensitive.&#10;&#10;The suffixes .tgz, .taz and .tz (case sensitive!) are all&#10;mapped to '.tar.gz'.  (This is table-driven too, using the&#10;dictionary suffix_map.)&#10;&#10;Optional `strict' argument when False adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="self" />
				<Param name="url" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.read" func="yes">
			<Overload retVal="" descr="Read a single mime.types-format file, specified by pathname.&#10;&#10;If strict is true, information will be added to&#10;list of standard types, else to the list of non-standard&#10;types.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.read_windows_registry" func="yes">
			<Overload retVal="" descr="Load the MIME types database from Windows registry.&#10;&#10;If strict is true, information will be added to&#10;list of standard types, else to the list of non-standard&#10;types.">
				<Param name="self" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.MimeTypes.readfp" func="yes">
			<Overload retVal="" descr="Read a single mime.types-format file.&#10;&#10;If strict is true, information will be added to&#10;list of standard types, else to the list of non-standard&#10;types.">
				<Param name="self" />
				<Param name="fp" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.add_type" func="yes">
			<Overload retVal="" descr="Add a mapping between a type and an extension.&#10;&#10;When the extension is already known, the new&#10;type will replace the old one. When the type&#10;is already known the extension will be added&#10;to the list of known extensions.&#10;&#10;If strict is true, information will be added to&#10;list of standard types, else to the list of non-standard&#10;types.">
				<Param name="type" />
				<Param name="ext" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.common_types" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.encodings_map" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.guess_all_extensions" func="yes">
			<Overload retVal="" descr="Guess the extensions for a file based on its MIME type.&#10;&#10;Return value is a list of strings giving the possible filename&#10;extensions, including the leading dot ('.').  The extension is not&#10;guaranteed to have been associated with any particular data&#10;stream, but would be mapped to the MIME type `type' by&#10;guess_type().  If no extension can be guessed for `type', None&#10;is returned.&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="type" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.guess_extension" func="yes">
			<Overload retVal="" descr="Guess the extension for a file based on its MIME type.&#10;&#10;Return value is a string giving a filename extension, including the&#10;leading dot ('.').  The extension is not guaranteed to have been&#10;associated with any particular data stream, but would be mapped to the&#10;MIME type `type' by guess_type().  If no extension can be guessed for&#10;`type', None is returned.&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found,&#10;but non-standard types.">
				<Param name="type" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.guess_type" func="yes">
			<Overload retVal="" descr="Guess the type of a file based on its URL.&#10;&#10;Return value is a tuple (type, encoding) where type is None if the&#10;type can't be guessed (no or unknown suffix) or a string of the&#10;form type/subtype, usable for a MIME Content-type header; and&#10;encoding is None for no encoding or the name of the program used&#10;to encode (e.g. compress or gzip).  The mappings are table&#10;driven.  Encoding suffixes are case sensitive; type suffixes are&#10;first tried case sensitive, then case insensitive.&#10;&#10;The suffixes .tgz, .taz and .tz (case sensitive!) are all mapped&#10;to &quot;.tar.gz&quot;.  (This is table-driven too, using the dictionary&#10;suffix_map).&#10;&#10;Optional `strict' argument when false adds a bunch of commonly found, but&#10;non-standard types.">
				<Param name="url" />
				<Param name="[strict=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.init" func="yes">
			<Overload retVal="" descr=>
				<Param name="[files=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.knownfiles" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.read_mime_types" />
		<KeyWord name="mimetypes.suffix_map" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="mimetypes.types_map" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="min" func="yes">
			<Overload retVal="" descr="min(iterable, *[, default=obj, key=func]) -&gt; value&#10;min(arg1, arg2, *args, *[, key=func]) -&gt; value&#10;&#10;With a single iterable argument, return its smallest item. The&#10;default keyword-only argument specifies an object to return if&#10;the provided iterable is empty.&#10;With two or more arguments, return the smallest argument.">
			</Overload>
		</KeyWord>
		<KeyWord name="min_mag" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="minus" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="mirrored" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="mkd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="mkdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="mkdtemp" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="mkpath" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="mkstemp" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="mktemp" func="yes">
			<Overload retVal="" descr="Function of tempfile">
			</Overload>
		</KeyWord>
		<KeyWord name="mlsd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="mod" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="mode" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="modpkglink" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder" func="yes">
			<Overload retVal="" descr="Find modules used by a script, using introspection.">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.AddPackagePath" />
		<KeyWord name="modulefinder.EXTENDED_ARG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.IMPORT_NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.LOAD_CONST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.Module" />
		<KeyWord name="modulefinder.ModuleFinder" />
		<KeyWord name="modulefinder.ModuleFinder.add_module" />
		<KeyWord name="modulefinder.ModuleFinder.any_missing" func="yes">
			<Overload retVal="" descr="Return a list of modules that appear to be missing. Use&#10;any_missing_maybe() if you want to know which modules are&#10;certain to be missing, and which *may* be missing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.any_missing_maybe" func="yes">
			<Overload retVal="" descr="Return two lists, one with modules that are certainly missing&#10;and one with modules that *may* be missing. The latter names could&#10;either be submodules *or* just global names in the package.&#10;&#10;The reason it can't always be determined is that it's impossible to&#10;tell which names are imported when &quot;from module import *&quot; is done&#10;with an extension module, short of actually importing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.determine_parent" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="caller" />
				<Param name="[level=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.ensure_fromlist" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="m" />
				<Param name="fromlist" />
				<Param name="[recursive=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.find_all_submodules" />
		<KeyWord name="modulefinder.ModuleFinder.find_head_package" />
		<KeyWord name="modulefinder.ModuleFinder.find_module" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="name" />
				<Param name="path" />
				<Param name="[parent=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.import_hook" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="name" />
				<Param name="[caller=None" />
				<Param name="[fromlist=None" />
				<Param name="[level=-1]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.import_module" />
		<KeyWord name="modulefinder.ModuleFinder.load_file" />
		<KeyWord name="modulefinder.ModuleFinder.load_module" />
		<KeyWord name="modulefinder.ModuleFinder.load_package" />
		<KeyWord name="modulefinder.ModuleFinder.load_tail" />
		<KeyWord name="modulefinder.ModuleFinder.msg" />
		<KeyWord name="modulefinder.ModuleFinder.msgin" />
		<KeyWord name="modulefinder.ModuleFinder.msgout" />
		<KeyWord name="modulefinder.ModuleFinder.replace_paths_in_code" />
		<KeyWord name="modulefinder.ModuleFinder.report" func="yes">
			<Overload retVal="" descr="Print a report to stdout, listing the found modules with their&#10;paths, as well as modules that are missing, or seem to be missing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.ModuleFinder.run_script" />
		<KeyWord name="modulefinder.ModuleFinder.scan_code" />
		<KeyWord name="modulefinder.ModuleFinder.scan_opcodes" />
		<KeyWord name="modulefinder.ReplacePackage" />
		<KeyWord name="modulefinder.STORE_GLOBAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.STORE_NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.STORE_OPS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="modulefinder.test" />
		<KeyWord name="modulelink" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="month" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthcalendar" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthdatescalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthdays2calendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthdayscalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="monthrange" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="more" func="yes">
			<Overload retVal="" descr="Function of asynchat.simple_producer">
			</Overload>
		</KeyWord>
		<KeyWord name="most_common" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="move" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="move_file" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="move_to_end" func="yes">
			<Overload retVal="" descr="Function of collections.OrderedDict">
			</Overload>
		</KeyWord>
		<KeyWord name="mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="msg" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="msgin" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="msgout" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib" />
		<KeyWord name="msilib.Binary" />
		<KeyWord name="msilib.CAB" />
		<KeyWord name="msilib.CAB.append" />
		<KeyWord name="msilib.CAB.commit" />
		<KeyWord name="msilib.CAB.gen_id" />
		<KeyWord name="msilib.Control" />
		<KeyWord name="msilib.Control.condition" />
		<KeyWord name="msilib.Control.event" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="event" />
				<Param name="argument" />
				<Param name="[condition=1" />
				<Param name="[ordering=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Control.mapping" />
		<KeyWord name="msilib.CreateRecord" func="yes">
			<Overload retVal="" descr="OpenDatabase(name, flags) -&gt; dbobj&#10;Wraps MsiCreateRecord">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Dialog" />
		<KeyWord name="msilib.Dialog.bitmap" />
		<KeyWord name="msilib.Dialog.checkbox" />
		<KeyWord name="msilib.Dialog.control" />
		<KeyWord name="msilib.Dialog.line" />
		<KeyWord name="msilib.Dialog.pushbutton" />
		<KeyWord name="msilib.Dialog.radiogroup" />
		<KeyWord name="msilib.Dialog.text" />
		<KeyWord name="msilib.Directory" />
		<KeyWord name="msilib.Directory.add_file" func="yes">
			<Overload retVal="" descr="Add a file to the current component of the directory, starting a new one&#10;if there is no current component. By default, the file name in the source&#10;and the file table will be identical. If the src file is specified, it is&#10;interpreted relative to the current directory. Optionally, a version and a&#10;language can be specified for the entry in the File table.">
				<Param name="self" />
				<Param name="file" />
				<Param name="[src=None" />
				<Param name="[version=None" />
				<Param name="[language=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Directory.glob" func="yes">
			<Overload retVal="" descr="Add a list of files to the current component as specified in the&#10;glob pattern. Individual files can be excluded in the exclude list.">
				<Param name="self" />
				<Param name="pattern" />
				<Param name="[exclude=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Directory.make_short" />
		<KeyWord name="msilib.Directory.remove_pyc" func="yes">
			<Overload retVal="" descr="Remove .pyc files on uninstall">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Directory.start_component" func="yes">
			<Overload retVal="" descr="Add an entry to the Component table, and make this component the current for this&#10;directory. If no component name is given, the directory name is used. If no feature&#10;is given, the current feature is used. If no flags are given, the directory's default&#10;flags are used. If no keyfile is given, the KeyPath is left null in the Component&#10;table.">
				<Param name="self" />
				<Param name="[component=None" />
				<Param name="[feature=None" />
				<Param name="[flags=None" />
				<Param name="[keyfile=None" />
				<Param name="[uuid=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.FCICreate" func="yes">
			<Overload retVal="" descr="fcicreate(cabname,files) -&gt; None">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.Feature" />
		<KeyWord name="msilib.Feature.set_current" />
		<KeyWord name="msilib.MSICOLINFO_TYPES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_CREATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_CREATEDIRECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_DIRECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_PATCHFILE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIDBOPEN_TRANSACT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_ASSIGN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_DELETE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_INSERT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_INSERT_TEMPORARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_MERGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_REPLACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_SEEK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_UPDATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE_DELETE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE_FIELD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.MSIMODIFY_VALIDATE_NEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.OpenDatabase" func="yes">
			<Overload retVal="" descr="OpenDatabase(name, flags) -&gt; dbobj&#10;Wraps MsiOpenDatabase">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_APPNAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_AUTHOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_CHARCOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_CODEPAGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_COMMENTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_CREATE_DTM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_KEYWORDS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_LASTAUTHOR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_LASTPRINTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_LASTSAVE_DTM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_PAGECOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_REVNUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_SECURITY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_SUBJECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_TITLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.PID_WORDCOUNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.RadioButtonGroup" />
		<KeyWord name="msilib.RadioButtonGroup.add" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="name" />
				<Param name="x" />
				<Param name="y" />
				<Param name="w" />
				<Param name="h" />
				<Param name="text" />
				<Param name="[value=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.RadioButtonGroup.condition" />
		<KeyWord name="msilib.RadioButtonGroup.event" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="event" />
				<Param name="argument" />
				<Param name="[condition=1" />
				<Param name="[ordering=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.RadioButtonGroup.mapping" />
		<KeyWord name="msilib.Table" />
		<KeyWord name="msilib.Table.add_field" />
		<KeyWord name="msilib.Table.create" />
		<KeyWord name="msilib.Table.sql" />
		<KeyWord name="msilib.UuidCreate" func="yes">
			<Overload retVal="" descr="UuidCreate() -&gt; string">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.add_data" />
		<KeyWord name="msilib.add_stream" />
		<KeyWord name="msilib.add_tables" />
		<KeyWord name="msilib.change_sequence" func="yes">
			<Overload retVal="" descr="Change the sequence number of an action in a sequence list">
				<Param name="seq" />
				<Param name="action" />
				<Param name="[seqno=<class 'msilib._Unspecified'>" />
				<Param name="[cond=<class 'msilib._Unspecified'>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.datasizemask" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.gen_uuid" />
		<KeyWord name="msilib.init_database" />
		<KeyWord name="msilib.knownbits" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.make_id" />
		<KeyWord name="msilib.type_binary" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_key" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_localizable" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_nullable" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_short" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_string" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.type_valid" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="msilib.typemask" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="mt_interact" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="mul" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="multicolumn" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="multiply" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing" />
		<KeyWord name="multiprocessing.Array" func="yes">
			<Overload retVal="" descr="Returns a synchronized shared array">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.AuthenticationError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.AuthenticationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.AuthenticationError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Barrier" func="yes">
			<Overload retVal="" descr="Returns a barrier object">
				<Param name="self" />
				<Param name="parties" />
				<Param name="[action=None" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="Returns a bounded semaphore object">
				<Param name="self" />
				<Param name="[value=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BufferTooShort" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BufferTooShort.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.BufferTooShort.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Condition" func="yes">
			<Overload retVal="" descr="Returns a condition object">
				<Param name="self" />
				<Param name="[lock=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Event" func="yes">
			<Overload retVal="" descr="Returns an event object">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.JoinableQueue" func="yes">
			<Overload retVal="" descr="Returns a queue object">
				<Param name="self" />
				<Param name="[maxsize=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Lock" func="yes">
			<Overload retVal="" descr="Returns a non-recursive lock object">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Manager" func="yes">
			<Overload retVal="" descr="Returns a manager associated with a running server process&#10;&#10;The managers methods such as `Lock()`, `Condition()` and `Queue()`&#10;can be used to create shared objects.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Pipe" func="yes">
			<Overload retVal="" descr="Returns two connection object connected by a pipe">
				<Param name="self" />
				<Param name="[duplex=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Pool" func="yes">
			<Overload retVal="" descr="Returns a process pool object">
				<Param name="self" />
				<Param name="[processes=None" />
				<Param name="[initializer=None" />
				<Param name="[initargs=()" />
				<Param name="[maxtasksperchild=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process" func="yes">
			<Overload retVal="" descr="Process objects represent activity that is run in a separate process&#10;&#10;The class is analogous to `threading.Thread`">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.authkey" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.exitcode" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.is_alive" func="yes">
			<Overload retVal="" descr="Return whether process is alive">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.join" func="yes">
			<Overload retVal="" descr="Wait until child process terminates">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.pid" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.run" func="yes">
			<Overload retVal="" descr="Method to be run in sub-process; can be overridden in sub-class">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.sentinel" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.start" func="yes">
			<Overload retVal="" descr="Start child process">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Process.terminate" func="yes">
			<Overload retVal="" descr="Terminate process; sends SIGTERM signal or uses TerminateProcess()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.ProcessError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.ProcessError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.ProcessError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Queue" func="yes">
			<Overload retVal="" descr="Returns a queue object">
				<Param name="self" />
				<Param name="[maxsize=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.RLock" func="yes">
			<Overload retVal="" descr="Returns a recursive lock object">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.RawArray" func="yes">
			<Overload retVal="" descr="Returns a shared array">
				<Param name="self" />
				<Param name="typecode_or_type" />
				<Param name="size_or_initializer" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.RawValue" func="yes">
			<Overload retVal="" descr="Returns a shared object">
				<Param name="self" />
				<Param name="typecode_or_type" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.SUBDEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.SUBWARNING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Semaphore" func="yes">
			<Overload retVal="" descr="Returns a semaphore object">
				<Param name="self" />
				<Param name="[value=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.SimpleQueue" func="yes">
			<Overload retVal="" descr="Returns a queue object">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.TimeoutError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.TimeoutError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.TimeoutError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.Value" func="yes">
			<Overload retVal="" descr="Returns a synchronized shared object">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.active_children" func="yes">
			<Overload retVal="" descr="Return list of process objects corresponding to live child processes">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.allow_connection_pickling" func="yes">
			<Overload retVal="" descr="Install support for sending connections and sockets&#10;between processes">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.cpu_count" func="yes">
			<Overload retVal="" descr="Returns the number of CPUs in the system">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.current_process" func="yes">
			<Overload retVal="" descr="Return process object representing the current process">
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.freeze_support" func="yes">
			<Overload retVal="" descr="Check whether this is a fake forked process in a frozen executable.&#10;If so then run code specified by commandline and exit.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.get_all_start_methods" />
		<KeyWord name="multiprocessing.get_context" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[method=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.get_logger" func="yes">
			<Overload retVal="" descr="Return package logger -- if it does not already exist then&#10;it is created.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.get_start_method" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[allow_none=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.log_to_stderr" func="yes">
			<Overload retVal="" descr="Turn on logging and add a handler which prints to stderr">
				<Param name="self" />
				<Param name="[level=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.set_executable" func="yes">
			<Overload retVal="" descr="Sets the path to a python.exe or pythonw.exe binary used to run&#10;child processes instead of sys.executable when using the 'spawn'&#10;start method.  Useful for people embedding Python.">
				<Param name="self" />
				<Param name="executable" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.set_forkserver_preload" func="yes">
			<Overload retVal="" descr="Set list of module names to try to load in forkserver process.&#10;This is really just a hint.">
				<Param name="self" />
				<Param name="module_names" />
			</Overload>
		</KeyWord>
		<KeyWord name="multiprocessing.set_start_method" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="method" />
				<Param name="[force=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="myrights" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="name" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="namedtuple" func="yes">
			<Overload retVal="" descr="Function of aifc">
			</Overload>
		</KeyWord>
		<KeyWord name="namelink" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="namelist" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="namereplace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="namespace" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="ndiff" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="ne" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="needsquoting" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="neg" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc" func="yes">
			<Overload retVal="" descr="An object-oriented interface to .netrc files.">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.NetrcParseError" func="yes">
			<Overload retVal="" descr="Exception raised on syntax errors in the .netrc file.">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.NetrcParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.NetrcParseError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="netrc.netrc" />
		<KeyWord name="netrc.netrc.authenticators" func="yes">
			<Overload retVal="" descr="Return a (user, account, password) tuple for given host.">
				<Param name="self" />
				<Param name="host" />
			</Overload>
		</KeyWord>
		<KeyWord name="new" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="new_alignment" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="new_class" func="yes">
			<Overload retVal="" descr="Function of types">
			</Overload>
		</KeyWord>
		<KeyWord name="new_event_loop" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="new_font" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="new_margin" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="new_module" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="new_spacing" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="new_styles" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="newgroups" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="newnews" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="next" func="yes">
			<Overload retVal="" descr="next(iterator[, default])&#10;&#10;Return the next item from the iterator. If default is given and the iterator&#10;is exhausted, it is returned instead of raising StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="next_minus" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="next_plus" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="next_toward" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="nextfile" func="yes">
			<Overload retVal="" descr="Function of fileinput">
			</Overload>
		</KeyWord>
		<KeyWord name="ngettext" func="yes">
			<Overload retVal="" descr="Function of argparse">
			</Overload>
		</KeyWord>
		<KeyWord name="nlargest" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="nlst" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib" func="yes">
			<Overload retVal="" descr="An NNTP client class based on:&#10;- RFC 977: Network News Transfer Protocol&#10;- RFC 2980: Common NNTP Extensions&#10;- RFC 3977: Network News Transfer Protocol (version 2)&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; from nntplib import NNTP&#10;&gt;&gt;&gt; s = NNTP('news')&#10;&gt;&gt;&gt; resp, count, first, last, name = s.group('comp.lang.python')&#10;&gt;&gt;&gt; print('Group', name, 'has', count, 'articles, range', first, 'to', last)&#10;Group comp.lang.python has 51 articles, range 5770 to 5821&#10;&gt;&gt;&gt; resp, subs = s.xhdr('subject', '{0}-{1}'.format(first, last))&#10;&gt;&gt;&gt; resp = s.quit()&#10;&gt;&gt;&gt;&#10;&#10;Here 'resp' is the server response line.&#10;Error responses are turned into exceptions.&#10;&#10;To post an article from a file:&#10;&gt;&gt;&gt; f = open(filename, 'rb') # file containing article, including header&#10;&gt;&gt;&gt; resp = s.post(f)&#10;&gt;&gt;&gt;&#10;&#10;For descriptions of all methods, read the comments in the code below.&#10;Note that all arguments and return values representing article numbers&#10;are strings, not numbers, since they are rarely used for calculations.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.ArticleInfo" func="yes">
			<Overload retVal="" descr="ArticleInfo(number, message_id, lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.ArticleInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.ArticleInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.ArticleInfo.lines" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.ArticleInfo.message_id" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.ArticleInfo.number" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo" func="yes">
			<Overload retVal="" descr="GroupInfo(group, last, first, flag)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo.first" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo.flag" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo.group" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.GroupInfo.last" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP" />
		<KeyWord name="nntplib.NNTP.article" func="yes">
			<Overload retVal="" descr="Process an ARTICLE command.  Argument:&#10;- message_spec: article number or message id&#10;- file: filename string or file object to store the article in&#10;Returns:&#10;- resp: server response if successful&#10;- ArticleInfo: (article number, message id, list of article lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.body" func="yes">
			<Overload retVal="" descr="Process a BODY command.  Argument:&#10;- message_spec: article number or message id&#10;- file: filename string or file object to store the body in&#10;Returns:&#10;- resp: server response if successful&#10;- ArticleInfo: (article number, message id, list of body lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.capabilities" func="yes">
			<Overload retVal="" descr="Process a CAPABILITIES command.  Not supported by all servers.&#10;Return:&#10;- resp: server response if successful&#10;- caps: a dictionary mapping capability names to lists of tokens&#10;(for example {'VERSION': ['2'], 'OVER': [], LIST: ['ACTIVE', 'HEADERS'] })">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.date" func="yes">
			<Overload retVal="" descr="Process the DATE command.&#10;Returns:&#10;- resp: server response if successful&#10;- date: datetime object">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.debug" func="yes">
			<Overload retVal="" descr="Set the debugging level.  Argument 'level' means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.description" func="yes">
			<Overload retVal="" descr="Get a description for a single group.  If more than one&#10;group matches ('group' is a pattern), return the first.  If no&#10;group matches, return an empty string.&#10;&#10;This elides the response code from the server, since it can&#10;only be '215' or '285' (for xgtitle) anyway.  If the response&#10;code is needed, use the 'descriptions' method.&#10;&#10;NOTE: This neither checks for a wildcard in 'group' nor does&#10;it check whether the group actually exists.">
				<Param name="self" />
				<Param name="group" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.descriptions" func="yes">
			<Overload retVal="" descr="Get descriptions for a range of groups.">
				<Param name="self" />
				<Param name="group_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.errors" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.getcapabilities" func="yes">
			<Overload retVal="" descr="Get the server capabilities, as read by __init__().&#10;If the CAPABILITIES command is not supported, an empty dict is&#10;returned.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.getwelcome" func="yes">
			<Overload retVal="" descr="Get the welcome message from the server&#10;(this is read and squirreled away by __init__()).&#10;If the response code is 200, posting is allowed;&#10;if it 201, posting is not allowed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.group" func="yes">
			<Overload retVal="" descr="Process a GROUP command.  Argument:&#10;- group: the group name&#10;Returns:&#10;- resp: server response if successful&#10;- count: number of articles&#10;- first: first article number&#10;- last: last article number&#10;- name: the group name">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.head" func="yes">
			<Overload retVal="" descr="Process a HEAD command.  Argument:&#10;- message_spec: article number or message id&#10;- file: filename string or file object to store the headers in&#10;Returns:&#10;- resp: server response if successful&#10;- ArticleInfo: (article number, message id, list of header lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.help" func="yes">
			<Overload retVal="" descr="Process a HELP command. Argument:&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of strings returned by the server in response to the&#10;        HELP command">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.ihave" func="yes">
			<Overload retVal="" descr="Process an IHAVE command.  Arguments:&#10;- message_id: message-id of the article&#10;- data: file containing the article&#10;Returns:&#10;- resp: server response if successful&#10;Note that if the server refuses the article an exception is raised.">
				<Param name="self" />
				<Param name="message_id" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.last" func="yes">
			<Overload retVal="" descr="Process a LAST command.  No arguments.  Return as for STAT.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.list" func="yes">
			<Overload retVal="" descr="Process a LIST or LIST ACTIVE command. Arguments:&#10;- group_pattern: a pattern indicating which groups to query&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of (group, last, first, flag) (strings)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.login" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[user=None" />
				<Param name="[password=None" />
				<Param name="[usenetrc=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.newgroups" func="yes">
			<Overload retVal="" descr="Process a NEWGROUPS command.  Arguments:&#10;- date: a date or datetime object&#10;Return:&#10;- resp: server response if successful&#10;- list: list of newsgroup names">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.newnews" func="yes">
			<Overload retVal="" descr="Process a NEWNEWS command.  Arguments:&#10;- group: group name or '*'&#10;- date: a date or datetime object&#10;Return:&#10;- resp: server response if successful&#10;- list: list of message ids">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.next" func="yes">
			<Overload retVal="" descr="Process a NEXT command.  No arguments.  Return as for STAT.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.over" func="yes">
			<Overload retVal="" descr="Process an OVER command.  If the command isn't supported, fall&#10;back to XOVER. Arguments:&#10;- message_spec:&#10;    - either a message id, indicating the article to fetch&#10;      information about&#10;    - or a (start, end) tuple, indicating a range of article numbers;&#10;      if end is None, information up to the newest message will be&#10;      retrieved&#10;    - or None, indicating the current article number must be used&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of dicts containing the response fields&#10;&#10;NOTE: the &quot;message id&quot; form isn't supported by XOVER">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.post" func="yes">
			<Overload retVal="" descr="Process a POST command.  Arguments:&#10;- data: bytes object, iterable or file containing the article&#10;Returns:&#10;- resp: server response if successful">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.quit" func="yes">
			<Overload retVal="" descr="Process a QUIT command and close the socket.  Returns:&#10;- resp: server response if successful">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debugging level.  Argument 'level' means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.slave" func="yes">
			<Overload retVal="" descr="Process a SLAVE command.  Returns:&#10;- resp: server response if successful">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.starttls" func="yes">
			<Overload retVal="" descr="Process a STARTTLS command. Arguments:&#10;- context: SSL context to use for the encrypted connection">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.stat" func="yes">
			<Overload retVal="" descr="Process a STAT command.  Argument:&#10;- message_spec: article number or message id (if not specified,&#10;  the current article is selected)&#10;Returns:&#10;- resp: server response if successful&#10;- art_num: the article number&#10;- message_id: the message id">
				<Param name="self" />
				<Param name="[message_spec=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.xgtitle" func="yes">
			<Overload retVal="" descr="Process an XGTITLE command (optional server extension) Arguments:&#10;- group: group name wildcard (i.e. news.*)&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of (name,title) strings">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.xhdr" func="yes">
			<Overload retVal="" descr="Process an XHDR command (optional server extension).  Arguments:&#10;- hdr: the header type (e.g. 'subject')&#10;- str: an article nr, a message id, or a range nr1-nr2&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of (nr, value) strings">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.xover" func="yes">
			<Overload retVal="" descr="Process an XOVER command (optional server extension) Arguments:&#10;- start: start of range&#10;- end: end of range&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of dicts containing the response fields">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP.xpath" func="yes">
			<Overload retVal="" descr="Process an XPATH command (optional server extension) Arguments:&#10;- id: Message id of article&#10;Returns:&#10;resp: server response if successful&#10;path: directory path to article">
				<Param name="self" />
				<Param name="id" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPDataError" func="yes">
			<Overload retVal="" descr="Error in response data">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPDataError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPDataError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPError" func="yes">
			<Overload retVal="" descr="Base class for all nntplib exceptions">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPPermanentError" func="yes">
			<Overload retVal="" descr="5xx errors">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPPermanentError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPPermanentError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPProtocolError" func="yes">
			<Overload retVal="" descr="Response does not begin with [1-5]">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPProtocolError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPProtocolError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPReplyError" func="yes">
			<Overload retVal="" descr="Unexpected [123]xx reply">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPReplyError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPReplyError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPTemporaryError" func="yes">
			<Overload retVal="" descr="4xx errors">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPTemporaryError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTPTemporaryError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL" />
		<KeyWord name="nntplib.NNTP_SSL.article" func="yes">
			<Overload retVal="" descr="Process an ARTICLE command.  Argument:&#10;- message_spec: article number or message id&#10;- file: filename string or file object to store the article in&#10;Returns:&#10;- resp: server response if successful&#10;- ArticleInfo: (article number, message id, list of article lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.body" func="yes">
			<Overload retVal="" descr="Process a BODY command.  Argument:&#10;- message_spec: article number or message id&#10;- file: filename string or file object to store the body in&#10;Returns:&#10;- resp: server response if successful&#10;- ArticleInfo: (article number, message id, list of body lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.capabilities" func="yes">
			<Overload retVal="" descr="Process a CAPABILITIES command.  Not supported by all servers.&#10;Return:&#10;- resp: server response if successful&#10;- caps: a dictionary mapping capability names to lists of tokens&#10;(for example {'VERSION': ['2'], 'OVER': [], LIST: ['ACTIVE', 'HEADERS'] })">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.date" func="yes">
			<Overload retVal="" descr="Process the DATE command.&#10;Returns:&#10;- resp: server response if successful&#10;- date: datetime object">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.debug" func="yes">
			<Overload retVal="" descr="Set the debugging level.  Argument 'level' means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.description" func="yes">
			<Overload retVal="" descr="Get a description for a single group.  If more than one&#10;group matches ('group' is a pattern), return the first.  If no&#10;group matches, return an empty string.&#10;&#10;This elides the response code from the server, since it can&#10;only be '215' or '285' (for xgtitle) anyway.  If the response&#10;code is needed, use the 'descriptions' method.&#10;&#10;NOTE: This neither checks for a wildcard in 'group' nor does&#10;it check whether the group actually exists.">
				<Param name="self" />
				<Param name="group" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.descriptions" func="yes">
			<Overload retVal="" descr="Get descriptions for a range of groups.">
				<Param name="self" />
				<Param name="group_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.errors" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.getcapabilities" func="yes">
			<Overload retVal="" descr="Get the server capabilities, as read by __init__().&#10;If the CAPABILITIES command is not supported, an empty dict is&#10;returned.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.getwelcome" func="yes">
			<Overload retVal="" descr="Get the welcome message from the server&#10;(this is read and squirreled away by __init__()).&#10;If the response code is 200, posting is allowed;&#10;if it 201, posting is not allowed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.group" func="yes">
			<Overload retVal="" descr="Process a GROUP command.  Argument:&#10;- group: the group name&#10;Returns:&#10;- resp: server response if successful&#10;- count: number of articles&#10;- first: first article number&#10;- last: last article number&#10;- name: the group name">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.head" func="yes">
			<Overload retVal="" descr="Process a HEAD command.  Argument:&#10;- message_spec: article number or message id&#10;- file: filename string or file object to store the headers in&#10;Returns:&#10;- resp: server response if successful&#10;- ArticleInfo: (article number, message id, list of header lines)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.help" func="yes">
			<Overload retVal="" descr="Process a HELP command. Argument:&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of strings returned by the server in response to the&#10;        HELP command">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.ihave" func="yes">
			<Overload retVal="" descr="Process an IHAVE command.  Arguments:&#10;- message_id: message-id of the article&#10;- data: file containing the article&#10;Returns:&#10;- resp: server response if successful&#10;Note that if the server refuses the article an exception is raised.">
				<Param name="self" />
				<Param name="message_id" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.last" func="yes">
			<Overload retVal="" descr="Process a LAST command.  No arguments.  Return as for STAT.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.list" func="yes">
			<Overload retVal="" descr="Process a LIST or LIST ACTIVE command. Arguments:&#10;- group_pattern: a pattern indicating which groups to query&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of (group, last, first, flag) (strings)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.login" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[user=None" />
				<Param name="[password=None" />
				<Param name="[usenetrc=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.newgroups" func="yes">
			<Overload retVal="" descr="Process a NEWGROUPS command.  Arguments:&#10;- date: a date or datetime object&#10;Return:&#10;- resp: server response if successful&#10;- list: list of newsgroup names">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.newnews" func="yes">
			<Overload retVal="" descr="Process a NEWNEWS command.  Arguments:&#10;- group: group name or '*'&#10;- date: a date or datetime object&#10;Return:&#10;- resp: server response if successful&#10;- list: list of message ids">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.next" func="yes">
			<Overload retVal="" descr="Process a NEXT command.  No arguments.  Return as for STAT.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.over" func="yes">
			<Overload retVal="" descr="Process an OVER command.  If the command isn't supported, fall&#10;back to XOVER. Arguments:&#10;- message_spec:&#10;    - either a message id, indicating the article to fetch&#10;      information about&#10;    - or a (start, end) tuple, indicating a range of article numbers;&#10;      if end is None, information up to the newest message will be&#10;      retrieved&#10;    - or None, indicating the current article number must be used&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of dicts containing the response fields&#10;&#10;NOTE: the &quot;message id&quot; form isn't supported by XOVER">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.post" func="yes">
			<Overload retVal="" descr="Process a POST command.  Arguments:&#10;- data: bytes object, iterable or file containing the article&#10;Returns:&#10;- resp: server response if successful">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.quit" func="yes">
			<Overload retVal="" descr="Process a QUIT command and close the socket.  Returns:&#10;- resp: server response if successful">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debugging level.  Argument 'level' means:&#10;0: no debugging output (default)&#10;1: print commands and responses but not body text etc.&#10;2: also print raw lines read and sent before stripping CR/LF">
				<Param name="self" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.slave" func="yes">
			<Overload retVal="" descr="Process a SLAVE command.  Returns:&#10;- resp: server response if successful">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.starttls" func="yes">
			<Overload retVal="" descr="Process a STARTTLS command. Arguments:&#10;- context: SSL context to use for the encrypted connection">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.stat" func="yes">
			<Overload retVal="" descr="Process a STAT command.  Argument:&#10;- message_spec: article number or message id (if not specified,&#10;  the current article is selected)&#10;Returns:&#10;- resp: server response if successful&#10;- art_num: the article number&#10;- message_id: the message id">
				<Param name="self" />
				<Param name="[message_spec=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.xgtitle" func="yes">
			<Overload retVal="" descr="Process an XGTITLE command (optional server extension) Arguments:&#10;- group: group name wildcard (i.e. news.*)&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of (name,title) strings">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.xhdr" func="yes">
			<Overload retVal="" descr="Process an XHDR command (optional server extension).  Arguments:&#10;- hdr: the header type (e.g. 'subject')&#10;- str: an article nr, a message id, or a range nr1-nr2&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of (nr, value) strings">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.xover" func="yes">
			<Overload retVal="" descr="Process an XOVER command (optional server extension) Arguments:&#10;- start: start of range&#10;- end: end of range&#10;- file: Filename string or file object to store the result in&#10;Returns:&#10;- resp: server response if successful&#10;- list: list of dicts containing the response fields">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL.xpath" func="yes">
			<Overload retVal="" descr="Process an XPATH command (optional server extension) Arguments:&#10;- id: Message id of article&#10;Returns:&#10;resp: server response if successful&#10;path: directory path to article">
				<Param name="self" />
				<Param name="id" />
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.NNTP_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="nntplib.decode_header" func="yes">
			<Overload retVal="" descr="Takes a unicode string representing a munged header value&#10;and decodes it as a (possibly non-ASCII) readable value.">
				<Param name="header_str" />
			</Overload>
		</KeyWord>
		<KeyWord name="no_type_check" func="yes">
			<Overload retVal="" descr="Function of typing">
			</Overload>
		</KeyWord>
		<KeyWord name="no_type_check_decorator" func="yes">
			<Overload retVal="" descr="Function of typing">
			</Overload>
		</KeyWord>
		<KeyWord name="node" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="nolog" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="nonlocal" />
		<KeyWord name="noop" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="norm_error" func="yes">
			<Overload retVal="" descr="Function of macpath.norm_error">
			</Overload>
		</KeyWord>
		<KeyWord name="normalize" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="normalize_encoding" func="yes">
			<Overload retVal="" descr="Function of encodings">
			</Overload>
		</KeyWord>
		<KeyWord name="normalize_keys" func="yes">
			<Overload retVal="" descr="Function of pip.ConfigOptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="normalize_path" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="normalvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="normcase" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="normpath" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="not" />
		<KeyWord name="not_equal_witness" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="not_less_witness" func="yes">
			<Overload retVal="" descr="Function of tabnanny.Whitespace">
			</Overload>
		</KeyWord>
		<KeyWord name="notify" func="yes">
			<Overload retVal="" descr="Function of asyncio.Condition">
			</Overload>
		</KeyWord>
		<KeyWord name="notifyAll" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Condition">
			</Overload>
		</KeyWord>
		<KeyWord name="notify_all" func="yes">
			<Overload retVal="" descr="Function of asyncio.Condition">
			</Overload>
		</KeyWord>
		<KeyWord name="now" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="nsmallest" func="yes">
			<Overload retVal="" descr="Function of heapq">
			</Overload>
		</KeyWord>
		<KeyWord name="nti" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="ntohl" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="ntohs" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath" func="yes">
			<Overload retVal="" descr="Common pathname manipulations, WindowsNT/95 version.&#10;&#10;Instead of importing this module directly, import os and refer to this&#10;module as os.path.">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.abspath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.altsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.basename" func="yes">
			<Overload retVal="" descr="Returns the final component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.commonpath" func="yes">
			<Overload retVal="" descr="Given a sequence of path names, returns the longest common sub-path.">
				<Param name="paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.dirname" func="yes">
			<Overload retVal="" descr="Returns the directory component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.expanduser" func="yes">
			<Overload retVal="" descr="Expand ~ and ~user constructs.&#10;&#10;If user or $HOME is unknown, do nothing.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.expandvars" func="yes">
			<Overload retVal="" descr="Expand shell variables of the forms $var, ${var} and %var%.&#10;&#10;Unknown variables are left unchanged.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.isabs" func="yes">
			<Overload retVal="" descr="Test whether a path is absolute">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.islink" func="yes">
			<Overload retVal="" descr="Test whether a path is a symbolic link.&#10;This will always return false for Windows prior to 6.0.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.ismount" func="yes">
			<Overload retVal="" descr="Test whether a path is a mount point (a drive root, the root of a&#10;share, or a mounted volume)">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.join" />
		<KeyWord name="ntpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns True for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.normcase" func="yes">
			<Overload retVal="" descr="Normalize case of pathname.&#10;&#10;Makes all characters lowercase and all slashes into backslashes.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize path, eliminating double slashes, etc.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.realpath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.relpath" func="yes">
			<Overload retVal="" descr="Return a relative version of a path">
				<Param name="path" />
				<Param name="[start=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.samefile" func="yes">
			<Overload retVal="" descr="Test whether two pathnames reference the same actual file">
				<Param name="f1" />
				<Param name="f2" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.sameopenfile" func="yes">
			<Overload retVal="" descr="Test whether two open file objects reference the same file">
				<Param name="fp1" />
				<Param name="fp2" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.samestat" func="yes">
			<Overload retVal="" descr="Test whether two stat buffers reference the same file">
				<Param name="s1" />
				<Param name="s2" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.split" func="yes">
			<Overload retVal="" descr="Split a pathname.&#10;&#10;Return tuple (head, tail) where tail is everything after the final slash.&#10;Either part may be empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.splitdrive" func="yes">
			<Overload retVal="" descr='Split a pathname into drive/UNC sharepoint and relative path specifiers.&#10;Returns a 2-tuple (drive_or_unc, path); either part may be empty.&#10;&#10;If you assign&#10;    result = splitdrive(p)&#10;It is always true that:&#10;    result[0] + result[1] == p&#10;&#10;If the path contained a drive letter, drive_or_unc will contain everything&#10;up to and including the colon.  e.g. splitdrive("c:/dir") returns ("c:", "/dir")&#10;&#10;If the path contained a UNC path, the drive_or_unc will contain the host name&#10;and share up to but not including the fourth directory separator character.&#10;e.g. splitdrive("//host/computer/dir") returns ("//host/computer", "/dir")&#10;&#10;Paths cannot contain both a drive letter and a UNC path.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.splitunc" func="yes">
			<Overload retVal="" descr="Deprecated since Python 3.1.  Please use splitdrive() instead;&#10;it now handles UNC paths.&#10;&#10;Split a pathname into UNC mount point and relative path specifiers.&#10;&#10;Return a 2-tuple (unc, rest); either part may be empty.&#10;If unc is not empty, it has the form '//host/mount' (or similar&#10;using backslashes).  unc+rest is always the input path.&#10;Paths containing drive letters never have a UNC part.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="ntpath.supports_unicode_filenames" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ntransfercmd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="nts" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="nturl2path" func="yes">
			<Overload retVal="" descr="Convert a NT pathname to a file URL and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="nturl2path.pathname2url" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a file system path to a relative URL&#10;of the 'file' scheme; not recommended for general use.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="nturl2path.url2pathname" func="yes">
			<Overload retVal="" descr="OS-specific conversion from a relative URL of the 'file' scheme&#10;to a file system path; not recommended for general use.">
				<Param name="url" />
			</Overload>
		</KeyWord>
		<KeyWord name="null_ns_handler" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="number_class" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers" func="yes">
			<Overload retVal="" descr="Abstract Base Classes (ABCs) for numbers, according to PEP 3141.&#10;&#10;TODO: Fill out more detailed documentation on the operators.">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.ABCMeta" func="yes">
			<Overload retVal="" descr="Metaclass for defining Abstract Base Classes (ABCs).&#10;&#10;Use this metaclass to create an ABC.  An ABC can be subclassed&#10;directly, and then acts as a mix-in class.  You can also register&#10;unrelated concrete classes (even built-in classes) and unrelated&#10;ABCs as 'virtual subclasses' -- these and their descendants will&#10;be considered subclasses of the registering ABC by the built-in&#10;issubclass() function, but the registering ABC won't show up in&#10;their MRO (Method Resolution Order) nor will method&#10;implementations defined by the registering ABC be callable (not&#10;even via super()).">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.ABCMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.ABCMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.&#10;&#10;Returns the subclass, to allow usage as a class decorator.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Complex" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Integral" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Number" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Rational" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.Real" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="numbers.abstractmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract methods.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract methods are overridden.&#10;The abstract methods can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractmethod&#10;        def my_abstract_method(self, ...):&#10;            ...">
				<Param name="funcobj" />
			</Overload>
		</KeyWord>
		<KeyWord name="numeric" func="yes">
			<Overload retVal="" descr="Function of unicodedata">
			</Overload>
		</KeyWord>
		<KeyWord name="object" func="yes">
			<Overload retVal="" descr="The most base type">
			</Overload>
		</KeyWord>
		<KeyWord name="obtain" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.AvailableDistributions">
			</Overload>
		</KeyWord>
		<KeyWord name="oct" func="yes">
			<Overload retVal="" descr="Return the octal representation of an integer.&#10;&#10;&gt;&gt;&gt; oct(342391)&#10;'0o1234567'">
				<Param name="number" />
			</Overload>
		</KeyWord>
		<KeyWord name="oem_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="oem_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="onecmd" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode" func="yes">
			<Overload retVal="" descr="opcode module - potentially shared between dis and other modules which&#10;operate on bytecodes (e.g. peephole optimizers).">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.EXTENDED_ARG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.HAVE_ARGUMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.cmp_op" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hascompare" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasconst" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasfree" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasjabs" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasjrel" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.haslocal" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.hasname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.opmap" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.opname" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="opcode.stack_effect" func="yes">
			<Overload retVal="" descr="Compute the stack effect of the opcode.">
				<Param name="opcode" />
				<Param name="oparg" />
			</Overload>
		</KeyWord>
		<KeyWord name="open" func="yes">
			<Overload retVal="" descr="Open file and return a stream.  Raise IOError upon failure.&#10;&#10;file is either a text or byte string giving the name (and the path&#10;if the file isn't in the current working directory) of the file to&#10;be opened or an integer file descriptor of the file to be&#10;wrapped. (If a file descriptor is given, it is closed when the&#10;returned I/O object is closed, unless closefd is set to False.)&#10;&#10;mode is an optional string that specifies the mode in which the file&#10;is opened. It defaults to 'r' which means open for reading in text&#10;mode.  Other common values are 'w' for writing (truncating the file if&#10;it already exists), 'x' for creating and writing to a new file, and&#10;'a' for appending (which on some Unix systems, means that all writes&#10;append to the end of the file regardless of the current seek position).&#10;In text mode, if encoding is not specified the encoding used is platform&#10;dependent: locale.getpreferredencoding(False) is called to get the&#10;current locale encoding. (For reading and writing raw bytes use binary&#10;mode and leave encoding unspecified.) The available modes are:&#10;&#10;========= ===============================================================&#10;Character Meaning&#10;--------- ---------------------------------------------------------------&#10;'r'       open for reading (default)&#10;'w'       open for writing, truncating the file first&#10;'x'       create a new file and open it for writing&#10;'a'       open for writing, appending to the end of the file if it exists&#10;'b'       binary mode&#10;'t'       text mode (default)&#10;'+'       open a disk file for updating (reading and writing)&#10;'U'       universal newline mode (deprecated)&#10;========= ===============================================================&#10;&#10;The default mode is 'rt' (open for reading text). For binary random&#10;access, the mode 'w+b' opens and truncates the file to 0 bytes, while&#10;'r+b' opens the file without truncation. The 'x' mode implies 'w' and&#10;raises an `FileExistsError` if the file already exists.&#10;&#10;Python distinguishes between files opened in binary and text modes,&#10;even when the underlying operating system doesn't. Files opened in&#10;binary mode (appending 'b' to the mode argument) return contents as&#10;bytes objects without any decoding. In text mode (the default, or when&#10;'t' is appended to the mode argument), the contents of the file are&#10;returned as strings, the bytes having been first decoded using a&#10;platform-dependent encoding or using the specified encoding if given.&#10;&#10;'U' mode is deprecated and will raise an exception in future versions&#10;of Python.  It has no effect in Python 3.  Use newline to control&#10;universal newlines mode.&#10;&#10;buffering is an optional integer used to set the buffering policy.&#10;Pass 0 to switch buffering off (only allowed in binary mode), 1 to select&#10;line buffering (only usable in text mode), and an integer &gt; 1 to indicate&#10;the size of a fixed-size chunk buffer.  When no buffering argument is&#10;given, the default buffering policy works as follows:&#10;&#10;* Binary files are buffered in fixed-size chunks; the size of the buffer&#10;  is chosen using a heuristic trying to determine the underlying device's&#10;  &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.&#10;  On many systems, the buffer will typically be 4096 or 8192 bytes long.&#10;&#10;* &quot;Interactive&quot; text files (files for which isatty() returns True)&#10;  use line buffering.  Other text files use the policy described above&#10;  for binary files.&#10;&#10;encoding is the name of the encoding used to decode or encode the&#10;file. This should only be used in text mode. The default encoding is&#10;platform dependent, but any encoding supported by Python can be&#10;passed.  See the codecs module for the list of supported encodings.&#10;&#10;errors is an optional string that specifies how encoding errors are to&#10;be handled---this argument should not be used in binary mode. Pass&#10;'strict' to raise a ValueError exception if there is an encoding error&#10;(the default of None has the same effect), or pass 'ignore' to ignore&#10;errors. (Note that ignoring encoding errors can lead to data loss.)&#10;See the documentation for codecs.register or run 'help(codecs.Codec)'&#10;for a list of the permitted encoding error strings.&#10;&#10;newline controls how universal newlines works (it only applies to text&#10;mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as&#10;follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If closefd is False, the underlying file descriptor will be kept open&#10;when the file is closed. This does not work when a file name is given&#10;and must be True in that case.&#10;&#10;A custom opener can be used by passing a callable as *opener*. The&#10;underlying file descriptor for the file object is then obtained by&#10;calling *opener* with (*file*, *flags*). *opener* must return an open&#10;file descriptor (passing os.open as *opener* results in functionality&#10;similar to passing None).&#10;&#10;open() returns a file object whose type depends on the mode, and&#10;through which the standard file operations such as reading and writing&#10;are performed. When open() is used to open a file in a text mode ('w',&#10;'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open&#10;a file in a binary mode, the returned class varies: in read binary&#10;mode, it returns a BufferedReader; in write binary and append binary&#10;modes, it returns a BufferedWriter, and in read/write mode, it returns&#10;a BufferedRandom.&#10;&#10;It is also possible to use a string or bytearray as a file for both&#10;reading and writing. For strings StringIO can be used like a file&#10;opened in a text mode, and for bytes a BytesIO can be used like a file&#10;opened in a binary mode.">
				<Param name="file" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None" />
				<Param name="[closefd=True" />
				<Param name="[opener=None]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="open_connection" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="open_new" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="open_new_tab" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="open_r" func="yes">
			<Overload retVal="" descr="Function of pipes.Template">
			</Overload>
		</KeyWord>
		<KeyWord name="open_w" func="yes">
			<Overload retVal="" descr="Function of pipes.Template">
			</Overload>
		</KeyWord>
		<KeyWord name="openfp" func="yes">
			<Overload retVal="" descr="Function of aifc">
			</Overload>
		</KeyWord>
		<KeyWord name="opengroup" func="yes">
			<Overload retVal="" descr="Function of sre_parse.Pattern">
			</Overload>
		</KeyWord>
		<KeyWord name="openrsrc" func="yes">
			<Overload retVal="" descr="Function of binhex.openrsrc">
			</Overload>
		</KeyWord>
		<KeyWord name="operator" func="yes">
			<Overload retVal="" descr="Operator interface.&#10;&#10;This module exports a set of functions implemented in C corresponding&#10;to the intrinsic operators of Python.  For example, operator.add(x, y)&#10;is equivalent to the expression x+y.  The function names are those&#10;used for special methods; variants without leading and trailing&#10;'__' are also provided for convenience.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.abs" func="yes">
			<Overload retVal="" descr="abs(a) -- Same as abs(a).">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.add" func="yes">
			<Overload retVal="" descr="add(a, b) -- Same as a + b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.attrgetter" func="yes">
			<Overload retVal="" descr="attrgetter(attr, ...) --&gt; attrgetter object&#10;&#10;Return a callable object that fetches the given attribute(s) from its operand.&#10;After f = attrgetter('name'), the call f(r) returns r.name.&#10;After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).&#10;After h = attrgetter('name.first', 'name.last'), the call h(r) returns&#10;(r.name.first, r.name.last).">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.concat" func="yes">
			<Overload retVal="" descr="concat(a, b) -- Same as a + b, for a and b sequences.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.contains" func="yes">
			<Overload retVal="" descr="contains(a, b) -- Same as b in a (note reversed operands).">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.countOf" func="yes">
			<Overload retVal="" descr="countOf(a, b) -- Return the number of times b occurs in a.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.delitem" func="yes">
			<Overload retVal="" descr="delitem(a, b) -- Same as del a[b].">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.eq" func="yes">
			<Overload retVal="" descr="eq(a, b) -- Same as a==b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.floordiv" func="yes">
			<Overload retVal="" descr="floordiv(a, b) -- Same as a // b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ge" func="yes">
			<Overload retVal="" descr="ge(a, b) -- Same as a&gt;=b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.getitem" func="yes">
			<Overload retVal="" descr="getitem(a, b) -- Same as a[b].">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.gt" func="yes">
			<Overload retVal="" descr="gt(a, b) -- Same as a&gt;b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.iadd" func="yes">
			<Overload retVal="" descr="a = iadd(a, b) -- Same as a += b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.iand" func="yes">
			<Overload retVal="" descr="a = iand(a, b) -- Same as a &amp;= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.iconcat" func="yes">
			<Overload retVal="" descr="a = iconcat(a, b) -- Same as a += b, for a and b sequences.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ifloordiv" func="yes">
			<Overload retVal="" descr="a = ifloordiv(a, b) -- Same as a //= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ilshift" func="yes">
			<Overload retVal="" descr="a = ilshift(a, b) -- Same as a &lt;&lt;= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.imatmul" func="yes">
			<Overload retVal="" descr="a = imatmul(a, b) -- Same as a @= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.imod" func="yes">
			<Overload retVal="" descr="a = imod(a, b) -- Same as a %= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.imul" func="yes">
			<Overload retVal="" descr="a = imul(a, b) -- Same as a *= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.index" func="yes">
			<Overload retVal="" descr="index(a) -- Same as a.__index__()">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.indexOf" func="yes">
			<Overload retVal="" descr="indexOf(a, b) -- Return the first index of b in a.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.inv" func="yes">
			<Overload retVal="" descr="inv(a) -- Same as ~a.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.invert" func="yes">
			<Overload retVal="" descr="invert(a) -- Same as ~a.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ior" func="yes">
			<Overload retVal="" descr="a = ior(a, b) -- Same as a |= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ipow" func="yes">
			<Overload retVal="" descr="a = ipow(a, b) -- Same as a **= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.irshift" func="yes">
			<Overload retVal="" descr="a = irshift(a, b) -- Same as a &gt;&gt;= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.is_not" func="yes">
			<Overload retVal="" descr="is_not(a, b) -- Same as a is not b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.isub" func="yes">
			<Overload retVal="" descr="a = isub(a, b) -- Same as a -= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.itemgetter" func="yes">
			<Overload retVal="" descr="itemgetter(item, ...) --&gt; itemgetter object&#10;&#10;Return a callable object that fetches the given item(s) from its operand.&#10;After f = itemgetter(2), the call f(r) returns r[2].&#10;After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.itruediv" func="yes">
			<Overload retVal="" descr="a = itruediv(a, b) -- Same as a /= b">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ixor" func="yes">
			<Overload retVal="" descr="a = ixor(a, b) -- Same as a ^= b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.le" func="yes">
			<Overload retVal="" descr="le(a, b) -- Same as a&lt;=b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.length_hint" func="yes">
			<Overload retVal="" descr="length_hint(obj, default=0) -&gt; int&#10;Return an estimate of the number of items in obj.&#10;This is useful for presizing containers when building from an&#10;iterable.&#10;&#10;If the object supports len(), the result will be&#10;exact. Otherwise, it may over- or under-estimate by an&#10;arbitrary amount. The result will be an integer &gt;= 0.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.lshift" func="yes">
			<Overload retVal="" descr="lshift(a, b) -- Same as a &lt;&lt; b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.lt" func="yes">
			<Overload retVal="" descr="lt(a, b) -- Same as a&lt;b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.matmul" func="yes">
			<Overload retVal="" descr="matmul(a, b) -- Same as a @ b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.methodcaller" func="yes">
			<Overload retVal="" descr="methodcaller(name, ...) --&gt; methodcaller object&#10;&#10;Return a callable object that calls the given method on its operand.&#10;After f = methodcaller('name'), the call f(r) returns r.name().&#10;After g = methodcaller('name', 'date', foo=1), the call g(r) returns&#10;r.name('date', foo=1).">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.mod" func="yes">
			<Overload retVal="" descr="mod(a, b) -- Same as a % b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.mul" func="yes">
			<Overload retVal="" descr="mul(a, b) -- Same as a * b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.ne" func="yes">
			<Overload retVal="" descr="ne(a, b) -- Same as a!=b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.neg" func="yes">
			<Overload retVal="" descr="neg(a) -- Same as -a.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.pos" func="yes">
			<Overload retVal="" descr="pos(a) -- Same as +a.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.pow" func="yes">
			<Overload retVal="" descr="pow(a, b) -- Same as a ** b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.rshift" func="yes">
			<Overload retVal="" descr="rshift(a, b) -- Same as a &gt;&gt; b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.setitem" func="yes">
			<Overload retVal="" descr="setitem(a, b, c) -- Same as a[b] = c.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.sub" func="yes">
			<Overload retVal="" descr="sub(a, b) -- Same as a - b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.truediv" func="yes">
			<Overload retVal="" descr="truediv(a, b) -- Same as a / b.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.truth" func="yes">
			<Overload retVal="" descr="truth(a) -- Return True if a is true, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="operator.xor" func="yes">
			<Overload retVal="" descr="xor(a, b) -- Same as a ^ b.">
			</Overload>
		</KeyWord>
		<KeyWord name="optimize" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse" func="yes">
			<Overload retVal="" descr="A powerful, extensible, and easy-to-use option parser.&#10;&#10;By Greg Ward &lt;gward@python.net&gt;&#10;&#10;Originally distributed as Optik.&#10;&#10;For support, use the optik-users@lists.sourceforge.net mailing list&#10;(http://lists.sourceforge.net/lists/listinfo/optik-users).&#10;&#10;Simple usage example:&#10;&#10;   from optparse import OptionParser&#10;&#10;   parser = OptionParser()&#10;   parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;,&#10;                     help=&quot;write report to FILE&quot;, metavar=&quot;FILE&quot;)&#10;   parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;,&#10;                     action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=True,&#10;                     help=&quot;don't print status messages to stdout&quot;)&#10;&#10;   (options, args) = parser.parse_args()">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.AmbiguousOptionError" func="yes">
			<Overload retVal="" descr="Raised if an ambiguous option is seen on the command line.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.AmbiguousOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.AmbiguousOptionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.BadOptionError" func="yes">
			<Overload retVal="" descr="Raised if an invalid option is seen on the command line.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.BadOptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.BadOptionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.HelpFormatter" func="yes">
			<Overload retVal="" descr="Abstract base class for formatting option help.  OptionParser&#10;instances should use one of the HelpFormatter subclasses for&#10;formatting help; by default IndentedHelpFormatter is used.&#10;&#10;Instance attributes:&#10;  parser : OptionParser&#10;    the controlling OptionParser instance&#10;  indent_increment : int&#10;    the number of columns to indent per nesting level&#10;  max_help_position : int&#10;    the maximum starting column for option help text&#10;  help_position : int&#10;    the calculated starting column for option help text;&#10;    initially the same as the maximum&#10;  width : int&#10;    total number of columns for output (pass None to constructor for&#10;    this value to be taken from the $COLUMNS environment variable)&#10;  level : int&#10;    current indentation level&#10;  current_indent : int&#10;    current indentation level (in columns)&#10;  help_width : int&#10;    number of columns available for option help text (calculated)&#10;  default_tag : str&#10;    text to replace with each option's default value, &quot;%default&quot;&#10;    by default.  Set to false value to disable default value expansion.&#10;  option_strings : { Option : str }&#10;    maps Option instances to the snippet of help text explaining&#10;    the syntax of that option, e.g. &quot;-h, --help&quot; or&#10;    &quot;-fFILE, --file=FILE&quot;&#10;  _short_opt_fmt : str&#10;    format string controlling how short options with values are&#10;    printed in help text.  Must be either &quot;%s%s&quot; (&quot;-fFILE&quot;) or&#10;    &quot;%s %s&quot; (&quot;-f FILE&quot;), because those are the two syntaxes that&#10;    Optik supports.&#10;  _long_opt_fmt : str&#10;    similar but for long options; must be either &quot;%s %s&quot; (&quot;--file FILE&quot;)&#10;    or &quot;%s=%s&quot; (&quot;--file=FILE&quot;).">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.HelpFormatter.NO_DEFAULT_VALUE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.HelpFormatter.dedent" />
		<KeyWord name="optparse.HelpFormatter.expand_default" />
		<KeyWord name="optparse.HelpFormatter.format_description" />
		<KeyWord name="optparse.HelpFormatter.format_epilog" />
		<KeyWord name="optparse.HelpFormatter.format_heading" />
		<KeyWord name="optparse.HelpFormatter.format_option" />
		<KeyWord name="optparse.HelpFormatter.format_option_strings" func="yes">
			<Overload retVal="" descr="Return a comma-separated list of option strings &amp; metavariables.">
				<Param name="self" />
				<Param name="option" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.HelpFormatter.format_usage" />
		<KeyWord name="optparse.HelpFormatter.indent" />
		<KeyWord name="optparse.HelpFormatter.set_long_opt_delimiter" />
		<KeyWord name="optparse.HelpFormatter.set_parser" />
		<KeyWord name="optparse.HelpFormatter.set_short_opt_delimiter" />
		<KeyWord name="optparse.HelpFormatter.store_option_strings" />
		<KeyWord name="optparse.IndentedHelpFormatter" func="yes">
			<Overload retVal="" descr="Format help with indented section bodies.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.IndentedHelpFormatter.NO_DEFAULT_VALUE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.IndentedHelpFormatter.dedent" />
		<KeyWord name="optparse.IndentedHelpFormatter.expand_default" />
		<KeyWord name="optparse.IndentedHelpFormatter.format_description" />
		<KeyWord name="optparse.IndentedHelpFormatter.format_epilog" />
		<KeyWord name="optparse.IndentedHelpFormatter.format_heading" />
		<KeyWord name="optparse.IndentedHelpFormatter.format_option" />
		<KeyWord name="optparse.IndentedHelpFormatter.format_option_strings" func="yes">
			<Overload retVal="" descr="Return a comma-separated list of option strings &amp; metavariables.">
				<Param name="self" />
				<Param name="option" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.IndentedHelpFormatter.format_usage" />
		<KeyWord name="optparse.IndentedHelpFormatter.indent" />
		<KeyWord name="optparse.IndentedHelpFormatter.set_long_opt_delimiter" />
		<KeyWord name="optparse.IndentedHelpFormatter.set_parser" />
		<KeyWord name="optparse.IndentedHelpFormatter.set_short_opt_delimiter" />
		<KeyWord name="optparse.IndentedHelpFormatter.store_option_strings" />
		<KeyWord name="optparse.NO_DEFAULT" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptParseError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptParseError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option" func="yes">
			<Overload retVal="" descr="Instance attributes:&#10;  _short_opts : [string]&#10;  _long_opts : [string]&#10;&#10;  action : string&#10;  type : string&#10;  dest : string&#10;  default : any&#10;  nargs : int&#10;  const : any&#10;  choices : [string]&#10;  callback : function&#10;  callback_args : (any*)&#10;  callback_kwargs : { string : any }&#10;  help : string&#10;  metavar : string">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.ALWAYS_TYPED_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.ATTRS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.CHECK_METHODS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.CONST_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.STORE_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.TYPED_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.TYPE_CHECKER" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Option.check_value" />
		<KeyWord name="optparse.Option.convert_value" />
		<KeyWord name="optparse.Option.get_opt_string" />
		<KeyWord name="optparse.Option.process" />
		<KeyWord name="optparse.Option.take_action" />
		<KeyWord name="optparse.Option.takes_value" />
		<KeyWord name="optparse.OptionConflictError" func="yes">
			<Overload retVal="" descr="Raised if conflicting options are added to an OptionParser.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionConflictError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionConflictError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionContainer" func="yes">
			<Overload retVal="" descr='Abstract base class.&#10;&#10;Class attributes:&#10;  standard_option_list : [Option]&#10;    list of standard options that will be accepted by all instances&#10;    of this parser class (intended to be overridden by subclasses).&#10;&#10;Instance attributes:&#10;  option_list : [Option]&#10;    the list of Option objects contained by this OptionContainer&#10;  _short_opt : { string : Option }&#10;    dictionary mapping short option strings, eg. "-f" or "-X",&#10;    to the Option instances that implement them.  If an Option&#10;    has multiple short option strings, it will appear in this&#10;    dictionary multiple times. [1]&#10;  _long_opt : { string : Option }&#10;    dictionary mapping long option strings, eg. "--file" or&#10;    "--exclude", to the Option instances that implement them.&#10;    Again, a given Option can occur multiple times in this&#10;    dictionary. [1]&#10;  defaults : { string : any }&#10;    dictionary mapping option destination names to default&#10;    values for each destination [1]&#10;&#10;[1] These mappings are common to (shared by) all components of the&#10;    controlling OptionParser, where they are initially created.'>
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionContainer.add_option" func="yes">
			<Overload retVal="" descr="add_option(Option)&#10;add_option(opt_str, ..., kwarg=val, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionContainer.add_options" />
		<KeyWord name="optparse.OptionContainer.destroy" func="yes">
			<Overload retVal="" descr="see OptionParser.destroy().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionContainer.format_description" />
		<KeyWord name="optparse.OptionContainer.format_help" />
		<KeyWord name="optparse.OptionContainer.format_option_help" />
		<KeyWord name="optparse.OptionContainer.get_description" />
		<KeyWord name="optparse.OptionContainer.get_option" />
		<KeyWord name="optparse.OptionContainer.has_option" />
		<KeyWord name="optparse.OptionContainer.remove_option" />
		<KeyWord name="optparse.OptionContainer.set_conflict_handler" />
		<KeyWord name="optparse.OptionContainer.set_description" />
		<KeyWord name="optparse.OptionError" func="yes">
			<Overload retVal="" descr="Raised if an Option instance is created with invalid or&#10;inconsistent arguments.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionGroup" func="yes">
			<Overload retVal="" descr='Abstract base class.&#10;&#10;Class attributes:&#10;  standard_option_list : [Option]&#10;    list of standard options that will be accepted by all instances&#10;    of this parser class (intended to be overridden by subclasses).&#10;&#10;Instance attributes:&#10;  option_list : [Option]&#10;    the list of Option objects contained by this OptionContainer&#10;  _short_opt : { string : Option }&#10;    dictionary mapping short option strings, eg. "-f" or "-X",&#10;    to the Option instances that implement them.  If an Option&#10;    has multiple short option strings, it will appear in this&#10;    dictionary multiple times. [1]&#10;  _long_opt : { string : Option }&#10;    dictionary mapping long option strings, eg. "--file" or&#10;    "--exclude", to the Option instances that implement them.&#10;    Again, a given Option can occur multiple times in this&#10;    dictionary. [1]&#10;  defaults : { string : any }&#10;    dictionary mapping option destination names to default&#10;    values for each destination [1]&#10;&#10;[1] These mappings are common to (shared by) all components of the&#10;    controlling OptionParser, where they are initially created.'>
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionGroup.add_option" func="yes">
			<Overload retVal="" descr="add_option(Option)&#10;add_option(opt_str, ..., kwarg=val, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionGroup.add_options" />
		<KeyWord name="optparse.OptionGroup.destroy" func="yes">
			<Overload retVal="" descr="see OptionParser.destroy().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionGroup.format_description" />
		<KeyWord name="optparse.OptionGroup.format_help" />
		<KeyWord name="optparse.OptionGroup.format_option_help" />
		<KeyWord name="optparse.OptionGroup.get_description" />
		<KeyWord name="optparse.OptionGroup.get_option" />
		<KeyWord name="optparse.OptionGroup.has_option" />
		<KeyWord name="optparse.OptionGroup.remove_option" />
		<KeyWord name="optparse.OptionGroup.set_conflict_handler" />
		<KeyWord name="optparse.OptionGroup.set_description" />
		<KeyWord name="optparse.OptionGroup.set_title" />
		<KeyWord name="optparse.OptionParser" func="yes">
			<Overload retVal="" descr="Class attributes:&#10;  standard_option_list : [Option]&#10;    list of standard options that will be accepted by all instances&#10;    of this parser class (intended to be overridden by subclasses).&#10;&#10;Instance attributes:&#10;  usage : string&#10;    a usage string for your program.  Before it is displayed&#10;    to the user, &quot;%prog&quot; will be expanded to the name of&#10;    your program (self.prog or os.path.basename(sys.argv[0])).&#10;  prog : string&#10;    the name of the current program (to override&#10;    os.path.basename(sys.argv[0])).&#10;  description : string&#10;    A paragraph of text giving a brief overview of your program.&#10;    optparse reformats this paragraph to fit the current terminal&#10;    width and prints it when the user requests help (after usage,&#10;    but before the list of options).&#10;  epilog : string&#10;    paragraph of help text to print after option help&#10;&#10;  option_groups : [OptionGroup]&#10;    list of option groups in this parser (option groups are&#10;    irrelevant for parsing the command-line, but very useful&#10;    for generating help)&#10;&#10;  allow_interspersed_args : bool = true&#10;    if true, positional arguments may be interspersed with options.&#10;    Assuming -a and -b each take a single argument, the command-line&#10;      -ablah foo bar -bboo baz&#10;    will be interpreted the same as&#10;      -ablah -bboo -- foo bar baz&#10;    If this flag were false, that command line would be interpreted as&#10;      -ablah -- foo bar -bboo baz&#10;    -- ie. we stop processing options as soon as we see the first&#10;    non-option argument.  (This is the tradition followed by&#10;    Python's getopt module, Perl's Getopt::Std, and other argument-&#10;    parsing libraries, but it is generally annoying to users.)&#10;&#10;  process_default_values : bool = true&#10;    if true, option default values are processed similarly to option&#10;    values from the command line: that is, they are passed to the&#10;    type-checking function for the option's type (as long as the&#10;    default value is a string).  (This really only matters if you&#10;    have defined custom types; see SF bug #955889.)  Set it to false&#10;    to restore the behaviour of Optik 1.4.1 and earlier.&#10;&#10;  rargs : [string]&#10;    the argument list currently being parsed.  Only set when&#10;    parse_args() is active, and continually trimmed down as&#10;    we consume arguments.  Mainly there for the benefit of&#10;    callback options.&#10;  largs : [string]&#10;    the list of leftover arguments that we have skipped while&#10;    parsing options.  If allow_interspersed_args is false, this&#10;    list is always empty.&#10;  values : Values&#10;    the set of option values currently being accumulated.  Only&#10;    set when parse_args() is active.  Also mainly for callbacks.&#10;&#10;Because of the 'rargs', 'largs', and 'values' attributes,&#10;OptionParser is not thread-safe.  If, for some perverse reason, you&#10;need to parse command-line arguments simultaneously in different&#10;threads, use different OptionParser instances.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.add_option" func="yes">
			<Overload retVal="" descr="add_option(Option)&#10;add_option(opt_str, ..., kwarg=val, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.add_option_group" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.add_options" />
		<KeyWord name="optparse.OptionParser.check_values" func="yes">
			<Overload retVal="" descr="check_values(values : Values, args : [string])&#10;-&gt; (values : Values, args : [string])&#10;&#10;Check that the supplied option values and leftover arguments are&#10;valid.  Returns the option values and leftover arguments&#10;(possibly adjusted, possibly completely new -- whatever you&#10;like).  Default implementation just returns the passed-in&#10;values; subclasses may override as desired.">
				<Param name="self" />
				<Param name="values" />
				<Param name="args" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.destroy" func="yes">
			<Overload retVal="" descr="Declare that you are done with this OptionParser.  This cleans up&#10;reference cycles so the OptionParser (and all objects referenced by&#10;it) can be garbage-collected promptly.  After calling destroy(), the&#10;OptionParser is unusable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.disable_interspersed_args" func="yes">
			<Overload retVal="" descr="Set parsing to stop on the first non-option. Use this if&#10;you have a command processor which runs another command that&#10;has options of its own and you want to make sure these options&#10;don't get confused.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.enable_interspersed_args" func="yes">
			<Overload retVal="" descr="Set parsing to not stop on the first non-option, allowing&#10;interspersing switches with command arguments. This is the&#10;default behavior. See also disable_interspersed_args() and the&#10;class documentation description of the attribute&#10;allow_interspersed_args.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.error" func="yes">
			<Overload retVal="" descr="error(msg : string)&#10;&#10;Print a usage message incorporating 'msg' to stderr and exit.&#10;If you override this in a subclass, it should not return -- it&#10;should either exit or raise an exception.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.exit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[status=0" />
				<Param name="[msg=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.expand_prog_name" />
		<KeyWord name="optparse.OptionParser.format_description" />
		<KeyWord name="optparse.OptionParser.format_epilog" />
		<KeyWord name="optparse.OptionParser.format_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[formatter=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.format_option_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[formatter=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.get_default_values" />
		<KeyWord name="optparse.OptionParser.get_description" />
		<KeyWord name="optparse.OptionParser.get_option" />
		<KeyWord name="optparse.OptionParser.get_option_group" />
		<KeyWord name="optparse.OptionParser.get_prog_name" />
		<KeyWord name="optparse.OptionParser.get_usage" />
		<KeyWord name="optparse.OptionParser.get_version" />
		<KeyWord name="optparse.OptionParser.has_option" />
		<KeyWord name="optparse.OptionParser.parse_args" func="yes">
			<Overload retVal="" descr="parse_args(args : [string] = sys.argv[1:],&#10;           values : Values = None)&#10;-&gt; (values : Values, args : [string])&#10;&#10;Parse the command-line options found in 'args' (default:&#10;sys.argv[1:]).  Any errors result in a call to 'error()', which&#10;by default prints the usage message to stderr and calls&#10;sys.exit() with an error message.  On success returns a pair&#10;(values, args) where 'values' is a Values instance (with all&#10;your option values) and 'args' is the list of arguments left&#10;over after parsing options.">
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[values=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.print_help" func="yes">
			<Overload retVal="" descr="print_help(file : file = stdout)&#10;&#10;Print an extended help message, listing all options and any&#10;help text provided with them, to 'file' (default stdout).">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.print_usage" func="yes">
			<Overload retVal="" descr="print_usage(file : file = stdout)&#10;&#10;Print the usage message for the current program (self.usage) to&#10;'file' (default stdout).  Any occurrence of the string &quot;%prog&quot; in&#10;self.usage is replaced with the name of the current program&#10;(basename of sys.argv[0]).  Does nothing if self.usage is empty&#10;or not defined.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.print_version" func="yes">
			<Overload retVal="" descr="print_version(file : file = stdout)&#10;&#10;Print the version message for this program (self.version) to&#10;'file' (default stdout).  As with print_usage(), any occurrence&#10;of &quot;%prog&quot; in self.version is replaced by the current program's&#10;name.  Does nothing if self.version is empty or undefined.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.remove_option" />
		<KeyWord name="optparse.OptionParser.set_conflict_handler" />
		<KeyWord name="optparse.OptionParser.set_default" />
		<KeyWord name="optparse.OptionParser.set_defaults" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionParser.set_description" />
		<KeyWord name="optparse.OptionParser.set_process_default_values" />
		<KeyWord name="optparse.OptionParser.set_usage" />
		<KeyWord name="optparse.OptionValueError" func="yes">
			<Overload retVal="" descr="Raised if an invalid option value is encountered on the command&#10;line.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionValueError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.OptionValueError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.SUPPRESS_HELP" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.SUPPRESS_USAGE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.TitledHelpFormatter" func="yes">
			<Overload retVal="" descr="Format help with underlined section headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.TitledHelpFormatter.NO_DEFAULT_VALUE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.TitledHelpFormatter.dedent" />
		<KeyWord name="optparse.TitledHelpFormatter.expand_default" />
		<KeyWord name="optparse.TitledHelpFormatter.format_description" />
		<KeyWord name="optparse.TitledHelpFormatter.format_epilog" />
		<KeyWord name="optparse.TitledHelpFormatter.format_heading" />
		<KeyWord name="optparse.TitledHelpFormatter.format_option" />
		<KeyWord name="optparse.TitledHelpFormatter.format_option_strings" func="yes">
			<Overload retVal="" descr="Return a comma-separated list of option strings &amp; metavariables.">
				<Param name="self" />
				<Param name="option" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.TitledHelpFormatter.format_usage" />
		<KeyWord name="optparse.TitledHelpFormatter.indent" />
		<KeyWord name="optparse.TitledHelpFormatter.set_long_opt_delimiter" />
		<KeyWord name="optparse.TitledHelpFormatter.set_parser" />
		<KeyWord name="optparse.TitledHelpFormatter.set_short_opt_delimiter" />
		<KeyWord name="optparse.TitledHelpFormatter.store_option_strings" />
		<KeyWord name="optparse.Values" />
		<KeyWord name="optparse.Values.ensure_value" />
		<KeyWord name="optparse.Values.read_file" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="filename" />
				<Param name="[mode=careful]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.Values.read_module" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="modname" />
				<Param name="[mode=careful]" />
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.check_builtin" />
		<KeyWord name="optparse.check_choice" />
		<KeyWord name="optparse.gettext" />
		<KeyWord name="optparse.make_option" func="yes">
			<Overload retVal="" descr="Instance attributes:&#10;  _short_opts : [string]&#10;  _long_opts : [string]&#10;&#10;  action : string&#10;  type : string&#10;  dest : string&#10;  default : any&#10;  nargs : int&#10;  const : any&#10;  choices : [string]&#10;  callback : function&#10;  callback_args : (any*)&#10;  callback_kwargs : { string : any }&#10;  help : string&#10;  metavar : string">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.ALWAYS_TYPED_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.ATTRS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.CHECK_METHODS" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.CONST_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.STORE_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.TYPED_ACTIONS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.TYPE_CHECKER" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="optparse.make_option.check_value" />
		<KeyWord name="optparse.make_option.convert_value" />
		<KeyWord name="optparse.make_option.get_opt_string" />
		<KeyWord name="optparse.make_option.process" />
		<KeyWord name="optparse.make_option.take_action" />
		<KeyWord name="optparse.make_option.takes_value" />
		<KeyWord name="optparse.ngettext" />
		<KeyWord name="or" />
		<KeyWord name="ord" func="yes">
			<Overload retVal="" descr="Return the Unicode code point for a one-character string.">
				<Param name="c" />
			</Overload>
		</KeyWord>
		<KeyWord name="os" func="yes">
			<Overload retVal="" descr="OS routines for NT or Posix depending on what system we're on.&#10;&#10;This exports:&#10;  - all functions from posix or nt, e.g. unlink, stat, etc.&#10;  - os.path is either posixpath or ntpath&#10;  - os.name is either 'posix' or 'nt'&#10;  - os.curdir is a string representing the current directory (always '.')&#10;  - os.pardir is a string representing the parent directory (always '..')&#10;  - os.sep is the (or a most common) pathname separator ('/' or '\\')&#10;  - os.extsep is the extension separator (always '.')&#10;  - os.altsep is the alternate pathname separator (None or '/')&#10;  - os.pathsep is the component separator used in $PATH etc&#10;  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')&#10;  - os.defpath is the default search path for executables&#10;  - os.devnull is the file path of the null device ('/dev/null', etc.)&#10;&#10;Programs that import and use 'os' stand a better chance of being&#10;portable between different platforms.  Of course, they must then&#10;only use functions that are defined by all platforms (e.g., unlink&#10;and opendir), and leave all pathname manipulation to os.path&#10;(e.g., split and join).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry" />
		<KeyWord name="os.DirEntry.inode" func="yes">
			<Overload retVal="" descr="return inode of the entry; cached per entry">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry.is_dir" func="yes">
			<Overload retVal="" descr="return True if the entry is a directory; cached per entry">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry.is_file" func="yes">
			<Overload retVal="" descr="return True if the entry is a file; cached per entry">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry.is_symlink" func="yes">
			<Overload retVal="" descr="return True if the entry is a symbolic link; cached per entry">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry.path" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.DirEntry.stat" func="yes">
			<Overload retVal="" descr="return stat_result object for the entry; cached per entry">
			</Overload>
		</KeyWord>
		<KeyWord name="os.MutableMapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_BINARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_CREAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_EXCL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_NOINHERIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_RANDOM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_RDWR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_SEQUENTIAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_SHORT_LIVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_TEMPORARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_TEXT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_TRUNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.O_WRONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_DETACH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_NOWAIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_NOWAITO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.P_OVERLAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.PathLike" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.R_OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.SEEK_CUR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.SEEK_END" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.TMP_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.W_OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.X_OK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.abort" func="yes">
			<Overload retVal="" descr="Abort the interpreter immediately.&#10;&#10;This function 'dumps core' or otherwise fails in the hardest way possible&#10;on the hosting operating system.  This function never returns.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.access" func="yes">
			<Overload retVal="" descr="Use the real uid/gid to test for access to a path.&#10;&#10;  path&#10;    Path to be tested; can be string or bytes&#10;  mode&#10;    Operating-system mode bitfield.  Can be F_OK to test existence,&#10;    or the inclusive-OR of R_OK, W_OK, and X_OK.&#10;  dir_fd&#10;    If not None, it should be a file descriptor open to a directory,&#10;    and path should be relative; path will then be relative to that&#10;    directory.&#10;  effective_ids&#10;    If True, access will use the effective uid/gid instead of&#10;    the real uid/gid.&#10;  follow_symlinks&#10;    If False, and the last element of the path is a symbolic link,&#10;    access will examine the symbolic link itself instead of the file&#10;    the link points to.&#10;&#10;dir_fd, effective_ids, and follow_symlinks may not be implemented&#10;  on your platform.  If they are unavailable, using them will raise a&#10;  NotImplementedError.&#10;&#10;Note that most operations will use the effective uid/gid, therefore this&#10;  routine can be used in a suid/sgid environment to test if the invoking user&#10;  has the specified access to the path.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.altsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.chdir" func="yes">
			<Overload retVal="" descr="Change the current working directory to the specified path.&#10;&#10;path may always be specified as a string.&#10;On some platforms, path may also be specified as an open file descriptor.&#10;  If this functionality is unavailable, using it raises an exception.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.chmod" func="yes">
			<Overload retVal="" descr="Change the access permissions of a file.&#10;&#10;  path&#10;    Path to be modified.  May always be specified as a str or bytes.&#10;    On some platforms, path may also be specified as an open file descriptor.&#10;    If this functionality is unavailable, using it raises an exception.&#10;  mode&#10;    Operating-system mode bitfield.&#10;  dir_fd&#10;    If not None, it should be a file descriptor open to a directory,&#10;    and path should be relative; path will then be relative to that&#10;    directory.&#10;  follow_symlinks&#10;    If False, and the last element of the path is a symbolic link,&#10;    chmod will modify the symbolic link itself instead of the file&#10;    the link points to.&#10;&#10;It is an error to use dir_fd or follow_symlinks when specifying path as&#10;  an open file descriptor.&#10;dir_fd and follow_symlinks may not be implemented on your platform.&#10;  If they are unavailable, using them will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.close" func="yes">
			<Overload retVal="" descr="Close a file descriptor.">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.closerange" func="yes">
			<Overload retVal="" descr="Closes all file descriptors in [fd_low, fd_high), ignoring errors.">
				<Param name="fd_low" />
				<Param name="fd_high" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.cpu_count" func="yes">
			<Overload retVal="" descr="Return the number of CPUs in the system; return None if indeterminable.&#10;&#10;This number is not equivalent to the number of CPUs the current process can&#10;use.  The number of usable CPUs can be obtained with&#10;``len(os.sched_getaffinity(0))``">
			</Overload>
		</KeyWord>
		<KeyWord name="os.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.device_encoding" func="yes">
			<Overload retVal="" descr="Return a string describing the encoding of a terminal's file descriptor.&#10;&#10;The file descriptor must be attached to a terminal.&#10;If the device is not a terminal, return None.">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.dup" func="yes">
			<Overload retVal="" descr="Return a duplicate of a file descriptor.">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.dup2" func="yes">
			<Overload retVal="" descr="Duplicate file descriptor.">
				<Param name="fd" />
				<Param name="fd2" />
				<Param name="[inheritable=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.environ" func="yes">
			<Overload retVal="" descr="(_Environ)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.execl" func="yes">
			<Overload retVal="" descr="execl(file, *args)&#10;&#10;Execute the executable file with argument list args, replacing the&#10;current process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execle" func="yes">
			<Overload retVal="" descr="execle(file, *args, env)&#10;&#10;Execute the executable file with argument list args and&#10;environment env, replacing the current process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execlp" func="yes">
			<Overload retVal="" descr="execlp(file, *args)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args, replacing the current process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execlpe" func="yes">
			<Overload retVal="" descr="execlpe(file, *args, env)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args and environment env, replacing the current&#10;process.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execv" func="yes">
			<Overload retVal="" descr="Execute an executable path with arguments, replacing current process.&#10;&#10;path&#10;  Path of executable file.&#10;argv&#10;  Tuple or list of strings.">
				<Param name="path" />
				<Param name="argv" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execve" func="yes">
			<Overload retVal="" descr="Execute an executable path with arguments, replacing current process.&#10;&#10;path&#10;  Path of executable file.&#10;argv&#10;  Tuple or list of strings.&#10;env&#10;  Dictionary of strings mapping to strings.">
				<Param name="path" />
				<Param name="argv" />
				<Param name="env" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execvp" func="yes">
			<Overload retVal="" descr="execvp(file, args)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args, replacing the current process.&#10;args may be a list or tuple of strings.">
				<Param name="file" />
				<Param name="args" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.execvpe" func="yes">
			<Overload retVal="" descr="execvpe(file, args, env)&#10;&#10;Execute the executable file (which is searched for along $PATH)&#10;with argument list args and environment env , replacing the&#10;current process.&#10;args may be a list or tuple of strings.">
				<Param name="file" />
				<Param name="args" />
				<Param name="env" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.fdopen" func="yes">
			<Overload retVal="" descr=>
				<Param name="fd" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.fsdecode" func="yes">
			<Overload retVal="" descr="Decode filename (an os.PathLike, bytes, or str) from the filesystem&#10;encoding with 'surrogateescape' error handler, return str unchanged. On&#10;Windows, use 'strict' error handler if the file system encoding is&#10;'mbcs' (which is the default encoding).">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.fsencode" func="yes">
			<Overload retVal="" descr="Encode filename (an os.PathLike, bytes, or str) to the filesystem&#10;encoding with 'surrogateescape' error handler, return bytes unchanged.&#10;On Windows, use 'strict' error handler if the file system encoding is&#10;'mbcs' (which is the default encoding).">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.fspath" func="yes">
			<Overload retVal="" descr="Return the file system path representation of the object.&#10;&#10;If the object is str or bytes, then allow it to pass through as-is. If the&#10;object defines __fspath__(), then return the result of that method. All other&#10;types raise a TypeError.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.fstat" func="yes">
			<Overload retVal="" descr="Perform a stat system call on the given file descriptor.&#10;&#10;Like stat(), but for an open file descriptor.&#10;Equivalent to os.stat(fd).">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.fsync" func="yes">
			<Overload retVal="" descr="Force write of fd to disk.">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.ftruncate" func="yes">
			<Overload retVal="" descr="Truncate a file, specified by file descriptor, to a specific length.">
				<Param name="fd" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.get_exec_path" func="yes">
			<Overload retVal="" descr="Returns the sequence of directories that will be searched for the&#10;named executable (similar to a shell) when launching a process.&#10;&#10;*env* must be an environment variable dict or None.  If *env* is None,&#10;os.environ will be used.">
				<Param name="[env=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.get_handle_inheritable" func="yes">
			<Overload retVal="" descr="Get the close-on-exe flag of the specified file descriptor.">
				<Param name="handle" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.get_inheritable" func="yes">
			<Overload retVal="" descr="Get the close-on-exe flag of the specified file descriptor.">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.get_terminal_size" func="yes">
			<Overload retVal="" descr="Return the size of the terminal window as (columns, lines).&#10;&#10;The optional argument fd (default standard output) specifies&#10;which file descriptor should be queried.&#10;&#10;If the file descriptor is not connected to a terminal, an OSError&#10;is thrown.&#10;&#10;This function will only be defined if an implementation is&#10;available for this system.&#10;&#10;shutil.get_terminal_size is the high-level function which should &#10;normally be used, os.get_terminal_size is the low-level implementation.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getcwd" func="yes">
			<Overload retVal="" descr="Return a unicode string representing the current working directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getcwdb" func="yes">
			<Overload retVal="" descr="Return a bytes string representing the current working directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getenv" func="yes">
			<Overload retVal="" descr="Get an environment variable, return None if it doesn't exist.&#10;The optional second argument can specify an alternate default.&#10;key, default and the result are str.">
				<Param name="key" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.getlogin" func="yes">
			<Overload retVal="" descr="Return the actual login name.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getpid" func="yes">
			<Overload retVal="" descr="Return the current process id.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.getppid" func="yes">
			<Overload retVal="" descr="Return the parent's process id.&#10;&#10;If the parent process has already exited, Windows machines will still&#10;return its id; others systems will return the id of the 'init' process (1).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.isatty" func="yes">
			<Overload retVal="" descr="Return True if the fd is connected to a terminal.&#10;&#10;Return True if the file descriptor is an open file descriptor&#10;connected to the slave end of a terminal.">
				<Param name="fd" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.kill" func="yes">
			<Overload retVal="" descr="Kill a process with a signal.">
				<Param name="pid" />
				<Param name="signal" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.linesep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.link" func="yes">
			<Overload retVal="" descr="Create a hard link to a file.&#10;&#10;If either src_dir_fd or dst_dir_fd is not None, it should be a file&#10;  descriptor open to a directory, and the respective path string (src or dst)&#10;  should be relative; the path will then be relative to that directory.&#10;If follow_symlinks is False, and the last element of src is a symbolic&#10;  link, link will create a link to the symbolic link itself instead of the&#10;  file the link points to.&#10;src_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your&#10;  platform.  If they are unavailable, using them will raise a&#10;  NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.listdir" func="yes">
			<Overload retVal="" descr="Return a list containing the names of the files in the directory.&#10;&#10;path can be specified as either str or bytes.  If path is bytes,&#10;  the filenames returned will also be bytes; in all other circumstances&#10;  the filenames returned will be str.&#10;If path is None, uses the path='.'.&#10;On some platforms, path may also be specified as an open file descriptor;\&#10;  the file descriptor must refer to a directory.&#10;  If this functionality is unavailable, using it raises NotImplementedError.&#10;&#10;The list is in arbitrary order.  It does not include the special&#10;entries '.' and '..' even if they are present in the directory.">
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.lseek" func="yes">
			<Overload retVal="" descr="Set the position of a file descriptor.  Return the new position.&#10;&#10;Return the new cursor position in number of bytes&#10;relative to the beginning of the file.">
				<Param name="fd" />
				<Param name="position" />
				<Param name="how" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.lstat" func="yes">
			<Overload retVal="" descr="Perform a stat system call on the given path, without following symbolic links.&#10;&#10;Like stat(), but do not follow symbolic links.&#10;Equivalent to stat(path, follow_symlinks=False).">
			</Overload>
		</KeyWord>
		<KeyWord name="os.makedirs" func="yes">
			<Overload retVal="" descr="makedirs(name [, mode=0o777][, exist_ok=False])&#10;&#10;Super-mkdir; create a leaf directory and all intermediate ones.  Works like&#10;mkdir, except that any intermediate path segment (not just the rightmost)&#10;will be created if it does not exist. If the target directory already&#10;exists, raise an OSError if exist_ok is False. Otherwise no exception is&#10;raised.  This is recursive.">
				<Param name="name" />
				<Param name="[mode=511" />
				<Param name="[exist_ok=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.mkdir" func="yes">
			<Overload retVal="" descr="Create a directory.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.&#10;&#10;The mode argument is ignored on Windows.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.open" func="yes">
			<Overload retVal="" descr="Open a file for low level IO.  Returns a file descriptor (integer).&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.pipe" func="yes">
			<Overload retVal="" descr="Create a pipe.&#10;&#10;Returns a tuple of two file descriptors:&#10;  (read_fd, write_fd)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.popen" func="yes">
			<Overload retVal="" descr=>
				<Param name="cmd" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.putenv" func="yes">
			<Overload retVal="" descr="Change or add an environment variable.">
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.read" func="yes">
			<Overload retVal="" descr="Read from a file descriptor.  Returns a bytes object.">
				<Param name="fd" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.readlink" func="yes">
			<Overload retVal="" descr="readlink(path, *, dir_fd=None) -&gt; path&#10;&#10;Return a string representing the path to which the symbolic link points.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.remove" func="yes">
			<Overload retVal="" descr="Remove a file (same as unlink()).&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.removedirs" func="yes">
			<Overload retVal="" descr="removedirs(name)&#10;&#10;Super-rmdir; remove a leaf directory and all empty intermediate&#10;ones.  Works like rmdir except that, if the leaf directory is&#10;successfully removed, directories corresponding to rightmost path&#10;segments will be pruned away until either the whole path is&#10;consumed or an error occurs.  Errors during this latter phase are&#10;ignored -- they generally mean that a directory was not empty.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.rename" func="yes">
			<Overload retVal="" descr="Rename a file or directory.&#10;&#10;If either src_dir_fd or dst_dir_fd is not None, it should be a file&#10;  descriptor open to a directory, and the respective path string (src or dst)&#10;  should be relative; the path will then be relative to that directory.&#10;src_dir_fd and dst_dir_fd, may not be implemented on your platform.&#10;  If they are unavailable, using them will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.renames" func="yes">
			<Overload retVal="" descr="renames(old, new)&#10;&#10;Super-rename; create directories as necessary and delete any left&#10;empty.  Works like rename, except creation of any intermediate&#10;directories needed to make the new pathname good is attempted&#10;first.  After the rename, directories corresponding to rightmost&#10;path segments of the old name will be pruned until either the&#10;whole path is consumed or a nonempty directory is found.&#10;&#10;Note: this function can fail with the new directory structure made&#10;if you lack permissions needed to unlink the leaf directory or&#10;file.">
				<Param name="old" />
				<Param name="new" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.replace" func="yes">
			<Overload retVal="" descr='Rename a file or directory, overwriting the destination.&#10;&#10;If either src_dir_fd or dst_dir_fd is not None, it should be a file&#10;  descriptor open to a directory, and the respective path string (src or dst)&#10;  should be relative; the path will then be relative to that directory.&#10;src_dir_fd and dst_dir_fd, may not be implemented on your platform.&#10;  If they are unavailable, using them will raise a NotImplementedError."'>
			</Overload>
		</KeyWord>
		<KeyWord name="os.rmdir" func="yes">
			<Overload retVal="" descr="Remove a directory.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.scandir" func="yes">
			<Overload retVal="" descr="scandir(path='.') -&gt; iterator of DirEntry objects for given path">
			</Overload>
		</KeyWord>
		<KeyWord name="os.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.set_handle_inheritable" func="yes">
			<Overload retVal="" descr="Set the inheritable flag of the specified handle.">
				<Param name="handle" />
				<Param name="inheritable" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.set_inheritable" func="yes">
			<Overload retVal="" descr="Set the inheritable flag of the specified file descriptor.">
				<Param name="fd" />
				<Param name="inheritable" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnl" func="yes">
			<Overload retVal="" descr="spawnl(mode, file, *args) -&gt; integer&#10;&#10;Execute file with arguments from args in a subprocess.&#10;If mode == P_NOWAIT return the pid of the process.&#10;If mode == P_WAIT return the process's exit code if it exits normally;&#10;otherwise return -SIG, where SIG is the signal that killed it.">
				<Param name="mode" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnle" func="yes">
			<Overload retVal="" descr="spawnle(mode, file, *args, env) -&gt; integer&#10;&#10;Execute file with arguments from args in a subprocess with the&#10;supplied environment.&#10;If mode == P_NOWAIT return the pid of the process.&#10;If mode == P_WAIT return the process's exit code if it exits normally;&#10;otherwise return -SIG, where SIG is the signal that killed it.">
				<Param name="mode" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnv" func="yes">
			<Overload retVal="" descr="Execute the program specified by path in a new process.&#10;&#10;mode&#10;  Mode of process creation.&#10;path&#10;  Path of executable file.&#10;argv&#10;  Tuple or list of strings.">
				<Param name="mode" />
				<Param name="path" />
				<Param name="argv" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.spawnve" func="yes">
			<Overload retVal="" descr="Execute the program specified by path in a new process.&#10;&#10;mode&#10;  Mode of process creation.&#10;path&#10;  Path of executable file.&#10;argv&#10;  Tuple or list of strings.&#10;env&#10;  Dictionary of strings mapping to strings.">
				<Param name="mode" />
				<Param name="path" />
				<Param name="argv" />
				<Param name="env" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.startfile" func="yes">
			<Overload retVal="" descr="startfile(filepath [, operation])&#10;&#10;Start a file with its associated application.&#10;&#10;When &quot;operation&quot; is not specified or &quot;open&quot;, this acts like&#10;double-clicking the file in Explorer, or giving the file name as an&#10;argument to the DOS &quot;start&quot; command: the file is opened with whatever&#10;application (if any) its extension is associated.&#10;When another &quot;operation&quot; is given, it specifies what should be done with&#10;the file.  A typical operation is &quot;print&quot;.&#10;&#10;startfile returns as soon as the associated application is launched.&#10;There is no option to wait for the application to close, and no way&#10;to retrieve the application's exit status.&#10;&#10;The filepath is relative to the current directory.  If you want to use&#10;an absolute path, make sure the first character is not a slash (&quot;/&quot;);&#10;the underlying Win32 ShellExecute function doesn't work if it is.">
				<Param name="filepath" />
				<Param name="[operation=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat" func="yes">
			<Overload retVal="" descr="Perform a stat system call on the given path.&#10;&#10;  path&#10;    Path to be examined; can be string, bytes, path-like object or&#10;    open-file-descriptor int.&#10;  dir_fd&#10;    If not None, it should be a file descriptor open to a directory,&#10;    and path should be a relative string; path will then be relative to&#10;    that directory.&#10;  follow_symlinks&#10;    If False, and the last element of the path is a symbolic link,&#10;    stat will examine the symbolic link itself instead of the file&#10;    the link points to.&#10;&#10;dir_fd and follow_symlinks may not be implemented&#10;  on your platform.  If they are unavailable, using them will raise a&#10;  NotImplementedError.&#10;&#10;It's an error to use dir_fd or follow_symlinks when specifying path as&#10;  an open file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_float_times" func="yes">
			<Overload retVal="" descr="stat_float_times([newval]) -&gt; oldval&#10;&#10;Determine whether os.[lf]stat represents time stamps as float objects.&#10;&#10;If value is True, future calls to stat() return floats; if it is False,&#10;future calls return ints.&#10;If value is omitted, return the current setting.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result" func="yes">
			<Overload retVal="" descr="stat_result: Result from stat, fstat, or lstat.&#10;&#10;This object may be accessed either as a tuple of&#10;  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)&#10;or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.&#10;&#10;Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,&#10;or st_flags, they are available as attributes only.&#10;&#10;See os.stat for more information.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.n_unnamed_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_atime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_atime_ns" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_ctime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_ctime_ns" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_dev" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_file_attributes" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_gid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_ino" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_mtime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_mtime_ns" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_nlink" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.stat_result.st_uid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result" func="yes">
			<Overload retVal="" descr="statvfs_result: Result from statvfs or fstatvfs.&#10;&#10;This object may be accessed either as a tuple of&#10;  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),&#10;or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.&#10;&#10;See os.statvfs for more information.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_bavail" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_bfree" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_blocks" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_bsize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_favail" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_ffree" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_files" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_flag" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_frsize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.f_namemax" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.statvfs_result.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.strerror" func="yes">
			<Overload retVal="" descr="Translate an error code to a message string.">
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.supports_fd" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.supports_follow_symlinks" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.symlink" func="yes">
			<Overload retVal="" descr="Create a symbolic link pointing to src named dst.&#10;&#10;target_is_directory is required on Windows if the target is to be&#10;  interpreted as a directory.  (On Windows, symlink requires&#10;  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)&#10;  target_is_directory is ignored on non-Windows platforms.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.system" func="yes">
			<Overload retVal="" descr="Execute the command in a subshell.">
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size" func="yes">
			<Overload retVal="" descr="A tuple of (columns, lines) for holding terminal window size">
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size.columns" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size.lines" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.terminal_size.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times" func="yes">
			<Overload retVal="" descr="Return a collection containing process timing information.&#10;&#10;The object returned behaves like a named tuple with these fields:&#10;  (utime, stime, cutime, cstime, elapsed_time)&#10;All fields are floating point numbers.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result" func="yes">
			<Overload retVal="" descr="times_result: Result from os.times().&#10;&#10;This object may be accessed either as a tuple of&#10;  (user, system, children_user, children_system, elapsed),&#10;or via the attributes user, system, children_user, children_system,&#10;and elapsed.&#10;&#10;See os.times for more information.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.children_system" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.children_user" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.elapsed" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.system" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.times_result.user" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.truncate" func="yes">
			<Overload retVal="" descr="Truncate a file, specified by path, to a specific length.&#10;&#10;On some platforms, path may also be specified as an open file descriptor.&#10;  If this functionality is unavailable, using it raises an exception.">
				<Param name="path" />
				<Param name="length" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.umask" func="yes">
			<Overload retVal="" descr="Set the current numeric umask and return the previous umask.">
				<Param name="mask" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result" func="yes">
			<Overload retVal="" descr="uname_result: Result from os.uname().&#10;&#10;This object may be accessed either as a tuple of&#10;  (sysname, nodename, release, version, machine),&#10;or via the attributes sysname, nodename, release, version, and machine.&#10;&#10;See os.uname for more information.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.machine" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.n_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.n_sequence_fields" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.nodename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.release" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.sysname" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.uname_result.version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="os.unlink" func="yes">
			<Overload retVal="" descr="Remove a file (same as remove()).&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.urandom" func="yes">
			<Overload retVal="" descr="Return a bytes object containing random bytes suitable for cryptographic use.">
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.utime" func="yes">
			<Overload retVal="" descr="Set the access and modified time of path.&#10;&#10;path may always be specified as a string.&#10;On some platforms, path may also be specified as an open file descriptor.&#10;  If this functionality is unavailable, using it raises an exception.&#10;&#10;If times is not None, it must be a tuple (atime, mtime);&#10;    atime and mtime should be expressed as float seconds since the epoch.&#10;If ns is specified, it must be a tuple (atime_ns, mtime_ns);&#10;    atime_ns and mtime_ns should be expressed as integer nanoseconds&#10;    since the epoch.&#10;If times is None and ns is unspecified, utime uses the current time.&#10;Specifying tuples for both times and ns is an error.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;If follow_symlinks is False, and the last element of the path is a symbolic&#10;  link, utime will modify the symbolic link itself instead of the file the&#10;  link points to.&#10;It is an error to use dir_fd or follow_symlinks when specifying path&#10;  as an open file descriptor.&#10;dir_fd and follow_symlinks may not be available on your platform.&#10;  If they are unavailable, using them will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="os.waitpid" func="yes">
			<Overload retVal="" descr="Wait for completion of a given process.&#10;&#10;Returns a tuple of information regarding the process:&#10;    (pid, status &lt;&lt; 8)&#10;&#10;The options argument is ignored on Windows.">
				<Param name="pid" />
				<Param name="options" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.walk" func="yes">
			<Overload retVal="" descr="Directory tree generator.&#10;&#10;For each directory in the directory tree rooted at top (including top&#10;itself, but excluding '.' and '..'), yields a 3-tuple&#10;&#10;    dirpath, dirnames, filenames&#10;&#10;dirpath is a string, the path to the directory.  dirnames is a list of&#10;the names of the subdirectories in dirpath (excluding '.' and '..').&#10;filenames is a list of the names of the non-directory files in dirpath.&#10;Note that the names in the lists are just names, with no path components.&#10;To get a full path (which begins with top) to a file or directory in&#10;dirpath, do os.path.join(dirpath, name).&#10;&#10;If optional arg 'topdown' is true or not specified, the triple for a&#10;directory is generated before the triples for any of its subdirectories&#10;(directories are generated top down).  If topdown is false, the triple&#10;for a directory is generated after the triples for all of its&#10;subdirectories (directories are generated bottom up).&#10;&#10;When topdown is true, the caller can modify the dirnames list in-place&#10;(e.g., via del or slice assignment), and walk will only recurse into the&#10;subdirectories whose names remain in dirnames; this can be used to prune the&#10;search, or to impose a specific order of visiting.  Modifying dirnames when&#10;topdown is false is ineffective, since the directories in dirnames have&#10;already been generated by the time dirnames itself is generated. No matter&#10;the value of topdown, the list of subdirectories is retrieved before the&#10;tuples for the directory and its subdirectories are generated.&#10;&#10;By default errors from the os.scandir() call are ignored.  If&#10;optional arg 'onerror' is specified, it should be a function; it&#10;will be called with one argument, an OSError instance.  It can&#10;report the error to continue with the walk, or raise the exception&#10;to abort the walk.  Note that the filename is available as the&#10;filename attribute of the exception object.&#10;&#10;By default, os.walk does not follow symbolic links to subdirectories on&#10;systems that support them.  In order to get this functionality, set the&#10;optional argument 'followlinks' to true.&#10;&#10;Caution:  if you pass a relative pathname for top, don't change the&#10;current working directory between resumptions of walk.  walk never&#10;changes the current directory, and assumes that the client doesn't&#10;either.&#10;&#10;Example:&#10;&#10;import os&#10;from os.path import join, getsize&#10;for root, dirs, files in os.walk('python/Lib/email'):&#10;    print(root, &quot;consumes&quot;, end=&quot;&quot;)&#10;    print(sum([getsize(join(root, name)) for name in files]), end=&quot;&quot;)&#10;    print(&quot;bytes in&quot;, len(files), &quot;non-directory files&quot;)&#10;    if 'CVS' in dirs:&#10;        dirs.remove('CVS')  # don't visit CVS directories">
				<Param name="top" />
				<Param name="[topdown=True" />
				<Param name="[onerror=None" />
				<Param name="[followlinks=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="os.write" func="yes">
			<Overload retVal="" descr="Write a bytes object to a file descriptor.">
				<Param name="fd" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="os_open" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="output_charset" func="yes">
			<Overload retVal="" descr="Function of gettext.GNUTranslations">
			</Overload>
		</KeyWord>
		<KeyWord name="output_difference" func="yes">
			<Overload retVal="" descr="Function of doctest.OutputChecker">
			</Overload>
		</KeyWord>
		<KeyWord name="over" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="overlaps" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="overload" func="yes">
			<Overload retVal="" descr="Function of typing">
			</Overload>
		</KeyWord>
		<KeyWord name="owner" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="pack" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_array" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_bool" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_bytes" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_double" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_enum" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_farray" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_float" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_fopaque" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_fstring" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_hyper" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_int" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_into" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_list" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_opaque" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_string" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_uhyper" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="pack_uint" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Packer">
			</Overload>
		</KeyWord>
		<KeyWord name="page" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="pager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="paretovariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="parse" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="parse150" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse227" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse229" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parse257" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="parseArgs" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_args" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_command_line" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_config_files" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_config_h" func="yes">
			<Overload retVal="" descr="Function of sysconfig">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_group" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EntryPoint">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_header" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_known_args" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_map" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.EntryPoint">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_multipart" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_qs" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_qsl" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_requirements" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_template" func="yes">
			<Overload retVal="" descr="Function of sre_parse">
			</Overload>
		</KeyWord>
		<KeyWord name="parse_version" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="parseargs" func="yes">
			<Overload retVal="" descr="Function of smtpd">
			</Overload>
		</KeyWord>
		<KeyWord name="parsefield" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="parseline" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="parseopts" func="yes">
			<Overload retVal="" descr="Function of pip">
			</Overload>
		</KeyWord>
		<KeyWord name="partial" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="pass" />
		<KeyWord name="patch_missing_pkg_info" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="pathdirs" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib" />
		<KeyWord name="pathlib.EINVAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.ENOENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.ENOTDIR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path" func="yes">
			<Overload retVal="" descr="PurePath represents a filesystem path and offers operations which&#10;don't imply any actual filesystem I/O.  Depending on your system,&#10;instantiating a PurePath will return either a PurePosixPath or a&#10;PureWindowsPath object.  You can also instantiate either of these classes&#10;directly, regardless of your system.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.absolute" func="yes">
			<Overload retVal="" descr="Return an absolute version of this path.  This function works&#10;even if the path doesn't point to anything.&#10;&#10;No normalization is done, i.e. all '.' and '..' will be kept along.&#10;Use resolve() to get the canonical path to a file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.anchor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.as_posix" func="yes">
			<Overload retVal="" descr="Return the string representation of the path with forward (/)&#10;slashes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.as_uri" func="yes">
			<Overload retVal="" descr="Return the path as a 'file' URI.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.chmod" func="yes">
			<Overload retVal="" descr="Change the permissions of the path, like os.chmod().">
				<Param name="self" />
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.cwd" func="yes">
			<Overload retVal="" descr="Return a new path pointing to the current working directory&#10;(as returned by os.getcwd()).">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.drive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.exists" func="yes">
			<Overload retVal="" descr="Whether this path exists.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.expanduser" func="yes">
			<Overload retVal="" descr="Return a new path with expanded ~ and ~user constructs&#10;(as returned by os.path.expanduser)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.glob" func="yes">
			<Overload retVal="" descr="Iterate over this subtree and yield all existing files (of any&#10;kind, including directories) matching the given pattern.">
				<Param name="self" />
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.group" func="yes">
			<Overload retVal="" descr="Return the group name of the file gid.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.home" func="yes">
			<Overload retVal="" descr="Return a new path pointing to the user's home directory (as&#10;returned by os.path.expanduser('~')).">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_absolute" func="yes">
			<Overload retVal="" descr="True if the path is absolute (has both a root and, if applicable,&#10;a drive).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_block_device" func="yes">
			<Overload retVal="" descr="Whether this path is a block device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_char_device" func="yes">
			<Overload retVal="" descr="Whether this path is a character device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_dir" func="yes">
			<Overload retVal="" descr="Whether this path is a directory.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_fifo" func="yes">
			<Overload retVal="" descr="Whether this path is a FIFO.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_file" func="yes">
			<Overload retVal="" descr="Whether this path is a regular file (also True for symlinks pointing&#10;to regular files).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_reserved" func="yes">
			<Overload retVal="" descr="Return True if the path contains one of the special names reserved&#10;by the system, if any.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_socket" func="yes">
			<Overload retVal="" descr="Whether this path is a socket.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.is_symlink" func="yes">
			<Overload retVal="" descr="Whether this path is a symbolic link.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.iterdir" func="yes">
			<Overload retVal="" descr="Iterate over the files in this directory.  Does not yield any&#10;result for the special paths '.' and '..'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.joinpath" func="yes">
			<Overload retVal="" descr="Combine this path with one or several arguments, and return a&#10;new path representing either a subpath (if all arguments are relative&#10;paths) or a totally different path (if one of the arguments is&#10;anchored).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.lchmod" func="yes">
			<Overload retVal="" descr="Like chmod(), except if the path points to a symlink, the symlink's&#10;permissions are changed, rather than its target's.">
				<Param name="self" />
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.lstat" func="yes">
			<Overload retVal="" descr="Like stat(), except if the path points to a symlink, the symlink's&#10;status information is returned, rather than its target's.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.match" func="yes">
			<Overload retVal="" descr="Return True if this path matches the given pattern.">
				<Param name="self" />
				<Param name="path_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.mkdir" func="yes">
			<Overload retVal="" descr="Create a new directory at this given path.">
				<Param name="self" />
				<Param name="[mode=511" />
				<Param name="[parents=False" />
				<Param name="[exist_ok=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.open" func="yes">
			<Overload retVal="" descr="Open the file pointed by this path and return a file object, as&#10;the built-in open() function does.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.owner" func="yes">
			<Overload retVal="" descr="Return the login name of the file owner.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.parent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.parents" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.parts" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.read_bytes" func="yes">
			<Overload retVal="" descr="Open the file in bytes mode, read it, and close the file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.read_text" func="yes">
			<Overload retVal="" descr="Open the file in text mode, read it, and close the file.">
				<Param name="self" />
				<Param name="[encoding=None" />
				<Param name="[errors=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.relative_to" func="yes">
			<Overload retVal="" descr="Return the relative path to another path identified by the passed&#10;arguments.  If the operation is not possible (because this is not&#10;a subpath of the other path), raise ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.rename" func="yes">
			<Overload retVal="" descr="Rename this path to the given path.">
				<Param name="self" />
				<Param name="target" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.replace" func="yes">
			<Overload retVal="" descr="Rename this path to the given path, clobbering the existing&#10;destination if it exists.">
				<Param name="self" />
				<Param name="target" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.resolve" func="yes">
			<Overload retVal="" descr="Make the path absolute, resolving all symlinks on the way and also&#10;normalizing it (for example turning slashes into backslashes under&#10;Windows).">
				<Param name="self" />
				<Param name="[strict=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.rglob" func="yes">
			<Overload retVal="" descr="Recursively yield all existing files (of any kind, including&#10;directories) matching the given pattern, anywhere in this subtree.">
				<Param name="self" />
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.rmdir" func="yes">
			<Overload retVal="" descr="Remove this directory.  The directory must be empty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.root" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.samefile" func="yes">
			<Overload retVal="" descr="Return whether other_path is the same or not as this file&#10;(as returned by os.path.samefile()).">
				<Param name="self" />
				<Param name="other_path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.stat" func="yes">
			<Overload retVal="" descr="Return the result of the stat() system call on this path, like&#10;os.stat() does.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.stem" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.suffixes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.symlink_to" func="yes">
			<Overload retVal="" descr="Make this path a symlink pointing to the given path.&#10;Note the order of arguments (self, target) is the reverse of os.symlink's.">
				<Param name="self" />
				<Param name="target" />
				<Param name="[target_is_directory=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.touch" func="yes">
			<Overload retVal="" descr="Create this file with the given access mode, if it doesn't exist.">
				<Param name="self" />
				<Param name="[mode=438" />
				<Param name="[exist_ok=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.unlink" func="yes">
			<Overload retVal="" descr="Remove this file or link.&#10;If the path is a directory, use rmdir() instead.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.with_name" func="yes">
			<Overload retVal="" descr="Return a new path with the file name changed.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.with_suffix" func="yes">
			<Overload retVal="" descr="Return a new path with the file suffix changed (or added, if none).">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.write_bytes" func="yes">
			<Overload retVal="" descr="Open the file in bytes mode, write to it, and close the file.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Path.write_text" func="yes">
			<Overload retVal="" descr="Open the file in text mode, write to it, and close the file.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[encoding=None" />
				<Param name="[errors=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath" func="yes">
			<Overload retVal="" descr="PurePath represents a filesystem path and offers operations which&#10;don't imply any actual filesystem I/O.  Depending on your system,&#10;instantiating a PurePath will return either a PurePosixPath or a&#10;PureWindowsPath object.  You can also instantiate either of these classes&#10;directly, regardless of your system.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.absolute" func="yes">
			<Overload retVal="" descr="Return an absolute version of this path.  This function works&#10;even if the path doesn't point to anything.&#10;&#10;No normalization is done, i.e. all '.' and '..' will be kept along.&#10;Use resolve() to get the canonical path to a file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.anchor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.as_posix" func="yes">
			<Overload retVal="" descr="Return the string representation of the path with forward (/)&#10;slashes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.as_uri" func="yes">
			<Overload retVal="" descr="Return the path as a 'file' URI.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.chmod" func="yes">
			<Overload retVal="" descr="Change the permissions of the path, like os.chmod().">
				<Param name="self" />
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.cwd" func="yes">
			<Overload retVal="" descr="Return a new path pointing to the current working directory&#10;(as returned by os.getcwd()).">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.drive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.exists" func="yes">
			<Overload retVal="" descr="Whether this path exists.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.expanduser" func="yes">
			<Overload retVal="" descr="Return a new path with expanded ~ and ~user constructs&#10;(as returned by os.path.expanduser)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.glob" func="yes">
			<Overload retVal="" descr="Iterate over this subtree and yield all existing files (of any&#10;kind, including directories) matching the given pattern.">
				<Param name="self" />
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.group" func="yes">
			<Overload retVal="" descr="Return the group name of the file gid.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.home" func="yes">
			<Overload retVal="" descr="Return a new path pointing to the user's home directory (as&#10;returned by os.path.expanduser('~')).">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_absolute" func="yes">
			<Overload retVal="" descr="True if the path is absolute (has both a root and, if applicable,&#10;a drive).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_block_device" func="yes">
			<Overload retVal="" descr="Whether this path is a block device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_char_device" func="yes">
			<Overload retVal="" descr="Whether this path is a character device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_dir" func="yes">
			<Overload retVal="" descr="Whether this path is a directory.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_fifo" func="yes">
			<Overload retVal="" descr="Whether this path is a FIFO.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_file" func="yes">
			<Overload retVal="" descr="Whether this path is a regular file (also True for symlinks pointing&#10;to regular files).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_reserved" func="yes">
			<Overload retVal="" descr="Return True if the path contains one of the special names reserved&#10;by the system, if any.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_socket" func="yes">
			<Overload retVal="" descr="Whether this path is a socket.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.is_symlink" func="yes">
			<Overload retVal="" descr="Whether this path is a symbolic link.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.iterdir" func="yes">
			<Overload retVal="" descr="Iterate over the files in this directory.  Does not yield any&#10;result for the special paths '.' and '..'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.joinpath" func="yes">
			<Overload retVal="" descr="Combine this path with one or several arguments, and return a&#10;new path representing either a subpath (if all arguments are relative&#10;paths) or a totally different path (if one of the arguments is&#10;anchored).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.lchmod" func="yes">
			<Overload retVal="" descr="Like chmod(), except if the path points to a symlink, the symlink's&#10;permissions are changed, rather than its target's.">
				<Param name="self" />
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.lstat" func="yes">
			<Overload retVal="" descr="Like stat(), except if the path points to a symlink, the symlink's&#10;status information is returned, rather than its target's.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.match" func="yes">
			<Overload retVal="" descr="Return True if this path matches the given pattern.">
				<Param name="self" />
				<Param name="path_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.mkdir" func="yes">
			<Overload retVal="" descr="Create a new directory at this given path.">
				<Param name="self" />
				<Param name="[mode=511" />
				<Param name="[parents=False" />
				<Param name="[exist_ok=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.open" func="yes">
			<Overload retVal="" descr="Open the file pointed by this path and return a file object, as&#10;the built-in open() function does.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.owner" func="yes">
			<Overload retVal="" descr="Return the login name of the file owner.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.parent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.parents" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.parts" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.read_bytes" func="yes">
			<Overload retVal="" descr="Open the file in bytes mode, read it, and close the file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.read_text" func="yes">
			<Overload retVal="" descr="Open the file in text mode, read it, and close the file.">
				<Param name="self" />
				<Param name="[encoding=None" />
				<Param name="[errors=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.relative_to" func="yes">
			<Overload retVal="" descr="Return the relative path to another path identified by the passed&#10;arguments.  If the operation is not possible (because this is not&#10;a subpath of the other path), raise ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.rename" func="yes">
			<Overload retVal="" descr="Rename this path to the given path.">
				<Param name="self" />
				<Param name="target" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.replace" func="yes">
			<Overload retVal="" descr="Rename this path to the given path, clobbering the existing&#10;destination if it exists.">
				<Param name="self" />
				<Param name="target" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.resolve" func="yes">
			<Overload retVal="" descr="Make the path absolute, resolving all symlinks on the way and also&#10;normalizing it (for example turning slashes into backslashes under&#10;Windows).">
				<Param name="self" />
				<Param name="[strict=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.rglob" func="yes">
			<Overload retVal="" descr="Recursively yield all existing files (of any kind, including&#10;directories) matching the given pattern, anywhere in this subtree.">
				<Param name="self" />
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.rmdir" func="yes">
			<Overload retVal="" descr="Remove this directory.  The directory must be empty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.root" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.samefile" func="yes">
			<Overload retVal="" descr="Return whether other_path is the same or not as this file&#10;(as returned by os.path.samefile()).">
				<Param name="self" />
				<Param name="other_path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.stat" func="yes">
			<Overload retVal="" descr="Return the result of the stat() system call on this path, like&#10;os.stat() does.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.stem" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.suffixes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.symlink_to" func="yes">
			<Overload retVal="" descr="Make this path a symlink pointing to the given path.&#10;Note the order of arguments (self, target) is the reverse of os.symlink's.">
				<Param name="self" />
				<Param name="target" />
				<Param name="[target_is_directory=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.touch" func="yes">
			<Overload retVal="" descr="Create this file with the given access mode, if it doesn't exist.">
				<Param name="self" />
				<Param name="[mode=438" />
				<Param name="[exist_ok=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.unlink" func="yes">
			<Overload retVal="" descr="Remove this file or link.&#10;If the path is a directory, use rmdir() instead.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.with_name" func="yes">
			<Overload retVal="" descr="Return a new path with the file name changed.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.with_suffix" func="yes">
			<Overload retVal="" descr="Return a new path with the file suffix changed (or added, if none).">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.write_bytes" func="yes">
			<Overload retVal="" descr="Open the file in bytes mode, write to it, and close the file.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PosixPath.write_text" func="yes">
			<Overload retVal="" descr="Open the file in text mode, write to it, and close the file.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[encoding=None" />
				<Param name="[errors=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath" func="yes">
			<Overload retVal="" descr="PurePath represents a filesystem path and offers operations which&#10;don't imply any actual filesystem I/O.  Depending on your system,&#10;instantiating a PurePath will return either a PurePosixPath or a&#10;PureWindowsPath object.  You can also instantiate either of these classes&#10;directly, regardless of your system.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.anchor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.as_posix" func="yes">
			<Overload retVal="" descr="Return the string representation of the path with forward (/)&#10;slashes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.as_uri" func="yes">
			<Overload retVal="" descr="Return the path as a 'file' URI.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.drive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.is_absolute" func="yes">
			<Overload retVal="" descr="True if the path is absolute (has both a root and, if applicable,&#10;a drive).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.is_reserved" func="yes">
			<Overload retVal="" descr="Return True if the path contains one of the special names reserved&#10;by the system, if any.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.joinpath" func="yes">
			<Overload retVal="" descr="Combine this path with one or several arguments, and return a&#10;new path representing either a subpath (if all arguments are relative&#10;paths) or a totally different path (if one of the arguments is&#10;anchored).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.match" func="yes">
			<Overload retVal="" descr="Return True if this path matches the given pattern.">
				<Param name="self" />
				<Param name="path_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.parent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.parents" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.parts" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.relative_to" func="yes">
			<Overload retVal="" descr="Return the relative path to another path identified by the passed&#10;arguments.  If the operation is not possible (because this is not&#10;a subpath of the other path), raise ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.root" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.stem" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.suffixes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.with_name" func="yes">
			<Overload retVal="" descr="Return a new path with the file name changed.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePath.with_suffix" func="yes">
			<Overload retVal="" descr="Return a new path with the file suffix changed (or added, if none).">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath" func="yes">
			<Overload retVal="" descr="PurePath represents a filesystem path and offers operations which&#10;don't imply any actual filesystem I/O.  Depending on your system,&#10;instantiating a PurePath will return either a PurePosixPath or a&#10;PureWindowsPath object.  You can also instantiate either of these classes&#10;directly, regardless of your system.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.anchor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.as_posix" func="yes">
			<Overload retVal="" descr="Return the string representation of the path with forward (/)&#10;slashes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.as_uri" func="yes">
			<Overload retVal="" descr="Return the path as a 'file' URI.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.drive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.is_absolute" func="yes">
			<Overload retVal="" descr="True if the path is absolute (has both a root and, if applicable,&#10;a drive).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.is_reserved" func="yes">
			<Overload retVal="" descr="Return True if the path contains one of the special names reserved&#10;by the system, if any.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.joinpath" func="yes">
			<Overload retVal="" descr="Combine this path with one or several arguments, and return a&#10;new path representing either a subpath (if all arguments are relative&#10;paths) or a totally different path (if one of the arguments is&#10;anchored).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.match" func="yes">
			<Overload retVal="" descr="Return True if this path matches the given pattern.">
				<Param name="self" />
				<Param name="path_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.parent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.parents" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.parts" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.relative_to" func="yes">
			<Overload retVal="" descr="Return the relative path to another path identified by the passed&#10;arguments.  If the operation is not possible (because this is not&#10;a subpath of the other path), raise ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.root" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.stem" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.suffixes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.with_name" func="yes">
			<Overload retVal="" descr="Return a new path with the file name changed.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PurePosixPath.with_suffix" func="yes">
			<Overload retVal="" descr="Return a new path with the file suffix changed (or added, if none).">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath" func="yes">
			<Overload retVal="" descr="PurePath represents a filesystem path and offers operations which&#10;don't imply any actual filesystem I/O.  Depending on your system,&#10;instantiating a PurePath will return either a PurePosixPath or a&#10;PureWindowsPath object.  You can also instantiate either of these classes&#10;directly, regardless of your system.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.anchor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.as_posix" func="yes">
			<Overload retVal="" descr="Return the string representation of the path with forward (/)&#10;slashes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.as_uri" func="yes">
			<Overload retVal="" descr="Return the path as a 'file' URI.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.drive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.is_absolute" func="yes">
			<Overload retVal="" descr="True if the path is absolute (has both a root and, if applicable,&#10;a drive).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.is_reserved" func="yes">
			<Overload retVal="" descr="Return True if the path contains one of the special names reserved&#10;by the system, if any.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.joinpath" func="yes">
			<Overload retVal="" descr="Combine this path with one or several arguments, and return a&#10;new path representing either a subpath (if all arguments are relative&#10;paths) or a totally different path (if one of the arguments is&#10;anchored).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.match" func="yes">
			<Overload retVal="" descr="Return True if this path matches the given pattern.">
				<Param name="self" />
				<Param name="path_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.parent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.parents" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.parts" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.relative_to" func="yes">
			<Overload retVal="" descr="Return the relative path to another path identified by the passed&#10;arguments.  If the operation is not possible (because this is not&#10;a subpath of the other path), raise ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.root" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.stem" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.suffixes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.with_name" func="yes">
			<Overload retVal="" descr="Return a new path with the file name changed.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.PureWindowsPath.with_suffix" func="yes">
			<Overload retVal="" descr="Return a new path with the file suffix changed (or added, if none).">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISBLK" func="yes">
			<Overload retVal="" descr="S_ISBLK(mode) -&gt; bool&#10;&#10;Return True if mode is from a block special device file.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISCHR" func="yes">
			<Overload retVal="" descr="S_ISCHR(mode) -&gt; bool&#10;&#10;Return True if mode is from a character special device file.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISDIR" func="yes">
			<Overload retVal="" descr="S_ISDIR(mode) -&gt; bool&#10;&#10;Return True if mode is from a directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISFIFO" func="yes">
			<Overload retVal="" descr="S_ISFIFO(mode) -&gt; bool&#10;&#10;Return True if mode is from a FIFO (named pipe).">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISLNK" func="yes">
			<Overload retVal="" descr="S_ISLNK(mode) -&gt; bool&#10;&#10;Return True if mode is from a symbolic link.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISREG" func="yes">
			<Overload retVal="" descr="S_ISREG(mode) -&gt; bool&#10;&#10;Return True if mode is from a regular file.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.S_ISSOCK" func="yes">
			<Overload retVal="" descr="S_ISSOCK(mode) -&gt; bool&#10;&#10;Return True if mode is from a socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.Sequence" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath" func="yes">
			<Overload retVal="" descr="PurePath represents a filesystem path and offers operations which&#10;don't imply any actual filesystem I/O.  Depending on your system,&#10;instantiating a PurePath will return either a PurePosixPath or a&#10;PureWindowsPath object.  You can also instantiate either of these classes&#10;directly, regardless of your system.">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.absolute" func="yes">
			<Overload retVal="" descr="Return an absolute version of this path.  This function works&#10;even if the path doesn't point to anything.&#10;&#10;No normalization is done, i.e. all '.' and '..' will be kept along.&#10;Use resolve() to get the canonical path to a file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.anchor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.as_posix" func="yes">
			<Overload retVal="" descr="Return the string representation of the path with forward (/)&#10;slashes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.as_uri" func="yes">
			<Overload retVal="" descr="Return the path as a 'file' URI.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.chmod" func="yes">
			<Overload retVal="" descr="Change the permissions of the path, like os.chmod().">
				<Param name="self" />
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.cwd" func="yes">
			<Overload retVal="" descr="Return a new path pointing to the current working directory&#10;(as returned by os.getcwd()).">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.drive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.exists" func="yes">
			<Overload retVal="" descr="Whether this path exists.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.expanduser" func="yes">
			<Overload retVal="" descr="Return a new path with expanded ~ and ~user constructs&#10;(as returned by os.path.expanduser)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.glob" func="yes">
			<Overload retVal="" descr="Iterate over this subtree and yield all existing files (of any&#10;kind, including directories) matching the given pattern.">
				<Param name="self" />
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.group" func="yes">
			<Overload retVal="" descr="Return the group name of the file gid.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.home" func="yes">
			<Overload retVal="" descr="Return a new path pointing to the user's home directory (as&#10;returned by os.path.expanduser('~')).">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_absolute" func="yes">
			<Overload retVal="" descr="True if the path is absolute (has both a root and, if applicable,&#10;a drive).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_block_device" func="yes">
			<Overload retVal="" descr="Whether this path is a block device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_char_device" func="yes">
			<Overload retVal="" descr="Whether this path is a character device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_dir" func="yes">
			<Overload retVal="" descr="Whether this path is a directory.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_fifo" func="yes">
			<Overload retVal="" descr="Whether this path is a FIFO.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_file" func="yes">
			<Overload retVal="" descr="Whether this path is a regular file (also True for symlinks pointing&#10;to regular files).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_reserved" func="yes">
			<Overload retVal="" descr="Return True if the path contains one of the special names reserved&#10;by the system, if any.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_socket" func="yes">
			<Overload retVal="" descr="Whether this path is a socket.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.is_symlink" func="yes">
			<Overload retVal="" descr="Whether this path is a symbolic link.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.iterdir" func="yes">
			<Overload retVal="" descr="Iterate over the files in this directory.  Does not yield any&#10;result for the special paths '.' and '..'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.joinpath" func="yes">
			<Overload retVal="" descr="Combine this path with one or several arguments, and return a&#10;new path representing either a subpath (if all arguments are relative&#10;paths) or a totally different path (if one of the arguments is&#10;anchored).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.lchmod" func="yes">
			<Overload retVal="" descr="Like chmod(), except if the path points to a symlink, the symlink's&#10;permissions are changed, rather than its target's.">
				<Param name="self" />
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.lstat" func="yes">
			<Overload retVal="" descr="Like stat(), except if the path points to a symlink, the symlink's&#10;status information is returned, rather than its target's.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.match" func="yes">
			<Overload retVal="" descr="Return True if this path matches the given pattern.">
				<Param name="self" />
				<Param name="path_pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.mkdir" func="yes">
			<Overload retVal="" descr="Create a new directory at this given path.">
				<Param name="self" />
				<Param name="[mode=511" />
				<Param name="[parents=False" />
				<Param name="[exist_ok=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.open" func="yes">
			<Overload retVal="" descr="Open the file pointed by this path and return a file object, as&#10;the built-in open() function does.">
				<Param name="self" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.owner" func="yes">
			<Overload retVal="" descr="Return the login name of the file owner.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.parent" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.parents" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.parts" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.read_bytes" func="yes">
			<Overload retVal="" descr="Open the file in bytes mode, read it, and close the file.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.read_text" func="yes">
			<Overload retVal="" descr="Open the file in text mode, read it, and close the file.">
				<Param name="self" />
				<Param name="[encoding=None" />
				<Param name="[errors=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.relative_to" func="yes">
			<Overload retVal="" descr="Return the relative path to another path identified by the passed&#10;arguments.  If the operation is not possible (because this is not&#10;a subpath of the other path), raise ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.rename" func="yes">
			<Overload retVal="" descr="Rename this path to the given path.">
				<Param name="self" />
				<Param name="target" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.replace" func="yes">
			<Overload retVal="" descr="Rename this path to the given path, clobbering the existing&#10;destination if it exists.">
				<Param name="self" />
				<Param name="target" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.resolve" func="yes">
			<Overload retVal="" descr="Make the path absolute, resolving all symlinks on the way and also&#10;normalizing it (for example turning slashes into backslashes under&#10;Windows).">
				<Param name="self" />
				<Param name="[strict=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.rglob" func="yes">
			<Overload retVal="" descr="Recursively yield all existing files (of any kind, including&#10;directories) matching the given pattern, anywhere in this subtree.">
				<Param name="self" />
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.rmdir" func="yes">
			<Overload retVal="" descr="Remove this directory.  The directory must be empty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.root" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.samefile" func="yes">
			<Overload retVal="" descr="Return whether other_path is the same or not as this file&#10;(as returned by os.path.samefile()).">
				<Param name="self" />
				<Param name="other_path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.stat" func="yes">
			<Overload retVal="" descr="Return the result of the stat() system call on this path, like&#10;os.stat() does.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.stem" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.suffix" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.suffixes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.symlink_to" func="yes">
			<Overload retVal="" descr="Make this path a symlink pointing to the given path.&#10;Note the order of arguments (self, target) is the reverse of os.symlink's.">
				<Param name="self" />
				<Param name="target" />
				<Param name="[target_is_directory=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.touch" func="yes">
			<Overload retVal="" descr="Create this file with the given access mode, if it doesn't exist.">
				<Param name="self" />
				<Param name="[mode=438" />
				<Param name="[exist_ok=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.unlink" func="yes">
			<Overload retVal="" descr="Remove this file or link.&#10;If the path is a directory, use rmdir() instead.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.with_name" func="yes">
			<Overload retVal="" descr="Return a new path with the file name changed.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.with_suffix" func="yes">
			<Overload retVal="" descr="Return a new path with the file suffix changed (or added, if none).">
				<Param name="self" />
				<Param name="suffix" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.write_bytes" func="yes">
			<Overload retVal="" descr="Open the file in bytes mode, write to it, and close the file.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.WindowsPath.write_text" func="yes">
			<Overload retVal="" descr="Open the file in text mode, write to it, and close the file.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[encoding=None" />
				<Param name="[errors=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.attrgetter" func="yes">
			<Overload retVal="" descr="attrgetter(attr, ...) --&gt; attrgetter object&#10;&#10;Return a callable object that fetches the given attribute(s) from its operand.&#10;After f = attrgetter('name'), the call f(r) returns r.name.&#10;After g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).&#10;After h = attrgetter('name.first', 'name.last'), the call h(r) returns&#10;(r.name.first, r.name.last).">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.contextmanager" func="yes">
			<Overload retVal="" descr="@contextmanager decorator.&#10;&#10;Typical usage:&#10;&#10;    @contextmanager&#10;    def some_generator(&lt;arguments&gt;):&#10;        &lt;setup&gt;&#10;        try:&#10;            yield &lt;value&gt;&#10;        finally:&#10;            &lt;cleanup&gt;&#10;&#10;This makes this:&#10;&#10;    with some_generator(&lt;arguments&gt;) as &lt;variable&gt;:&#10;        &lt;body&gt;&#10;&#10;equivalent to this:&#10;&#10;    &lt;setup&gt;&#10;    try:&#10;        &lt;variable&gt; = &lt;value&gt;&#10;        &lt;body&gt;&#10;    finally:&#10;        &lt;cleanup&gt;">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.supports_symlinks" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="pathlib.urlquote_from_bytes" func="yes">
			<Overload retVal="" descr="Like quote(), but accepts a bytes object rather than a str, and does&#10;not perform string-to-bytes encoding.  It always returns an ASCII string.&#10;quote_from_bytes(b'abc def?') -&gt; 'abc%20def%3f'">
				<Param name="bs" />
				<Param name="[safe=/]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pathname2url" func="yes">
			<Overload retVal="" descr="Function of macurl2path">
			</Overload>
		</KeyWord>
		<KeyWord name="pause_reading" func="yes">
			<Overload retVal="" descr="Function of asyncio.ReadTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="pause_writing" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="pbkdf2_hmac" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb" func="yes">
			<Overload retVal="" descr="The Python Debugger Pdb&#10;=======================&#10;&#10;To use the debugger in its simplest form:&#10;&#10;        &gt;&gt;&gt; import pdb&#10;        &gt;&gt;&gt; pdb.run('&lt;a statement&gt;')&#10;&#10;The debugger's prompt is '(Pdb) '.  This will stop in the first&#10;function call in &lt;a statement&gt;.&#10;&#10;Alternatively, if a statement terminated with an unhandled exception,&#10;you can use pdb's post-mortem facility to inspect the contents of the&#10;traceback:&#10;&#10;        &gt;&gt;&gt; &lt;a statement&gt;&#10;        &lt;exception traceback&gt;&#10;        &gt;&gt;&gt; import pdb&#10;        &gt;&gt;&gt; pdb.pm()&#10;&#10;The commands recognized by the debugger are listed in the next&#10;section.  Most can be abbreviated as indicated; e.g., h(elp) means&#10;that 'help' can be typed as 'h' or 'help' (but not as 'he' or 'hel',&#10;nor as 'H' or 'Help' or 'HELP').  Optional arguments are enclosed in&#10;square brackets.  Alternatives in the command syntax are separated&#10;by a vertical bar (|).&#10;&#10;A blank line repeats the previous command literally, except for&#10;'list', where it lists the next 11 lines.&#10;&#10;Commands that the debugger doesn't recognize are assumed to be Python&#10;statements and are executed in the context of the program being&#10;debugged.  Python statements can also be prefixed with an exclamation&#10;point ('!').  This is a powerful way to inspect the program being&#10;debugged; it is even possible to change variables or call functions.&#10;When an exception occurs in such a statement, the exception name is&#10;printed but the debugger's state is not changed.&#10;&#10;The debugger supports aliases, which can save typing.  And aliases can&#10;have parameters (see the alias help entry) which allows one a certain&#10;level of adaptability to the context under examination.&#10;&#10;Multiple commands may be entered on a single line, separated by the&#10;pair ';;'.  No intelligence is applied to separating the commands; the&#10;input is split at the first ';;', even if it is in the middle of a&#10;quoted string.&#10;&#10;If a file &quot;.pdbrc&quot; exists in your home directory or in the current&#10;directory, it is read in and executed as if it had been typed at the&#10;debugger prompt.  This is particularly useful for aliases.  If both&#10;files exist, the one in the home directory is read first and aliases&#10;defined there can be overridden by the local file.  This behavior can be&#10;disabled by passing the &quot;readrc=False&quot; argument to the Pdb constructor.&#10;&#10;Aside from aliases, the debugger is not directly programmable; but it&#10;is implemented as a class from which you can derive your own debugger&#10;class, which you can make as fancy as you like.&#10;&#10;&#10;Debugger commands&#10;=================&#10;&#10;h(elp)&#10;        Without argument, print the list of available commands.&#10;        With a command name as argument, print help about that command.&#10;        &quot;help pdb&quot; shows the full pdb documentation.&#10;        &quot;help exec&quot; gives help on the ! command.&#10;&#10;w(here)&#10;        Print a stack trace, with the most recent frame at the bottom.&#10;        An arrow indicates the &quot;current frame&quot;, which determines the&#10;        context of most commands.  'bt' is an alias for this command.&#10;&#10;d(own) [count]&#10;        Move the current frame count (default one) levels down in the&#10;        stack trace (to a newer frame).&#10;&#10;u(p) [count]&#10;        Move the current frame count (default one) levels up in the&#10;        stack trace (to an older frame).&#10;&#10;b(reak) [ ([filename:]lineno | function) [, condition] ]&#10;        Without argument, list all breaks.&#10;&#10;        With a line number argument, set a break at this line in the&#10;        current file.  With a function name, set a break at the first&#10;        executable line of that function.  If a second argument is&#10;        present, it is a string specifying an expression which must&#10;        evaluate to true before the breakpoint is honored.&#10;&#10;        The line number may be prefixed with a filename and a colon,&#10;        to specify a breakpoint in another file (probably one that&#10;        hasn't been loaded yet).  The file is searched for on&#10;        sys.path; the .py suffix may be omitted.&#10;&#10;tbreak [ ([filename:]lineno | function) [, condition] ]&#10;        Same arguments as break, but sets a temporary breakpoint: it&#10;        is automatically deleted when first hit.&#10;&#10;cl(ear) filename:lineno&#10;cl(ear) [bpnumber [bpnumber...]]&#10;        With a space separated list of breakpoint numbers, clear&#10;        those breakpoints.  Without argument, clear all breaks (but&#10;        first ask confirmation).  With a filename:lineno argument,&#10;        clear all breaks at that line in that file.&#10;&#10;disable bpnumber [bpnumber ...]&#10;        Disables the breakpoints given as a space separated list of&#10;        breakpoint numbers.  Disabling a breakpoint means it cannot&#10;        cause the program to stop execution, but unlike clearing a&#10;        breakpoint, it remains in the list of breakpoints and can be&#10;        (re-)enabled.&#10;&#10;enable bpnumber [bpnumber ...]&#10;        Enables the breakpoints given as a space separated list of&#10;        breakpoint numbers.&#10;&#10;ignore bpnumber [count]&#10;        Set the ignore count for the given breakpoint number.  If&#10;        count is omitted, the ignore count is set to 0.  A breakpoint&#10;        becomes active when the ignore count is zero.  When non-zero,&#10;        the count is decremented each time the breakpoint is reached&#10;        and the breakpoint is not disabled and any associated&#10;        condition evaluates to true.&#10;&#10;condition bpnumber [condition]&#10;        Set a new condition for the breakpoint, an expression which&#10;        must evaluate to true before the breakpoint is honored.  If&#10;        condition is absent, any existing condition is removed; i.e.,&#10;        the breakpoint is made unconditional.&#10;&#10;commands [bpnumber]&#10;        (com) ...&#10;        (com) end&#10;        (Pdb)&#10;&#10;        Specify a list of commands for breakpoint number bpnumber.&#10;        The commands themselves are entered on the following lines.&#10;        Type a line containing just 'end' to terminate the commands.&#10;        The commands are executed when the breakpoint is hit.&#10;&#10;        To remove all commands from a breakpoint, type commands and&#10;        follow it immediately with end; that is, give no commands.&#10;&#10;        With no bpnumber argument, commands refers to the last&#10;        breakpoint set.&#10;&#10;        You can use breakpoint commands to start your program up&#10;        again.  Simply use the continue command, or step, or any other&#10;        command that resumes execution.&#10;&#10;        Specifying any command resuming execution (currently continue,&#10;        step, next, return, jump, quit and their abbreviations)&#10;        terminates the command list (as if that command was&#10;        immediately followed by end).  This is because any time you&#10;        resume execution (even with a simple next or step), you may&#10;        encounter another breakpoint -- which could have its own&#10;        command list, leading to ambiguities about which list to&#10;        execute.&#10;&#10;        If you use the 'silent' command in the command list, the usual&#10;        message about stopping at a breakpoint is not printed.  This&#10;        may be desirable for breakpoints that are to print a specific&#10;        message and then continue.  If none of the other commands&#10;        print anything, you will see no sign that the breakpoint was&#10;        reached.&#10;&#10;s(tep)&#10;        Execute the current line, stop at the first possible occasion&#10;        (either in a function that is called or in the current&#10;        function).&#10;&#10;n(ext)&#10;        Continue execution until the next line in the current function&#10;        is reached or it returns.&#10;&#10;unt(il) [lineno]&#10;        Without argument, continue execution until the line with a&#10;        number greater than the current one is reached.  With a line&#10;        number, continue execution until a line with a number greater&#10;        or equal to that is reached.  In both cases, also stop when&#10;        the current frame returns.&#10;&#10;j(ump) lineno&#10;        Set the next line that will be executed.  Only available in&#10;        the bottom-most frame.  This lets you jump back and execute&#10;        code again, or jump forward to skip code that you don't want&#10;        to run.&#10;&#10;        It should be noted that not all jumps are allowed -- for&#10;        instance it is not possible to jump into the middle of a&#10;        for loop or out of a finally clause.&#10;&#10;r(eturn)&#10;        Continue execution until the current function returns.&#10;&#10;retval&#10;        Print the return value for the last return of a function.&#10;&#10;run [args...]&#10;        Restart the debugged python program. If a string is supplied&#10;        it is split with &quot;shlex&quot;, and the result is used as the new&#10;        sys.argv.  History, breakpoints, actions and debugger options&#10;        are preserved.  &quot;restart&quot; is an alias for &quot;run&quot;.&#10;&#10;c(ont(inue))&#10;        Continue execution, only stop when a breakpoint is encountered.&#10;&#10;l(ist) [first [,last] | .]&#10;&#10;        List source code for the current file.  Without arguments,&#10;        list 11 lines around the current line or continue the previous&#10;        listing.  With . as argument, list 11 lines around the current&#10;        line.  With one argument, list 11 lines starting at that line.&#10;        With two arguments, list the given range; if the second&#10;        argument is less than the first, it is a count.&#10;&#10;        The current line in the current frame is indicated by &quot;-&gt;&quot;.&#10;        If an exception is being debugged, the line where the&#10;        exception was originally raised or propagated is indicated by&#10;        &quot;&gt;&gt;&quot;, if it differs from the current line.&#10;&#10;longlist | ll&#10;        List the whole source code for the current function or frame.&#10;&#10;a(rgs)&#10;        Print the argument list of the current function.&#10;&#10;p expression&#10;        Print the value of the expression.&#10;&#10;pp expression&#10;        Pretty-print the value of the expression.&#10;&#10;whatis arg&#10;        Print the type of the argument.&#10;&#10;source expression&#10;        Try to get source code for the given object and display it.&#10;&#10;display [expression]&#10;&#10;        Display the value of the expression if it changed, each time execution&#10;        stops in the current frame.&#10;&#10;        Without expression, list all display expressions for the current frame.&#10;&#10;undisplay [expression]&#10;&#10;        Do not display the expression any more in the current frame.&#10;&#10;        Without expression, clear all display expressions for the current frame.&#10;&#10;interact&#10;&#10;        Start an interactive interpreter whose global namespace&#10;        contains all the (global and local) names found in the current scope.&#10;&#10;alias [name [command [parameter parameter ...] ]]&#10;        Create an alias called 'name' that executes 'command'.  The&#10;        command must *not* be enclosed in quotes.  Replaceable&#10;        parameters can be indicated by %1, %2, and so on, while %* is&#10;        replaced by all the parameters.  If no command is given, the&#10;        current alias for name is shown. If no name is given, all&#10;        aliases are listed.&#10;&#10;        Aliases may be nested and can contain anything that can be&#10;        legally typed at the pdb prompt.  Note!  You *can* override&#10;        internal pdb commands with aliases!  Those internal commands&#10;        are then hidden until the alias is removed.  Aliasing is&#10;        recursively applied to the first word of the command line; all&#10;        other words in the line are left alone.&#10;&#10;        As an example, here are two useful aliases (especially when&#10;        placed in the .pdbrc file):&#10;&#10;        # Print instance variables (usage &quot;pi classInst&quot;)&#10;        alias pi for k in %1.__dict__.keys(): print(&quot;%1.&quot;,k,&quot;=&quot;,%1.__dict__[k])&#10;        # Print instance variables in self&#10;        alias ps pi self&#10;&#10;unalias name&#10;        Delete the specified alias.&#10;&#10;debug code&#10;        Enter a recursive debugger that steps through the code&#10;        argument (which is an arbitrary expression or statement to be&#10;        executed in the current environment).&#10;&#10;q(uit)&#10;exit&#10;        Quit from the debugger. The program being executed is aborted.&#10;&#10;(!) statement&#10;        Execute the (one-line) statement in the context of the current&#10;        stack frame.  The exclamation point can be omitted unless the&#10;        first word of the statement resembles a debugger command.  To&#10;        assign to a global variable you must always prefix the command&#10;        with a 'global' command, e.g.:&#10;        (Pdb) global list_options; list_options = ['-l']&#10;        (Pdb)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb" func="yes">
			<Overload retVal="" descr="Generic Python debugger base class.&#10;&#10;This class takes care of details of the trace facility;&#10;a derived class should implement user interaction.&#10;The standard debugger class (pdb.Pdb) is an example.">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.bp_commands" func="yes">
			<Overload retVal="" descr="Call every command that was set for the current active breakpoint&#10;(if there is one).&#10;&#10;Returns True if the normal interaction function must be called,&#10;False otherwise.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.break_anywhere" />
		<KeyWord name="pdb.Pdb.break_here" />
		<KeyWord name="pdb.Pdb.canonic" />
		<KeyWord name="pdb.Pdb.checkline" func="yes">
			<Overload retVal="" descr="Check whether specified line seems to be executable.&#10;&#10;Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank&#10;line or EOF). Warning: testing is not comprehensive.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="lineno" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.clear_all_breaks" />
		<KeyWord name="pdb.Pdb.clear_all_file_breaks" />
		<KeyWord name="pdb.Pdb.clear_bpbynumber" />
		<KeyWord name="pdb.Pdb.clear_break" />
		<KeyWord name="pdb.Pdb.cmdloop" func="yes">
			<Overload retVal="" descr="Repeatedly issue a prompt, accept input, parse an initial prefix&#10;off the received input, and dispatch to action methods, passing them&#10;the remainder of the line as argument.">
				<Param name="self" />
				<Param name="[intro=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.columnize" func="yes">
			<Overload retVal="" descr="Display a list of strings as a compact set of columns.&#10;&#10;Each column is only as wide as necessary.&#10;Columns are separated by two spaces (one was not legible enough).">
				<Param name="self" />
				<Param name="list" />
				<Param name="[displaywidth=80]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.commands_resuming" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.complete" func="yes">
			<Overload retVal="" descr="Return the next possible completion for 'text'.&#10;&#10;If a command has not been entered, then complete against command list.&#10;Otherwise try to call complete_&lt;command&gt; to get list of completions.">
				<Param name="self" />
				<Param name="text" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.complete_b" />
		<KeyWord name="pdb.Pdb.complete_break" />
		<KeyWord name="pdb.Pdb.complete_cl" />
		<KeyWord name="pdb.Pdb.complete_clear" />
		<KeyWord name="pdb.Pdb.complete_commands" />
		<KeyWord name="pdb.Pdb.complete_condition" />
		<KeyWord name="pdb.Pdb.complete_debug" />
		<KeyWord name="pdb.Pdb.complete_disable" />
		<KeyWord name="pdb.Pdb.complete_display" />
		<KeyWord name="pdb.Pdb.complete_enable" />
		<KeyWord name="pdb.Pdb.complete_help" />
		<KeyWord name="pdb.Pdb.complete_ignore" />
		<KeyWord name="pdb.Pdb.complete_p" />
		<KeyWord name="pdb.Pdb.complete_pp" />
		<KeyWord name="pdb.Pdb.complete_print" />
		<KeyWord name="pdb.Pdb.complete_source" />
		<KeyWord name="pdb.Pdb.complete_tbreak" />
		<KeyWord name="pdb.Pdb.complete_unalias" />
		<KeyWord name="pdb.Pdb.complete_undisplay" />
		<KeyWord name="pdb.Pdb.complete_whatis" />
		<KeyWord name="pdb.Pdb.completedefault" func="yes">
			<Overload retVal="" descr="Method called to complete an input line when no command-specific&#10;complete_*() method is available.&#10;&#10;By default, it returns an empty list.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.completenames" />
		<KeyWord name="pdb.Pdb.default" func="yes">
			<Overload retVal="" descr="Called on an input line when the command prefix is not recognized.&#10;&#10;If this method is not overridden, it prints an error message and&#10;returns.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.defaultFile" func="yes">
			<Overload retVal="" descr="Produce a reasonable default.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.dispatch_call" />
		<KeyWord name="pdb.Pdb.dispatch_exception" />
		<KeyWord name="pdb.Pdb.dispatch_line" />
		<KeyWord name="pdb.Pdb.dispatch_return" />
		<KeyWord name="pdb.Pdb.displayhook" func="yes">
			<Overload retVal="" descr="Custom displayhook for the exec in default(), which prevents&#10;assignment of the _ variable in the builtins.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_EOF" func="yes">
			<Overload retVal="" descr="EOF&#10;Handles the receipt of EOF as a command.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_a" func="yes">
			<Overload retVal="" descr="a(rgs)&#10;Print the argument list of the current function.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_alias" func="yes">
			<Overload retVal="" descr="alias [name [command [parameter parameter ...] ]]&#10;Create an alias called 'name' that executes 'command'.  The&#10;command must *not* be enclosed in quotes.  Replaceable&#10;parameters can be indicated by %1, %2, and so on, while %* is&#10;replaced by all the parameters.  If no command is given, the&#10;current alias for name is shown. If no name is given, all&#10;aliases are listed.&#10;&#10;Aliases may be nested and can contain anything that can be&#10;legally typed at the pdb prompt.  Note!  You *can* override&#10;internal pdb commands with aliases!  Those internal commands&#10;are then hidden until the alias is removed.  Aliasing is&#10;recursively applied to the first word of the command line; all&#10;other words in the line are left alone.&#10;&#10;As an example, here are two useful aliases (especially when&#10;placed in the .pdbrc file):&#10;&#10;# Print instance variables (usage &quot;pi classInst&quot;)&#10;alias pi for k in %1.__dict__.keys(): print(&quot;%1.&quot;,k,&quot;=&quot;,%1.__dict__[k])&#10;# Print instance variables in self&#10;alias ps pi self">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_args" func="yes">
			<Overload retVal="" descr="a(rgs)&#10;Print the argument list of the current function.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_b" func="yes">
			<Overload retVal="" descr="b(reak) [ ([filename:]lineno | function) [, condition] ]&#10;Without argument, list all breaks.&#10;&#10;With a line number argument, set a break at this line in the&#10;current file.  With a function name, set a break at the first&#10;executable line of that function.  If a second argument is&#10;present, it is a string specifying an expression which must&#10;evaluate to true before the breakpoint is honored.&#10;&#10;The line number may be prefixed with a filename and a colon,&#10;to specify a breakpoint in another file (probably one that&#10;hasn't been loaded yet).  The file is searched for on&#10;sys.path; the .py suffix may be omitted.">
				<Param name="self" />
				<Param name="arg" />
				<Param name="[temporary=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_break" func="yes">
			<Overload retVal="" descr="b(reak) [ ([filename:]lineno | function) [, condition] ]&#10;Without argument, list all breaks.&#10;&#10;With a line number argument, set a break at this line in the&#10;current file.  With a function name, set a break at the first&#10;executable line of that function.  If a second argument is&#10;present, it is a string specifying an expression which must&#10;evaluate to true before the breakpoint is honored.&#10;&#10;The line number may be prefixed with a filename and a colon,&#10;to specify a breakpoint in another file (probably one that&#10;hasn't been loaded yet).  The file is searched for on&#10;sys.path; the .py suffix may be omitted.">
				<Param name="self" />
				<Param name="arg" />
				<Param name="[temporary=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_bt" func="yes">
			<Overload retVal="" descr="w(here)&#10;Print a stack trace, with the most recent frame at the bottom.&#10;An arrow indicates the &quot;current frame&quot;, which determines the&#10;context of most commands.  'bt' is an alias for this command.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_c" func="yes">
			<Overload retVal="" descr="c(ont(inue))&#10;Continue execution, only stop when a breakpoint is encountered.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_cl" func="yes">
			<Overload retVal="" descr="cl(ear) filename:lineno&#10;cl(ear) [bpnumber [bpnumber...]]&#10;        With a space separated list of breakpoint numbers, clear&#10;        those breakpoints.  Without argument, clear all breaks (but&#10;        first ask confirmation).  With a filename:lineno argument,&#10;        clear all breaks at that line in that file.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_clear" func="yes">
			<Overload retVal="" descr="cl(ear) filename:lineno&#10;cl(ear) [bpnumber [bpnumber...]]&#10;        With a space separated list of breakpoint numbers, clear&#10;        those breakpoints.  Without argument, clear all breaks (but&#10;        first ask confirmation).  With a filename:lineno argument,&#10;        clear all breaks at that line in that file.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_commands" func="yes">
			<Overload retVal="" descr="commands [bpnumber]&#10;(com) ...&#10;(com) end&#10;(Pdb)&#10;&#10;Specify a list of commands for breakpoint number bpnumber.&#10;The commands themselves are entered on the following lines.&#10;Type a line containing just 'end' to terminate the commands.&#10;The commands are executed when the breakpoint is hit.&#10;&#10;To remove all commands from a breakpoint, type commands and&#10;follow it immediately with end; that is, give no commands.&#10;&#10;With no bpnumber argument, commands refers to the last&#10;breakpoint set.&#10;&#10;You can use breakpoint commands to start your program up&#10;again.  Simply use the continue command, or step, or any other&#10;command that resumes execution.&#10;&#10;Specifying any command resuming execution (currently continue,&#10;step, next, return, jump, quit and their abbreviations)&#10;terminates the command list (as if that command was&#10;immediately followed by end).  This is because any time you&#10;resume execution (even with a simple next or step), you may&#10;encounter another breakpoint -- which could have its own&#10;command list, leading to ambiguities about which list to&#10;execute.&#10;&#10;If you use the 'silent' command in the command list, the usual&#10;message about stopping at a breakpoint is not printed.  This&#10;may be desirable for breakpoints that are to print a specific&#10;message and then continue.  If none of the other commands&#10;print anything, you will see no sign that the breakpoint was&#10;reached.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_condition" func="yes">
			<Overload retVal="" descr="condition bpnumber [condition]&#10;Set a new condition for the breakpoint, an expression which&#10;must evaluate to true before the breakpoint is honored.  If&#10;condition is absent, any existing condition is removed; i.e.,&#10;the breakpoint is made unconditional.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_cont" func="yes">
			<Overload retVal="" descr="c(ont(inue))&#10;Continue execution, only stop when a breakpoint is encountered.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_continue" func="yes">
			<Overload retVal="" descr="c(ont(inue))&#10;Continue execution, only stop when a breakpoint is encountered.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_d" func="yes">
			<Overload retVal="" descr="d(own) [count]&#10;Move the current frame count (default one) levels down in the&#10;stack trace (to a newer frame).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_debug" func="yes">
			<Overload retVal="" descr="debug code&#10;Enter a recursive debugger that steps through the code&#10;argument (which is an arbitrary expression or statement to be&#10;executed in the current environment).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_disable" func="yes">
			<Overload retVal="" descr="disable bpnumber [bpnumber ...]&#10;Disables the breakpoints given as a space separated list of&#10;breakpoint numbers.  Disabling a breakpoint means it cannot&#10;cause the program to stop execution, but unlike clearing a&#10;breakpoint, it remains in the list of breakpoints and can be&#10;(re-)enabled.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_display" func="yes">
			<Overload retVal="" descr="display [expression]&#10;&#10;Display the value of the expression if it changed, each time execution&#10;stops in the current frame.&#10;&#10;Without expression, list all display expressions for the current frame.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_down" func="yes">
			<Overload retVal="" descr="d(own) [count]&#10;Move the current frame count (default one) levels down in the&#10;stack trace (to a newer frame).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_enable" func="yes">
			<Overload retVal="" descr="enable bpnumber [bpnumber ...]&#10;Enables the breakpoints given as a space separated list of&#10;breakpoint numbers.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_exit" func="yes">
			<Overload retVal="" descr="q(uit)&#10;exit&#10;        Quit from the debugger. The program being executed is aborted.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_h" func="yes">
			<Overload retVal="" descr='h(elp)&#10;Without argument, print the list of available commands.&#10;With a command name as argument, print help about that command.&#10;"help pdb" shows the full pdb documentation.&#10;"help exec" gives help on the ! command.'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_help" func="yes">
			<Overload retVal="" descr='h(elp)&#10;Without argument, print the list of available commands.&#10;With a command name as argument, print help about that command.&#10;"help pdb" shows the full pdb documentation.&#10;"help exec" gives help on the ! command.'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_ignore" func="yes">
			<Overload retVal="" descr="ignore bpnumber [count]&#10;Set the ignore count for the given breakpoint number.  If&#10;count is omitted, the ignore count is set to 0.  A breakpoint&#10;becomes active when the ignore count is zero.  When non-zero,&#10;the count is decremented each time the breakpoint is reached&#10;and the breakpoint is not disabled and any associated&#10;condition evaluates to true.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_interact" func="yes">
			<Overload retVal="" descr="interact&#10;&#10;Start an interactive interpreter whose global namespace&#10;contains all the (global and local) names found in the current scope.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_j" func="yes">
			<Overload retVal="" descr="j(ump) lineno&#10;Set the next line that will be executed.  Only available in&#10;the bottom-most frame.  This lets you jump back and execute&#10;code again, or jump forward to skip code that you don't want&#10;to run.&#10;&#10;It should be noted that not all jumps are allowed -- for&#10;instance it is not possible to jump into the middle of a&#10;for loop or out of a finally clause.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_jump" func="yes">
			<Overload retVal="" descr="j(ump) lineno&#10;Set the next line that will be executed.  Only available in&#10;the bottom-most frame.  This lets you jump back and execute&#10;code again, or jump forward to skip code that you don't want&#10;to run.&#10;&#10;It should be noted that not all jumps are allowed -- for&#10;instance it is not possible to jump into the middle of a&#10;for loop or out of a finally clause.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_l" func="yes">
			<Overload retVal="" descr='l(ist) [first [,last] | .]&#10;&#10;List source code for the current file.  Without arguments,&#10;list 11 lines around the current line or continue the previous&#10;listing.  With . as argument, list 11 lines around the current&#10;line.  With one argument, list 11 lines starting at that line.&#10;With two arguments, list the given range; if the second&#10;argument is less than the first, it is a count.&#10;&#10;The current line in the current frame is indicated by "-&gt;".&#10;If an exception is being debugged, the line where the&#10;exception was originally raised or propagated is indicated by&#10;"&gt;&gt;", if it differs from the current line.'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_list" func="yes">
			<Overload retVal="" descr='l(ist) [first [,last] | .]&#10;&#10;List source code for the current file.  Without arguments,&#10;list 11 lines around the current line or continue the previous&#10;listing.  With . as argument, list 11 lines around the current&#10;line.  With one argument, list 11 lines starting at that line.&#10;With two arguments, list the given range; if the second&#10;argument is less than the first, it is a count.&#10;&#10;The current line in the current frame is indicated by "-&gt;".&#10;If an exception is being debugged, the line where the&#10;exception was originally raised or propagated is indicated by&#10;"&gt;&gt;", if it differs from the current line.'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_ll" func="yes">
			<Overload retVal="" descr="longlist | ll&#10;List the whole source code for the current function or frame.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_longlist" func="yes">
			<Overload retVal="" descr="longlist | ll&#10;List the whole source code for the current function or frame.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_n" func="yes">
			<Overload retVal="" descr="n(ext)&#10;Continue execution until the next line in the current function&#10;is reached or it returns.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_next" func="yes">
			<Overload retVal="" descr="n(ext)&#10;Continue execution until the next line in the current function&#10;is reached or it returns.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_p" func="yes">
			<Overload retVal="" descr="p expression&#10;Print the value of the expression.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_pp" func="yes">
			<Overload retVal="" descr="pp expression&#10;Pretty-print the value of the expression.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_q" func="yes">
			<Overload retVal="" descr="q(uit)&#10;exit&#10;        Quit from the debugger. The program being executed is aborted.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_quit" func="yes">
			<Overload retVal="" descr="q(uit)&#10;exit&#10;        Quit from the debugger. The program being executed is aborted.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_r" func="yes">
			<Overload retVal="" descr="r(eturn)&#10;Continue execution until the current function returns.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_restart" func="yes">
			<Overload retVal="" descr='run [args...]&#10;Restart the debugged python program. If a string is supplied&#10;it is split with "shlex", and the result is used as the new&#10;sys.argv.  History, breakpoints, actions and debugger options&#10;are preserved.  "restart" is an alias for "run".'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_return" func="yes">
			<Overload retVal="" descr="r(eturn)&#10;Continue execution until the current function returns.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_retval" func="yes">
			<Overload retVal="" descr="retval&#10;Print the return value for the last return of a function.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_run" func="yes">
			<Overload retVal="" descr='run [args...]&#10;Restart the debugged python program. If a string is supplied&#10;it is split with "shlex", and the result is used as the new&#10;sys.argv.  History, breakpoints, actions and debugger options&#10;are preserved.  "restart" is an alias for "run".'>
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_rv" func="yes">
			<Overload retVal="" descr="retval&#10;Print the return value for the last return of a function.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_s" func="yes">
			<Overload retVal="" descr="s(tep)&#10;Execute the current line, stop at the first possible occasion&#10;(either in a function that is called or in the current&#10;function).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_source" func="yes">
			<Overload retVal="" descr="source expression&#10;Try to get source code for the given object and display it.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_step" func="yes">
			<Overload retVal="" descr="s(tep)&#10;Execute the current line, stop at the first possible occasion&#10;(either in a function that is called or in the current&#10;function).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_tbreak" func="yes">
			<Overload retVal="" descr="tbreak [ ([filename:]lineno | function) [, condition] ]&#10;Same arguments as break, but sets a temporary breakpoint: it&#10;is automatically deleted when first hit.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_u" func="yes">
			<Overload retVal="" descr="u(p) [count]&#10;Move the current frame count (default one) levels up in the&#10;stack trace (to an older frame).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_unalias" func="yes">
			<Overload retVal="" descr="unalias name&#10;Delete the specified alias.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_undisplay" func="yes">
			<Overload retVal="" descr="undisplay [expression]&#10;&#10;Do not display the expression any more in the current frame.&#10;&#10;Without expression, clear all display expressions for the current frame.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_unt" func="yes">
			<Overload retVal="" descr="unt(il) [lineno]&#10;Without argument, continue execution until the line with a&#10;number greater than the current one is reached.  With a line&#10;number, continue execution until a line with a number greater&#10;or equal to that is reached.  In both cases, also stop when&#10;the current frame returns.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_until" func="yes">
			<Overload retVal="" descr="unt(il) [lineno]&#10;Without argument, continue execution until the line with a&#10;number greater than the current one is reached.  With a line&#10;number, continue execution until a line with a number greater&#10;or equal to that is reached.  In both cases, also stop when&#10;the current frame returns.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_up" func="yes">
			<Overload retVal="" descr="u(p) [count]&#10;Move the current frame count (default one) levels up in the&#10;stack trace (to an older frame).">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_w" func="yes">
			<Overload retVal="" descr="w(here)&#10;Print a stack trace, with the most recent frame at the bottom.&#10;An arrow indicates the &quot;current frame&quot;, which determines the&#10;context of most commands.  'bt' is an alias for this command.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_whatis" func="yes">
			<Overload retVal="" descr="whatis arg&#10;Print the type of the argument.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.do_where" func="yes">
			<Overload retVal="" descr="w(here)&#10;Print a stack trace, with the most recent frame at the bottom.&#10;An arrow indicates the &quot;current frame&quot;, which determines the&#10;context of most commands.  'bt' is an alias for this command.">
				<Param name="self" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.doc_header" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.emptyline" func="yes">
			<Overload retVal="" descr="Called when an empty line is entered in response to the prompt.&#10;&#10;If this method is not overridden, it repeats the last nonempty&#10;command entered.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.error" />
		<KeyWord name="pdb.Pdb.execRcLines" />
		<KeyWord name="pdb.Pdb.forget" />
		<KeyWord name="pdb.Pdb.format_stack_entry" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="frame_lineno" />
				<Param name="[lprefix=: ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.get_all_breaks" />
		<KeyWord name="pdb.Pdb.get_bpbynumber" />
		<KeyWord name="pdb.Pdb.get_break" />
		<KeyWord name="pdb.Pdb.get_breaks" />
		<KeyWord name="pdb.Pdb.get_file_breaks" />
		<KeyWord name="pdb.Pdb.get_names" />
		<KeyWord name="pdb.Pdb.get_stack" />
		<KeyWord name="pdb.Pdb.handle_command_def" func="yes">
			<Overload retVal="" descr="Handles one command line during command list definition.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.help_exec" func="yes">
			<Overload retVal="" descr="(!) statement&#10;Execute the (one-line) statement in the context of the current&#10;stack frame.  The exclamation point can be omitted unless the&#10;first word of the statement resembles a debugger command.  To&#10;assign to a global variable you must always prefix the command&#10;with a 'global' command, e.g.:&#10;(Pdb) global list_options; list_options = ['-l']&#10;(Pdb)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.help_pdb" />
		<KeyWord name="pdb.Pdb.identchars" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.interaction" />
		<KeyWord name="pdb.Pdb.is_skipped_module" />
		<KeyWord name="pdb.Pdb.lineinfo" />
		<KeyWord name="pdb.Pdb.lookupmodule" func="yes">
			<Overload retVal="" descr="Helper function for break/clear parsing -- may be overridden.&#10;&#10;lookupmodule() translates (possibly incomplete) file or module name&#10;into an absolute file name.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.message" />
		<KeyWord name="pdb.Pdb.misc_header" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.nohelp" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.onecmd" func="yes">
			<Overload retVal="" descr="Interpret the argument as though it had been typed in response&#10;to the prompt.&#10;&#10;Checks whether this line is typed at the normal prompt or in&#10;a breakpoint command list definition.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.parseline" func="yes">
			<Overload retVal="" descr="Parse the line into a command name and a string containing&#10;the arguments.  Returns a tuple containing (command, args, line).&#10;'command' and 'args' may be None if the line couldn't be parsed.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.postcmd" func="yes">
			<Overload retVal="" descr="Hook method executed just after a command dispatch is finished.">
				<Param name="self" />
				<Param name="stop" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.postloop" func="yes">
			<Overload retVal="" descr="Hook method executed once when the cmdloop() method is about to&#10;return.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.precmd" func="yes">
			<Overload retVal="" descr="Handle alias expansion and ';;' separator.">
				<Param name="self" />
				<Param name="line" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.preloop" func="yes">
			<Overload retVal="" descr="Hook method executed once when the cmdloop() method is called.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.print_stack_entry" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="frame_lineno" />
				<Param name="[prompt_prefix=
-> ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.print_stack_trace" />
		<KeyWord name="pdb.Pdb.print_topics" />
		<KeyWord name="pdb.Pdb.prompt" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.reset" />
		<KeyWord name="pdb.Pdb.ruler" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.runctx" />
		<KeyWord name="pdb.Pdb.runeval" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="expr" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.set_break" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[temporary=False" />
				<Param name="[cond=None" />
				<Param name="[funcname=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.set_continue" />
		<KeyWord name="pdb.Pdb.set_next" func="yes">
			<Overload retVal="" descr="Stop on the next line in or below the given frame.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.set_quit" />
		<KeyWord name="pdb.Pdb.set_return" func="yes">
			<Overload retVal="" descr="Stop when returning from the given frame.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.set_step" func="yes">
			<Overload retVal="" descr="Stop after one line of code.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.set_trace" func="yes">
			<Overload retVal="" descr="Start debugging from `frame`.&#10;&#10;If frame is not specified, debugging starts from caller's frame.">
				<Param name="self" />
				<Param name="[frame=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.set_until" func="yes">
			<Overload retVal="" descr="Stop when the line with the line no greater than the current one is&#10;reached or when returning from current frame">
				<Param name="self" />
				<Param name="frame" />
				<Param name="[lineno=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.setup" />
		<KeyWord name="pdb.Pdb.sigint_handler" />
		<KeyWord name="pdb.Pdb.stop_here" />
		<KeyWord name="pdb.Pdb.trace_dispatch" />
		<KeyWord name="pdb.Pdb.undoc_header" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.use_rawinput" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.user_call" func="yes">
			<Overload retVal="" descr="This method is called when there is the remote possibility&#10;that we ever need to stop in this function.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="argument_list" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.user_exception" func="yes">
			<Overload retVal="" descr="This function is called if an exception occurs,&#10;but only if we are to stop at or just below this level.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="exc_info" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.user_line" func="yes">
			<Overload retVal="" descr="This function is called when we stop or break at this line.">
				<Param name="self" />
				<Param name="frame" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Pdb.user_return" func="yes">
			<Overload retVal="" descr="This function is called when a return trap is set here.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="return_value" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Restart" func="yes">
			<Overload retVal="" descr="Causes a debugger to be restarted for the debugged python program.">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Restart.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.Restart.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.TESTCMD" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.find_function" />
		<KeyWord name="pdb.getsourcelines" />
		<KeyWord name="pdb.help" />
		<KeyWord name="pdb.lasti2lineno" />
		<KeyWord name="pdb.line_prefix" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.main" />
		<KeyWord name="pdb.pm" />
		<KeyWord name="pdb.post_mortem" func="yes">
			<Overload retVal="" descr=>
				<Param name="[t=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="statement" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.runctx" />
		<KeyWord name="pdb.runeval" func="yes">
			<Overload retVal="" descr=>
				<Param name="expression" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pdb.set_trace" />
		<KeyWord name="pdb.test" />
		<KeyWord name="peek" func="yes">
			<Overload retVal="" descr="Function of io.BufferedRWPair">
			</Overload>
		</KeyWord>
		<KeyWord name="pending" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="pformat" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="phase0" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="phase1" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="phase2" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="phase3" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="phase4" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="phase4_closure" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle" func="yes">
			<Overload retVal="" descr="Create portable serialized representations of Python objects.&#10;&#10;See module copyreg for a mechanism for registering custom picklers.&#10;See module pickletools source for extensive comments.&#10;&#10;Classes:&#10;&#10;    Pickler&#10;    Unpickler&#10;&#10;Functions:&#10;&#10;    dump(object, file)&#10;    dumps(object) -&gt; string&#10;    load(file) -&gt; object&#10;    loads(string) -&gt; object&#10;&#10;Misc variables:&#10;&#10;    __version__&#10;    format_version&#10;    compatible_formats">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.ADDITEMS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.APPEND" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.APPENDS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINBYTES" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINBYTES8" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINFLOAT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINGET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BININT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BININT1" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BININT2" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINPERSID" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINPUT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINSTRING" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINUNICODE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BINUNICODE8" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.BUILD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DEFAULT_PROTOCOL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DICT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.DUP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_DICT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_LIST" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_SET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EMPTY_TUPLE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EXT1" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EXT2" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.EXT4" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FALSE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FLOAT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FRAME" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FROZENSET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.GLOBAL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.HIGHEST_PROTOCOL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.INST" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.INT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LIST" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG1" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG4" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG_BINGET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.LONG_BINPUT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MARK" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.MEMOIZE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWFALSE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWOBJ" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWOBJ_EX" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NEWTRUE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.NONE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.OBJ" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PERSID" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.POP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.POP_MARK" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PROTO" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PUT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PickleError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PickleError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PickleError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler" func="yes">
			<Overload retVal="" descr="This takes a binary file for writing a pickle data stream.&#10;&#10;The optional *protocol* argument tells the pickler to use the given&#10;protocol; supported protocols are 0, 1, 2, 3 and 4.  The default&#10;protocol is 3; a backward-incompatible protocol designed for Python 3.&#10;&#10;Specifying a negative protocol version selects the highest protocol&#10;version supported.  The higher the protocol used, the more recent the&#10;version of Python needed to read the pickle produced.&#10;&#10;The *file* argument must have a write() method that accepts a single&#10;bytes argument. It can thus be a file object opened for binary&#10;writing, an io.BytesIO instance, or any other custom object that meets&#10;this interface.&#10;&#10;If *fix_imports* is True and protocol is less than 3, pickle will try&#10;to map the new Python 3 names to the old module names used in Python&#10;2, so that the pickle data stream is readable with Python 2.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.bin" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.clear_memo" func="yes">
			<Overload retVal="" descr="Clears the pickler's &quot;memo&quot;.&#10;&#10;The memo is the data structure that remembers which objects the&#10;pickler has already seen, so that shared or recursive objects are&#10;pickled by reference and not by value.  This method is useful when&#10;re-using picklers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.dispatch_table" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.dump" func="yes">
			<Overload retVal="" descr="Write a pickled representation of the given object to the open file.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.fast" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.memo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Pickler.persistent_id" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PicklingError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PicklingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.PicklingError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.REDUCE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SETITEM" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SETITEMS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SHORT_BINBYTES" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SHORT_BINSTRING" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.SHORT_BINUNICODE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.STACK_GLOBAL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.STOP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.STRING" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TRUE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE1" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE2" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.TUPLE3" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UNICODE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Unpickler" func="yes">
			<Overload retVal="" descr="This takes a binary file for reading a pickle data stream.&#10;&#10;The protocol version of the pickle is detected automatically, so no&#10;protocol argument is needed.  Bytes past the pickled object's&#10;representation are ignored.&#10;&#10;The argument *file* must have two methods, a read() method that takes&#10;an integer argument, and a readline() method that requires no&#10;arguments.  Both methods should return bytes.  Thus *file* can be a&#10;binary file object opened for reading, an io.BytesIO object, or any&#10;other custom object that meets this interface.&#10;&#10;Optional keyword arguments are *fix_imports*, *encoding* and *errors*,&#10;which are used to control compatibility support for pickle stream&#10;generated by Python 2.  If *fix_imports* is True, pickle will try to&#10;map the old Python 2 names to the new names used in Python 3.  The&#10;*encoding* and *errors* tell pickle how to decode 8-bit string&#10;instances pickled by Python 2; these default to 'ASCII' and 'strict',&#10;respectively.  The *encoding* can be 'bytes' to read these 8-bit&#10;string instances as bytes objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Unpickler.find_class" func="yes">
			<Overload retVal="" descr="Return an object from a specified module.&#10;&#10;If necessary, the module will be imported. Subclasses may override&#10;this method (e.g. to restrict unpickling of arbitrary classes and&#10;functions).&#10;&#10;This method is called whenever a class or a function object is&#10;needed.  Both arguments passed are str objects.">
				<Param name="self" />
				<Param name="module_name" />
				<Param name="global_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Unpickler.load" func="yes">
			<Overload retVal="" descr="Load a pickle.&#10;&#10;Read a pickled object representation from the open file object given&#10;in the constructor, and return the reconstituted object hierarchy&#10;specified therein.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Unpickler.memo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.Unpickler.persistent_load" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnpicklingError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnpicklingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.UnpicklingError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.bytes_types" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.compatible_formats" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.decode_long" func="yes">
			<Overload retVal="" descr="Decode a long from a two's complement little-endian binary string.&#10;&#10;&gt;&gt;&gt; decode_long(b'')&#10;0&#10;&gt;&gt;&gt; decode_long(b&quot;\xff\x00&quot;)&#10;255&#10;&gt;&gt;&gt; decode_long(b&quot;\xff\x7f&quot;)&#10;32767&#10;&gt;&gt;&gt; decode_long(b&quot;\x00\xff&quot;)&#10;-256&#10;&gt;&gt;&gt; decode_long(b&quot;\x00\x80&quot;)&#10;-32768&#10;&gt;&gt;&gt; decode_long(b&quot;\x80&quot;)&#10;-128&#10;&gt;&gt;&gt; decode_long(b&quot;\x7f&quot;)&#10;127">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.dispatch_table" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.dump" func="yes">
			<Overload retVal="" descr="Write a pickled representation of obj to the open file object file.&#10;&#10;This is equivalent to ``Pickler(file, protocol).dump(obj)``, but may&#10;be more efficient.&#10;&#10;The optional *protocol* argument tells the pickler to use the given&#10;protocol supported protocols are 0, 1, 2, 3 and 4.  The default&#10;protocol is 3; a backward-incompatible protocol designed for Python 3.&#10;&#10;Specifying a negative protocol version selects the highest protocol&#10;version supported.  The higher the protocol used, the more recent the&#10;version of Python needed to read the pickle produced.&#10;&#10;The *file* argument must have a write() method that accepts a single&#10;bytes argument.  It can thus be a file object opened for binary&#10;writing, an io.BytesIO instance, or any other custom object that meets&#10;this interface.&#10;&#10;If *fix_imports* is True and protocol is less than 3, pickle will try&#10;to map the new Python 3 names to the old module names used in Python&#10;2, so that the pickle data stream is readable with Python 2.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.dumps" func="yes">
			<Overload retVal="" descr="Return the pickled representation of the object as a bytes object.&#10;&#10;The optional *protocol* argument tells the pickler to use the given&#10;protocol; supported protocols are 0, 1, 2, 3 and 4.  The default&#10;protocol is 3; a backward-incompatible protocol designed for Python 3.&#10;&#10;Specifying a negative protocol version selects the highest protocol&#10;version supported.  The higher the protocol used, the more recent the&#10;version of Python needed to read the pickle produced.&#10;&#10;If *fix_imports* is True and *protocol* is less than 3, pickle will&#10;try to map the new Python 3 names to the old module names used in&#10;Python 2, so that the pickle data stream is readable with Python 2.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.encode_long" func="yes">
			<Overload retVal="" descr="Encode a long to a two's complement little-endian binary string.&#10;Note that 0 is a special case, returning an empty string, to save a&#10;byte in the LONG1 pickling context.&#10;&#10;&gt;&gt;&gt; encode_long(0)&#10;b''&#10;&gt;&gt;&gt; encode_long(255)&#10;b'\xff\x00'&#10;&gt;&gt;&gt; encode_long(32767)&#10;b'\xff\x7f'&#10;&gt;&gt;&gt; encode_long(-256)&#10;b'\x00\xff'&#10;&gt;&gt;&gt; encode_long(-32768)&#10;b'\x00\x80'&#10;&gt;&gt;&gt; encode_long(-128)&#10;b'\x80'&#10;&gt;&gt;&gt; encode_long(127)&#10;b'\x7f'&#10;&gt;&gt;&gt;">
				<Param name="x" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.format_version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.islice" func="yes">
			<Overload retVal="" descr="islice(iterable, stop) --&gt; islice object&#10;islice(iterable, start, stop[, step]) --&gt; islice object&#10;&#10;Return an iterator whose next() method returns selected values from an&#10;iterable.  If start is specified, will skip all preceding elements;&#10;otherwise, start defaults to zero.  Step defaults to one.  If&#10;specified as another value, step determines how many values are &#10;skipped between successive calls.  Works like a slice() on a list&#10;but returns an iterator.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.load" func="yes">
			<Overload retVal="" descr="Read and return an object from the pickle data stored in a file.&#10;&#10;This is equivalent to ``Unpickler(file).load()``, but may be more&#10;efficient.&#10;&#10;The protocol version of the pickle is detected automatically, so no&#10;protocol argument is needed.  Bytes past the pickled object's&#10;representation are ignored.&#10;&#10;The argument *file* must have two methods, a read() method that takes&#10;an integer argument, and a readline() method that requires no&#10;arguments.  Both methods should return bytes.  Thus *file* can be a&#10;binary file object opened for reading, an io.BytesIO object, or any&#10;other custom object that meets this interface.&#10;&#10;Optional keyword arguments are *fix_imports*, *encoding* and *errors*,&#10;which are used to control compatibility support for pickle stream&#10;generated by Python 2.  If *fix_imports* is True, pickle will try to&#10;map the old Python 2 names to the new names used in Python 3.  The&#10;*encoding* and *errors* tell pickle how to decode 8-bit string&#10;instances pickled by Python 2; these default to 'ASCII' and 'strict',&#10;respectively.  The *encoding* can be 'bytes' to read these 8-bit&#10;string instances as bytes objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.loads" func="yes">
			<Overload retVal="" descr="Read and return an object from the given pickle data.&#10;&#10;The protocol version of the pickle is detected automatically, so no&#10;protocol argument is needed.  Bytes past the pickled object's&#10;representation are ignored.&#10;&#10;Optional keyword arguments are *fix_imports*, *encoding* and *errors*,&#10;which are used to control compatibility support for pickle stream&#10;generated by Python 2.  If *fix_imports* is True, pickle will try to&#10;map the old Python 2 names to the new names used in Python 3.  The&#10;*encoding* and *errors* tell pickle how to decode 8-bit string&#10;instances pickled by Python 2; these default to 'ASCII' and 'strict',&#10;respectively.  The *encoding* can be 'bytes' to read these 8-bit&#10;string instances as bytes objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.maxsize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.pack" func="yes">
			<Overload retVal="" descr="pack(fmt, v1, v2, ...) -&gt; bytes&#10;&#10;Return a bytes object containing the values v1, v2, ... packed according&#10;to the format string fmt.  See help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.partial" func="yes">
			<Overload retVal="" descr="partial(func, *args, **keywords) - new function with partial application&#10;of the given arguments and keywords.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.partial.args" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.partial.func" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.partial.keywords" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.unpack" func="yes">
			<Overload retVal="" descr="unpack(fmt, buffer) -&gt; (v1, v2, ...)&#10;&#10;Return a tuple containing values unpacked according to the format string&#10;fmt.  The buffer's size in bytes must be calcsize(fmt). See help(struct)&#10;for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="pickle.whichmodule" func="yes">
			<Overload retVal="" descr="Find the module an object belong to.">
				<Param name="obj" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickle_complex" func="yes">
			<Overload retVal="" descr="Function of copyreg">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools" func="yes">
			<Overload retVal="" descr='"Executable documentation" for the pickle module.&#10;&#10;Extensive comments about the pickle protocols and pickle-machine opcodes&#10;can be found here.  Some functions meant for external use:&#10;&#10;genops(pickle)&#10;   Generate all the opcodes in a pickle, as (opcode, arg, position) triples.&#10;&#10;dis(pickle, out=None, memo=None, indentlevel=4)&#10;   Print a symbolic disassembly of a pickle.'>
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor" />
		<KeyWord name="pickletools.ArgumentDescriptor.doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor.n" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.ArgumentDescriptor.reader" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo" />
		<KeyWord name="pickletools.OpcodeInfo.arg" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.proto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.stack_after" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.OpcodeInfo.stack_before" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.StackObject" />
		<KeyWord name="pickletools.StackObject.doc" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.StackObject.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.StackObject.obtype" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.TAKEN_FROM_ARGUMENT1" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.TAKEN_FROM_ARGUMENT4" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.TAKEN_FROM_ARGUMENT4U" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.TAKEN_FROM_ARGUMENT8U" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.UP_TO_NEWLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.anyobject" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.bytes1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.bytes4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.bytes8" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.bytes_types" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.code2op" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.decimalnl_long" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.decimalnl_short" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.decode_long" func="yes">
			<Overload retVal="" descr="Decode a long from a two's complement little-endian binary string.&#10;&#10;&gt;&gt;&gt; decode_long(b'')&#10;0&#10;&gt;&gt;&gt; decode_long(b&quot;\xff\x00&quot;)&#10;255&#10;&gt;&gt;&gt; decode_long(b&quot;\xff\x7f&quot;)&#10;32767&#10;&gt;&gt;&gt; decode_long(b&quot;\x00\xff&quot;)&#10;-256&#10;&gt;&gt;&gt; decode_long(b&quot;\x00\x80&quot;)&#10;-32768&#10;&gt;&gt;&gt; decode_long(b&quot;\x80&quot;)&#10;-128&#10;&gt;&gt;&gt; decode_long(b&quot;\x7f&quot;)&#10;127">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.dis" func="yes">
			<Overload retVal="" descr="Produce a symbolic disassembly of a pickle.&#10;&#10;'pickle' is a file-like object, or string, containing a (at least one)&#10;pickle.  The pickle is disassembled from the current position, through&#10;the first STOP opcode encountered.&#10;&#10;Optional arg 'out' is a file-like object to which the disassembly is&#10;printed.  It defaults to sys.stdout.&#10;&#10;Optional arg 'memo' is a Python dict, used as the pickle's memo.  It&#10;may be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.&#10;Passing the same memo object to another dis() call then allows disassembly&#10;to proceed across multiple pickles that were all created by the same&#10;pickler with the same memo.  Ordinarily you don't need to worry about this.&#10;&#10;Optional arg 'indentlevel' is the number of blanks by which to indent&#10;a new MARK level.  It defaults to 4.&#10;&#10;Optional arg 'annotate' if nonzero instructs dis() to add short&#10;description of the opcode on each line of disassembled output.&#10;The value given to 'annotate' must be an integer and is used as a&#10;hint for the column where annotation should start.  The default&#10;value is 0, meaning no annotations.&#10;&#10;In addition to printing the disassembly, some sanity checks are made:&#10;&#10;+ All embedded opcode arguments &quot;make sense&quot;.&#10;&#10;+ Explicit and implicit pop operations have enough items on the stack.&#10;&#10;+ When an opcode implicitly refers to a markobject, a markobject is&#10;  actually on the stack.&#10;&#10;+ A memo entry isn't referenced before it's defined.&#10;&#10;+ The markobject isn't stored in the memo.&#10;&#10;+ A memo entry isn't redefined.">
				<Param name="pickle" />
				<Param name="[out=None" />
				<Param name="[memo=None" />
				<Param name="[indentlevel=4" />
				<Param name="[annotate=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.float8" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.floatnl" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.genops" func="yes">
			<Overload retVal="" descr="Generate all the opcodes in a pickle.&#10;&#10;'pickle' is a file-like object, or string, containing the pickle.&#10;&#10;Each opcode in the pickle is generated, from the current pickle position,&#10;stopping after a STOP opcode is delivered.  A triple is generated for&#10;each opcode:&#10;&#10;    opcode, arg, pos&#10;&#10;opcode is an OpcodeInfo record, describing the current opcode.&#10;&#10;If the opcode has an argument embedded in the pickle, arg is its decoded&#10;value, as a Python object.  If the opcode doesn't have an argument, arg&#10;is None.&#10;&#10;If the pickle has a tell() method, pos was the value of pickle.tell()&#10;before reading the current opcode.  If the pickle is a bytes object,&#10;it's wrapped in a BytesIO object, and the latter's tell() result is&#10;used.  Else (the pickle doesn't have a tell(), and it's not obvious how&#10;to query its current position) pos is None.">
				<Param name="pickle" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.int4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.long1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.long4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.markobject" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.opcodes" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.optimize" func="yes">
			<Overload retVal="" descr="Optimize a pickle string by removing unused PUT opcodes">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pybool" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pybytes" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pybytes_or_str" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pydict" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyfloat" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyfrozenset" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyint" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyinteger_or_bool" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pylist" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pylong" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pynone" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyset" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pystring" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pytuple" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.pyunicode" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_bytes1" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_bytes1(io.BytesIO(b&quot;\x00&quot;))&#10;b''&#10;&gt;&gt;&gt; read_bytes1(io.BytesIO(b&quot;\x03abcdef&quot;))&#10;b'abc'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_bytes4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_bytes4(io.BytesIO(b&quot;\x00\x00\x00\x00abc&quot;))&#10;b''&#10;&gt;&gt;&gt; read_bytes4(io.BytesIO(b&quot;\x03\x00\x00\x00abcdef&quot;))&#10;b'abc'&#10;&gt;&gt;&gt; read_bytes4(io.BytesIO(b&quot;\x00\x00\x00\x03abcdef&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 50331648 bytes in a bytes4, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_bytes8" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io, struct, sys&#10;&gt;&gt;&gt; read_bytes8(io.BytesIO(b&quot;\x00\x00\x00\x00\x00\x00\x00\x00abc&quot;))&#10;b''&#10;&gt;&gt;&gt; read_bytes8(io.BytesIO(b&quot;\x03\x00\x00\x00\x00\x00\x00\x00abcdef&quot;))&#10;b'abc'&#10;&gt;&gt;&gt; bigsize8 = struct.pack(&quot;&lt;Q&quot;, sys.maxsize//3)&#10;&gt;&gt;&gt; read_bytes8(io.BytesIO(bigsize8 + b&quot;abcdef&quot;))  #doctest: +ELLIPSIS&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected ... bytes in a bytes8, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_decimalnl_long" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import io&#10;&#10;&gt;&gt;&gt; read_decimalnl_long(io.BytesIO(b"1234L\n56"))&#10;1234&#10;&#10;&gt;&gt;&gt; read_decimalnl_long(io.BytesIO(b"123456789012345678901234L\n6"))&#10;123456789012345678901234'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_decimalnl_short" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_decimalnl_short(io.BytesIO(b&quot;1234\n56&quot;))&#10;1234&#10;&#10;&gt;&gt;&gt; read_decimalnl_short(io.BytesIO(b&quot;1234L\n56&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: invalid literal for int() with base 10: b'1234L'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_float8" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io, struct&#10;&gt;&gt;&gt; raw = struct.pack(&quot;&gt;d&quot;, -1.25)&#10;&gt;&gt;&gt; raw&#10;b'\xbf\xf4\x00\x00\x00\x00\x00\x00'&#10;&gt;&gt;&gt; read_float8(io.BytesIO(raw + b&quot;\n&quot;))&#10;-1.25">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_floatnl" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_floatnl(io.BytesIO(b"-1.25\n6"))&#10;-1.25'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_int4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_int4(io.BytesIO(b'\xff\x00\x00\x00'))&#10;255&#10;&gt;&gt;&gt; read_int4(io.BytesIO(b'\x00\x00\x00\x80')) == -(2**31)&#10;True">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_long1" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_long1(io.BytesIO(b"\x00"))&#10;0&#10;&gt;&gt;&gt; read_long1(io.BytesIO(b"\x02\xff\x00"))&#10;255&#10;&gt;&gt;&gt; read_long1(io.BytesIO(b"\x02\xff\x7f"))&#10;32767&#10;&gt;&gt;&gt; read_long1(io.BytesIO(b"\x02\x00\xff"))&#10;-256&#10;&gt;&gt;&gt; read_long1(io.BytesIO(b"\x02\x00\x80"))&#10;-32768'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_long4" func="yes">
			<Overload retVal="" descr='&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_long4(io.BytesIO(b"\x02\x00\x00\x00\xff\x00"))&#10;255&#10;&gt;&gt;&gt; read_long4(io.BytesIO(b"\x02\x00\x00\x00\xff\x7f"))&#10;32767&#10;&gt;&gt;&gt; read_long4(io.BytesIO(b"\x02\x00\x00\x00\x00\xff"))&#10;-256&#10;&gt;&gt;&gt; read_long4(io.BytesIO(b"\x02\x00\x00\x00\x00\x80"))&#10;-32768&#10;&gt;&gt;&gt; read_long1(io.BytesIO(b"\x00\x00\x00\x00"))&#10;0'>
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_string1" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_string1(io.BytesIO(b&quot;\x00&quot;))&#10;''&#10;&gt;&gt;&gt; read_string1(io.BytesIO(b&quot;\x03abcdef&quot;))&#10;'abc'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_string4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_string4(io.BytesIO(b&quot;\x00\x00\x00\x00abc&quot;))&#10;''&#10;&gt;&gt;&gt; read_string4(io.BytesIO(b&quot;\x03\x00\x00\x00abcdef&quot;))&#10;'abc'&#10;&gt;&gt;&gt; read_string4(io.BytesIO(b&quot;\x00\x00\x00\x03abcdef&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 50331648 bytes in a string4, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_stringnl" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;'abcd'\nefg\n&quot;))&#10;'abcd'&#10;&#10;&gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;\n&quot;))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: no string quotes around b''&#10;&#10;&gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;\n&quot;), stripquotes=False)&#10;''&#10;&#10;&gt;&gt;&gt; read_stringnl(io.BytesIO(b&quot;''\n&quot;))&#10;''&#10;&#10;&gt;&gt;&gt; read_stringnl(io.BytesIO(b'&quot;abcd&quot;'))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: no newline found when trying to read stringnl&#10;&#10;Embedded escapes are undone in the result.&#10;&gt;&gt;&gt; read_stringnl(io.BytesIO(br&quot;'a\n\\b\x00c\td'&quot; + b&quot;\n'e'&quot;))&#10;'a\n\\b\x00c\td'">
				<Param name="f" />
				<Param name="[decode=True" />
				<Param name="[stripquotes=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_stringnl_noescape" />
		<KeyWord name="pickletools.read_stringnl_noescape_pair" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_stringnl_noescape_pair(io.BytesIO(b&quot;Queue\nEmpty\njunk&quot;))&#10;'Queue Empty'">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_uint1" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_uint1(io.BytesIO(b'\xff'))&#10;255">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_uint2" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_uint2(io.BytesIO(b'\xff\x00'))&#10;255&#10;&gt;&gt;&gt; read_uint2(io.BytesIO(b'\xff\xff'))&#10;65535">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_uint4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_uint4(io.BytesIO(b'\xff\x00\x00\x00'))&#10;255&#10;&gt;&gt;&gt; read_uint4(io.BytesIO(b'\x00\x00\x00\x80')) == 2**31&#10;True">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_uint8" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_uint8(io.BytesIO(b'\xff\x00\x00\x00\x00\x00\x00\x00'))&#10;255&#10;&gt;&gt;&gt; read_uint8(io.BytesIO(b'\xff' * 8)) == 2**64-1&#10;True">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_unicodestring1" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; s = 'abcd\uabcd'&#10;&gt;&gt;&gt; enc = s.encode('utf-8')&#10;&gt;&gt;&gt; enc&#10;b'abcd\xea\xaf\x8d'&#10;&gt;&gt;&gt; n = bytes([len(enc)])  # little-endian 1-byte length&#10;&gt;&gt;&gt; t = read_unicodestring1(io.BytesIO(n + enc + b'junk'))&#10;&gt;&gt;&gt; s == t&#10;True&#10;&#10;&gt;&gt;&gt; read_unicodestring1(io.BytesIO(n + enc[:-1]))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 7 bytes in a unicodestring1, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_unicodestring4" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; s = 'abcd\uabcd'&#10;&gt;&gt;&gt; enc = s.encode('utf-8')&#10;&gt;&gt;&gt; enc&#10;b'abcd\xea\xaf\x8d'&#10;&gt;&gt;&gt; n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length&#10;&gt;&gt;&gt; t = read_unicodestring4(io.BytesIO(n + enc + b'junk'))&#10;&gt;&gt;&gt; s == t&#10;True&#10;&#10;&gt;&gt;&gt; read_unicodestring4(io.BytesIO(n + enc[:-1]))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 7 bytes in a unicodestring4, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_unicodestring8" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; s = 'abcd\uabcd'&#10;&gt;&gt;&gt; enc = s.encode('utf-8')&#10;&gt;&gt;&gt; enc&#10;b'abcd\xea\xaf\x8d'&#10;&gt;&gt;&gt; n = bytes([len(enc)]) + b'\0' * 7  # little-endian 8-byte length&#10;&gt;&gt;&gt; t = read_unicodestring8(io.BytesIO(n + enc + b'junk'))&#10;&gt;&gt;&gt; s == t&#10;True&#10;&#10;&gt;&gt;&gt; read_unicodestring8(io.BytesIO(n + enc[:-1]))&#10;Traceback (most recent call last):&#10;...&#10;ValueError: expected 7 bytes in a unicodestring8, but only 6 remain">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.read_unicodestringnl" func="yes">
			<Overload retVal="" descr="&gt;&gt;&gt; import io&#10;&gt;&gt;&gt; read_unicodestringnl(io.BytesIO(b&quot;abc\\uabcd\njunk&quot;)) == 'abc\uabcd'&#10;True">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stackslice" func="yes">
			<Overload retVal="" descr="(StackObject)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.string1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.string4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stringnl" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stringnl_noescape" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.stringnl_noescape_pair" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.uint1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.uint2" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.uint4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.uint8" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.unicodestring1" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.unicodestring4" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.unicodestring8" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pickletools.unicodestringnl" func="yes">
			<Overload retVal="" descr="(ArgumentDescriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip" />
		<KeyWord name="pip.CommandError" func="yes">
			<Overload retVal="" descr="Raised when there is an error in command-line arguments">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.CommandError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.CommandError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser" func="yes">
			<Overload retVal="" descr="Custom option parser which updates its defaults by checking the&#10;configuration files and environmental variables">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.add_option" func="yes">
			<Overload retVal="" descr="add_option(Option)&#10;add_option(opt_str, ..., kwarg=val, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.add_option_group" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.add_options" />
		<KeyWord name="pip.ConfigOptionParser.check_default" />
		<KeyWord name="pip.ConfigOptionParser.check_values" func="yes">
			<Overload retVal="" descr="check_values(values : Values, args : [string])&#10;-&gt; (values : Values, args : [string])&#10;&#10;Check that the supplied option values and leftover arguments are&#10;valid.  Returns the option values and leftover arguments&#10;(possibly adjusted, possibly completely new -- whatever you&#10;like).  Default implementation just returns the passed-in&#10;values; subclasses may override as desired.">
				<Param name="self" />
				<Param name="values" />
				<Param name="args" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.destroy" func="yes">
			<Overload retVal="" descr="Declare that you are done with this OptionParser.  This cleans up&#10;reference cycles so the OptionParser (and all objects referenced by&#10;it) can be garbage-collected promptly.  After calling destroy(), the&#10;OptionParser is unusable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.disable_interspersed_args" func="yes">
			<Overload retVal="" descr="Set parsing to stop on the first non-option. Use this if&#10;you have a command processor which runs another command that&#10;has options of its own and you want to make sure these options&#10;don't get confused.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.enable_interspersed_args" func="yes">
			<Overload retVal="" descr="Set parsing to not stop on the first non-option, allowing&#10;interspersing switches with command arguments. This is the&#10;default behavior. See also disable_interspersed_args() and the&#10;class documentation description of the attribute&#10;allow_interspersed_args.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.error" func="yes">
			<Overload retVal="" descr="error(msg : string)&#10;&#10;Print a usage message incorporating 'msg' to stderr and exit.&#10;If you override this in a subclass, it should not return -- it&#10;should either exit or raise an exception.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.exit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[status=0" />
				<Param name="[msg=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.expand_prog_name" />
		<KeyWord name="pip.ConfigOptionParser.format_description" />
		<KeyWord name="pip.ConfigOptionParser.format_epilog" />
		<KeyWord name="pip.ConfigOptionParser.format_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[formatter=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.format_option_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[formatter=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.get_config_files" />
		<KeyWord name="pip.ConfigOptionParser.get_config_section" func="yes">
			<Overload retVal="" descr="Get a section of a configuration">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.get_default_values" func="yes">
			<Overload retVal="" descr="Overriding to make updating the defaults after instantiation of&#10;the option parser possible, _update_defaults() does the dirty work.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.get_description" />
		<KeyWord name="pip.ConfigOptionParser.get_environ_vars" func="yes">
			<Overload retVal="" descr="Returns a generator with all environmental vars with prefix PIP_">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.get_option" />
		<KeyWord name="pip.ConfigOptionParser.get_option_group" />
		<KeyWord name="pip.ConfigOptionParser.get_prog_name" />
		<KeyWord name="pip.ConfigOptionParser.get_usage" />
		<KeyWord name="pip.ConfigOptionParser.get_version" />
		<KeyWord name="pip.ConfigOptionParser.has_option" />
		<KeyWord name="pip.ConfigOptionParser.insert_option_group" func="yes">
			<Overload retVal="" descr="Insert an OptionGroup at a given position.">
				<Param name="self" />
				<Param name="idx" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.normalize_keys" func="yes">
			<Overload retVal="" descr="Return a config dictionary with normalized keys regardless of&#10;whether the keys were specified in environment variables or in config&#10;files">
				<Param name="self" />
				<Param name="items" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.option_list_all" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.parse_args" func="yes">
			<Overload retVal="" descr="parse_args(args : [string] = sys.argv[1:],&#10;           values : Values = None)&#10;-&gt; (values : Values, args : [string])&#10;&#10;Parse the command-line options found in 'args' (default:&#10;sys.argv[1:]).  Any errors result in a call to 'error()', which&#10;by default prints the usage message to stderr and calls&#10;sys.exit() with an error message.  On success returns a pair&#10;(values, args) where 'values' is a Values instance (with all&#10;your option values) and 'args' is the list of arguments left&#10;over after parsing options.">
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[values=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.print_help" func="yes">
			<Overload retVal="" descr="print_help(file : file = stdout)&#10;&#10;Print an extended help message, listing all options and any&#10;help text provided with them, to 'file' (default stdout).">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.print_usage" func="yes">
			<Overload retVal="" descr="print_usage(file : file = stdout)&#10;&#10;Print the usage message for the current program (self.usage) to&#10;'file' (default stdout).  Any occurrence of the string &quot;%prog&quot; in&#10;self.usage is replaced with the name of the current program&#10;(basename of sys.argv[0]).  Does nothing if self.usage is empty&#10;or not defined.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.print_version" func="yes">
			<Overload retVal="" descr="print_version(file : file = stdout)&#10;&#10;Print the version message for this program (self.version) to&#10;'file' (default stdout).  As with print_usage(), any occurrence&#10;of &quot;%prog&quot; in self.version is replaced by the current program's&#10;name.  Does nothing if self.version is empty or undefined.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.remove_option" />
		<KeyWord name="pip.ConfigOptionParser.set_conflict_handler" />
		<KeyWord name="pip.ConfigOptionParser.set_default" />
		<KeyWord name="pip.ConfigOptionParser.set_defaults" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.ConfigOptionParser.set_description" />
		<KeyWord name="pip.ConfigOptionParser.set_process_default_values" />
		<KeyWord name="pip.ConfigOptionParser.set_usage" />
		<KeyWord name="pip.DependencyWarning" func="yes">
			<Overload retVal="" descr="Warned when an attempt is made to import a module with missing optional&#10;dependencies.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.DependencyWarning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.DependencyWarning.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.FrozenRequirement" />
		<KeyWord name="pip.FrozenRequirement.egg_name" />
		<KeyWord name="pip.FrozenRequirement.from_dist" />
		<KeyWord name="pip.InsecureRequestWarning" func="yes">
			<Overload retVal="" descr="Warned when making an unverified HTTPS request.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.InsecureRequestWarning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.InsecureRequestWarning.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.InstallationError" func="yes">
			<Overload retVal="" descr="General exception during installation">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.InstallationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.InstallationError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.PipError" func="yes">
			<Overload retVal="" descr="Base pip exception">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.PipError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.PipError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter" func="yes">
			<Overload retVal="" descr="Custom help formatter for use in ConfigOptionParser.&#10;&#10;This is updates the defaults before expanding them, allowing&#10;them to show up correctly in the help listing.">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.NO_DEFAULT_VALUE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.dedent" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.expand_default" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.format_description" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.format_epilog" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.format_heading" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.format_option" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.format_option_strings" func="yes">
			<Overload retVal="" descr="Return a comma-separated list of option strings &amp; metavariables.">
				<Param name="self" />
				<Param name="option" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.format_usage" func="yes">
			<Overload retVal="" descr="Ensure there is only one newline between usage and the first heading&#10;if there is no description.">
				<Param name="self" />
				<Param name="usage" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.indent" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.indent_lines" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.set_long_opt_delimiter" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.set_parser" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.set_short_opt_delimiter" />
		<KeyWord name="pip.UpdatingDefaultsHelpFormatter.store_option_strings" />
		<KeyWord name="pip.absolute_import" func="yes">
			<Overload retVal="" descr="(_Feature)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.autocomplete" func="yes">
			<Overload retVal="" descr="Command and option completion for the main option parser (and options)&#10;and its subcommands (and options).&#10;&#10;Enable by sourcing one of the completion shell scripts (bash, zsh or fish).">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.check_isolated" />
		<KeyWord name="pip.commands_dict" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.create_main_parser" />
		<KeyWord name="pip.dist_is_editable" func="yes">
			<Overload retVal="" descr="Is distribution an editable install?">
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.get_installed_distributions" func="yes">
			<Overload retVal="" descr="Return a list of installed Distribution objects.&#10;&#10;If ``local_only`` is True (default), only return installations&#10;local to the current virtualenv, if in a virtualenv.&#10;&#10;``skip`` argument is an iterable of lower-case project names to&#10;ignore; defaults to stdlib_pkgs&#10;&#10;If ``editables`` is False, don't report editables.&#10;&#10;If ``editables_only`` is True , only report editables.&#10;&#10;If ``user_only`` is True , only report installations in the user&#10;site directory.">
				<Param name="[local_only=True" />
				<Param name="[skip=('python', 'wsgiref', 'argparse')" />
				<Param name="[include_editables=True" />
				<Param name="[editables_only=False" />
				<Param name="[user_only=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.get_prog" />
		<KeyWord name="pip.get_similar_commands" func="yes">
			<Overload retVal="" descr="Command name auto-correct.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.get_summaries" func="yes">
			<Overload retVal="" descr="Yields sorted (command name, command summary) tuples.">
				<Param name="[ordered=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.logger" func="yes">
			<Overload retVal="" descr="(Logger)">
			</Overload>
		</KeyWord>
		<KeyWord name="pip.main" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pip.parseopts" />
		<KeyWord name="pipe" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="pipe_connection_lost" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="pipe_data_received" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="pipepager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes" func="yes">
			<Overload retVal="" descr="Conversion pipeline templates.&#10;&#10;The problem:&#10;------------&#10;&#10;Suppose you have some data that you want to convert to another format,&#10;such as from GIF image format to PPM image format.  Maybe the&#10;conversion involves several steps (e.g. piping it through compress or&#10;uuencode).  Some of the conversion steps may require that their input&#10;is a disk file, others may be able to read standard input; similar for&#10;their output.  The input to the entire conversion may also be read&#10;from a disk file or from an open file, and similar for its output.&#10;&#10;The module lets you construct a pipeline template by sticking one or&#10;more conversion steps together.  It will take care of creating and&#10;removing temporary files if they are necessary to hold intermediate&#10;data.  You can then use the template to do conversions from many&#10;different sources to many different destinations.  The temporary&#10;file names used are different each time the template is used.&#10;&#10;The templates are objects so you can create templates for many&#10;different conversion steps and store them in a dictionary, for&#10;instance.&#10;&#10;&#10;Directions:&#10;-----------&#10;&#10;To create a template:&#10;    t = Template()&#10;&#10;To add a conversion step to a template:&#10;   t.append(command, kind)&#10;where kind is a string of two characters: the first is '-' if the&#10;command reads its standard input or 'f' if it requires a file; the&#10;second likewise for the output. The command must be valid /bin/sh&#10;syntax.  If input or output files are required, they are passed as&#10;$IN and $OUT; otherwise, it must be  possible to use the command in&#10;a pipeline.&#10;&#10;To add a conversion step at the beginning:&#10;   t.prepend(command, kind)&#10;&#10;To convert a file to another file using a template:&#10;  sts = t.copy(infile, outfile)&#10;If infile or outfile are the empty string, standard input is read or&#10;standard output is written, respectively.  The return value is the&#10;exit status of the conversion pipeline.&#10;&#10;To open a file for reading or writing through a conversion pipeline:&#10;   fp = t.open(file, mode)&#10;where mode is 'r' to read the file, or 'w' to write it -- just like&#10;for the built-in function open() or for os.popen().&#10;&#10;To create a new template object initialized to a given one:&#10;   t2 = t.clone()">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.FILEIN_FILEOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.FILEIN_STDOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.SINK" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.SOURCE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.STDIN_FILEOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.STDIN_STDOUT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template" func="yes">
			<Overload retVal="" descr="Class representing a pipeline template.">
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.append" func="yes">
			<Overload retVal="" descr="t.append(cmd, kind) adds a new step at the end.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="kind" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.clone" func="yes">
			<Overload retVal="" descr="t.clone() returns a new pipeline template with identical&#10;initial state as the current one.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.copy" />
		<KeyWord name="pipes.Template.debug" func="yes">
			<Overload retVal="" descr="t.debug(flag) turns debugging on or off.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.makepipeline" />
		<KeyWord name="pipes.Template.open" func="yes">
			<Overload retVal="" descr="t.open(file, rw) returns a pipe or file object open for&#10;reading or writing; the file is the other end of the pipeline.">
				<Param name="self" />
				<Param name="file" />
				<Param name="rw" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.open_r" func="yes">
			<Overload retVal="" descr="t.open_r(file) and t.open_w(file) implement&#10;t.open(file, 'r') and t.open(file, 'w') respectively.">
				<Param name="self" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.open_w" />
		<KeyWord name="pipes.Template.prepend" func="yes">
			<Overload retVal="" descr="t.prepend(cmd, kind) adds a new step at the front.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="kind" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.Template.reset" func="yes">
			<Overload retVal="" descr="t.reset() restores a pipeline template to its initial state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.makepipeline" />
		<KeyWord name="pipes.quote" func="yes">
			<Overload retVal="" descr="Return a shell-escaped version of the string *s*.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="pipes.stepkinds" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources" func="yes">
			<Overload retVal="" descr="Package resource API&#10;--------------------&#10;&#10;A resource is a logical file contained within a package, or a logical&#10;subdirectory thereof.  The package resource API expects resource names&#10;to have their path parts separated with ``/``, *not* whatever the local&#10;path separator is.  Do not use os.path operations to manipulate resource&#10;names being passed into the API.&#10;&#10;The package resource API is designed to work with normal filesystem packages,&#10;.egg files, and unpacked .egg files.  It can also work in a limited way with&#10;.zip files and with custom PEP 302 loaders that support the ``get_data()``&#10;method.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions" func="yes">
			<Overload retVal="" descr="Searchable snapshot of distributions on a search path">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions.add" func="yes">
			<Overload retVal="" descr="Add `dist` if we ``can_add()`` it and it has not already been added">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions.best_match" func="yes">
			<Overload retVal="" descr="Find distribution best matching `req` and usable on `working_set`&#10;&#10;This calls the ``find(req)`` method of the `working_set` to see if a&#10;suitable distribution is already active.  (This may raise&#10;``VersionConflict`` if an unsuitable version of the project is already&#10;active in the specified `working_set`.)  If a suitable distribution&#10;isn't active, this method returns the newest distribution in the&#10;environment that meets the ``Requirement`` in `req`.  If no suitable&#10;distribution is found, and `installer` is supplied, then the result of&#10;calling the environment's ``obtain(req, installer)`` method will be&#10;returned.">
				<Param name="self" />
				<Param name="req" />
				<Param name="working_set" />
				<Param name="[installer=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions.can_add" func="yes">
			<Overload retVal="" descr="Is distribution `dist` acceptable for this environment?&#10;&#10;The distribution must match the platform and python version&#10;requirements specified when this environment was created, or False&#10;is returned.">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions.obtain" func="yes">
			<Overload retVal="" descr="Obtain a distribution matching `requirement` (e.g. via download)&#10;&#10;Obtain a distro that matches requirement (e.g. via download).  In the&#10;base ``Environment`` class, this routine just returns&#10;``installer(requirement)``, unless `installer` is None, in which case&#10;None is returned instead.  This method is a hook that allows subclasses&#10;to attempt other ways of obtaining a distribution before falling back&#10;to the `installer` argument.">
				<Param name="self" />
				<Param name="requirement" />
				<Param name="[installer=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions.remove" func="yes">
			<Overload retVal="" descr="Remove `dist` from the environment">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.AvailableDistributions.scan" func="yes">
			<Overload retVal="" descr="Scan `search_path` for distributions usable in this environment&#10;&#10;Any distributions found are added to the environment.&#10;`search_path` should be a sequence of ``sys.path`` items.  If not&#10;supplied, ``sys.path`` is used.  Only distributions conforming to&#10;the platform/python version defined at initialization are added.">
				<Param name="self" />
				<Param name="[search_path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.BINARY_DIST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict" func="yes">
			<Overload retVal="" descr="A VersionConflict that accepts a third parameter, the set of the&#10;requirements that required the installed Distribution.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict.dist" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict.report" />
		<KeyWord name="pkg_resources.ContextualVersionConflict.req" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict.required_by" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict.with_context" func="yes">
			<Overload retVal="" descr="If required_by is non-empty, return a version of self that is a&#10;ContextualVersionConflict.">
				<Param name="self" />
				<Param name="required_by" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualVersionConflict.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile" func="yes">
			<Overload retVal="" descr="Supplement ZipFile class to support context manager for Python 2.6">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.close" func="yes">
			<Overload retVal="" descr="Close the file, and for mode 'w', 'x' and 'a' write the ending&#10;records.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.comment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a ZipInfo object. You can&#10;specify a different directory using `path'.">
				<Param name="self" />
				<Param name="member" />
				<Param name="[path=None" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory. `path' specifies a different directory to extract to.&#10;`members' is optional and must be a subset of the list returned&#10;by namelist().">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[members=None" />
				<Param name="[pwd=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.getinfo" func="yes">
			<Overload retVal="" descr="Return the instance of ZipInfo given 'name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.infolist" func="yes">
			<Overload retVal="" descr="Return a list of class ZipInfo instances for files in the&#10;archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.namelist" func="yes">
			<Overload retVal="" descr="Return a list of file names in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.open" func="yes">
			<Overload retVal="" descr="Return file-like object for 'name'.&#10;&#10;name is a string for the file name within the ZIP file, or a ZipInfo&#10;object.&#10;&#10;mode should be 'r' to read a file already in the ZIP file, or 'w' to&#10;write to a file newly added to the archive.&#10;&#10;pwd is the password to decrypt files (only used for reading).&#10;&#10;When writing, if the file size is not known in advance but may exceed&#10;2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large&#10;files.  If the size is known in advance, it is best to pass a ZipInfo&#10;instance for name, with zinfo.file_size set.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.printdir" func="yes">
			<Overload retVal="" descr="Print a table of contents for the zip file.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.read" func="yes">
			<Overload retVal="" descr="Return file bytes (as a string) for name.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[pwd=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.setpassword" func="yes">
			<Overload retVal="" descr="Set default password for encrypted files.">
				<Param name="self" />
				<Param name="pwd" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.testzip" func="yes">
			<Overload retVal="" descr="Read all the files and check the CRC.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.write" func="yes">
			<Overload retVal="" descr="Put the bytes from filename into the archive under the name&#10;arcname.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="[arcname=None" />
				<Param name="[compress_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ContextualZipFile.writestr" func="yes">
			<Overload retVal="" descr="Write a file into the archive.  The contents is 'data', which&#10;may be either a 'str' or a 'bytes' instance; if it is a 'str',&#10;it is encoded as UTF-8 first.&#10;'zinfo_or_arcname' is either a ZipInfo instance or&#10;the name of the file in the archive.">
				<Param name="self" />
				<Param name="zinfo_or_arcname" />
				<Param name="data" />
				<Param name="[compress_type=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DEVELOP_DIST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DefaultProvider" func="yes">
			<Overload retVal="" descr="Provides access to package resources in the filesystem">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DefaultProvider.get_metadata" />
		<KeyWord name="pkg_resources.DefaultProvider.get_metadata_lines" />
		<KeyWord name="pkg_resources.DefaultProvider.get_resource_filename" />
		<KeyWord name="pkg_resources.DefaultProvider.get_resource_stream" />
		<KeyWord name="pkg_resources.DefaultProvider.get_resource_string" />
		<KeyWord name="pkg_resources.DefaultProvider.has_metadata" />
		<KeyWord name="pkg_resources.DefaultProvider.has_resource" />
		<KeyWord name="pkg_resources.DefaultProvider.metadata_isdir" />
		<KeyWord name="pkg_resources.DefaultProvider.metadata_listdir" />
		<KeyWord name="pkg_resources.DefaultProvider.resource_isdir" />
		<KeyWord name="pkg_resources.DefaultProvider.resource_listdir" />
		<KeyWord name="pkg_resources.DefaultProvider.run_script" />
		<KeyWord name="pkg_resources.DistInfoDistribution" func="yes">
			<Overload retVal="" descr="Wrap an actual or potential sys.path entry w/metadata, .dist-info style">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.EQEQ" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.PKG_INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.activate" func="yes">
			<Overload retVal="" descr="Ensure distribution is importable on `path` (default=sys.path)">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[replace=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.as_requirement" func="yes">
			<Overload retVal="" descr="Return a ``Requirement`` that matches this distribution exactly">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.check_version_conflict" />
		<KeyWord name="pkg_resources.DistInfoDistribution.clone" func="yes">
			<Overload retVal="" descr="Copy this distribution, substituting in any changed keyword args">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.egg_name" func="yes">
			<Overload retVal="" descr="Return what this distribution's standard .egg filename should be">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.extras" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.from_filename" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="filename" />
				<Param name="[metadata=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.from_location" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="location" />
				<Param name="basename" />
				<Param name="[metadata=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.get_entry_info" func="yes">
			<Overload retVal="" descr="Return the EntryPoint object for `group`+`name`, or ``None``">
				<Param name="self" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.get_entry_map" func="yes">
			<Overload retVal="" descr="Return the entry point map for `group`, or the full entry map">
				<Param name="self" />
				<Param name="[group=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.has_version" />
		<KeyWord name="pkg_resources.DistInfoDistribution.hashcmp" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.insert_on" func="yes">
			<Overload retVal="" descr="Ensure self.location is on path&#10;&#10;If replace=False (default):&#10;    - If location is already in path anywhere, do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent.&#10;      - Else: add to the end of path.&#10;If replace=True:&#10;    - If location is already on path anywhere (not eggs)&#10;      or higher priority than its parent (eggs)&#10;      do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent,&#10;        removing any lower-priority entries.&#10;      - Else: add it to the front of path.">
				<Param name="self" />
				<Param name="path" />
				<Param name="[loc=None" />
				<Param name="[replace=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.key" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.load_entry_point" func="yes">
			<Overload retVal="" descr="Return the `name` entry point of `group` or raise ImportError">
				<Param name="self" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.parsed_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.requires" func="yes">
			<Overload retVal="" descr="List of Requirements needed for this distro if `extras` are used">
				<Param name="self" />
				<Param name="[extras=()]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistInfoDistribution.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution" func="yes">
			<Overload retVal="" descr="Wrap an actual or potential sys.path entry w/metadata">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.PKG_INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.activate" func="yes">
			<Overload retVal="" descr="Ensure distribution is importable on `path` (default=sys.path)">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[replace=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.as_requirement" func="yes">
			<Overload retVal="" descr="Return a ``Requirement`` that matches this distribution exactly">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.check_version_conflict" />
		<KeyWord name="pkg_resources.Distribution.clone" func="yes">
			<Overload retVal="" descr="Copy this distribution, substituting in any changed keyword args">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.egg_name" func="yes">
			<Overload retVal="" descr="Return what this distribution's standard .egg filename should be">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.extras" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.from_filename" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="filename" />
				<Param name="[metadata=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.from_location" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="location" />
				<Param name="basename" />
				<Param name="[metadata=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.get_entry_info" func="yes">
			<Overload retVal="" descr="Return the EntryPoint object for `group`+`name`, or ``None``">
				<Param name="self" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.get_entry_map" func="yes">
			<Overload retVal="" descr="Return the entry point map for `group`, or the full entry map">
				<Param name="self" />
				<Param name="[group=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.has_version" />
		<KeyWord name="pkg_resources.Distribution.hashcmp" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.insert_on" func="yes">
			<Overload retVal="" descr="Ensure self.location is on path&#10;&#10;If replace=False (default):&#10;    - If location is already in path anywhere, do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent.&#10;      - Else: add to the end of path.&#10;If replace=True:&#10;    - If location is already on path anywhere (not eggs)&#10;      or higher priority than its parent (eggs)&#10;      do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent,&#10;        removing any lower-priority entries.&#10;      - Else: add it to the front of path.">
				<Param name="self" />
				<Param name="path" />
				<Param name="[loc=None" />
				<Param name="[replace=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.key" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.load_entry_point" func="yes">
			<Overload retVal="" descr="Return the `name` entry point of `group` or raise ImportError">
				<Param name="self" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.parsed_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.requires" func="yes">
			<Overload retVal="" descr="List of Requirements needed for this distro if `extras` are used">
				<Param name="self" />
				<Param name="[extras=()]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Distribution.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistributionNotFound" func="yes">
			<Overload retVal="" descr="A requested distribution was not found">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistributionNotFound.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistributionNotFound.report" />
		<KeyWord name="pkg_resources.DistributionNotFound.req" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistributionNotFound.requirers" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistributionNotFound.requirers_str" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.DistributionNotFound.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EGG_DIST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EGG_NAME" func="yes">
			<Overload retVal="" descr="Matches zero or more characters at the beginning of the string.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution" func="yes">
			<Overload retVal="" descr="Wrap an actual or potential sys.path entry w/metadata">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.PKG_INFO" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.activate" func="yes">
			<Overload retVal="" descr="Ensure distribution is importable on `path` (default=sys.path)">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[replace=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.as_requirement" func="yes">
			<Overload retVal="" descr="Return a ``Requirement`` that matches this distribution exactly">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.check_version_conflict" />
		<KeyWord name="pkg_resources.EggInfoDistribution.clone" func="yes">
			<Overload retVal="" descr="Copy this distribution, substituting in any changed keyword args">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.egg_name" func="yes">
			<Overload retVal="" descr="Return what this distribution's standard .egg filename should be">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.extras" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.from_filename" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="filename" />
				<Param name="[metadata=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.from_location" func="yes">
			<Overload retVal="" descr=>
				<Param name="cls" />
				<Param name="location" />
				<Param name="basename" />
				<Param name="[metadata=None" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.get_entry_info" func="yes">
			<Overload retVal="" descr="Return the EntryPoint object for `group`+`name`, or ``None``">
				<Param name="self" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.get_entry_map" func="yes">
			<Overload retVal="" descr="Return the entry point map for `group`, or the full entry map">
				<Param name="self" />
				<Param name="[group=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.has_version" />
		<KeyWord name="pkg_resources.EggInfoDistribution.hashcmp" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.insert_on" func="yes">
			<Overload retVal="" descr="Ensure self.location is on path&#10;&#10;If replace=False (default):&#10;    - If location is already in path anywhere, do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent.&#10;      - Else: add to the end of path.&#10;If replace=True:&#10;    - If location is already on path anywhere (not eggs)&#10;      or higher priority than its parent (eggs)&#10;      do nothing.&#10;    - Else:&#10;      - If it's an egg and its parent directory is on path,&#10;        insert just ahead of the parent,&#10;        removing any lower-priority entries.&#10;      - Else: add it to the front of path.">
				<Param name="self" />
				<Param name="path" />
				<Param name="[loc=None" />
				<Param name="[replace=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.key" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.load_entry_point" func="yes">
			<Overload retVal="" descr="Return the `name` entry point of `group` or raise ImportError">
				<Param name="self" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.parsed_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.requires" func="yes">
			<Overload retVal="" descr="List of Requirements needed for this distro if `extras` are used">
				<Param name="self" />
				<Param name="[extras=()]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggInfoDistribution.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggMetadata" func="yes">
			<Overload retVal="" descr="Metadata provider for .egg files">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggMetadata.get_metadata" />
		<KeyWord name="pkg_resources.EggMetadata.get_metadata_lines" />
		<KeyWord name="pkg_resources.EggMetadata.get_resource_filename" />
		<KeyWord name="pkg_resources.EggMetadata.get_resource_stream" />
		<KeyWord name="pkg_resources.EggMetadata.get_resource_string" />
		<KeyWord name="pkg_resources.EggMetadata.has_metadata" />
		<KeyWord name="pkg_resources.EggMetadata.has_resource" />
		<KeyWord name="pkg_resources.EggMetadata.metadata_isdir" />
		<KeyWord name="pkg_resources.EggMetadata.metadata_listdir" />
		<KeyWord name="pkg_resources.EggMetadata.resource_isdir" />
		<KeyWord name="pkg_resources.EggMetadata.resource_listdir" />
		<KeyWord name="pkg_resources.EggMetadata.run_script" />
		<KeyWord name="pkg_resources.EggMetadata.zipinfo" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggProvider" func="yes">
			<Overload retVal="" descr="Provider based on a virtual filesystem">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EggProvider.get_metadata" />
		<KeyWord name="pkg_resources.EggProvider.get_metadata_lines" />
		<KeyWord name="pkg_resources.EggProvider.get_resource_filename" />
		<KeyWord name="pkg_resources.EggProvider.get_resource_stream" />
		<KeyWord name="pkg_resources.EggProvider.get_resource_string" />
		<KeyWord name="pkg_resources.EggProvider.has_metadata" />
		<KeyWord name="pkg_resources.EggProvider.has_resource" />
		<KeyWord name="pkg_resources.EggProvider.metadata_isdir" />
		<KeyWord name="pkg_resources.EggProvider.metadata_listdir" />
		<KeyWord name="pkg_resources.EggProvider.resource_isdir" />
		<KeyWord name="pkg_resources.EggProvider.resource_listdir" />
		<KeyWord name="pkg_resources.EggProvider.run_script" />
		<KeyWord name="pkg_resources.EmptyProvider" func="yes">
			<Overload retVal="" descr="Provider that returns nothing for all requests">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EmptyProvider.get_metadata" />
		<KeyWord name="pkg_resources.EmptyProvider.get_metadata_lines" />
		<KeyWord name="pkg_resources.EmptyProvider.get_resource_filename" />
		<KeyWord name="pkg_resources.EmptyProvider.get_resource_stream" />
		<KeyWord name="pkg_resources.EmptyProvider.get_resource_string" />
		<KeyWord name="pkg_resources.EmptyProvider.has_metadata" />
		<KeyWord name="pkg_resources.EmptyProvider.has_resource" />
		<KeyWord name="pkg_resources.EmptyProvider.metadata_isdir" />
		<KeyWord name="pkg_resources.EmptyProvider.metadata_listdir" />
		<KeyWord name="pkg_resources.EmptyProvider.resource_isdir" />
		<KeyWord name="pkg_resources.EmptyProvider.resource_listdir" />
		<KeyWord name="pkg_resources.EmptyProvider.run_script" />
		<KeyWord name="pkg_resources.EntryPoint" func="yes">
			<Overload retVal="" descr="Object representing an advertised importable object">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.load" func="yes">
			<Overload retVal="" descr="Require packages for this EntryPoint, then resolve it.">
				<Param name="self" />
				<Param name="[require=True" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.parse" func="yes">
			<Overload retVal="" descr="Parse a single entry point from string `src`&#10;&#10;Entry point syntax follows the form::&#10;&#10;    name = some.module:some.attr [extra1, extra2]&#10;&#10;The entry name and module name are required, but the ``:attrs`` and&#10;``[extras]`` parts are optional">
				<Param name="cls" />
				<Param name="src" />
				<Param name="[dist=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.parse_group" func="yes">
			<Overload retVal="" descr="Parse an entry point group">
				<Param name="cls" />
				<Param name="group" />
				<Param name="lines" />
				<Param name="[dist=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.parse_map" func="yes">
			<Overload retVal="" descr="Parse a map of entry point groups">
				<Param name="cls" />
				<Param name="data" />
				<Param name="[dist=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.pattern" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.require" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[env=None" />
				<Param name="[installer=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.EntryPoint.resolve" func="yes">
			<Overload retVal="" descr="Resolve the entry point from its module and attrs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment" func="yes">
			<Overload retVal="" descr="Searchable snapshot of distributions on a search path">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment.add" func="yes">
			<Overload retVal="" descr="Add `dist` if we ``can_add()`` it and it has not already been added">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment.best_match" func="yes">
			<Overload retVal="" descr="Find distribution best matching `req` and usable on `working_set`&#10;&#10;This calls the ``find(req)`` method of the `working_set` to see if a&#10;suitable distribution is already active.  (This may raise&#10;``VersionConflict`` if an unsuitable version of the project is already&#10;active in the specified `working_set`.)  If a suitable distribution&#10;isn't active, this method returns the newest distribution in the&#10;environment that meets the ``Requirement`` in `req`.  If no suitable&#10;distribution is found, and `installer` is supplied, then the result of&#10;calling the environment's ``obtain(req, installer)`` method will be&#10;returned.">
				<Param name="self" />
				<Param name="req" />
				<Param name="working_set" />
				<Param name="[installer=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment.can_add" func="yes">
			<Overload retVal="" descr="Is distribution `dist` acceptable for this environment?&#10;&#10;The distribution must match the platform and python version&#10;requirements specified when this environment was created, or False&#10;is returned.">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment.obtain" func="yes">
			<Overload retVal="" descr="Obtain a distribution matching `requirement` (e.g. via download)&#10;&#10;Obtain a distro that matches requirement (e.g. via download).  In the&#10;base ``Environment`` class, this routine just returns&#10;``installer(requirement)``, unless `installer` is None, in which case&#10;None is returned instead.  This method is a hook that allows subclasses&#10;to attempt other ways of obtaining a distribution before falling back&#10;to the `installer` argument.">
				<Param name="self" />
				<Param name="requirement" />
				<Param name="[installer=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment.remove" func="yes">
			<Overload retVal="" descr="Remove `dist` from the environment">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Environment.scan" func="yes">
			<Overload retVal="" descr="Scan `search_path` for distributions usable in this environment&#10;&#10;Any distributions found are added to the environment.&#10;`search_path` should be a sequence of ``sys.path`` items.  If not&#10;supplied, ``sys.path`` is used.  Only distributions conforming to&#10;the platform/python version defined at initialization are added.">
				<Param name="self" />
				<Param name="[search_path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ExtractionError" func="yes">
			<Overload retVal="" descr="An error occurred extracting a resource&#10;&#10;The following attributes are available from instances of this exception:&#10;&#10;manager&#10;    The resource manager that raised this exception&#10;&#10;cache_path&#10;    The base directory for resource extraction&#10;&#10;original_error&#10;    The exception instance that caused extraction to fail">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ExtractionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ExtractionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.FileMetadata" func="yes">
			<Overload retVal="" descr='Metadata handler for standalone PKG-INFO files&#10;&#10;Usage::&#10;&#10;    metadata = FileMetadata("/path/to/PKG-INFO")&#10;&#10;This provider rejects all data and metadata requests except for PKG-INFO,&#10;which is treated as existing, and will be the contents of the file at&#10;the provided location.'>
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.FileMetadata.get_metadata" />
		<KeyWord name="pkg_resources.FileMetadata.get_metadata_lines" />
		<KeyWord name="pkg_resources.FileMetadata.get_resource_filename" />
		<KeyWord name="pkg_resources.FileMetadata.get_resource_stream" />
		<KeyWord name="pkg_resources.FileMetadata.get_resource_string" />
		<KeyWord name="pkg_resources.FileMetadata.has_metadata" />
		<KeyWord name="pkg_resources.FileMetadata.has_resource" />
		<KeyWord name="pkg_resources.FileMetadata.metadata_isdir" />
		<KeyWord name="pkg_resources.FileMetadata.metadata_listdir" />
		<KeyWord name="pkg_resources.FileMetadata.resource_isdir" />
		<KeyWord name="pkg_resources.FileMetadata.resource_listdir" />
		<KeyWord name="pkg_resources.FileMetadata.run_script" />
		<KeyWord name="pkg_resources.IMetadataProvider" />
		<KeyWord name="pkg_resources.IMetadataProvider.get_metadata" func="yes">
			<Overload retVal="" descr="The named metadata resource as a string">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IMetadataProvider.get_metadata_lines" func="yes">
			<Overload retVal="" descr="Yield named metadata resource as list of non-blank non-comment lines&#10;&#10;Leading and trailing whitespace is stripped from each line, and lines&#10;with ``#`` as the first non-blank character are omitted.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IMetadataProvider.has_metadata" func="yes">
			<Overload retVal="" descr="Does the package's distribution contain the named metadata?">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IMetadataProvider.metadata_isdir" func="yes">
			<Overload retVal="" descr="Is the named metadata a directory?  (like ``os.path.isdir()``)">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IMetadataProvider.metadata_listdir" func="yes">
			<Overload retVal="" descr="List of metadata names in the directory (like ``os.listdir()``)">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IMetadataProvider.run_script" func="yes">
			<Overload retVal="" descr="Execute the named script in the supplied namespace dictionary">
				<Param name="script_name" />
				<Param name="namespace" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider" func="yes">
			<Overload retVal="" descr="An object that provides access to package resources">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.get_metadata" func="yes">
			<Overload retVal="" descr="The named metadata resource as a string">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.get_metadata_lines" func="yes">
			<Overload retVal="" descr="Yield named metadata resource as list of non-blank non-comment lines&#10;&#10;Leading and trailing whitespace is stripped from each line, and lines&#10;with ``#`` as the first non-blank character are omitted.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.get_resource_filename" func="yes">
			<Overload retVal="" descr="Return a true filesystem path for `resource_name`&#10;&#10;`manager` must be an ``IResourceManager``">
				<Param name="manager" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.get_resource_stream" func="yes">
			<Overload retVal="" descr="Return a readable file-like object for `resource_name`&#10;&#10;`manager` must be an ``IResourceManager``">
				<Param name="manager" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.get_resource_string" func="yes">
			<Overload retVal="" descr="Return a string containing the contents of `resource_name`&#10;&#10;`manager` must be an ``IResourceManager``">
				<Param name="manager" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.has_metadata" func="yes">
			<Overload retVal="" descr="Does the package's distribution contain the named metadata?">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.has_resource" func="yes">
			<Overload retVal="" descr="Does the package contain the named resource?">
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.metadata_isdir" func="yes">
			<Overload retVal="" descr="Is the named metadata a directory?  (like ``os.path.isdir()``)">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.metadata_listdir" func="yes">
			<Overload retVal="" descr="List of metadata names in the directory (like ``os.listdir()``)">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.resource_isdir" func="yes">
			<Overload retVal="" descr="Is the named resource a directory?  (like ``os.path.isdir()``)">
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.resource_listdir" func="yes">
			<Overload retVal="" descr="List of resource names in the directory (like ``os.listdir()``)">
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.IResourceProvider.run_script" func="yes">
			<Overload retVal="" descr="Execute the named script in the supplied namespace dictionary">
				<Param name="script_name" />
				<Param name="namespace" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MODULE" func="yes">
			<Overload retVal="" descr="Matches zero or more characters at the beginning of the string.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests" func="yes">
			<Overload retVal="" descr="Memoized zipfile manifests.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.build" func="yes">
			<Overload retVal="" descr="Build a dictionary similar to the zipimport directory&#10;caches, except instead of tuples, store ZipInfo objects.&#10;&#10;Use a platform-specific path separator (os.sep) for the path keys&#10;for compatibility with pypy on Windows.">
				<Param name="cls" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="type" />
				<Param name="iterable" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.load" func="yes">
			<Overload retVal="" descr="Load a manifest at path or return a suitable manifest already loaded.">
				<Param name="self" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.manifest_mod" func="yes">
			<Overload retVal="" descr="manifest_mod(manifest, mtime)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.MemoizedZipManifests.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.NullProvider" func="yes">
			<Overload retVal="" descr="Try to implement resources and metadata for arbitrary PEP 302 loaders">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.NullProvider.get_metadata" />
		<KeyWord name="pkg_resources.NullProvider.get_metadata_lines" />
		<KeyWord name="pkg_resources.NullProvider.get_resource_filename" />
		<KeyWord name="pkg_resources.NullProvider.get_resource_stream" />
		<KeyWord name="pkg_resources.NullProvider.get_resource_string" />
		<KeyWord name="pkg_resources.NullProvider.has_metadata" />
		<KeyWord name="pkg_resources.NullProvider.has_resource" />
		<KeyWord name="pkg_resources.NullProvider.metadata_isdir" />
		<KeyWord name="pkg_resources.NullProvider.metadata_listdir" />
		<KeyWord name="pkg_resources.NullProvider.resource_isdir" />
		<KeyWord name="pkg_resources.NullProvider.resource_listdir" />
		<KeyWord name="pkg_resources.NullProvider.run_script" />
		<KeyWord name="pkg_resources.PEP440Warning" func="yes">
			<Overload retVal="" descr="Used when there is an issue with a version or specifier not complying with&#10;PEP 440.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.PEP440Warning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.PEP440Warning.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.PY_MAJOR" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.PathMetadata" func="yes">
			<Overload retVal="" descr="Metadata provider for egg directories&#10;&#10;Usage::&#10;&#10;    # Development eggs:&#10;&#10;    egg_info = &quot;/path/to/PackageName.egg-info&quot;&#10;    base_dir = os.path.dirname(egg_info)&#10;    metadata = PathMetadata(base_dir, egg_info)&#10;    dist_name = os.path.splitext(os.path.basename(egg_info))[0]&#10;    dist = Distribution(basedir, project_name=dist_name, metadata=metadata)&#10;&#10;    # Unpacked egg directories:&#10;&#10;    egg_path = &quot;/path/to/PackageName-ver-pyver-etc.egg&quot;&#10;    metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))&#10;    dist = Distribution.from_filename(egg_path, metadata=metadata)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.PathMetadata.get_metadata" />
		<KeyWord name="pkg_resources.PathMetadata.get_metadata_lines" />
		<KeyWord name="pkg_resources.PathMetadata.get_resource_filename" />
		<KeyWord name="pkg_resources.PathMetadata.get_resource_stream" />
		<KeyWord name="pkg_resources.PathMetadata.get_resource_string" />
		<KeyWord name="pkg_resources.PathMetadata.has_metadata" />
		<KeyWord name="pkg_resources.PathMetadata.has_resource" />
		<KeyWord name="pkg_resources.PathMetadata.metadata_isdir" />
		<KeyWord name="pkg_resources.PathMetadata.metadata_listdir" />
		<KeyWord name="pkg_resources.PathMetadata.resource_isdir" />
		<KeyWord name="pkg_resources.PathMetadata.resource_listdir" />
		<KeyWord name="pkg_resources.PathMetadata.run_script" />
		<KeyWord name="pkg_resources.Requirement" func="yes">
			<Overload retVal="" descr="Parse a requirement.&#10;&#10;Parse a given requirement string into its parts, such as name, specifier,&#10;URL, and extras. Raises InvalidRequirement on a badly-formed requirement&#10;string.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.Requirement.parse" />
		<KeyWord name="pkg_resources.RequirementParseError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.RequirementParseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.RequirementParseError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResolutionError" func="yes">
			<Overload retVal="" descr="Abstract base for dependency resolution errors">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResolutionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResolutionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager" func="yes">
			<Overload retVal="" descr="Manage resource extraction and packages">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.cleanup_resources" func="yes">
			<Overload retVal="" descr="Delete all extracted resource files and directories, returning a list&#10;of the file and directory names that could not be successfully removed.&#10;This function does not have any concurrency protection, so it should&#10;generally only be called when the extraction path is a temporary&#10;directory exclusive to a single process.  This method is not&#10;automatically called; you must call it explicitly or register it as an&#10;``atexit`` function if you wish to ensure cleanup of a temporary&#10;directory used for extractions.">
				<Param name="self" />
				<Param name="[force=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.extraction_error" func="yes">
			<Overload retVal="" descr="Give an error message for problems extracting file(s)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.get_cache_path" func="yes">
			<Overload retVal="" descr="Return absolute location in cache for `archive_name` and `names`&#10;&#10;The parent directory of the resulting path will be created if it does&#10;not already exist.  `archive_name` should be the base filename of the&#10;enclosing egg (which may not be the name of the enclosing zipfile!),&#10;including its &quot;.egg&quot; extension.  `names`, if provided, should be a&#10;sequence of path name parts &quot;under&quot; the egg's extraction location.&#10;&#10;This method should only be called by resource providers that need to&#10;obtain an extraction location, and only for names they intend to&#10;extract, as it tracks the generated names for possible cleanup later.">
				<Param name="self" />
				<Param name="archive_name" />
				<Param name="[names=()]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.postprocess" func="yes">
			<Overload retVal="" descr="Perform any platform-specific postprocessing of `tempname`&#10;&#10;This is where Mac header rewrites should be done; other platforms don't&#10;have anything special they should do.&#10;&#10;Resource providers should call this method ONLY after successfully&#10;extracting a compressed resource.  They must NOT call it on resources&#10;that are already in the filesystem.&#10;&#10;`tempname` is the current (temporary) name of the file, and `filename`&#10;is the name it will be renamed to by the caller after this routine&#10;returns.">
				<Param name="self" />
				<Param name="tempname" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.resource_exists" func="yes">
			<Overload retVal="" descr="Does the named resource exist?">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.resource_filename" func="yes">
			<Overload retVal="" descr="Return a true filesystem path for specified resource">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.resource_isdir" func="yes">
			<Overload retVal="" descr="Is the named resource an existing directory?">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.resource_listdir" func="yes">
			<Overload retVal="" descr="List the contents of the named resource directory">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.resource_stream" func="yes">
			<Overload retVal="" descr="Return a readable file-like object for specified resource">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.resource_string" func="yes">
			<Overload retVal="" descr="Return specified resource as a string">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ResourceManager.set_extraction_path" func="yes">
			<Overload retVal="" descr="Set the base path where resources will be extracted to, if needed.&#10;&#10;If you do not call this routine before any extractions take place, the&#10;path defaults to the return value of ``get_default_cache()``.  (Which&#10;is based on the ``PYTHON_EGG_CACHE`` environment variable, with various&#10;platform-specific fallbacks.  See that routine's documentation for more&#10;details.)&#10;&#10;Resources are extracted to subdirectories of this path based upon&#10;information given by the ``IResourceProvider``.  You may set this to a&#10;temporary directory, but then you must call ``cleanup_resources()`` to&#10;delete the extracted files when done.  There is no guarantee that&#10;``cleanup_resources()`` will be able to remove all extracted files.&#10;&#10;(Note: you may not change the extraction path for a given resource&#10;manager once resources have been extracted, unless you first call&#10;``cleanup_resources()``.)">
				<Param name="self" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SOURCE_DIST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsLegacyVersion" />
		<KeyWord name="pkg_resources.SetuptoolsLegacyVersion.base_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsLegacyVersion.is_postrelease" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsLegacyVersion.is_prerelease" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsLegacyVersion.local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsLegacyVersion.public" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsVersion" />
		<KeyWord name="pkg_resources.SetuptoolsVersion.base_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsVersion.is_postrelease" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsVersion.is_prerelease" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsVersion.local" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.SetuptoolsVersion.public" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.UnknownExtra" func="yes">
			<Overload retVal="" descr="Distribution doesn't have an &quot;extra feature&quot; of the given name">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.UnknownExtra.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.UnknownExtra.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.VersionConflict" func="yes">
			<Overload retVal="" descr="An already-installed version conflicts with the requested version.&#10;&#10;Should be initialized with the installed Distribution and the requested&#10;Requirement.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.VersionConflict.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.VersionConflict.dist" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.VersionConflict.report" />
		<KeyWord name="pkg_resources.VersionConflict.req" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.VersionConflict.with_context" func="yes">
			<Overload retVal="" descr="If required_by is non-empty, return a version of self that is a&#10;ContextualVersionConflict.">
				<Param name="self" />
				<Param name="required_by" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.VersionConflict.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WRITE_SUPPORT" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet" func="yes">
			<Overload retVal="" descr="A collection of active distributions on sys.path (or a similar list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.add" func="yes">
			<Overload retVal="" descr="Add `dist` to working set, associated with `entry`&#10;&#10;If `entry` is unspecified, it defaults to the ``.location`` of `dist`.&#10;On exit from this routine, `entry` is added to the end of the working&#10;set's ``.entries`` (if it wasn't already present).&#10;&#10;`dist` is only added to the working set if it's for a project that&#10;doesn't already have a distribution in the set, unless `replace=True`.&#10;If it's added, any callbacks registered with the ``subscribe()`` method&#10;will be called.">
				<Param name="self" />
				<Param name="dist" />
				<Param name="[entry=None" />
				<Param name="[insert=True" />
				<Param name="[replace=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.add_entry" func="yes">
			<Overload retVal="" descr="Add a path item to ``.entries``, finding any distributions on it&#10;&#10;``find_distributions(entry, True)`` is used to find distributions&#10;corresponding to the path entry, and they are added.  `entry` is&#10;always appended to ``.entries``, even if it is already present.&#10;(This is because ``sys.path`` can contain the same value more than&#10;once, and the ``.entries`` of the ``sys.path`` WorkingSet should always&#10;equal ``sys.path``.)">
				<Param name="self" />
				<Param name="entry" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.find" func="yes">
			<Overload retVal="" descr="Find a distribution matching requirement `req`&#10;&#10;If there is an active distribution for the requested project, this&#10;returns it as long as it meets the version requirement specified by&#10;`req`.  But, if there is an active distribution for the project and it&#10;does *not* meet the `req` requirement, ``VersionConflict`` is raised.&#10;If there is no active distribution for the requested project, ``None``&#10;is returned.">
				<Param name="self" />
				<Param name="req" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.find_plugins" func="yes">
			<Overload retVal="" descr="Find all activatable distributions in `plugin_env`&#10;&#10;Example usage::&#10;&#10;    distributions, errors = working_set.find_plugins(&#10;        Environment(plugin_dirlist)&#10;    )&#10;    # add plugins+libs to sys.path&#10;    map(working_set.add, distributions)&#10;    # display errors&#10;    print('Could not load', errors)&#10;&#10;The `plugin_env` should be an ``Environment`` instance that contains&#10;only distributions that are in the project's &quot;plugin directory&quot; or&#10;directories. The `full_env`, if supplied, should be an ``Environment``&#10;contains all currently-available distributions.  If `full_env` is not&#10;supplied, one is created automatically from the ``WorkingSet`` this&#10;method is called on, which will typically mean that every directory on&#10;``sys.path`` will be scanned for distributions.&#10;&#10;`installer` is a standard installer callback as used by the&#10;``resolve()`` method. The `fallback` flag indicates whether we should&#10;attempt to resolve older versions of a plugin if the newest version&#10;cannot be resolved.&#10;&#10;This method returns a 2-tuple: (`distributions`, `error_info`), where&#10;`distributions` is a list of the distributions found in `plugin_env`&#10;that were loadable, along with any other distributions that are needed&#10;to resolve their dependencies.  `error_info` is a dictionary mapping&#10;unloadable plugin distributions to an exception instance describing the&#10;error that occurred. Usually this will be a ``DistributionNotFound`` or&#10;``VersionConflict`` instance.">
				<Param name="self" />
				<Param name="plugin_env" />
				<Param name="[full_env=None" />
				<Param name="[installer=None" />
				<Param name="[fallback=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.iter_entry_points" func="yes">
			<Overload retVal="" descr="Yield entry point objects from `group` matching `name`&#10;&#10;If `name` is None, yields all entry points in `group` from all&#10;distributions in the working set, otherwise only ones matching&#10;both `group` and `name` are yielded (in distribution order).">
				<Param name="self" />
				<Param name="group" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.require" func="yes">
			<Overload retVal="" descr="Ensure that distributions matching `requirements` are activated&#10;&#10;`requirements` must be a string or a (possibly-nested) sequence&#10;thereof, specifying the distributions and versions required.  The&#10;return value is a sequence of the distributions that needed to be&#10;activated to fulfill the requirements; all relevant distributions are&#10;included, even if they were already activated in this working set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.resolve" func="yes">
			<Overload retVal="" descr="List all distributions needed to (recursively) meet `requirements`&#10;&#10;`requirements` must be a sequence of ``Requirement`` objects.  `env`,&#10;if supplied, should be an ``Environment`` instance.  If&#10;not supplied, it defaults to all distributions available within any&#10;entry or distribution in the working set.  `installer`, if supplied,&#10;will be invoked with each requirement that cannot be met by an&#10;already-installed distribution; it should return a ``Distribution`` or&#10;``None``.&#10;&#10;Unless `replace_conflicting=True`, raises a VersionConflict exception if&#10;any requirements are found on the path that have the correct name but&#10;the wrong version.  Otherwise, if an `installer` is supplied it will be&#10;invoked to obtain the correct version of the requirement and activate&#10;it.">
				<Param name="self" />
				<Param name="requirements" />
				<Param name="[env=None" />
				<Param name="[installer=None" />
				<Param name="[replace_conflicting=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.run_script" func="yes">
			<Overload retVal="" descr="Locate distribution for `requires` and run `script_name` script">
				<Param name="self" />
				<Param name="requires" />
				<Param name="script_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.WorkingSet.subscribe" func="yes">
			<Overload retVal="" descr="Invoke `callback` for all distributions&#10;&#10;If `existing=True` (default),&#10;call on all existing ones, as well.">
				<Param name="self" />
				<Param name="callback" />
				<Param name="[existing=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests" func="yes">
			<Overload retVal="" descr="zip manifest builder">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.build" func="yes">
			<Overload retVal="" descr="Build a dictionary similar to the zipimport directory&#10;caches, except instead of tuples, store ZipInfo objects.&#10;&#10;Use a platform-specific path separator (os.sep) for the path keys&#10;for compatibility with pypy on Windows.">
				<Param name="cls" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="type" />
				<Param name="iterable" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.load" func="yes">
			<Overload retVal="" descr="Build a dictionary similar to the zipimport directory&#10;caches, except instead of tuples, store ZipInfo objects.&#10;&#10;Use a platform-specific path separator (os.sep) for the path keys&#10;for compatibility with pypy on Windows.">
				<Param name="cls" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipManifests.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipProvider" func="yes">
			<Overload retVal="" descr="Resource support for zips and eggs">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ZipProvider.get_metadata" />
		<KeyWord name="pkg_resources.ZipProvider.get_metadata_lines" />
		<KeyWord name="pkg_resources.ZipProvider.get_resource_filename" />
		<KeyWord name="pkg_resources.ZipProvider.get_resource_stream" />
		<KeyWord name="pkg_resources.ZipProvider.get_resource_string" />
		<KeyWord name="pkg_resources.ZipProvider.has_metadata" />
		<KeyWord name="pkg_resources.ZipProvider.has_resource" />
		<KeyWord name="pkg_resources.ZipProvider.metadata_isdir" />
		<KeyWord name="pkg_resources.ZipProvider.metadata_listdir" />
		<KeyWord name="pkg_resources.ZipProvider.resource_isdir" />
		<KeyWord name="pkg_resources.ZipProvider.resource_listdir" />
		<KeyWord name="pkg_resources.ZipProvider.run_script" />
		<KeyWord name="pkg_resources.ZipProvider.zipinfo" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.absolute_import" func="yes">
			<Overload retVal="" descr="(_Feature)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.add_activation_listener" func="yes">
			<Overload retVal="" descr="Invoke `callback` for all distributions&#10;&#10;If `existing=True` (default),&#10;call on all existing ones, as well.">
				<Param name="self" />
				<Param name="callback" />
				<Param name="[existing=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.cleanup_resources" func="yes">
			<Overload retVal="" descr="Delete all extracted resource files and directories, returning a list&#10;of the file and directory names that could not be successfully removed.&#10;This function does not have any concurrency protection, so it should&#10;generally only be called when the extraction path is a temporary&#10;directory exclusive to a single process.  This method is not&#10;automatically called; you must call it explicitly or register it as an&#10;``atexit`` function if you wish to ensure cleanup of a temporary&#10;directory used for extractions.">
				<Param name="self" />
				<Param name="[force=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.compatible_platforms" func="yes">
			<Overload retVal="" descr="Can code for the `provided` platform run on the `required` platform?&#10;&#10;Returns true if either platform is ``None``, or the platforms are equal.&#10;&#10;XXX Needs compatibility checks for Linux and other unixy OSes.">
				<Param name="provided" />
				<Param name="required" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.darwinVersionString" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.declare_namespace" func="yes">
			<Overload retVal="" descr="Declare that package 'packageName' is a namespace package">
				<Param name="packageName" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.empty_provider" func="yes">
			<Overload retVal="" descr="(EmptyProvider)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.ensure_directory" func="yes">
			<Overload retVal="" descr="Ensure that the parent directory of `path` exists">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.evaluate_marker" func="yes">
			<Overload retVal="" descr="Evaluate a PEP 508 environment marker.&#10;Return a boolean indicating the marker result in this environment.&#10;Raise SyntaxError if marker is invalid.&#10;&#10;This implementation uses the 'pyparsing' module.">
				<Param name="text" />
				<Param name="[extra=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.extraction_error" func="yes">
			<Overload retVal="" descr="Give an error message for problems extracting file(s)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.file_ns_handler" func="yes">
			<Overload retVal="" descr="Compute an ns-package subpath for a filesystem or zipfile importer">
				<Param name="importer" />
				<Param name="path_item" />
				<Param name="packageName" />
				<Param name="module" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.filter" func="yes">
			<Overload retVal="" descr="filter(function or None, iterable) --&gt; filter object&#10;&#10;Return an iterator yielding those items of iterable for which function(item)&#10;is true. If function is None, return the items that are true.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.find_distributions" func="yes">
			<Overload retVal="" descr="Yield distributions accessible via `path_item`">
				<Param name="path_item" />
				<Param name="[only=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.find_eggs_in_zip" func="yes">
			<Overload retVal="" descr="Find eggs in zip files; possibly multiple nested eggs.">
				<Param name="importer" />
				<Param name="path_item" />
				<Param name="[only=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.find_nothing" func="yes">
			<Overload retVal="" descr=>
				<Param name="importer" />
				<Param name="path_item" />
				<Param name="[only=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.find_on_path" func="yes">
			<Overload retVal="" descr="Yield distributions accessible on a sys.path directory">
				<Param name="importer" />
				<Param name="path_item" />
				<Param name="[only=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.fixup_namespace_packages" func="yes">
			<Overload retVal="" descr="Ensure that previously-declared namespace packages include path_item">
				<Param name="path_item" />
				<Param name="[parent=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_build_platform" func="yes">
			<Overload retVal="" descr="Return this platform's string for platform-specific distributions&#10;&#10;XXX Currently this is the same as ``distutils.util.get_platform()``, but it&#10;needs some hacks for Linux and Mac OS X.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_cache_path" func="yes">
			<Overload retVal="" descr="Return absolute location in cache for `archive_name` and `names`&#10;&#10;The parent directory of the resulting path will be created if it does&#10;not already exist.  `archive_name` should be the base filename of the&#10;enclosing egg (which may not be the name of the enclosing zipfile!),&#10;including its &quot;.egg&quot; extension.  `names`, if provided, should be a&#10;sequence of path name parts &quot;under&quot; the egg's extraction location.&#10;&#10;This method should only be called by resource providers that need to&#10;obtain an extraction location, and only for names they intend to&#10;extract, as it tracks the generated names for possible cleanup later.">
				<Param name="self" />
				<Param name="archive_name" />
				<Param name="[names=()]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_default_cache" func="yes">
			<Overload retVal="" descr='Return the ``PYTHON_EGG_CACHE`` environment variable&#10;or a platform-relevant user cache dir for an app&#10;named "Python-Eggs".'>
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_distribution" func="yes">
			<Overload retVal="" descr="Return a current distribution object for a Requirement or string">
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_entry_info" func="yes">
			<Overload retVal="" descr="Return the EntryPoint object for `group`+`name`, or ``None``">
				<Param name="dist" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_entry_map" func="yes">
			<Overload retVal="" descr="Return the entry point map for `group`, or the full entry map">
				<Param name="dist" />
				<Param name="[group=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_importer" func="yes">
			<Overload retVal="" descr="Retrieve a finder for the given path item&#10;&#10;The returned finder is cached in sys.path_importer_cache&#10;if it was newly created by a path hook.&#10;&#10;The cache (or part of it) can be cleared manually if a&#10;rescan of sys.path_hooks is necessary.">
				<Param name="path_item" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_platform" func="yes">
			<Overload retVal="" descr="Return this platform's string for platform-specific distributions&#10;&#10;XXX Currently this is the same as ``distutils.util.get_platform()``, but it&#10;needs some hacks for Linux and Mac OS X.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_provider" func="yes">
			<Overload retVal="" descr="Return an IResourceProvider for the named module or requirement">
				<Param name="moduleOrReq" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.get_supported_platform" func="yes">
			<Overload retVal="" descr="Return this platform's maximum compatible version.&#10;&#10;distutils.util.get_platform() normally reports the minimum version&#10;of Mac OS X that would be required to *use* extensions produced by&#10;distutils.  But what we want when checking compatibility is to know the&#10;version of Mac OS X that we are *running*.  To allow usage of packages that&#10;explicitly require a newer version of Mac OS X, we must also know the&#10;current version of the OS.&#10;&#10;If this condition occurs for any other platform with a version in its&#10;platform strings, this function should be extended accordingly.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.invalid_marker" func="yes">
			<Overload retVal="" descr="Validate text as a PEP 508 environment marker; return an exception&#10;if invalid or False otherwise.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.issue_warning" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.iter_entry_points" func="yes">
			<Overload retVal="" descr="Yield entry point objects from `group` matching `name`&#10;&#10;If `name` is None, yields all entry points in `group` from all&#10;distributions in the working set, otherwise only ones matching&#10;both `group` and `name` are yielded (in distribution order).">
				<Param name="self" />
				<Param name="group" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.load_entry_point" func="yes">
			<Overload retVal="" descr="Return `name` entry point of `group` for `dist` or raise ImportError">
				<Param name="dist" />
				<Param name="group" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.macosVersionString" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.map" func="yes">
			<Overload retVal="" descr="map(func, *iterables) --&gt; map object&#10;&#10;Make an iterator that computes the function using arguments from&#10;each of the iterables.  Stops when the shortest iterable is exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.mkdir" func="yes">
			<Overload retVal="" descr="Create a directory.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.&#10;&#10;The mode argument is ignored on Windows.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.normalize_path" func="yes">
			<Overload retVal="" descr="Normalize a file/dir name for comparison purposes">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.null_ns_handler" />
		<KeyWord name="pkg_resources.os_open" func="yes">
			<Overload retVal="" descr="Open a file for low level IO.  Returns a file descriptor (integer).&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.parse_requirements" func="yes">
			<Overload retVal="" descr="Yield ``Requirement`` objects for each specification in `strs`&#10;&#10;`strs` must be a string, or a (possibly-nested) iterable thereof.">
				<Param name="strs" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.parse_version" />
		<KeyWord name="pkg_resources.postprocess" func="yes">
			<Overload retVal="" descr="Perform any platform-specific postprocessing of `tempname`&#10;&#10;This is where Mac header rewrites should be done; other platforms don't&#10;have anything special they should do.&#10;&#10;Resource providers should call this method ONLY after successfully&#10;extracting a compressed resource.  They must NOT call it on resources&#10;that are already in the filesystem.&#10;&#10;`tempname` is the current (temporary) name of the file, and `filename`&#10;is the name it will be renamed to by the caller after this routine&#10;returns.">
				<Param name="self" />
				<Param name="tempname" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.register_finder" func="yes">
			<Overload retVal="" descr='Register `distribution_finder` to find distributions in sys.path items&#10;&#10;`importer_type` is the type or class of a PEP 302 "Importer" (sys.path item&#10;handler), and `distribution_finder` is a callable that, passed a path&#10;item and the importer instance, yields ``Distribution`` instances found on&#10;that path item.  See ``pkg_resources.find_on_path`` for an example.'>
				<Param name="importer_type" />
				<Param name="distribution_finder" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.register_loader_type" func="yes">
			<Overload retVal="" descr="Register `provider_factory` to make providers for `loader_type`&#10;&#10;`loader_type` is the type or class of a PEP 302 ``module.__loader__``,&#10;and `provider_factory` is a function that, passed a *module* object,&#10;returns an ``IResourceProvider`` for that module.">
				<Param name="loader_type" />
				<Param name="provider_factory" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.register_namespace_handler" func="yes">
			<Overload retVal="" descr='Register `namespace_handler` to declare namespace packages&#10;&#10;`importer_type` is the type or class of a PEP 302 "Importer" (sys.path item&#10;handler), and `namespace_handler` is a callable like this::&#10;&#10;    def namespace_handler(importer, path_entry, moduleName, module):&#10;        # return a path_entry to use for child packages&#10;&#10;Namespace handlers are only called if the importer object has already&#10;agreed that it can handle the relevant path item, and they should only&#10;return a subpath if the module __path__ does not already contain an&#10;equivalent subpath.  For an example namespace handler, see&#10;``pkg_resources.file_ns_handler``.'>
				<Param name="importer_type" />
				<Param name="namespace_handler" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.rename" func="yes">
			<Overload retVal="" descr="Rename a file or directory.&#10;&#10;If either src_dir_fd or dst_dir_fd is not None, it should be a file&#10;  descriptor open to a directory, and the respective path string (src or dst)&#10;  should be relative; the path will then be relative to that directory.&#10;src_dir_fd and dst_dir_fd, may not be implemented on your platform.&#10;  If they are unavailable, using them will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.require" func="yes">
			<Overload retVal="" descr="Ensure that distributions matching `requirements` are activated&#10;&#10;`requirements` must be a string or a (possibly-nested) sequence&#10;thereof, specifying the distributions and versions required.  The&#10;return value is a sequence of the distributions that needed to be&#10;activated to fulfill the requirements; all relevant distributions are&#10;included, even if they were already activated in this working set.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.resource_exists" func="yes">
			<Overload retVal="" descr="Does the named resource exist?">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.resource_filename" func="yes">
			<Overload retVal="" descr="Return a true filesystem path for specified resource">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.resource_isdir" func="yes">
			<Overload retVal="" descr="Is the named resource an existing directory?">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.resource_listdir" func="yes">
			<Overload retVal="" descr="List the contents of the named resource directory">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.resource_stream" func="yes">
			<Overload retVal="" descr="Return a readable file-like object for specified resource">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.resource_string" func="yes">
			<Overload retVal="" descr="Return specified resource as a string">
				<Param name="self" />
				<Param name="package_or_requirement" />
				<Param name="resource_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.run_main" func="yes">
			<Overload retVal="" descr="Locate distribution for `requires` and run `script_name` script">
				<Param name="self" />
				<Param name="requires" />
				<Param name="script_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.run_script" func="yes">
			<Overload retVal="" descr="Locate distribution for `requires` and run `script_name` script">
				<Param name="self" />
				<Param name="requires" />
				<Param name="script_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.safe_extra" func="yes">
			<Overload retVal="" descr="Convert an arbitrary string to a standard 'extra' name&#10;&#10;Any runs of non-alphanumeric characters are replaced with a single '_',&#10;and the result is always lowercased.">
				<Param name="extra" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.safe_name" func="yes">
			<Overload retVal="" descr="Convert an arbitrary string to a standard distribution name&#10;&#10;Any runs of non-alphanumeric/. characters are replaced with a single '-'.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.safe_version" func="yes">
			<Overload retVal="" descr="Convert an arbitrary string to a standard version string">
				<Param name="version" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.set_extraction_path" func="yes">
			<Overload retVal="" descr="Set the base path where resources will be extracted to, if needed.&#10;&#10;If you do not call this routine before any extractions take place, the&#10;path defaults to the return value of ``get_default_cache()``.  (Which&#10;is based on the ``PYTHON_EGG_CACHE`` environment variable, with various&#10;platform-specific fallbacks.  See that routine's documentation for more&#10;details.)&#10;&#10;Resources are extracted to subdirectories of this path based upon&#10;information given by the ``IResourceProvider``.  You may set this to a&#10;temporary directory, but then you must call ``cleanup_resources()`` to&#10;delete the extracted files when done.  There is no guarantee that&#10;``cleanup_resources()`` will be able to remove all extracted files.&#10;&#10;(Note: you may not change the extraction path for a given resource&#10;manager once resources have been extracted, unless you first call&#10;``cleanup_resources()``.)">
				<Param name="self" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.split" func="yes">
			<Overload retVal="" descr="Split a pathname.&#10;&#10;Return tuple (head, tail) where tail is everything after the final slash.&#10;Either part may be empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.split_sections" func="yes">
			<Overload retVal="" descr="Split a string or iterable thereof into (section, content) pairs&#10;&#10;Each ``section`` is a stripped version of the section header (&quot;[section]&quot;)&#10;and each ``content`` is a list of stripped lines excluding blank lines and&#10;comment-only lines.  If there are any such lines before the first section&#10;header, they're returned in a first ``section`` of ``None``.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.to_filename" func="yes">
			<Overload retVal="" descr="Convert a project or version name to its filename-escaped form&#10;&#10;Any '-' characters are currently replaced with '_'.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.unlink" func="yes">
			<Overload retVal="" descr="Remove a file (same as remove()).&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;dir_fd may not be implemented on your platform.&#10;  If it is unavailable, using it will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.urllib" func="yes">
			<Overload retVal="" descr="(Module_six_moves_urllib)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.utime" func="yes">
			<Overload retVal="" descr="Set the access and modified time of path.&#10;&#10;path may always be specified as a string.&#10;On some platforms, path may also be specified as an open file descriptor.&#10;  If this functionality is unavailable, using it raises an exception.&#10;&#10;If times is not None, it must be a tuple (atime, mtime);&#10;    atime and mtime should be expressed as float seconds since the epoch.&#10;If ns is specified, it must be a tuple (atime_ns, mtime_ns);&#10;    atime_ns and mtime_ns should be expressed as integer nanoseconds&#10;    since the epoch.&#10;If times is None and ns is unspecified, utime uses the current time.&#10;Specifying tuples for both times and ns is an error.&#10;&#10;If dir_fd is not None, it should be a file descriptor open to a directory,&#10;  and path should be relative; path will then be relative to that directory.&#10;If follow_symlinks is False, and the last element of the path is a symbolic&#10;  link, utime will modify the symbolic link itself instead of the file the&#10;  link points to.&#10;It is an error to use dir_fd or follow_symlinks when specifying path&#10;  as an open file descriptor.&#10;dir_fd and follow_symlinks may not be available on your platform.&#10;  If they are unavailable, using them will raise a NotImplementedError.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.working_set" func="yes">
			<Overload retVal="" descr="(WorkingSet)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkg_resources.yield_lines" func="yes">
			<Overload retVal="" descr="Yield non-empty/non-comment lines of a string or sequence">
				<Param name="strs" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil" func="yes">
			<Overload retVal="" descr="Utilities to support packages.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpImporter" func="yes">
			<Overload retVal="" descr="PEP 302 Finder that wraps Python's &quot;classic&quot; import algorithm&#10;&#10;ImpImporter(dirname) produces a PEP 302 finder that searches that&#10;directory.  ImpImporter(None) produces a PEP 302 finder that searches&#10;the current sys.path, plus any modules that are frozen or built-in.&#10;&#10;Note that ImpImporter does not currently support being used by placement&#10;on sys.meta_path.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpImporter.find_module" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="fullname" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpImporter.iter_modules" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[prefix]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpLoader" func="yes">
			<Overload retVal="" descr="PEP 302 Loader that wraps Python's &quot;classic&quot; import algorithm">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpLoader.get_code" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[fullname=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpLoader.get_data" />
		<KeyWord name="pkgutil.ImpLoader.get_filename" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[fullname=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpLoader.get_source" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[fullname=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ImpLoader.is_package" />
		<KeyWord name="pkgutil.ImpLoader.load_module" />
		<KeyWord name="pkgutil.ModuleInfo" func="yes">
			<Overload retVal="" descr="A namedtuple with minimal info about a module.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleInfo.ispkg" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleInfo.module_finder" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleInfo.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.extend_path" func="yes">
			<Overload retVal="" descr="Extend a package's path.&#10;&#10;Intended use is to place the following code in a package's __init__.py:&#10;&#10;    from pkgutil import extend_path&#10;    __path__ = extend_path(__path__, __name__)&#10;&#10;This will add to the package's __path__ all subdirectories of&#10;directories on sys.path named after the package.  This is useful&#10;if one wants to distribute different parts of a single logical&#10;package as multiple directories.&#10;&#10;It also looks for *.pkg files beginning where * matches the name&#10;argument.  This feature is similar to *.pth files (see site.py),&#10;except that it doesn't special-case lines starting with 'import'.&#10;A *.pkg file is trusted at face value: apart from checking for&#10;duplicates, all entries found in a *.pkg file are added to the&#10;path, regardless of whether they are exist the filesystem.  (This&#10;is a feature.)&#10;&#10;If the input path is not a list (as is the case for frozen&#10;packages) it is returned unchanged.  The input path is not&#10;modified; an extended copy is returned.  Items are only appended&#10;to the copy at the end.&#10;&#10;It is assumed that sys.path is a sequence.  Items of sys.path that&#10;are not (unicode or 8-bit) strings referring to existing&#10;directories are ignored.  Unicode items of sys.path that cause&#10;errors when used as filenames may cause this function to raise an&#10;exception (in line with os.path.isdir() behavior).">
				<Param name="path" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.find_loader" func="yes">
			<Overload retVal="" descr='Find a "loader" object for fullname&#10;&#10;This is a backwards compatibility wrapper around&#10;importlib.util.find_spec that converts most failures to ImportError&#10;and only returns the loader rather than the full spec'>
				<Param name="fullname" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.get_data" func="yes">
			<Overload retVal="" descr="Get a resource from a package.&#10;&#10;This is a wrapper round the PEP 302 loader get_data API. The package&#10;argument should be the name of a package, in standard module format&#10;(foo.bar). The resource argument should be in the form of a relative&#10;filename, using '/' as the path separator. The parent directory name '..'&#10;is not allowed, and nor is a rooted name (starting with a '/').&#10;&#10;The function returns a binary string, which is the contents of the&#10;specified resource.&#10;&#10;For packages located in the filesystem, which have already been imported,&#10;this is the rough equivalent of&#10;&#10;    d = os.path.dirname(sys.modules[package].__file__)&#10;    data = open(os.path.join(d, resource), 'rb').read()&#10;&#10;If the package cannot be located or loaded, or it uses a PEP 302 loader&#10;which does not support get_data(), then None is returned.">
				<Param name="package" />
				<Param name="resource" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.get_importer" func="yes">
			<Overload retVal="" descr="Retrieve a finder for the given path item&#10;&#10;The returned finder is cached in sys.path_importer_cache&#10;if it was newly created by a path hook.&#10;&#10;The cache (or part of it) can be cleared manually if a&#10;rescan of sys.path_hooks is necessary.">
				<Param name="path_item" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.get_loader" func="yes">
			<Overload retVal="" descr='Get a "loader" object for module_or_name&#10;&#10;Returns None if the module cannot be found or imported.&#10;If the named module is not already imported, its containing package&#10;(if any) is imported, in order to establish the package __path__.'>
				<Param name="module_or_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_importer_modules" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_importers" func="yes">
			<Overload retVal="" descr="Yield finders for the given module name&#10;&#10;If fullname contains a '.', the finders will be for the package&#10;containing fullname, otherwise they will be all registered top level&#10;finders (i.e. those on both sys.meta_path and sys.path_hooks).&#10;&#10;If the named module is in a package, that package is imported as a side&#10;effect of invoking this function.&#10;&#10;If no module name is specified, all top level finders are produced.">
				<Param name="[fullname]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_modules" func="yes">
			<Overload retVal="" descr="Yields ModuleInfo for all submodules on path,&#10;or, if path is None, all top-level modules on sys.path.&#10;&#10;'path' should be either None or a list of paths to look for&#10;modules in.&#10;&#10;'prefix' is a string to output on the front of every module name&#10;on output.">
				<Param name="[path=None" />
				<Param name="[prefix]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.iter_zipimport_modules" func="yes">
			<Overload retVal="" descr=>
				<Param name="importer" />
				<Param name="[prefix]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.read_code" />
		<KeyWord name="pkgutil.simplegeneric" func="yes">
			<Overload retVal="" descr="Single-dispatch generic function decorator.&#10;&#10;Transforms a function into a generic function, which can have different&#10;behaviours depending upon the type of its first argument. The decorated&#10;function acts as the default implementation, and additional&#10;implementations can be registered using the register() attribute of the&#10;generic function.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.walk_packages" func="yes">
			<Overload retVal="" descr="Yields ModuleInfo for all modules recursively&#10;on path, or, if path is None, all accessible modules.&#10;&#10;'path' should be either None or a list of paths to look for&#10;modules in.&#10;&#10;'prefix' is a string to output on the front of every module name&#10;on output.&#10;&#10;Note that this function must import all *packages* (NOT all&#10;modules!) on the given path, in order to access the __path__&#10;attribute to find submodules.&#10;&#10;'onerror' is a function which gets called with one argument (the&#10;name of the package which was being imported) if any exception&#10;occurs while trying to import a package.  If no onerror function is&#10;supplied, ImportErrors are caught and ignored, while all other&#10;exceptions are propagated, terminating the search.&#10;&#10;Examples:&#10;&#10;# list all modules python can access&#10;walk_packages()&#10;&#10;# list all submodules of ctypes&#10;walk_packages(ctypes.__path__, ctypes.__name__+'.')">
				<Param name="[path=None" />
				<Param name="[prefix" />
				<Param name="[onerror=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter" func="yes">
			<Overload retVal="" descr="zipimporter(archivepath) -&gt; zipimporter object&#10;&#10;Create a new zipimporter instance. 'archivepath' must be a path to&#10;a zipfile, or to a specific path inside a zipfile. For example, it can be&#10;'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a&#10;valid directory inside the archive.&#10;&#10;'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip&#10;archive.&#10;&#10;The 'archive' attribute of zipimporter objects contains the name of the&#10;zipfile targeted.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.archive" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.find_loader" func="yes">
			<Overload retVal="" descr="find_loader(fullname, path=None) -&gt; self, str or None.&#10;&#10;Search for a module specified by 'fullname'. 'fullname' must be the&#10;fully qualified (dotted) module name. It returns the zipimporter&#10;instance itself if the module was found, a string containing the&#10;full path name if it's possibly a portion of a namespace package,&#10;or None otherwise. The optional 'path' argument is ignored -- it's&#10; there for compatibility with the importer protocol.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.find_module" func="yes">
			<Overload retVal="" descr="find_module(fullname, path=None) -&gt; self or None.&#10;&#10;Search for a module specified by 'fullname'. 'fullname' must be the&#10;fully qualified (dotted) module name. It returns the zipimporter&#10;instance itself if the module was found, or None if it wasn't.&#10;The optional 'path' argument is ignored -- it's there for compatibility&#10;with the importer protocol.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_code" func="yes">
			<Overload retVal="" descr="get_code(fullname) -&gt; code object.&#10;&#10;Return the code object for the specified module. Raise ZipImportError&#10;if the module couldn't be found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_data" func="yes">
			<Overload retVal="" descr="get_data(pathname) -&gt; string with file data.&#10;&#10;Return the data associated with 'pathname'. Raise IOError if&#10;the file wasn't found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_filename" func="yes">
			<Overload retVal="" descr="get_filename(fullname) -&gt; filename string.&#10;&#10;Return the filename for the specified module.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.get_source" func="yes">
			<Overload retVal="" descr="get_source(fullname) -&gt; source string.&#10;&#10;Return the source code for the specified module. Raise ZipImportError&#10;if the module couldn't be found, return None if the archive does&#10;contain the module, but has no source for it.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.is_package" func="yes">
			<Overload retVal="" descr="is_package(fullname) -&gt; bool.&#10;&#10;Return True if the module specified by fullname is a package.&#10;Raise ZipImportError if the module couldn't be found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.load_module" func="yes">
			<Overload retVal="" descr="load_module(fullname) -&gt; module.&#10;&#10;Load the module specified by 'fullname'. 'fullname' must be the&#10;fully qualified (dotted) module name. It returns the imported&#10;module, or raises ZipImportError if it wasn't found.">
			</Overload>
		</KeyWord>
		<KeyWord name="pkgutil.zipimporter.prefix" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="plain" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="plainpager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="platform" func="yes">
			<Overload retVal="" descr="This module tries to retrieve as much platform-identifying data as&#10;possible. It makes this information available via function APIs.&#10;&#10;If called from the command line, it prints the platform&#10;information concatenated as single string to stdout. The output&#10;format is useable as part of a filename.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.DEV_NULL" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.architecture" func="yes">
			<Overload retVal="" descr="Queries the given executable (defaults to the Python interpreter&#10;binary) for various architecture information.&#10;&#10;Returns a tuple (bits, linkage) which contains information about&#10;the bit architecture and the linkage format used for the&#10;executable. Both values are returned as strings.&#10;&#10;Values that cannot be determined are returned as given by the&#10;parameter presets. If bits is given as '', the sizeof(pointer)&#10;(or sizeof(long) on Python version &lt; 1.5.2) is used as&#10;indicator for the supported pointer size.&#10;&#10;The function relies on the system's &quot;file&quot; command to do the&#10;actual work. This is available on most if not all Unix&#10;platforms. On some non-Unix platforms where the &quot;file&quot; command&#10;does not exist and the executable is set to the Python interpreter&#10;binary defaults from _default_architecture are used.">
				<Param name="[executable=C:\Program Files (x86)\Python36-32\python.exe" />
				<Param name="[bits" />
				<Param name="[linkage]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.dist" func="yes">
			<Overload retVal="" descr="Tries to determine the name of the Linux OS distribution name.&#10;&#10;The function first looks for a distribution release file in&#10;/etc and then reverts to _dist_try_harder() in case no&#10;suitable files are found.&#10;&#10;Returns a tuple (distname, version, id) which default to the&#10;args given as parameters.">
				<Param name="[distname" />
				<Param name="[version" />
				<Param name="[id" />
				<Param name="[supported_dists=('SuSE', 'debian', 'fedora', 'redhat', 'centos', 'mandrake', 'mandriva', 'rocks', 'slackware', 'yellowdog', 'gentoo', 'UnitedLinux', 'turbolinux', 'arch', 'mageia')]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.java_ver" func="yes">
			<Overload retVal="" descr="Version interface for Jython.&#10;&#10;Returns a tuple (release, vendor, vminfo, osinfo) with vminfo being&#10;a tuple (vm_name, vm_release, vm_vendor) and osinfo being a&#10;tuple (os_name, os_version, os_arch).&#10;&#10;Values which cannot be determined are set to the defaults&#10;given as parameters (which all default to '').">
				<Param name="[release" />
				<Param name="[vendor" />
				<Param name="[vminfo=('', '', '')" />
				<Param name="[osinfo=('', '', '')]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.libc_ver" func="yes">
			<Overload retVal="" descr="Tries to determine the libc version that the file executable&#10;(which defaults to the Python interpreter) is linked against.&#10;&#10;Returns a tuple of strings (lib,version) which default to the&#10;given parameters in case the lookup fails.&#10;&#10;Note that the function has intimate knowledge of how different&#10;libc versions add symbols to the executable and thus is probably&#10;only useable for executables compiled using gcc.&#10;&#10;The file is read and scanned in chunks of chunksize bytes.">
				<Param name="[executable=C:\Program Files (x86)\Python36-32\python.exe" />
				<Param name="[lib" />
				<Param name="[version" />
				<Param name="[chunksize=16384]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.linux_distribution" func="yes">
			<Overload retVal="" descr=>
				<Param name="[distname" />
				<Param name="[version" />
				<Param name="[id" />
				<Param name="[supported_dists=('SuSE', 'debian', 'fedora', 'redhat', 'centos', 'mandrake', 'mandriva', 'rocks', 'slackware', 'yellowdog', 'gentoo', 'UnitedLinux', 'turbolinux', 'arch', 'mageia')" />
				<Param name="[full_distribution_name=1]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.mac_ver" func="yes">
			<Overload retVal="" descr="Get MacOS version information and return it as tuple (release,&#10;versioninfo, machine) with versioninfo being a tuple (version,&#10;dev_stage, non_release_version).&#10;&#10;Entries which cannot be determined are set to the parameter values&#10;which default to ''. All tuple entries are strings.">
				<Param name="[release" />
				<Param name="[versioninfo=('', '', '')" />
				<Param name="[machine]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.machine" func="yes">
			<Overload retVal="" descr="Returns the machine type, e.g. 'i386'&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.node" func="yes">
			<Overload retVal="" descr="Returns the computer's network name (which may not be fully&#10;qualified)&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.platform" func="yes">
			<Overload retVal="" descr='Returns a single string identifying the underlying platform&#10;with as much useful information as possible (but no more :).&#10;&#10;The output is intended to be human readable rather than&#10;machine parseable. It may look different on different&#10;platforms and this is intended.&#10;&#10;If "aliased" is true, the function will use aliases for&#10;various platforms that report system names which differ from&#10;their common names, e.g. SunOS will be reported as&#10;Solaris. The system_alias() function is used to implement&#10;this.&#10;&#10;Setting terse to true causes the function to return only the&#10;absolute minimum information needed to identify the platform.'>
				<Param name="[aliased=0" />
				<Param name="[terse=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.popen" func="yes">
			<Overload retVal="" descr="Portable popen() interface.">
				<Param name="cmd" />
				<Param name="[mode=r" />
				<Param name="[bufsize=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.processor" func="yes">
			<Overload retVal="" descr="Returns the (true) processor name, e.g. 'amdk6'&#10;&#10;An empty string is returned if the value cannot be&#10;determined. Note that many platforms do not provide this&#10;information or simply return the same value as for machine(),&#10;e.g.  NetBSD does this.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_branch" func="yes">
			<Overload retVal="" descr="Returns a string identifying the Python implementation&#10;branch.&#10;&#10;For CPython this is the Subversion branch from which the&#10;Python binary was built.&#10;&#10;If not available, an empty string is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_build" func="yes">
			<Overload retVal="" descr="Returns a tuple (buildno, builddate) stating the Python&#10;build number and date as strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_compiler" func="yes">
			<Overload retVal="" descr="Returns a string identifying the compiler used for compiling&#10;Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_implementation" func="yes">
			<Overload retVal="" descr="Returns a string identifying the Python implementation.&#10;&#10;Currently, the following implementations are identified:&#10;  'CPython' (C implementation of Python),&#10;  'IronPython' (.NET implementation of Python),&#10;  'Jython' (Java implementation of Python),&#10;  'PyPy' (Python implementation of Python).">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_revision" func="yes">
			<Overload retVal="" descr="Returns a string identifying the Python implementation&#10;revision.&#10;&#10;For CPython this is the Subversion revision from which the&#10;Python binary was built.&#10;&#10;If not available, an empty string is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_version" func="yes">
			<Overload retVal="" descr="Returns the Python version as string 'major.minor.patchlevel'&#10;&#10;Note that unlike the Python sys.version, the returned value&#10;will always include the patchlevel (it defaults to 0).">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.python_version_tuple" func="yes">
			<Overload retVal="" descr="Returns the Python version as tuple (major, minor, patchlevel)&#10;of strings.&#10;&#10;Note that unlike the Python sys.version, the returned value&#10;will always include the patchlevel (it defaults to 0).">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.release" func="yes">
			<Overload retVal="" descr="Returns the system's release, e.g. '2.2.0' or 'NT'&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.system" func="yes">
			<Overload retVal="" descr="Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.system_alias" func="yes">
			<Overload retVal="" descr="Returns (system, release, version) aliased to common&#10;marketing names used for some systems.&#10;&#10;It also does some reordering of the information in some cases&#10;where it would otherwise cause confusion.">
				<Param name="system" />
				<Param name="release" />
				<Param name="version" />
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname" func="yes">
			<Overload retVal="" descr="Fairly portable uname interface. Returns a tuple&#10;of strings (system, node, release, version, machine, processor)&#10;identifying the underlying platform.&#10;&#10;Note that unlike the os.uname function this also returns&#10;possible processor information as an additional tuple entry.&#10;&#10;Entries which cannot be determined are set to ''.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result" func="yes">
			<Overload retVal="" descr="uname_result(system, node, release, version, machine, processor)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.machine" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.node" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.processor" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.release" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.system" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.uname_result.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.version" func="yes">
			<Overload retVal="" descr="Returns the system's release version, e.g. '#3 on degas'&#10;&#10;An empty string is returned if the value cannot be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="platform.win32_ver" func="yes">
			<Overload retVal="" descr=>
				<Param name="[release" />
				<Param name="[version" />
				<Param name="[csd" />
				<Param name="[ptype]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib" func="yes">
			<Overload retVal="" descr="plistlib.py -- a tool to generate and parse MacOSX .plist files.&#10;&#10;The property list (.plist) file format is a simple XML pickle supporting&#10;basic object types, like dictionaries, lists, numbers and strings.&#10;Usually the top level object is a dictionary.&#10;&#10;To write out a plist file, use the dump(value, file)&#10;function. 'value' is the top level object, 'file' is&#10;a (writable) file object.&#10;&#10;To parse a plist from a file, use the load(file) function,&#10;with a (readable) file object as the only argument. It&#10;returns the top level object (again, usually a dictionary).&#10;&#10;To work with plist data in bytes objects, you can use loads()&#10;and dumps().&#10;&#10;Values can be strings, integers, floats, booleans, tuples, lists,&#10;dictionaries (but only with string keys), Data, bytes, bytearray, or&#10;datetime.datetime objects.&#10;&#10;Generate Plist example:&#10;&#10;    pl = dict(&#10;        aString = &quot;Doodah&quot;,&#10;        aList = [&quot;A&quot;, &quot;B&quot;, 12, 32.1, [1, 2, 3]],&#10;        aFloat = 0.1,&#10;        anInt = 728,&#10;        aDict = dict(&#10;            anotherString = &quot;&lt;hello &amp; hi there!&gt;&quot;,&#10;            aUnicodeValue = &quot;M\xe4ssig, Ma\xdf&quot;,&#10;            aTrueValue = True,&#10;            aFalseValue = False,&#10;        ),&#10;        someData = b&quot;&lt;binary gunk&gt;&quot;,&#10;        someMoreData = b&quot;&lt;lots of binary gunk&gt;&quot; * 10,&#10;        aDate = datetime.datetime.fromtimestamp(time.mktime(time.gmtime())),&#10;    )&#10;    with open(fileName, 'wb') as fp:&#10;        dump(pl, fp)&#10;&#10;Parse Plist example:&#10;&#10;    with open(fileName, 'rb') as fp:&#10;        pl = load(fp)&#10;    print(pl[&quot;aKey&quot;])">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO" func="yes">
			<Overload retVal="" descr="Buffered I/O implementation using an in-memory bytes buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.close" func="yes">
			<Overload retVal="" descr="Disable all I/O operations.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.flush" func="yes">
			<Overload retVal="" descr="Does nothing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.getbuffer" func="yes">
			<Overload retVal="" descr="Get a read-write view over the contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.isatty" func="yes">
			<Overload retVal="" descr="Always returns False.&#10;&#10;BytesIO objects are not connected to a TTY-like device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.read1" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.readinto" func="yes">
			<Overload retVal="" descr="Read bytes into buffer.&#10;&#10;Returns number of bytes read (0 for EOF), or None if the object&#10;is set not to block and has no data to read.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.readinto1" />
		<KeyWord name="plistlib.BytesIO.readline" func="yes">
			<Overload retVal="" descr="Next line from the file, as a bytes object.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.readlines" func="yes">
			<Overload retVal="" descr="List of bytes objects, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to byte offset pos relative to position indicated by whence:&#10;     0  Start of stream (the default).  pos should be &gt;= 0;&#10;     1  Current position - pos may be negative;&#10;     2  End of stream - pos usually negative.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.tell" func="yes">
			<Overload retVal="" descr="Current file position, an integer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is unchanged.  Returns the new size.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.write" func="yes">
			<Overload retVal="" descr="Write bytes to file.&#10;&#10;Return the number of bytes written.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.BytesIO.writelines" func="yes">
			<Overload retVal="" descr="Write lines to the file.&#10;&#10;Note that newlines are not added.  lines can be any iterable object&#10;producing bytes-like objects. This is equivalent to calling write() for&#10;each element.">
				<Param name="self" />
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Data" func="yes">
			<Overload retVal="" descr="Wrapper for binary data.&#10;&#10;This class is deprecated, use a bytes object instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Data.asBase64" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[maxlinelength=76]" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Data.fromBase64" />
		<KeyWord name="plistlib.Dict" func="yes">
			<Overload retVal="" descr="dict() -&gt; new empty dictionary&#10;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#10;    (key, value) pairs&#10;dict(iterable) -&gt; new dictionary initialized as if via:&#10;    d = {}&#10;    for k, v in iterable:&#10;        d[k] = v&#10;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#10;    in the keyword argument list.  For example:  dict(one=1, two=2)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="type" />
				<Param name="iterable" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Dict.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.FMT_BINARY" func="yes">
			<Overload retVal="" descr="(PlistFormat)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.FMT_XML" func="yes">
			<Overload retVal="" descr="(PlistFormat)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.InvalidFileException" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.InvalidFileException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.InvalidFileException.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.PLISTHEADER" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.ParserCreate" func="yes">
			<Overload retVal="" descr="Return a new XML parser object.">
				<Param name="[encoding=None" />
				<Param name="[namespace_separator=None" />
				<Param name="[intern=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist" func="yes">
			<Overload retVal="" descr="This class has been deprecated. Use dump() and load()&#10;functions instead, together with regular dict objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.clear" func="yes">
			<Overload retVal="" descr="D.clear() -&gt; None.  Remove all items from D.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.fromFile" func="yes">
			<Overload retVal="" descr="Deprecated. Use the load() function instead.">
				<Param name="cls" />
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.fromkeys" func="yes">
			<Overload retVal="" descr="Returns a new dict with keys from iterable and values equal to value.">
				<Param name="type" />
				<Param name="iterable" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; a set-like object providing a view on D's items">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; a set-like object providing a view on D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.pop" func="yes">
			<Overload retVal="" descr="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.&#10;If key is not found, d is returned if given, otherwise KeyError is raised">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.update" func="yes">
			<Overload retVal="" descr="D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.&#10;If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]&#10;If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v&#10;In either case, this is followed by: for k in F:  D[k] = F[k]">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.Plist.write" func="yes">
			<Overload retVal="" descr="Deprecated. Use the dump() function instead.">
				<Param name="self" />
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.PlistFormat" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.dump" func="yes">
			<Overload retVal="" descr="Write 'value' to a .plist file. 'fp' should be a (writable)&#10;file object.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.dumps" func="yes">
			<Overload retVal="" descr="Return a bytes object with the contents for a .plist file.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.load" func="yes">
			<Overload retVal="" descr="Read a .plist file. 'fp' should be (readable) file object.&#10;Return the unpacked root object (which usually is a dictionary).">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.loads" func="yes">
			<Overload retVal="" descr="Read a .plist file from a bytes object.&#10;Return the unpacked root object (which usually is a dictionary).">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.readPlist" func="yes">
			<Overload retVal="" descr="Read a .plist from a path or file. pathOrFile should either&#10;be a file name, or a readable binary file object.&#10;&#10;This function is deprecated, use load instead.">
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.readPlistFromBytes" func="yes">
			<Overload retVal="" descr="Read a plist data from a bytes object. Return the root object.&#10;&#10;This function is deprecated, use loads instead.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.writePlist" func="yes">
			<Overload retVal="" descr="Write 'value' to a .plist file. 'pathOrFile' may either be a&#10;file name or a (writable) file object.&#10;&#10;This function is deprecated, use dump instead.">
				<Param name="value" />
				<Param name="pathOrFile" />
			</Overload>
		</KeyWord>
		<KeyWord name="plistlib.writePlistToBytes" func="yes">
			<Overload retVal="" descr="Return 'value' as a plist-formatted bytes object.&#10;&#10;This function is deprecated, use dumps instead.">
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="plus" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="pm" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="pointer" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="poll" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="poll2" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="poll3" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="pop" func="yes">
			<Overload retVal="" descr="Remove and return an arbitrary set element.&#10;Raises KeyError if the set is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="pop_alignment" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="pop_font" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="pop_margin" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="pop_source" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="pop_style" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="popen" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="popitem" func="yes">
			<Overload retVal="" descr="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#10;2-tuple; but raise KeyError if D is empty.">
			</Overload>
		</KeyWord>
		<KeyWord name="popleft" func="yes">
			<Overload retVal="" descr="Function of asynchat.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib" func="yes">
			<Overload retVal="" descr="A POP3 client class.&#10;&#10;Based on the J. Myers POP3 draft, Jan. 96">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.CR" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.CRLF" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.HAVE_SSL" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.LF" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3" func="yes">
			<Overload retVal="" descr="This class supports both the minimal and optional command sets.&#10;Arguments can be strings or integers (where appropriate)&#10;(e.g.: retr(1) and retr('1') both work equally well.&#10;&#10;Minimal Command Set:&#10;        USER name               user(name)&#10;        PASS string             pass_(string)&#10;        STAT                    stat()&#10;        LIST [msg]              list(msg = None)&#10;        RETR msg                retr(msg)&#10;        DELE msg                dele(msg)&#10;        NOOP                    noop()&#10;        RSET                    rset()&#10;        QUIT                    quit()&#10;&#10;Optional Commands (some servers support these):&#10;        RPOP name               rpop(name)&#10;        APOP name digest        apop(name, digest)&#10;        TOP msg n               top(msg, n)&#10;        UIDL [msg]              uidl(msg = None)&#10;        CAPA                    capa()&#10;        STLS                    stls()&#10;        UTF8                    utf8()&#10;&#10;Raises one exception: 'error_proto'.&#10;&#10;Instantiate with:&#10;        POP3(hostname, port=110)&#10;&#10;NB:     the POP protocol locks the mailbox from user&#10;        authorization until QUIT, so be sure to get in, suck&#10;        the messages, and quit, each time you access the&#10;        mailbox.&#10;&#10;        POP is a line-based protocol, which means large mail&#10;        messages consume lots of python cycles reading them&#10;        line-by-line.&#10;&#10;        If it's available on your mail server, use IMAP4&#10;        instead, it doesn't suffer from the two problems&#10;        above.">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.apop" func="yes">
			<Overload retVal="" descr="Authorisation&#10;&#10;- only possible if server has supplied a timestamp in initial greeting.&#10;&#10;Args:&#10;        user     - mailbox user;&#10;        password - mailbox password.&#10;&#10;NB: mailbox is locked by server from here to 'quit()'">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.capa" func="yes">
			<Overload retVal="" descr="Return server capabilities (RFC 2449) as a dictionary&#10;&gt;&gt;&gt; c=poplib.POP3('localhost')&#10;&gt;&gt;&gt; c.capa()&#10;{'IMPLEMENTATION': ['Cyrus', 'POP3', 'server', 'v2.2.12'],&#10; 'TOP': [], 'LOGIN-DELAY': ['0'], 'AUTH-RESP-CODE': [],&#10; 'EXPIRE': ['NEVER'], 'USER': [], 'STLS': [], 'PIPELINING': [],&#10; 'UIDL': [], 'RESP-CODES': []}&#10;&gt;&gt;&gt;&#10;&#10;Really, according to RFC 2449, the cyrus folks should avoid&#10;having the implementation split into multiple arguments...">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.close" func="yes">
			<Overload retVal="" descr="Close the connection without assuming anything about it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.dele" func="yes">
			<Overload retVal="" descr="Delete message number 'which'.&#10;&#10;Result is 'response'.">
				<Param name="self" />
				<Param name="which" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.getwelcome" />
		<KeyWord name="poplib.POP3.list" func="yes">
			<Overload retVal="" descr="Request listing, return result.&#10;&#10;Result without a message number argument is in form&#10;['response', ['mesg_num octets', ...], octets].&#10;&#10;Result when a message number argument is given is a&#10;single response: the &quot;scan listing&quot; for that message.">
				<Param name="self" />
				<Param name="[which=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.noop" func="yes">
			<Overload retVal="" descr="Does nothing.&#10;&#10;One supposes the response indicates the server is alive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.quit" func="yes">
			<Overload retVal="" descr="Signoff: commit changes on server, unlock mailbox, close connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.retr" func="yes">
			<Overload retVal="" descr="Retrieve whole message number 'which'.&#10;&#10;Result is in form ['response', ['line', ...], octets].">
				<Param name="self" />
				<Param name="which" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.rpop" func="yes">
			<Overload retVal="" descr="Not sure what this does.">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.rset" func="yes">
			<Overload retVal="" descr="Unmark all messages marked for deletion.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.set_debuglevel" />
		<KeyWord name="poplib.POP3.stat" func="yes">
			<Overload retVal="" descr="Get mailbox status.&#10;&#10;Result is tuple of 2 ints (message count, mailbox size)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.stls" func="yes">
			<Overload retVal="" descr="Start a TLS session on the active connection as specified in RFC 2595.&#10;&#10;context - a ssl.SSLContext">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.timestamp" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.top" func="yes">
			<Overload retVal="" descr="Retrieve message header of message number 'which'&#10;and first 'howmuch' lines of message body.&#10;&#10;Result is in form ['response', ['line', ...], octets].">
				<Param name="self" />
				<Param name="which" />
				<Param name="howmuch" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.uidl" func="yes">
			<Overload retVal="" descr="Return message digest (unique id) list.&#10;&#10;If 'which', result contains unique id for that message&#10;in the form 'response mesgnum uid', otherwise result is&#10;the list ['response', ['mesgnum uid', ...], octets]">
				<Param name="self" />
				<Param name="[which=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.user" func="yes">
			<Overload retVal="" descr="Send user name, return response&#10;&#10;(should indicate password required).">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3.utf8" func="yes">
			<Overload retVal="" descr="Try to enter UTF-8 mode (see RFC 6856). Returns server response.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL" func="yes">
			<Overload retVal="" descr="POP3 client class over SSL connection&#10;&#10;Instantiate with: POP3_SSL(hostname, port=995, keyfile=None, certfile=None,&#10;                           context=None)&#10;&#10;       hostname - the hostname of the pop3 over ssl server&#10;       port - port number&#10;       keyfile - PEM formatted file that contains your private key&#10;       certfile - PEM formatted certificate chain file&#10;       context - a ssl.SSLContext&#10;&#10;See the methods of the parent class POP3 for more documentation.">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.apop" func="yes">
			<Overload retVal="" descr="Authorisation&#10;&#10;- only possible if server has supplied a timestamp in initial greeting.&#10;&#10;Args:&#10;        user     - mailbox user;&#10;        password - mailbox password.&#10;&#10;NB: mailbox is locked by server from here to 'quit()'">
				<Param name="self" />
				<Param name="user" />
				<Param name="password" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.capa" func="yes">
			<Overload retVal="" descr="Return server capabilities (RFC 2449) as a dictionary&#10;&gt;&gt;&gt; c=poplib.POP3('localhost')&#10;&gt;&gt;&gt; c.capa()&#10;{'IMPLEMENTATION': ['Cyrus', 'POP3', 'server', 'v2.2.12'],&#10; 'TOP': [], 'LOGIN-DELAY': ['0'], 'AUTH-RESP-CODE': [],&#10; 'EXPIRE': ['NEVER'], 'USER': [], 'STLS': [], 'PIPELINING': [],&#10; 'UIDL': [], 'RESP-CODES': []}&#10;&gt;&gt;&gt;&#10;&#10;Really, according to RFC 2449, the cyrus folks should avoid&#10;having the implementation split into multiple arguments...">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.close" func="yes">
			<Overload retVal="" descr="Close the connection without assuming anything about it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.dele" func="yes">
			<Overload retVal="" descr="Delete message number 'which'.&#10;&#10;Result is 'response'.">
				<Param name="self" />
				<Param name="which" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.getwelcome" />
		<KeyWord name="poplib.POP3_SSL.list" func="yes">
			<Overload retVal="" descr="Request listing, return result.&#10;&#10;Result without a message number argument is in form&#10;['response', ['mesg_num octets', ...], octets].&#10;&#10;Result when a message number argument is given is a&#10;single response: the &quot;scan listing&quot; for that message.">
				<Param name="self" />
				<Param name="[which=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.noop" func="yes">
			<Overload retVal="" descr="Does nothing.&#10;&#10;One supposes the response indicates the server is alive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.quit" func="yes">
			<Overload retVal="" descr="Signoff: commit changes on server, unlock mailbox, close connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.retr" func="yes">
			<Overload retVal="" descr="Retrieve whole message number 'which'.&#10;&#10;Result is in form ['response', ['line', ...], octets].">
				<Param name="self" />
				<Param name="which" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.rpop" func="yes">
			<Overload retVal="" descr="Not sure what this does.">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.rset" func="yes">
			<Overload retVal="" descr="Unmark all messages marked for deletion.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.set_debuglevel" />
		<KeyWord name="poplib.POP3_SSL.stat" func="yes">
			<Overload retVal="" descr="Get mailbox status.&#10;&#10;Result is tuple of 2 ints (message count, mailbox size)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.stls" func="yes">
			<Overload retVal="" descr="The method unconditionally raises an exception since the&#10;STLS command doesn't make any sense on an already established&#10;SSL/TLS session.">
				<Param name="self" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None" />
				<Param name="[context=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.timestamp" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.top" func="yes">
			<Overload retVal="" descr="Retrieve message header of message number 'which'&#10;and first 'howmuch' lines of message body.&#10;&#10;Result is in form ['response', ['line', ...], octets].">
				<Param name="self" />
				<Param name="which" />
				<Param name="howmuch" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.uidl" func="yes">
			<Overload retVal="" descr="Return message digest (unique id) list.&#10;&#10;If 'which', result contains unique id for that message&#10;in the form 'response mesgnum uid', otherwise result is&#10;the list ['response', ['mesgnum uid', ...], octets]">
				<Param name="self" />
				<Param name="[which=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.user" func="yes">
			<Overload retVal="" descr="Send user name, return response&#10;&#10;(should indicate password required).">
				<Param name="self" />
				<Param name="user" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL.utf8" func="yes">
			<Overload retVal="" descr="Try to enter UTF-8 mode (see RFC 6856). Returns server response.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.POP3_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.error_proto" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.error_proto.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="poplib.error_proto.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pos" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath" func="yes">
			<Overload retVal="" descr='Common operations on Posix pathnames.&#10;&#10;Instead of importing this module directly, import os and refer to&#10;this module as os.path.  The "os.path" name is an alias for this&#10;module on Posix systems; on other systems (e.g. Mac, Windows),&#10;os.path provides the same operations in a manner specific to that&#10;platform, and is an alias to another module (e.g. macpath, ntpath).&#10;&#10;Some of this can actually be useful on non-Posix systems too, e.g.&#10;for manipulation of the pathname component of URLs.'>
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.abspath" func="yes">
			<Overload retVal="" descr="Return an absolute path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.basename" func="yes">
			<Overload retVal="" descr="Returns the final component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.commonpath" func="yes">
			<Overload retVal="" descr="Given a sequence of path names, returns the longest common sub-path.">
				<Param name="paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.commonprefix" func="yes">
			<Overload retVal="" descr="Given a list of pathnames, returns the longest common leading component">
				<Param name="m" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.curdir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.defpath" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.devnull" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.dirname" func="yes">
			<Overload retVal="" descr="Returns the directory component of a pathname">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.exists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns False for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.expanduser" func="yes">
			<Overload retVal="" descr="Expand ~ and ~user constructions.  If user or $HOME is unknown,&#10;do nothing.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.expandvars" func="yes">
			<Overload retVal="" descr="Expand shell variables of form $var and ${var}.  Unknown variables&#10;are left unchanged.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.extsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getatime" func="yes">
			<Overload retVal="" descr="Return the last access time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getctime" func="yes">
			<Overload retVal="" descr="Return the metadata change time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getmtime" func="yes">
			<Overload retVal="" descr="Return the last modification time of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.getsize" func="yes">
			<Overload retVal="" descr="Return the size of a file, reported by os.stat().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.isabs" func="yes">
			<Overload retVal="" descr="Test whether a path is absolute">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.isdir" func="yes">
			<Overload retVal="" descr="Return true if the pathname refers to an existing directory.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.isfile" func="yes">
			<Overload retVal="" descr="Test whether a path is a regular file">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.islink" func="yes">
			<Overload retVal="" descr="Test whether a path is a symbolic link">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.ismount" func="yes">
			<Overload retVal="" descr="Test whether a path is a mount point">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.join" func="yes">
			<Overload retVal="" descr="Join two or more pathname components, inserting '/' as needed.&#10;If any component is an absolute path, all previous path components&#10;will be discarded.  An empty last part will result in a path that&#10;ends with a separator.">
				<Param name="a" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.lexists" func="yes">
			<Overload retVal="" descr="Test whether a path exists.  Returns True for broken symbolic links">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.normcase" func="yes">
			<Overload retVal="" descr="Normalize case of pathname.  Has no effect under Posix">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.normpath" func="yes">
			<Overload retVal="" descr="Normalize path, eliminating double slashes, etc.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.pathsep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.realpath" func="yes">
			<Overload retVal="" descr="Return the canonical path of the specified filename, eliminating any&#10;symbolic links encountered in the path.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.relpath" func="yes">
			<Overload retVal="" descr="Return a relative version of a path">
				<Param name="path" />
				<Param name="[start=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.samefile" func="yes">
			<Overload retVal="" descr="Test whether two pathnames reference the same actual file">
				<Param name="f1" />
				<Param name="f2" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.sameopenfile" func="yes">
			<Overload retVal="" descr="Test whether two open file objects reference the same file">
				<Param name="fp1" />
				<Param name="fp2" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.samestat" func="yes">
			<Overload retVal="" descr="Test whether two stat buffers reference the same file">
				<Param name="s1" />
				<Param name="s2" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.sep" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.split" func="yes">
			<Overload retVal="" descr='Split a pathname.  Returns tuple "(head, tail)" where "tail" is&#10;everything after the final slash.  Either part may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.splitdrive" func="yes">
			<Overload retVal="" descr="Split a pathname into drive and path. On Posix, drive is always&#10;empty.">
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="posixpath.splitext" func="yes">
			<Overload retVal="" descr='Split the extension from a pathname.&#10;&#10;Extension is everything from the last dot to the end, ignoring&#10;leading dots.  Returns "(root, ext)"; ext may be empty.'>
				<Param name="p" />
			</Overload>
		</KeyWord>
		<KeyWord name="post" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="post_mortem" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="post_setup" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="postcmd" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="postloop" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="postprocess" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="pow" func="yes">
			<Overload retVal="" descr="Equivalent to x**y (with two arguments) or x**y % z (with three arguments)&#10;&#10;Some types, such as ints, are able to use a more efficient algorithm when&#10;invoked using the three argument form.">
				<Param name="x" />
				<Param name="y" />
				<Param name="z" />
			</Overload>
		</KeyWord>
		<KeyWord name="power" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint" func="yes">
			<Overload retVal="" descr="Support to pretty-print lists, tuples, &amp; dictionaries recursively.&#10;&#10;Very simple, but useful, especially in debugging data structures.&#10;&#10;Classes&#10;-------&#10;&#10;PrettyPrinter()&#10;    Handle pretty-printing operations onto a stream using a configured&#10;    set of formatting parameters.&#10;&#10;Functions&#10;---------&#10;&#10;pformat()&#10;    Format a Python object into a pretty-printed representation.&#10;&#10;pprint()&#10;    Pretty-print a Python object to a stream [default is sys.stdout].&#10;&#10;saferepr()&#10;    Generate a 'standard' repr()-like value, but protect against recursive&#10;    data structures.">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.PrettyPrinter" />
		<KeyWord name="pprint.PrettyPrinter.format" func="yes">
			<Overload retVal="" descr="Format object for a specific context, returning a string&#10;and flags indicating whether the representation is 'readable'&#10;and whether the object represents a recursive construct.">
				<Param name="self" />
				<Param name="object" />
				<Param name="context" />
				<Param name="maxlevels" />
				<Param name="level" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.PrettyPrinter.isreadable" />
		<KeyWord name="pprint.PrettyPrinter.isrecursive" />
		<KeyWord name="pprint.PrettyPrinter.pformat" />
		<KeyWord name="pprint.PrettyPrinter.pprint" />
		<KeyWord name="pprint.isreadable" func="yes">
			<Overload retVal="" descr="Determine if saferepr(object) is readable by eval().">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.isrecursive" func="yes">
			<Overload retVal="" descr="Determine if object requires a recursive representation.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.pformat" func="yes">
			<Overload retVal="" descr="Format a Python object into a pretty-printed representation.">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.pprint" func="yes">
			<Overload retVal="" descr="Pretty-print a Python object to a stream [default is sys.stdout].">
			</Overload>
		</KeyWord>
		<KeyWord name="pprint.saferepr" func="yes">
			<Overload retVal="" descr="Version of repr() which can handle recursive data structures.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="prcal" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="precmd" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="preformat" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="preloop" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="prepare_class" func="yes">
			<Overload retVal="" descr="Function of types">
			</Overload>
		</KeyWord>
		<KeyWord name="prepend" func="yes">
			<Overload retVal="" descr="Function of pipes.Template">
			</Overload>
		</KeyWord>
		<KeyWord name="pretty_flags" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="print" func="yes">
			<Overload retVal="" descr="print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)&#10;&#10;Prints the values to a stream, or to sys.stdout by default.&#10;Optional keyword arguments:&#10;file:  a file-like object (stream); defaults to the current sys.stdout.&#10;sep:   string inserted between values, default a space.&#10;end:   string appended after the last value, default a newline.&#10;flush: whether to forcibly flush the stream.">
			</Overload>
		</KeyWord>
		<KeyWord name="printErrorList" func="yes">
			<Overload retVal="" descr="Function of unittest.TextTestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="printErrors" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="print_arguments" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_call_heading" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="print_call_line" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="print_callees" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="print_callers" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="print_command_list" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="print_commands" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="print_directory" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_environ" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_environ_usage" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_exc" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_exception" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_form" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="print_help" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="print_last" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_line" func="yes">
			<Overload retVal="" descr="Function of ftplib">
			</Overload>
		</KeyWord>
		<KeyWord name="print_list" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_log" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="print_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_stack_entry" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="print_stack_trace" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="print_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="print_tb" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="print_title" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="print_topics" func="yes">
			<Overload retVal="" descr="Function of cmd.Cmd">
			</Overload>
		</KeyWord>
		<KeyWord name="print_usage" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="print_version" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="printdir" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="prmonth" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="process" func="yes">
			<Overload retVal="" descr="Function of logging.LoggerAdapter">
			</Overload>
		</KeyWord>
		<KeyWord name="process_exited" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="process_message" func="yes">
			<Overload retVal="" descr="Function of smtpd.DebuggingServer">
			</Overload>
		</KeyWord>
		<KeyWord name="process_rawq" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="process_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="process_request_thread" func="yes">
			<Overload retVal="" descr="Function of socketserver.ThreadingMixIn">
			</Overload>
		</KeyWord>
		<KeyWord name="process_tokens" func="yes">
			<Overload retVal="" descr="Function of tabnanny">
			</Overload>
		</KeyWord>
		<KeyWord name="processor" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="profile" func="yes">
			<Overload retVal="" descr="Class for profiling Python code.">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser" func="yes">
			<Overload retVal="" descr="Class attributes:&#10;  standard_option_list : [Option]&#10;    list of standard options that will be accepted by all instances&#10;    of this parser class (intended to be overridden by subclasses).&#10;&#10;Instance attributes:&#10;  usage : string&#10;    a usage string for your program.  Before it is displayed&#10;    to the user, &quot;%prog&quot; will be expanded to the name of&#10;    your program (self.prog or os.path.basename(sys.argv[0])).&#10;  prog : string&#10;    the name of the current program (to override&#10;    os.path.basename(sys.argv[0])).&#10;  description : string&#10;    A paragraph of text giving a brief overview of your program.&#10;    optparse reformats this paragraph to fit the current terminal&#10;    width and prints it when the user requests help (after usage,&#10;    but before the list of options).&#10;  epilog : string&#10;    paragraph of help text to print after option help&#10;&#10;  option_groups : [OptionGroup]&#10;    list of option groups in this parser (option groups are&#10;    irrelevant for parsing the command-line, but very useful&#10;    for generating help)&#10;&#10;  allow_interspersed_args : bool = true&#10;    if true, positional arguments may be interspersed with options.&#10;    Assuming -a and -b each take a single argument, the command-line&#10;      -ablah foo bar -bboo baz&#10;    will be interpreted the same as&#10;      -ablah -bboo -- foo bar baz&#10;    If this flag were false, that command line would be interpreted as&#10;      -ablah -- foo bar -bboo baz&#10;    -- ie. we stop processing options as soon as we see the first&#10;    non-option argument.  (This is the tradition followed by&#10;    Python's getopt module, Perl's Getopt::Std, and other argument-&#10;    parsing libraries, but it is generally annoying to users.)&#10;&#10;  process_default_values : bool = true&#10;    if true, option default values are processed similarly to option&#10;    values from the command line: that is, they are passed to the&#10;    type-checking function for the option's type (as long as the&#10;    default value is a string).  (This really only matters if you&#10;    have defined custom types; see SF bug #955889.)  Set it to false&#10;    to restore the behaviour of Optik 1.4.1 and earlier.&#10;&#10;  rargs : [string]&#10;    the argument list currently being parsed.  Only set when&#10;    parse_args() is active, and continually trimmed down as&#10;    we consume arguments.  Mainly there for the benefit of&#10;    callback options.&#10;  largs : [string]&#10;    the list of leftover arguments that we have skipped while&#10;    parsing options.  If allow_interspersed_args is false, this&#10;    list is always empty.&#10;  values : Values&#10;    the set of option values currently being accumulated.  Only&#10;    set when parse_args() is active.  Also mainly for callbacks.&#10;&#10;Because of the 'rargs', 'largs', and 'values' attributes,&#10;OptionParser is not thread-safe.  If, for some perverse reason, you&#10;need to parse command-line arguments simultaneously in different&#10;threads, use different OptionParser instances.">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.add_option" func="yes">
			<Overload retVal="" descr="add_option(Option)&#10;add_option(opt_str, ..., kwarg=val, ...)">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.add_option_group" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.add_options" />
		<KeyWord name="profile.OptionParser.check_values" func="yes">
			<Overload retVal="" descr="check_values(values : Values, args : [string])&#10;-&gt; (values : Values, args : [string])&#10;&#10;Check that the supplied option values and leftover arguments are&#10;valid.  Returns the option values and leftover arguments&#10;(possibly adjusted, possibly completely new -- whatever you&#10;like).  Default implementation just returns the passed-in&#10;values; subclasses may override as desired.">
				<Param name="self" />
				<Param name="values" />
				<Param name="args" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.destroy" func="yes">
			<Overload retVal="" descr="Declare that you are done with this OptionParser.  This cleans up&#10;reference cycles so the OptionParser (and all objects referenced by&#10;it) can be garbage-collected promptly.  After calling destroy(), the&#10;OptionParser is unusable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.disable_interspersed_args" func="yes">
			<Overload retVal="" descr="Set parsing to stop on the first non-option. Use this if&#10;you have a command processor which runs another command that&#10;has options of its own and you want to make sure these options&#10;don't get confused.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.enable_interspersed_args" func="yes">
			<Overload retVal="" descr="Set parsing to not stop on the first non-option, allowing&#10;interspersing switches with command arguments. This is the&#10;default behavior. See also disable_interspersed_args() and the&#10;class documentation description of the attribute&#10;allow_interspersed_args.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.error" func="yes">
			<Overload retVal="" descr="error(msg : string)&#10;&#10;Print a usage message incorporating 'msg' to stderr and exit.&#10;If you override this in a subclass, it should not return -- it&#10;should either exit or raise an exception.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.exit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[status=0" />
				<Param name="[msg=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.expand_prog_name" />
		<KeyWord name="profile.OptionParser.format_description" />
		<KeyWord name="profile.OptionParser.format_epilog" />
		<KeyWord name="profile.OptionParser.format_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[formatter=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.format_option_help" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[formatter=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.get_default_values" />
		<KeyWord name="profile.OptionParser.get_description" />
		<KeyWord name="profile.OptionParser.get_option" />
		<KeyWord name="profile.OptionParser.get_option_group" />
		<KeyWord name="profile.OptionParser.get_prog_name" />
		<KeyWord name="profile.OptionParser.get_usage" />
		<KeyWord name="profile.OptionParser.get_version" />
		<KeyWord name="profile.OptionParser.has_option" />
		<KeyWord name="profile.OptionParser.parse_args" func="yes">
			<Overload retVal="" descr="parse_args(args : [string] = sys.argv[1:],&#10;           values : Values = None)&#10;-&gt; (values : Values, args : [string])&#10;&#10;Parse the command-line options found in 'args' (default:&#10;sys.argv[1:]).  Any errors result in a call to 'error()', which&#10;by default prints the usage message to stderr and calls&#10;sys.exit() with an error message.  On success returns a pair&#10;(values, args) where 'values' is a Values instance (with all&#10;your option values) and 'args' is the list of arguments left&#10;over after parsing options.">
				<Param name="self" />
				<Param name="[args=None" />
				<Param name="[values=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.print_help" func="yes">
			<Overload retVal="" descr="print_help(file : file = stdout)&#10;&#10;Print an extended help message, listing all options and any&#10;help text provided with them, to 'file' (default stdout).">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.print_usage" func="yes">
			<Overload retVal="" descr="print_usage(file : file = stdout)&#10;&#10;Print the usage message for the current program (self.usage) to&#10;'file' (default stdout).  Any occurrence of the string &quot;%prog&quot; in&#10;self.usage is replaced with the name of the current program&#10;(basename of sys.argv[0]).  Does nothing if self.usage is empty&#10;or not defined.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.print_version" func="yes">
			<Overload retVal="" descr="print_version(file : file = stdout)&#10;&#10;Print the version message for this program (self.version) to&#10;'file' (default stdout).  As with print_usage(), any occurrence&#10;of &quot;%prog&quot; in self.version is replaced by the current program's&#10;name.  Does nothing if self.version is empty or undefined.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.remove_option" />
		<KeyWord name="profile.OptionParser.set_conflict_handler" />
		<KeyWord name="profile.OptionParser.set_default" />
		<KeyWord name="profile.OptionParser.set_defaults" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.OptionParser.set_description" />
		<KeyWord name="profile.OptionParser.set_process_default_values" />
		<KeyWord name="profile.OptionParser.set_usage" />
		<KeyWord name="profile.Profile" func="yes">
			<Overload retVal="" descr="Profiler class.&#10;&#10;self.cur is always a tuple.  Each such tuple corresponds to a stack&#10;frame that is currently active (self.cur[-2]).  The following are the&#10;definitions of its members.  We use this external &quot;parallel stack&quot; to&#10;avoid contaminating the program that we are profiling. (old profiler&#10;used to write into the frames local dictionary!!) Derived classes&#10;can change the definition of some entries, as long as they leave&#10;[-2:] intact (frame and previous tuple).  In case an internal error is&#10;detected, the -3 element is used as the function name.&#10;&#10;[ 0] = Time that needs to be charged to the parent frame's function.&#10;       It is used so that a function call will not have to access the&#10;       timing data for the parent frame.&#10;[ 1] = Total time spent in this frame's function, excluding time in&#10;       subfunctions (this latter is tallied in cur[2]).&#10;[ 2] = Total time spent in subfunctions, excluding time executing the&#10;       frame's function (this latter is tallied in cur[1]).&#10;[-3] = Name of the function that corresponds to this frame.&#10;[-2] = Actual frame that we correspond to (used to sync exception handling).&#10;[-1] = Our parent 6-tuple (corresponds to frame.f_back).&#10;&#10;Timing data for each function is stored as a 5-tuple in the dictionary&#10;self.timings[].  The index is always the name stored in self.cur[-3].&#10;The following are the definitions of the members:&#10;&#10;[0] = The number of times this function was called, not counting direct&#10;      or indirect recursion,&#10;[1] = Number of times this function appears on the stack, minus one&#10;[2] = Total time spent internal to this function&#10;[3] = Cumulative time that this function was present on the stack.  In&#10;      non-recursive functions, this is the total execution time from start&#10;      to finish of each invocation of a function, including time spent in&#10;      all subfunctions.&#10;[4] = A dictionary indicating for each function name, the number of times&#10;      it was called by us.">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Profile.calibrate" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="m" />
				<Param name="[verbose=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Profile.create_stats" />
		<KeyWord name="profile.Profile.dispatch" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Profile.dump_stats" />
		<KeyWord name="profile.Profile.fake_code" />
		<KeyWord name="profile.Profile.fake_frame" />
		<KeyWord name="profile.Profile.print_stats" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[sort=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Profile.run" />
		<KeyWord name="profile.Profile.runcall" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.Profile.runctx" />
		<KeyWord name="profile.Profile.set_cmd" />
		<KeyWord name="profile.Profile.simulate_call" />
		<KeyWord name="profile.Profile.simulate_cmd_complete" />
		<KeyWord name="profile.Profile.snapshot_stats" />
		<KeyWord name="profile.Profile.trace_dispatch" />
		<KeyWord name="profile.Profile.trace_dispatch_c_call" />
		<KeyWord name="profile.Profile.trace_dispatch_call" />
		<KeyWord name="profile.Profile.trace_dispatch_exception" />
		<KeyWord name="profile.Profile.trace_dispatch_i" />
		<KeyWord name="profile.Profile.trace_dispatch_l" />
		<KeyWord name="profile.Profile.trace_dispatch_mac" />
		<KeyWord name="profile.Profile.trace_dispatch_return" />
		<KeyWord name="profile.main" />
		<KeyWord name="profile.run" func="yes">
			<Overload retVal="" descr='Run statement under profiler optionally saving results in filename&#10;&#10;This function takes a single argument that can be passed to the&#10;"exec" statement, and an optional file name.  In all cases this&#10;routine attempts to "exec" its first argument and gather profiling&#10;statistics from the execution. If no file name is present, then this&#10;function automatically prints a simple profiling report, sorted by the&#10;standard name string (file/line/function-name) that is presented in&#10;each line.'>
				<Param name="statement" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="profile.runctx" func="yes">
			<Overload retVal="" descr="Run statement under profiler, supplying your own globals and locals,&#10;optionally saving results in filename.&#10;&#10;statement and filename have the same semantics as profile.run">
				<Param name="statement" />
				<Param name="globals" />
				<Param name="locals" />
				<Param name="[filename=None" />
				<Param name="[sort=-1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="property" func="yes">
			<Overload retVal="" descr="property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute&#10;&#10;fget is a function to be used for getting an attribute value, and likewise&#10;fset is a function for setting, and fdel a function for del'ing, an&#10;attribute.  Typical use is to define a managed attribute x:&#10;&#10;class C(object):&#10;    def getx(self): return self._x&#10;    def setx(self, value): self._x = value&#10;    def delx(self): del self._x&#10;    x = property(getx, setx, delx, &quot;I'm the 'x' property.&quot;)&#10;&#10;Decorators make defining new properties or modifying existing ones easy:&#10;&#10;class C(object):&#10;    @property&#10;    def x(self):&#10;        &quot;I am the 'x' property.&quot;&#10;        return self._x&#10;    @x.setter&#10;    def x(self, value):&#10;        self._x = value&#10;    @x.deleter&#10;    def x(self):&#10;        del self._x">
			</Overload>
		</KeyWord>
		<KeyWord name="prot_c" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP_TLS">
			</Overload>
		</KeyWord>
		<KeyWord name="prot_p" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP_TLS">
			</Overload>
		</KeyWord>
		<KeyWord name="proxy" func="yes">
			<Overload retVal="" descr="Function of weakref">
			</Overload>
		</KeyWord>
		<KeyWord name="proxyauth" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="prweek" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="pryear" func="yes">
			<Overload retVal="" descr="Function of calendar.LocaleTextCalendar">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats" func="yes">
			<Overload retVal="" descr="Class for printing reports on profiled python code.">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats" func="yes">
			<Overload retVal="" descr="This class is used for creating reports from data generated by the&#10;Profile class.  It is a &quot;friend&quot; of that class, and imports data either&#10;by direct access to members of Profile class, or by reading in a dictionary&#10;that was emitted (via marshal) from the Profile class.&#10;&#10;The big change from the previous Profiler (in terms of raw functionality)&#10;is that an &quot;add()&quot; method has been provided to combine Stats from&#10;several distinct profile runs.  Both the constructor and the add()&#10;method now take arbitrarily many file names as arguments.&#10;&#10;All the print methods now take an argument that indicates how many lines&#10;to print.  If the arg is a floating point number between 0 and 1.0, then&#10;it is taken as a decimal percentage of the available lines to be printed&#10;(e.g., .1 means print 10% of all available lines).  If it is an integer,&#10;it is taken to mean the number of lines of data that you wish to have&#10;printed.&#10;&#10;The sort_stats() method now processes some additional options (i.e., in&#10;addition to the old -1, 0, 1, or 2 that are respectively interpreted as&#10;'stdname', 'calls', 'time', and 'cumulative').  It takes an arbitrary number&#10;of quoted strings to select the sort order.&#10;&#10;For example sort_stats('time', 'name') sorts on the major key of 'internal&#10;function time', and on the minor key of 'the name of the function'.  Look at&#10;the two tables in sort_stats() and get_sort_arg_defs(self) for more&#10;examples.&#10;&#10;All methods return self, so you can string together commands like:&#10;    Stats('foo', 'goo').strip_dirs().sort_stats('calls').                            print_stats(5).print_callers(5)">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats.add" />
		<KeyWord name="pstats.Stats.calc_callees" />
		<KeyWord name="pstats.Stats.dump_stats" func="yes">
			<Overload retVal="" descr="Write the profile data to a file we know how to load back.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats.eval_print_amount" />
		<KeyWord name="pstats.Stats.get_print_list" />
		<KeyWord name="pstats.Stats.get_sort_arg_defs" func="yes">
			<Overload retVal="" descr="Expand all abbreviations that are unique.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats.get_top_level_stats" />
		<KeyWord name="pstats.Stats.init" />
		<KeyWord name="pstats.Stats.load_stats" />
		<KeyWord name="pstats.Stats.print_call_heading" />
		<KeyWord name="pstats.Stats.print_call_line" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="name_size" />
				<Param name="source" />
				<Param name="call_dict" />
				<Param name="[arrow=->]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats.print_callees" />
		<KeyWord name="pstats.Stats.print_callers" />
		<KeyWord name="pstats.Stats.print_line" />
		<KeyWord name="pstats.Stats.print_stats" />
		<KeyWord name="pstats.Stats.print_title" />
		<KeyWord name="pstats.Stats.reverse_order" />
		<KeyWord name="pstats.Stats.sort_arg_dict_default" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.Stats.sort_stats" />
		<KeyWord name="pstats.Stats.strip_dirs" />
		<KeyWord name="pstats.TupleComp" func="yes">
			<Overload retVal="" descr="This class provides a generic function for comparing any two tuples.&#10;Each instance records a list of tuple-indices (from most significant&#10;to least significant), and sort direction (ascending or decending) for&#10;each tuple-index.  The compare functions can then be used as the function&#10;argument to the system sort() function when a list of tuples need to be&#10;sorted in the instances order.">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.TupleComp.compare" />
		<KeyWord name="pstats.add_callers" func="yes">
			<Overload retVal="" descr="Combine two caller lists in a single list.">
				<Param name="target" />
				<Param name="source" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.add_func_stats" func="yes">
			<Overload retVal="" descr="Add together all the stats for two profile entries.">
				<Param name="target" />
				<Param name="source" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.cmp_to_key" func="yes">
			<Overload retVal="" descr="Convert a cmp= function into a key= function.">
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.count_calls" func="yes">
			<Overload retVal="" descr="Sum the caller statistics to get total number of calls received.">
				<Param name="callers" />
			</Overload>
		</KeyWord>
		<KeyWord name="pstats.f8" />
		<KeyWord name="pstats.func_get_function_name" />
		<KeyWord name="pstats.func_std_string" />
		<KeyWord name="pstats.func_strip_path" />
		<KeyWord name="pstdev" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="purge" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="push" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="push_alignment" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="push_font" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="push_margin" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="push_source" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="push_style" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="push_token" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="push_with_producer" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="pushbutton" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="put" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="put_nowait" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="putcmd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="putenv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="putline" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="pvariance" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="pwd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile" func="yes">
			<Overload retVal="" descr='Routine to "compile" a .py file to a .pyc file.&#10;&#10;This module has intimate knowledge of the format of .pyc files.'>
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.PyCompileError" func="yes">
			<Overload retVal="" descr="Exception raised when an error occurs while attempting to&#10;compile the file.&#10;&#10;To raise this exception, use&#10;&#10;    raise PyCompileError(exc_type,exc_value,file[,msg])&#10;&#10;where&#10;&#10;    exc_type:   exception type to be used in error message&#10;                type name can be accesses as class variable&#10;                'exc_type_name'&#10;&#10;    exc_value:  exception value to be used in error message&#10;                can be accesses as class variable 'exc_value'&#10;&#10;    file:       name of file being compiled to be used in error message&#10;                can be accesses as class variable 'file'&#10;&#10;    msg:        string message to be written as error message&#10;                If no value is given, a default exception message will be&#10;                given, consistent with 'standard' py_compile output.&#10;                message (or default) can be accesses as class variable&#10;                'msg'">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.PyCompileError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.PyCompileError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.compile" func="yes">
			<Overload retVal="" descr="Byte-compile one Python source file to Python bytecode.&#10;&#10;:param file: The source file name.&#10;:param cfile: The target byte compiled file name.  When not given, this&#10;    defaults to the PEP 3147/PEP 488 location.&#10;:param dfile: Purported file name, i.e. the file name that shows up in&#10;    error messages.  Defaults to the source file name.&#10;:param doraise: Flag indicating whether or not an exception should be&#10;    raised when a compile error is found.  If an exception occurs and this&#10;    flag is set to False, a string indicating the nature of the exception&#10;    will be printed, and the function will return to the caller. If an&#10;    exception occurs and this flag is set to True, a PyCompileError&#10;    exception will be raised.&#10;:param optimize: The optimization level for the compiler.  Valid values&#10;    are -1, 0, 1 and 2.  A value of -1 means to use the optimization&#10;    level of the current interpreter, as given by -O command line options.&#10;&#10;:return: Path to the resulting byte compiled file.&#10;&#10;Note that it isn't necessary to byte-compile Python modules for&#10;execution efficiency -- Python itself byte-compiles a module when&#10;it is loaded, and if it can, writes out the bytecode to the&#10;corresponding .pyc file.&#10;&#10;However, if a Python installation is shared between users, it is a&#10;good idea to byte-compile all modules upon installation, since&#10;other users may not be able to write in the source directories,&#10;and thus they won't be able to write the .pyc file, and then&#10;they would be byte-compiling every module each time it is loaded.&#10;This can slow down program start-up considerably.&#10;&#10;See compileall.py for a script/module that uses this module to&#10;byte-compile all installed files (or all files in selected&#10;directories).&#10;&#10;Do note that FileExistsError is raised if cfile ends up pointing at a&#10;non-regular file or symlink. Because the compilation uses a file renaming,&#10;the resulting file would be regular and thus not the same type of file as&#10;it was previously.">
				<Param name="file" />
				<Param name="[cfile=None" />
				<Param name="[dfile=None" />
				<Param name="[doraise=False" />
				<Param name="[optimize=-1]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="py_compile.main" func="yes">
			<Overload retVal="" descr="Compile several source files.&#10;&#10;The files named in 'args' (or on the command line, if 'args' is&#10;not specified) are compiled and the resulting bytecode is cached&#10;in the normal manner.  This function does not search a directory&#10;structure to locate source files; it only compiles files named&#10;explicitly.  If '-' is the only parameter in args, the list of&#10;files is taken from standard input.">
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr" func="yes">
			<Overload retVal="" descr="Parse a Python module and describe its classes and methods.&#10;&#10;Parse enough of a Python file to recognize imports and class and&#10;method definitions, and to find out the superclasses of a class.&#10;&#10;The interface consists of a single function:&#10;        readmodule_ex(module [, path])&#10;where module is the name of a Python module, and path is an optional&#10;list of directories where the module is to be searched.  If present,&#10;path is prepended to the system search path sys.path.  The return&#10;value is a dictionary.  The keys of the dictionary are the names of&#10;the classes defined in the module (including classes that are defined&#10;via the from XXX import YYY construct).  The values are class&#10;instances of the class Class defined here.  One special key/value pair&#10;is present for packages: the key '__path__' has a list as its value&#10;which contains the package search path.&#10;&#10;A class is described by the class Class in this module.  Instances&#10;of this class have the following instance variables:&#10;        module -- the module name&#10;        name -- the name of the class&#10;        super -- a list of super classes (Class instances)&#10;        methods -- a dictionary of methods&#10;        file -- the file in which the class was defined&#10;        lineno -- the line in the file on which the class statement occurred&#10;The dictionary of methods uses the method names as keys and the line&#10;numbers on which the method was defined as values.&#10;If the name of a super class is not recognized, the corresponding&#10;entry in the list of super classes is not a class instance but a&#10;string giving the name of the super class.  Since import statements&#10;are recognized and imported modules are scanned as well, this&#10;shouldn't happen often.&#10;&#10;A function is described by the class Function in this module.&#10;Instances of this class have the following instance variables:&#10;        module -- the module name&#10;        name -- the name of the class&#10;        file -- the file in which the class was defined&#10;        lineno -- the line in the file on which the class statement occurred">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.Class" func="yes">
			<Overload retVal="" descr="Class to represent a Python class.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.Function" func="yes">
			<Overload retVal="" descr="Class to represent a top-level Python function">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.OP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.readmodule" func="yes">
			<Overload retVal="" descr="Backwards compatible interface.&#10;&#10;Call readmodule_ex() and then only keep Class objects from the&#10;resulting dictionary.">
				<Param name="module" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyclbr.readmodule_ex" func="yes">
			<Overload retVal="" descr="Read a module file and return a dictionary of classes.&#10;&#10;Search for MODULE in PATH and sys.path, read and parse the&#10;module and return a dictionary with one entry for each class&#10;found in the module.">
				<Param name="module" />
				<Param name="[path=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc" func="yes">
			<Overload retVal="" descr='Generate Python documentation in HTML or text for interactive use.&#10;&#10;At the Python interactive prompt, calling help(thing) on a Python object&#10;documents the object, and calling help() starts up an interactive&#10;help session.&#10;&#10;Or, at the shell command line outside of Python:&#10;&#10;Run "pydoc &lt;name&gt;" to show documentation on something.  &lt;name&gt; may be&#10;the name of a function, module, package, or a dotted reference to a&#10;class or function within a module or module in a package.  If the&#10;argument contains a path segment delimiter (e.g. slash on Unix,&#10;backslash on Windows) it is treated as the path to a Python source file.&#10;&#10;Run "pydoc -k &lt;keyword&gt;" to search for a keyword in the synopsis lines&#10;of all available modules.&#10;&#10;Run "pydoc -p &lt;port&gt;" to start an HTTP server on the given port on the&#10;local machine.  Port number 0 can be used to get an arbitrary unused port.&#10;&#10;Run "pydoc -b" to start an HTTP server on an arbitrary unused port and&#10;open a Web browser to interactively browse documentation.  The -p option&#10;can be used with the -b option to explicitly specify the server port.&#10;&#10;Run "pydoc -w &lt;name&gt;" to write out the HTML documentation for a module&#10;to a file named "&lt;name&gt;.html".&#10;&#10;Module docs for core modules are assumed to be in&#10;&#10;    https://docs.python.org/X.Y/library/&#10;&#10;This can be overridden by setting the PYTHONDOCS environment variable&#10;to a different URL or to a local directory containing the Library&#10;Reference Manual pages.'>
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc" />
		<KeyWord name="pydoc.Doc.PYTHONDOCS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.docclass" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.docdata" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.docmodule" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.docother" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.docproperty" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.docroutine" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.document" func="yes">
			<Overload retVal="" descr="Generate documentation for an object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.fail" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Doc.getdocloc" func="yes">
			<Overload retVal="" descr="Return the location of module docs or None">
				<Param name="self" />
				<Param name="object" />
				<Param name="[basedir=C:\Program Files (x86)\Python36-32\lib\python3.6]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ErrorDuringImport" func="yes">
			<Overload retVal="" descr="Errors that occurred while trying to import something to document it.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ErrorDuringImport.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ErrorDuringImport.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc" func="yes">
			<Overload retVal="" descr="Formatter class for HTML documentation.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.PYTHONDOCS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.bigsection" func="yes">
			<Overload retVal="" descr="Format a section with a big heading.">
				<Param name="self" />
				<Param name="title" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.classlink" func="yes">
			<Overload retVal="" descr="Make a link for a class.">
				<Param name="self" />
				<Param name="object" />
				<Param name="modname" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.docclass" func="yes">
			<Overload retVal="" descr="Produce HTML documentation for a class object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[funcs={}" />
				<Param name="[classes={}]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.docdata" func="yes">
			<Overload retVal="" descr="Produce html documentation for a data descriptor.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[cl=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.docmodule" func="yes">
			<Overload retVal="" descr="Produce HTML documentation for a module object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.docother" func="yes">
			<Overload retVal="" descr="Produce HTML documentation for a data object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.docproperty" func="yes">
			<Overload retVal="" descr="Produce html documentation for a property.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[cl=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.docroutine" func="yes">
			<Overload retVal="" descr="Produce HTML documentation for a function or method object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[funcs={}" />
				<Param name="[classes={}" />
				<Param name="[methods={}" />
				<Param name="[cl=None]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.document" func="yes">
			<Overload retVal="" descr="Generate documentation for an object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.escape" />
		<KeyWord name="pydoc.HTMLDoc.fail" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.filelink" func="yes">
			<Overload retVal="" descr="Make a link to source file.">
				<Param name="self" />
				<Param name="url" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.formattree" func="yes">
			<Overload retVal="" descr="Produce HTML for a class tree as given by inspect.getclasstree().">
				<Param name="self" />
				<Param name="tree" />
				<Param name="modname" />
				<Param name="[parent=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.formatvalue" func="yes">
			<Overload retVal="" descr="Format an argument default value as text.">
				<Param name="self" />
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.getdocloc" func="yes">
			<Overload retVal="" descr="Return the location of module docs or None">
				<Param name="self" />
				<Param name="object" />
				<Param name="[basedir=C:\Program Files (x86)\Python36-32\lib\python3.6]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.grey" />
		<KeyWord name="pydoc.HTMLDoc.heading" func="yes">
			<Overload retVal="" descr="Format a page heading.">
				<Param name="self" />
				<Param name="title" />
				<Param name="fgcol" />
				<Param name="bgcol" />
				<Param name="[extras]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.index" func="yes">
			<Overload retVal="" descr="Generate an HTML index for a directory of modules.">
				<Param name="self" />
				<Param name="dir" />
				<Param name="[shadowed=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.markup" func="yes">
			<Overload retVal="" descr="Mark up some plain text, given a context of symbols to look for.&#10;Each context dictionary maps object names to anchor names.">
				<Param name="self" />
				<Param name="text" />
				<Param name="[escape=None" />
				<Param name="[funcs={}" />
				<Param name="[classes={}" />
				<Param name="[methods={}]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.modpkglink" func="yes">
			<Overload retVal="" descr="Make a link for a module or package to display in an index.">
				<Param name="self" />
				<Param name="modpkginfo" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.modulelink" func="yes">
			<Overload retVal="" descr="Make a link for a module.">
				<Param name="self" />
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.multicolumn" func="yes">
			<Overload retVal="" descr="Format a list of items into a multi-column list.">
				<Param name="self" />
				<Param name="list" />
				<Param name="format" />
				<Param name="[cols=4]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.namelink" func="yes">
			<Overload retVal="" descr="Make a link for an identifier, given name-to-URL mappings.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.page" func="yes">
			<Overload retVal="" descr="Format an HTML page.">
				<Param name="self" />
				<Param name="title" />
				<Param name="contents" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.preformat" func="yes">
			<Overload retVal="" descr="Format literal preformatted text.">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLDoc.repr" />
		<KeyWord name="pydoc.HTMLDoc.section" func="yes">
			<Overload retVal="" descr="Format a section with a heading.">
				<Param name="self" />
				<Param name="title" />
				<Param name="fgcol" />
				<Param name="bgcol" />
				<Param name="contents" />
				<Param name="[width=6" />
				<Param name="[prelude" />
				<Param name="[marginalia=None" />
				<Param name="[gap=&nbsp;]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLRepr" func="yes">
			<Overload retVal="" descr="Class for safely making an HTML representation of a Python object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.HTMLRepr.escape" />
		<KeyWord name="pydoc.HTMLRepr.repr" />
		<KeyWord name="pydoc.HTMLRepr.repr1" />
		<KeyWord name="pydoc.HTMLRepr.repr_array" />
		<KeyWord name="pydoc.HTMLRepr.repr_deque" />
		<KeyWord name="pydoc.HTMLRepr.repr_dict" />
		<KeyWord name="pydoc.HTMLRepr.repr_frozenset" />
		<KeyWord name="pydoc.HTMLRepr.repr_instance" />
		<KeyWord name="pydoc.HTMLRepr.repr_int" />
		<KeyWord name="pydoc.HTMLRepr.repr_list" />
		<KeyWord name="pydoc.HTMLRepr.repr_set" />
		<KeyWord name="pydoc.HTMLRepr.repr_str" />
		<KeyWord name="pydoc.HTMLRepr.repr_string" />
		<KeyWord name="pydoc.HTMLRepr.repr_tuple" />
		<KeyWord name="pydoc.HTMLRepr.repr_unicode" />
		<KeyWord name="pydoc.Helper" />
		<KeyWord name="pydoc.Helper.getline" func="yes">
			<Overload retVal="" descr="Read one line, using input() when appropriate.">
				<Param name="self" />
				<Param name="prompt" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.help" />
		<KeyWord name="pydoc.Helper.input" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.interact" />
		<KeyWord name="pydoc.Helper.intro" />
		<KeyWord name="pydoc.Helper.keywords" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.list" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="items" />
				<Param name="[columns=4" />
				<Param name="[width=80]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.listkeywords" />
		<KeyWord name="pydoc.Helper.listmodules" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[key]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.listsymbols" />
		<KeyWord name="pydoc.Helper.listtopics" />
		<KeyWord name="pydoc.Helper.output" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.showsymbol" />
		<KeyWord name="pydoc.Helper.showtopic" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="topic" />
				<Param name="[more_xrefs]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.symbol" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.symbols" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.topic" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Helper.topics" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ModuleScanner" func="yes">
			<Overload retVal="" descr="An interruptible scanner that searches module synopses.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ModuleScanner.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="callback" />
				<Param name="[key=None" />
				<Param name="[completer=None" />
				<Param name="[onerror=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.Repr" />
		<KeyWord name="pydoc.Repr.repr" />
		<KeyWord name="pydoc.Repr.repr1" />
		<KeyWord name="pydoc.Repr.repr_array" />
		<KeyWord name="pydoc.Repr.repr_deque" />
		<KeyWord name="pydoc.Repr.repr_dict" />
		<KeyWord name="pydoc.Repr.repr_frozenset" />
		<KeyWord name="pydoc.Repr.repr_instance" />
		<KeyWord name="pydoc.Repr.repr_int" />
		<KeyWord name="pydoc.Repr.repr_list" />
		<KeyWord name="pydoc.Repr.repr_set" />
		<KeyWord name="pydoc.Repr.repr_str" />
		<KeyWord name="pydoc.Repr.repr_tuple" />
		<KeyWord name="pydoc.TextDoc" func="yes">
			<Overload retVal="" descr="Formatter class for text documentation.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.PYTHONDOCS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.bold" func="yes">
			<Overload retVal="" descr="Format a string in bold by overstriking.">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.docclass" func="yes">
			<Overload retVal="" descr="Produce text documentation for a given class object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.docdata" func="yes">
			<Overload retVal="" descr="Produce text documentation for a data descriptor.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[cl=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.docmodule" func="yes">
			<Overload retVal="" descr="Produce text documentation for a given module object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.docother" func="yes">
			<Overload retVal="" descr="Produce text documentation for a data object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[parent=None" />
				<Param name="[maxlen=None" />
				<Param name="[doc=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.docproperty" func="yes">
			<Overload retVal="" descr="Produce text documentation for a property.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[cl=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.docroutine" func="yes">
			<Overload retVal="" descr="Produce text documentation for a function or method object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None" />
				<Param name="[mod=None" />
				<Param name="[cl=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.document" func="yes">
			<Overload retVal="" descr="Generate documentation for an object.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.fail" func="yes">
			<Overload retVal="" descr="Raise an exception for unimplemented types.">
				<Param name="self" />
				<Param name="object" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.formattree" func="yes">
			<Overload retVal="" descr="Render in text a class tree as returned by inspect.getclasstree().">
				<Param name="self" />
				<Param name="tree" />
				<Param name="modname" />
				<Param name="[parent=None" />
				<Param name="[prefix]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.formatvalue" func="yes">
			<Overload retVal="" descr="Format an argument default value as text.">
				<Param name="self" />
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.getdocloc" func="yes">
			<Overload retVal="" descr="Return the location of module docs or None">
				<Param name="self" />
				<Param name="object" />
				<Param name="[basedir=C:\Program Files (x86)\Python36-32\lib\python3.6]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.indent" func="yes">
			<Overload retVal="" descr="Indent text by prepending a given prefix to each line.">
				<Param name="self" />
				<Param name="text" />
				<Param name="[prefix=    ]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextDoc.repr" />
		<KeyWord name="pydoc.TextDoc.section" func="yes">
			<Overload retVal="" descr="Format a section with a given heading.">
				<Param name="self" />
				<Param name="title" />
				<Param name="contents" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextRepr" func="yes">
			<Overload retVal="" descr="Class for safely making a text representation of a Python object.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.TextRepr.repr" />
		<KeyWord name="pydoc.TextRepr.repr1" />
		<KeyWord name="pydoc.TextRepr.repr_array" />
		<KeyWord name="pydoc.TextRepr.repr_deque" />
		<KeyWord name="pydoc.TextRepr.repr_dict" />
		<KeyWord name="pydoc.TextRepr.repr_frozenset" />
		<KeyWord name="pydoc.TextRepr.repr_instance" />
		<KeyWord name="pydoc.TextRepr.repr_int" />
		<KeyWord name="pydoc.TextRepr.repr_list" />
		<KeyWord name="pydoc.TextRepr.repr_set" />
		<KeyWord name="pydoc.TextRepr.repr_str" />
		<KeyWord name="pydoc.TextRepr.repr_string" />
		<KeyWord name="pydoc.TextRepr.repr_tuple" />
		<KeyWord name="pydoc.allmethods" />
		<KeyWord name="pydoc.apropos" func="yes">
			<Overload retVal="" descr="Print all the one-line module summaries that contain a substring.">
				<Param name="key" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.browse" func="yes">
			<Overload retVal="" descr="Start the enhanced pydoc Web server and open a Web browser.&#10;&#10;Use port '0' to start the server on an arbitrary port.&#10;Set open_browser to False to suppress opening a browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.classify_class_attrs" func="yes">
			<Overload retVal="" descr="Wrap inspect.classify_class_attrs, with fixup for data descriptors.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.classname" func="yes">
			<Overload retVal="" descr="Get a class name and qualify it with a module name if necessary.">
				<Param name="object" />
				<Param name="modname" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.cli" func="yes">
			<Overload retVal="" descr="Command-line interface (looks at sys.argv to decide what to do).">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.cram" func="yes">
			<Overload retVal="" descr="Omit part of a string if needed to make it fit in a maximum length.">
				<Param name="text" />
				<Param name="maxlen" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;A list-like sequence optimized for data accesses near its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.index" func="yes">
			<Overload retVal="" descr="D.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.insert" func="yes">
			<Overload retVal="" descr="D.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.describe" func="yes">
			<Overload retVal="" descr="Produce a short description of the given thing.">
				<Param name="thing" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.doc" func="yes">
			<Overload retVal="" descr="Display text documentation, given an object or a path to an object.">
				<Param name="thing" />
				<Param name="[title=Python Library Documentation: %s" />
				<Param name="[forceload=0" />
				<Param name="[output=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.format_exception_only" func="yes">
			<Overload retVal="" descr="Format the exception part of a traceback.&#10;&#10;The arguments are the exception type and value such as given by&#10;sys.last_type and sys.last_value. The return value is a list of&#10;strings, each ending in a newline.&#10;&#10;Normally, the list contains a single string; however, for&#10;SyntaxError exceptions, it contains several lines that (when&#10;printed) display detailed information about where the syntax&#10;error occurred.&#10;&#10;The message indicating which exception occurred is always the last&#10;string in the list.">
				<Param name="etype" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.getdoc" func="yes">
			<Overload retVal="" descr="Get the doc string or comments for an object.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.getpager" func="yes">
			<Overload retVal="" descr="Decide what method to use for paging through text.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.help" func="yes">
			<Overload retVal="" descr="(Helper)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.html" func="yes">
			<Overload retVal="" descr="(HTMLDoc)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.importfile" func="yes">
			<Overload retVal="" descr="Import a Python source file or compiled file given its path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.isdata" func="yes">
			<Overload retVal="" descr="Check if an object is of a type that probably means it's data.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ispackage" func="yes">
			<Overload retVal="" descr="Guess whether a path refers to a package directory.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ispath" />
		<KeyWord name="pydoc.locate" func="yes">
			<Overload retVal="" descr="Locate an object by name or dotted path, importing as necessary.">
				<Param name="path" />
				<Param name="[forceload=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.pager" func="yes">
			<Overload retVal="" descr="The first time this is called, determine what kind of pager to use.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.pathdirs" func="yes">
			<Overload retVal="" descr="Convert sys.path into a list of absolute, existing, unique paths.">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.pipepager" func="yes">
			<Overload retVal="" descr="Page through text by feeding it to another program.">
				<Param name="text" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.plain" func="yes">
			<Overload retVal="" descr="Remove boldface formatting from text.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.plainpager" func="yes">
			<Overload retVal="" descr="Simply print unformatted text.  This is the ultimate fallback.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.plaintext" func="yes">
			<Overload retVal="" descr="(_PlainTextDoc)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.render_doc" func="yes">
			<Overload retVal="" descr="Render text documentation, given an object or a path to an object.">
				<Param name="thing" />
				<Param name="[title=Python Library Documentation: %s" />
				<Param name="[forceload=0" />
				<Param name="[renderer=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.replace" func="yes">
			<Overload retVal="" descr="Do a series of global replacements on a string.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.resolve" func="yes">
			<Overload retVal="" descr="Given an object or a path to an object, get the object and its name.">
				<Param name="thing" />
				<Param name="[forceload=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.safeimport" func="yes">
			<Overload retVal="" descr="Import a module; handle errors; return None if the module isn't found.&#10;&#10;If the module *is* found but an exception occurs, it's wrapped in an&#10;ErrorDuringImport exception and reraised.  Unlike __import__, if a&#10;package path is specified, the module at the end of the path is returned,&#10;not the package at the beginning.  If the optional 'forceload' argument&#10;is 1, we reload the module from disk (unless it's a dynamic extension).">
				<Param name="path" />
				<Param name="[forceload=0" />
				<Param name="[cache={}]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.sort_attributes" func="yes">
			<Overload retVal="" descr="Sort the attrs list in-place by _fields and then alphabetically by name">
				<Param name="attrs" />
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.source_synopsis" />
		<KeyWord name="pydoc.splitdoc" func="yes">
			<Overload retVal="" descr="Split a doc string into a synopsis line (if any) and the rest.">
				<Param name="doc" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.stripid" func="yes">
			<Overload retVal="" descr="Remove the hexadecimal id from a Python object representation.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.synopsis" func="yes">
			<Overload retVal="" descr="Get the one-line summary out of a module file.">
				<Param name="filename" />
				<Param name="[cache={}]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.tempfilepager" func="yes">
			<Overload retVal="" descr="Page through text by invoking a program on a temporary file.">
				<Param name="text" />
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.text" func="yes">
			<Overload retVal="" descr="(TextDoc)">
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.ttypager" func="yes">
			<Overload retVal="" descr="Page through text on a text terminal.">
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.visiblename" func="yes">
			<Overload retVal="" descr="Decide whether to show documentation on a variable.">
				<Param name="name" />
				<Param name="[all=None" />
				<Param name="[obj=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.writedoc" func="yes">
			<Overload retVal="" descr="Write HTML documentation to a file in the current directory.">
				<Param name="thing" />
				<Param name="[forceload=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc.writedocs" func="yes">
			<Overload retVal="" descr="Write out HTML documentation for all modules in a directory tree.">
				<Param name="dir" />
				<Param name="[pkgpath" />
				<Param name="[done=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pydoc_data" />
		<KeyWord name="pyexpat" func="yes">
			<Overload retVal="" descr="Python wrapper for Expat parser.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.EXPAT_VERSION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ErrorString" func="yes">
			<Overload retVal="" descr="Returns string error for given number.">
				<Param name="code" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ExpatError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ExpatError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ExpatError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.ParserCreate" func="yes">
			<Overload retVal="" descr="Return a new XML parser object.">
				<Param name="[encoding=None" />
				<Param name="[namespace_separator=None" />
				<Param name="[intern=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType" func="yes">
			<Overload retVal="" descr="XML parser">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.ExternalEntityParserCreate" func="yes">
			<Overload retVal="" descr="Create a parser for parsing an external entity based on the information passed to the ExternalEntityRefHandler.">
				<Param name="self" />
				<Param name="context" />
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.GetBase" func="yes">
			<Overload retVal="" descr="Return base URL string for the parser.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.GetInputContext" func="yes">
			<Overload retVal="" descr="Return the untranslated text of the input that caused the current event.&#10;&#10;If the event was generated by a large amount of text (such as a start tag&#10;for an element with many attributes), not all of the text may be available.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.Parse" func="yes">
			<Overload retVal="" descr="Parse XML data.&#10;&#10;`isfinal' should be true at end of input.">
				<Param name="self" />
				<Param name="data" />
				<Param name="isfinal" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.ParseFile" func="yes">
			<Overload retVal="" descr="Parse XML data from file-like object.">
				<Param name="self" />
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.SetBase" func="yes">
			<Overload retVal="" descr="Set the base URL for the parser.">
				<Param name="self" />
				<Param name="base" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.SetParamEntityParsing" func="yes">
			<Overload retVal="" descr="Controls parsing of parameter entities (including the external DTD subset).&#10;&#10;Possible flag values are XML_PARAM_ENTITY_PARSING_NEVER,&#10;XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and&#10;XML_PARAM_ENTITY_PARSING_ALWAYS. Returns true if setting the flag&#10;was successful.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XMLParserType.UseForeignDTD" func="yes">
			<Overload retVal="" descr="Allows the application to provide an artificial external subset if one is not specified as part of the document instance.&#10;&#10;This readily allows the use of a 'default' document type controlled by the&#10;application, while still getting the advantage of providing document type&#10;information to the parser. 'flag' defaults to True if not provided.">
				<Param name="self" />
				<Param name="flag" />
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XML_PARAM_ENTITY_PARSING_ALWAYS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.expat_CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.features" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.native_encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="pyexpat.version_info" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="python_branch" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_build" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_compiler" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_implementation" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_list_modules" />
		<KeyWord name="python_list_modules.item" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="python_list_modules.stuff" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="python_revision" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_version" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="python_version_tuple" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="qsize" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="quantize" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="queue" func="yes">
			<Overload retVal="" descr="A multi-producer, multi-consumer queue.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Empty" func="yes">
			<Overload retVal="" descr="Exception raised by Queue.get(block=0)/get_nowait().">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Empty.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Empty.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Full" func="yes">
			<Overload retVal="" descr="Exception raised by Queue.put(block=0)/put_nowait().">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Full.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Full.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue" func="yes">
			<Overload retVal="" descr="Variant of Queue that retrieves most recently added entries first.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.empty" func="yes">
			<Overload retVal="" descr="Return True if the queue is empty, False otherwise (not reliable!).&#10;&#10;This method is likely to be removed at some point.  Use qsize() == 0&#10;as a direct substitute, but be aware that either approach risks a race&#10;condition where a queue can grow before the result of empty() or&#10;qsize() can be used.&#10;&#10;To create code that needs to wait for all queued tasks to be&#10;completed, the preferred technique is to use the join() method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.full" func="yes">
			<Overload retVal="" descr="Return True if the queue is full, False otherwise (not reliable!).&#10;&#10;This method is likely to be removed at some point.  Use qsize() &gt;= n&#10;as a direct substitute, but be aware that either approach risks a race&#10;condition where a queue can shrink before the result of full() or&#10;qsize() can be used.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.get" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;If optional args 'block' is true and 'timeout' is None (the default),&#10;block if necessary until an item is available. If 'timeout' is&#10;a non-negative number, it blocks at most 'timeout' seconds and raises&#10;the Empty exception if no item was available within that time.&#10;Otherwise ('block' is false), return an item if one is immediately&#10;available, else raise the Empty exception ('timeout' is ignored&#10;in that case).">
				<Param name="self" />
				<Param name="[block=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.get_nowait" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue without blocking.&#10;&#10;Only get an item if one is immediately available. Otherwise&#10;raise the Empty exception.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.join" func="yes">
			<Overload retVal="" descr="Blocks until all items in the Queue have been gotten and processed.&#10;&#10;The count of unfinished tasks goes up whenever an item is added to the&#10;queue. The count goes down whenever a consumer thread calls task_done()&#10;to indicate the item was retrieved and all work on it is complete.&#10;&#10;When the count of unfinished tasks drops to zero, join() unblocks.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.put" func="yes">
			<Overload retVal="" descr="Put an item into the queue.&#10;&#10;If optional args 'block' is true and 'timeout' is None (the default),&#10;block if necessary until a free slot is available. If 'timeout' is&#10;a non-negative number, it blocks at most 'timeout' seconds and raises&#10;the Full exception if no free slot was available within that time.&#10;Otherwise ('block' is false), put an item on the queue if a free slot&#10;is immediately available, else raise the Full exception ('timeout'&#10;is ignored in that case).">
				<Param name="self" />
				<Param name="item" />
				<Param name="[block=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.put_nowait" func="yes">
			<Overload retVal="" descr="Put an item into the queue without blocking.&#10;&#10;Only enqueue the item if a free slot is immediately available.&#10;Otherwise raise the Full exception.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.qsize" func="yes">
			<Overload retVal="" descr="Return the approximate size of the queue (not reliable!).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.LifoQueue.task_done" func="yes">
			<Overload retVal="" descr="Indicate that a formerly enqueued task is complete.&#10;&#10;Used by Queue consumer threads.  For each get() used to fetch a task,&#10;a subsequent call to task_done() tells the queue that the processing&#10;on the task is complete.&#10;&#10;If a join() is currently blocking, it will resume when all items&#10;have been processed (meaning that a task_done() call was received&#10;for every item that had been put() into the queue).&#10;&#10;Raises a ValueError if called more times than there were items&#10;placed in the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue" func="yes">
			<Overload retVal="" descr="Variant of Queue that retrieves open entries in priority order (lowest first).&#10;&#10;Entries are typically tuples of the form:  (priority number, data).">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.empty" func="yes">
			<Overload retVal="" descr="Return True if the queue is empty, False otherwise (not reliable!).&#10;&#10;This method is likely to be removed at some point.  Use qsize() == 0&#10;as a direct substitute, but be aware that either approach risks a race&#10;condition where a queue can grow before the result of empty() or&#10;qsize() can be used.&#10;&#10;To create code that needs to wait for all queued tasks to be&#10;completed, the preferred technique is to use the join() method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.full" func="yes">
			<Overload retVal="" descr="Return True if the queue is full, False otherwise (not reliable!).&#10;&#10;This method is likely to be removed at some point.  Use qsize() &gt;= n&#10;as a direct substitute, but be aware that either approach risks a race&#10;condition where a queue can shrink before the result of full() or&#10;qsize() can be used.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.get" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;If optional args 'block' is true and 'timeout' is None (the default),&#10;block if necessary until an item is available. If 'timeout' is&#10;a non-negative number, it blocks at most 'timeout' seconds and raises&#10;the Empty exception if no item was available within that time.&#10;Otherwise ('block' is false), return an item if one is immediately&#10;available, else raise the Empty exception ('timeout' is ignored&#10;in that case).">
				<Param name="self" />
				<Param name="[block=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.get_nowait" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue without blocking.&#10;&#10;Only get an item if one is immediately available. Otherwise&#10;raise the Empty exception.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.join" func="yes">
			<Overload retVal="" descr="Blocks until all items in the Queue have been gotten and processed.&#10;&#10;The count of unfinished tasks goes up whenever an item is added to the&#10;queue. The count goes down whenever a consumer thread calls task_done()&#10;to indicate the item was retrieved and all work on it is complete.&#10;&#10;When the count of unfinished tasks drops to zero, join() unblocks.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.put" func="yes">
			<Overload retVal="" descr="Put an item into the queue.&#10;&#10;If optional args 'block' is true and 'timeout' is None (the default),&#10;block if necessary until a free slot is available. If 'timeout' is&#10;a non-negative number, it blocks at most 'timeout' seconds and raises&#10;the Full exception if no free slot was available within that time.&#10;Otherwise ('block' is false), put an item on the queue if a free slot&#10;is immediately available, else raise the Full exception ('timeout'&#10;is ignored in that case).">
				<Param name="self" />
				<Param name="item" />
				<Param name="[block=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.put_nowait" func="yes">
			<Overload retVal="" descr="Put an item into the queue without blocking.&#10;&#10;Only enqueue the item if a free slot is immediately available.&#10;Otherwise raise the Full exception.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.qsize" func="yes">
			<Overload retVal="" descr="Return the approximate size of the queue (not reliable!).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.PriorityQueue.task_done" func="yes">
			<Overload retVal="" descr="Indicate that a formerly enqueued task is complete.&#10;&#10;Used by Queue consumer threads.  For each get() used to fetch a task,&#10;a subsequent call to task_done() tells the queue that the processing&#10;on the task is complete.&#10;&#10;If a join() is currently blocking, it will resume when all items&#10;have been processed (meaning that a task_done() call was received&#10;for every item that had been put() into the queue).&#10;&#10;Raises a ValueError if called more times than there were items&#10;placed in the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue" func="yes">
			<Overload retVal="" descr="Create a queue object with a given maximum size.&#10;&#10;If maxsize is &lt;= 0, the queue size is infinite.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.empty" func="yes">
			<Overload retVal="" descr="Return True if the queue is empty, False otherwise (not reliable!).&#10;&#10;This method is likely to be removed at some point.  Use qsize() == 0&#10;as a direct substitute, but be aware that either approach risks a race&#10;condition where a queue can grow before the result of empty() or&#10;qsize() can be used.&#10;&#10;To create code that needs to wait for all queued tasks to be&#10;completed, the preferred technique is to use the join() method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.full" func="yes">
			<Overload retVal="" descr="Return True if the queue is full, False otherwise (not reliable!).&#10;&#10;This method is likely to be removed at some point.  Use qsize() &gt;= n&#10;as a direct substitute, but be aware that either approach risks a race&#10;condition where a queue can shrink before the result of full() or&#10;qsize() can be used.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.get" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue.&#10;&#10;If optional args 'block' is true and 'timeout' is None (the default),&#10;block if necessary until an item is available. If 'timeout' is&#10;a non-negative number, it blocks at most 'timeout' seconds and raises&#10;the Empty exception if no item was available within that time.&#10;Otherwise ('block' is false), return an item if one is immediately&#10;available, else raise the Empty exception ('timeout' is ignored&#10;in that case).">
				<Param name="self" />
				<Param name="[block=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.get_nowait" func="yes">
			<Overload retVal="" descr="Remove and return an item from the queue without blocking.&#10;&#10;Only get an item if one is immediately available. Otherwise&#10;raise the Empty exception.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.join" func="yes">
			<Overload retVal="" descr="Blocks until all items in the Queue have been gotten and processed.&#10;&#10;The count of unfinished tasks goes up whenever an item is added to the&#10;queue. The count goes down whenever a consumer thread calls task_done()&#10;to indicate the item was retrieved and all work on it is complete.&#10;&#10;When the count of unfinished tasks drops to zero, join() unblocks.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.put" func="yes">
			<Overload retVal="" descr="Put an item into the queue.&#10;&#10;If optional args 'block' is true and 'timeout' is None (the default),&#10;block if necessary until a free slot is available. If 'timeout' is&#10;a non-negative number, it blocks at most 'timeout' seconds and raises&#10;the Full exception if no free slot was available within that time.&#10;Otherwise ('block' is false), put an item on the queue if a free slot&#10;is immediately available, else raise the Full exception ('timeout'&#10;is ignored in that case).">
				<Param name="self" />
				<Param name="item" />
				<Param name="[block=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.put_nowait" func="yes">
			<Overload retVal="" descr="Put an item into the queue without blocking.&#10;&#10;Only enqueue the item if a free slot is immediately available.&#10;Otherwise raise the Full exception.">
				<Param name="self" />
				<Param name="item" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.qsize" func="yes">
			<Overload retVal="" descr="Return the approximate size of the queue (not reliable!).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.Queue.task_done" func="yes">
			<Overload retVal="" descr="Indicate that a formerly enqueued task is complete.&#10;&#10;Used by Queue consumer threads.  For each get() used to fetch a task,&#10;a subsequent call to task_done() tells the queue that the processing&#10;on the task is complete.&#10;&#10;If a join() is currently blocking, it will resume when all items&#10;have been processed (meaning that a task_done() call was received&#10;for every item that had been put() into the queue).&#10;&#10;Raises a ValueError if called more times than there were items&#10;placed in the queue.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;A list-like sequence optimized for data accesses near its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.index" func="yes">
			<Overload retVal="" descr="D.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.insert" func="yes">
			<Overload retVal="" descr="D.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.heappop" func="yes">
			<Overload retVal="" descr="Pop the smallest item off the heap, maintaining the heap invariant.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.heappush" func="yes">
			<Overload retVal="" descr="heappush(heap, item) -&gt; None. Push item onto heap, maintaining the heap invariant.">
			</Overload>
		</KeyWord>
		<KeyWord name="queue.time" func="yes">
			<Overload retVal="" descr="monotonic() -&gt; float&#10;&#10;Monotonic clock, cannot go backward.">
			</Overload>
		</KeyWord>
		<KeyWord name="quick_ratio" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="quit" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri" func="yes">
			<Overload retVal="" descr="Conversions to/from quoted-printable transport encoding as per RFC 1521.">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.ESCAPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.HEX" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.MAXLINESIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.a2b_qp" func="yes">
			<Overload retVal="" descr="Decode a string of qp-encoded data.">
				<Param name="data" />
				<Param name="[header=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.b2a_qp" func="yes">
			<Overload retVal="" descr="Encode a string using quoted-printable encoding.&#10;&#10;On encoding, when istext is set, newlines are not encoded, and white&#10;space at end of lines is.  When istext is not set, \r and \n (CR/LF)&#10;are both encoded.  When quotetabs is set, space and tabs are encoded.">
				<Param name="data" />
				<Param name="[quotetabs=False" />
				<Param name="[istext=True" />
				<Param name="[header=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.decode" func="yes">
			<Overload retVal="" descr="Read 'input', apply quoted-printable decoding, and write to 'output'.&#10;'input' and 'output' are binary file objects.&#10;If 'header' is true, decode underscore as space (per RFC 1522).">
				<Param name="input" />
				<Param name="output" />
				<Param name="[header=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.decodestring" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[header=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.encode" func="yes">
			<Overload retVal="" descr="Read 'input', apply quoted-printable encoding, and write to 'output'.&#10;&#10;'input' and 'output' are binary file objects. The 'quotetabs' flag&#10;indicates whether embedded tabs and spaces should be quoted. Note that&#10;line-ending tabs and spaces are always encoded, as per RFC 1521.&#10;The 'header' flag indicates whether we are encoding spaces as _ as per RFC&#10;1522.">
				<Param name="input" />
				<Param name="output" />
				<Param name="quotetabs" />
				<Param name="[header=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.encodestring" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[quotetabs=False" />
				<Param name="[header=False]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.ishex" func="yes">
			<Overload retVal="" descr="Return true if the byte ordinal 'c' is a hexadecimal digit in ASCII.">
				<Param name="c" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.main" />
		<KeyWord name="quopri.needsquoting" func="yes">
			<Overload retVal="" descr="Decide whether a particular byte ordinal needs to be quoted.&#10;&#10;The 'quotetabs' flag indicates whether embedded tabs and spaces should be&#10;quoted.  Note that line-ending tabs and spaces are always encoded, as per&#10;RFC 1521.">
				<Param name="c" />
				<Param name="quotetabs" />
				<Param name="header" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.quote" func="yes">
			<Overload retVal="" descr="Quote a single character.">
				<Param name="c" />
			</Overload>
		</KeyWord>
		<KeyWord name="quopri.unhex" func="yes">
			<Overload retVal="" descr="Get the integer value of a hexadecimal number.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="quote" func="yes">
			<Overload retVal="" descr="Function of pipes">
			</Overload>
		</KeyWord>
		<KeyWord name="quoteaddr" func="yes">
			<Overload retVal="" descr="Function of smtplib">
			</Overload>
		</KeyWord>
		<KeyWord name="quoteattr" func="yes">
			<Overload retVal="" descr="Function of generate_python_autocomplete">
			</Overload>
		</KeyWord>
		<KeyWord name="quotedata" func="yes">
			<Overload retVal="" descr="Function of smtplib">
			</Overload>
		</KeyWord>
		<KeyWord name="radiogroup" func="yes">
			<Overload retVal="" descr="Function of msilib.Dialog">
			</Overload>
		</KeyWord>
		<KeyWord name="radix" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="raise" />
		<KeyWord name="raise_conversion_error" func="yes">
			<Overload retVal="" descr="Function of xdrlib">
			</Overload>
		</KeyWord>
		<KeyWord name="randbelow" func="yes">
			<Overload retVal="" descr="Function of secrets">
			</Overload>
		</KeyWord>
		<KeyWord name="randbits" func="yes">
			<Overload retVal="" descr="Function of secrets">
			</Overload>
		</KeyWord>
		<KeyWord name="randint" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="random" func="yes">
			<Overload retVal="" descr="Random variable generators.&#10;&#10;    integers&#10;    --------&#10;           uniform within range&#10;&#10;    sequences&#10;    ---------&#10;           pick random element&#10;           pick random sample&#10;           pick weighted random sample&#10;           generate random permutation&#10;&#10;    distributions on the real line:&#10;    ------------------------------&#10;           uniform&#10;           triangular&#10;           normal (Gaussian)&#10;           lognormal&#10;           negative exponential&#10;           gamma&#10;           beta&#10;           pareto&#10;           Weibull&#10;&#10;    distributions on the circle (angles 0 to 2pi)&#10;    ---------------------------------------------&#10;           circular uniform&#10;           von Mises&#10;&#10;General notes on the underlying Mersenne Twister core generator:&#10;&#10;* The period is 2**19937-1.&#10;* It is one of the most extensively tested generators in existence.&#10;* The random() method is implemented in C, executes in a single Python step,&#10;  and is, therefore, threadsafe.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.BPF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.LOG4" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.NV_MAGICCONST" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.RECIP_BPF" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random" func="yes">
			<Overload retVal="" descr="Random number generator base class used by bound module functions.&#10;&#10;Used to instantiate instances of Random to get generators that don't&#10;share state.&#10;&#10;Class Random can also be subclassed if you want to use a different basic&#10;generator of your own devising: in that case, override the following&#10;methods:  random(), seed(), getstate(), and setstate().&#10;Optionally, implement a getrandbits() method so that randrange()&#10;can cover arbitrarily large ranges.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.choices" func="yes">
			<Overload retVal="" descr="Return a k sized list of population elements chosen with replacement.&#10;&#10;If the relative weights or cumulative weights are not specified,&#10;the selections are made with equal probability.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates an int with k random bits.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.getstate" func="yes">
			<Overload retVal="" descr="Return internal state; can be passed to setstate() later.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.random" func="yes">
			<Overload retVal="" descr="random() -&gt; x in the interval [0, 1).">
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<class 'int'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence or set.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use range as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(range(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.seed" func="yes">
			<Overload retVal="" descr="Initialize internal state from hashable object.&#10;&#10;None or no argument seeds from current time or from an operating&#10;system specific randomness source if available.&#10;&#10;If *a* is an int, all bits are used.&#10;&#10;For version 2 (the default), all of the bits are used if *a* is a str,&#10;bytes, or bytearray.  For version 1 (provided for reproducing random&#10;sequences from older versions of Python), the algorithm for str and&#10;bytes generates a narrower range of seeds.">
				<Param name="self" />
				<Param name="[a=None" />
				<Param name="[version=2]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.setstate" func="yes">
			<Overload retVal="" descr="Restore internal state from object returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.shuffle" func="yes">
			<Overload retVal="" descr="Shuffle list x in place, and return None.&#10;&#10;Optional argument random is a 0-argument function returning a&#10;random float in [0.0, 1.0); if it is the default None, the&#10;standard random.random will be used.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.Random.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SG_MAGICCONST" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom" func="yes">
			<Overload retVal="" descr="Alternate random number generator using sources provided&#10;by the operating system (such as /dev/urandom on Unix or&#10;CryptGenRandom on Windows).&#10;&#10; Not available on all systems (see os.urandom() for details).">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.choices" func="yes">
			<Overload retVal="" descr="Return a k sized list of population elements chosen with replacement.&#10;&#10;If the relative weights or cumulative weights are not specified,&#10;the selections are made with equal probability.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates an int with k random bits.">
				<Param name="self" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.getstate" func="yes">
			<Overload retVal="" descr="Method should not be called for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.random" func="yes">
			<Overload retVal="" descr="Get the next random number in the range [0.0, 1.0).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<class 'int'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence or set.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use range as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(range(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.seed" func="yes">
			<Overload retVal="" descr="Stub method.  Not used for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.setstate" func="yes">
			<Overload retVal="" descr="Method should not be called for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.shuffle" func="yes">
			<Overload retVal="" descr="Shuffle list x in place, and return None.&#10;&#10;Optional argument random is a 0-argument function returning a&#10;random float in [0.0, 1.0); if it is the default None, the&#10;standard random.random will be used.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.SystemRandom.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.TWOPI" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="random.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.choices" func="yes">
			<Overload retVal="" descr="Return a k sized list of population elements chosen with replacement.&#10;&#10;If the relative weights or cumulative weights are not specified,&#10;the selections are made with equal probability.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates an int with k random bits.">
			</Overload>
		</KeyWord>
		<KeyWord name="random.getstate" func="yes">
			<Overload retVal="" descr="Return internal state; can be passed to setstate() later.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.random" func="yes">
			<Overload retVal="" descr="random() -&gt; x in the interval [0, 1).">
			</Overload>
		</KeyWord>
		<KeyWord name="random.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<class 'int'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence or set.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use range as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(range(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.seed" func="yes">
			<Overload retVal="" descr="Initialize internal state from hashable object.&#10;&#10;None or no argument seeds from current time or from an operating&#10;system specific randomness source if available.&#10;&#10;If *a* is an int, all bits are used.&#10;&#10;For version 2 (the default), all of the bits are used if *a* is a str,&#10;bytes, or bytearray.  For version 1 (provided for reproducing random&#10;sequences from older versions of Python), the algorithm for str and&#10;bytes generates a narrower range of seeds.">
				<Param name="self" />
				<Param name="[a=None" />
				<Param name="[version=2]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.setstate" func="yes">
			<Overload retVal="" descr="Restore internal state from object returned by getstate().">
				<Param name="self" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.shuffle" func="yes">
			<Overload retVal="" descr="Shuffle list x in place, and return None.&#10;&#10;Optional argument random is a 0-argument function returning a&#10;random float in [0.0, 1.0); if it is the default None, the&#10;standard random.random will be used.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="random.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="randrange" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="range" func="yes">
			<Overload retVal="" descr="range(stop) -&gt; range object&#10;range(start, stop[, step]) -&gt; range object&#10;&#10;Return an object that produces a sequence of integers from start (inclusive)&#10;to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.&#10;start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.&#10;These are exactly the valid indices for a list of 4 elements.&#10;When step is given, it specifies the increment (or decrement).">
			</Overload>
		</KeyWord>
		<KeyWord name="ratio" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_decode" func="yes">
			<Overload retVal="" descr="Function of json.JSONDecoder">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_input" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_items" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_unicode_escape_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="raw_unicode_escape_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="rawq_getchar" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="rcpt" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="re" func="yes">
			<Overload retVal="" descr="Support for regular expressions (RE).&#10;&#10;This module provides regular expression matching operations similar to&#10;those found in Perl.  It supports both 8-bit and Unicode strings; both&#10;the pattern and the strings being processed can contain null bytes and&#10;characters outside the US ASCII range.&#10;&#10;Regular expressions can contain both special and ordinary characters.&#10;Most ordinary characters, like &quot;A&quot;, &quot;a&quot;, or &quot;0&quot;, are the simplest&#10;regular expressions; they simply match themselves.  You can&#10;concatenate ordinary characters, so last matches the string 'last'.&#10;&#10;The special characters are:&#10;    &quot;.&quot;      Matches any character except a newline.&#10;    &quot;^&quot;      Matches the start of the string.&#10;    &quot;$&quot;      Matches the end of the string or just before the newline at&#10;             the end of the string.&#10;    &quot;*&quot;      Matches 0 or more (greedy) repetitions of the preceding RE.&#10;             Greedy means that it will match as many repetitions as possible.&#10;    &quot;+&quot;      Matches 1 or more (greedy) repetitions of the preceding RE.&#10;    &quot;?&quot;      Matches 0 or 1 (greedy) of the preceding RE.&#10;    *?,+?,?? Non-greedy versions of the previous three special characters.&#10;    {m,n}    Matches from m to n repetitions of the preceding RE.&#10;    {m,n}?   Non-greedy version of the above.&#10;    &quot;\\&quot;     Either escapes special characters or signals a special sequence.&#10;    []       Indicates a set of characters.&#10;             A &quot;^&quot; as the first character indicates a complementing set.&#10;    &quot;|&quot;      A|B, creates an RE that will match either A or B.&#10;    (...)    Matches the RE inside the parentheses.&#10;             The contents can be retrieved or matched later in the string.&#10;    (?aiLmsux) Set the A, I, L, M, S, U, or X flag for the RE (see below).&#10;    (?:...)  Non-grouping version of regular parentheses.&#10;    (?P&lt;name&gt;...) The substring matched by the group is accessible by name.&#10;    (?P=name)     Matches the text matched earlier by the group named name.&#10;    (?#...)  A comment; ignored.&#10;    (?=...)  Matches if ... matches next, but doesn't consume the string.&#10;    (?!...)  Matches if ... doesn't match next.&#10;    (?&lt;=...) Matches if preceded by ... (must be fixed length).&#10;    (?&lt;!...) Matches if not preceded by ... (must be fixed length).&#10;    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,&#10;                       the (optional) no pattern otherwise.&#10;&#10;The special sequences consist of &quot;\\&quot; and a character from the list&#10;below.  If the ordinary character is not on the list, then the&#10;resulting RE will match the second character.&#10;    \number  Matches the contents of the group of the same number.&#10;    \A       Matches only at the start of the string.&#10;    \Z       Matches only at the end of the string.&#10;    \b       Matches the empty string, but only at the start or end of a word.&#10;    \B       Matches the empty string, but not at the start or end of a word.&#10;    \d       Matches any decimal digit; equivalent to the set [0-9] in&#10;             bytes patterns or string patterns with the ASCII flag.&#10;             In string patterns without the ASCII flag, it will match the whole&#10;             range of Unicode digits.&#10;    \D       Matches any non-digit character; equivalent to [^\d].&#10;    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in&#10;             bytes patterns or string patterns with the ASCII flag.&#10;             In string patterns without the ASCII flag, it will match the whole&#10;             range of Unicode whitespace characters.&#10;    \S       Matches any non-whitespace character; equivalent to [^\s].&#10;    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]&#10;             in bytes patterns or string patterns with the ASCII flag.&#10;             In string patterns without the ASCII flag, it will match the&#10;             range of Unicode alphanumeric characters (letters plus digits&#10;             plus underscore).&#10;             With LOCALE, it will match the set [0-9_] plus characters defined&#10;             as letters for the current locale.&#10;    \W       Matches the complement of \w.&#10;    \\       Matches a literal backslash.&#10;&#10;This module exports the following functions:&#10;    match     Match a regular expression pattern to the beginning of a string.&#10;    fullmatch Match a regular expression pattern to all of a string.&#10;    search    Search a string for the presence of a pattern.&#10;    sub       Substitute occurrences of a pattern found in a string.&#10;    subn      Same as sub, but also return the number of substitutions made.&#10;    split     Split a string by the occurrences of a pattern.&#10;    findall   Find all occurrences of a pattern in a string.&#10;    finditer  Return an iterator yielding a match object for each match.&#10;    compile   Compile a pattern into a RegexObject.&#10;    purge     Clear the regular expression cache.&#10;    escape    Backslash all non-alphanumerics in a string.&#10;&#10;Some of the functions in this module takes flags as optional parameters:&#10;    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D&#10;                   match the corresponding ASCII character categories&#10;                   (rather than the whole Unicode categories, which is the&#10;                   default).&#10;                   For bytes patterns, this flag is the only available&#10;                   behaviour and needn't be specified.&#10;    I  IGNORECASE  Perform case-insensitive matching.&#10;    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.&#10;    M  MULTILINE   &quot;^&quot; matches the beginning of lines (after a newline)&#10;                   as well as the string.&#10;                   &quot;$&quot; matches the end of lines (before a newline) as well&#10;                   as the end of the string.&#10;    S  DOTALL      &quot;.&quot; matches any character at all, including the newline.&#10;    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.&#10;    U  UNICODE     For compatibility only. Ignored for string patterns (it&#10;                   is the default), and forbidden for bytes patterns.&#10;&#10;This module also defines an exception 'error'.">
			</Overload>
		</KeyWord>
		<KeyWord name="re.A" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.ASCII" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.DEBUG" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.DOTALL" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.I" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.IGNORECASE" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.L" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.LOCALE" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.M" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.MULTILINE" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.RegexFlag" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.S" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.Scanner" />
		<KeyWord name="re.Scanner.scan" />
		<KeyWord name="re.T" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.TEMPLATE" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.U" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.UNICODE" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.VERBOSE" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.X" func="yes">
			<Overload retVal="" descr="(RegexFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.compile" func="yes">
			<Overload retVal="" descr="Compile a regular expression pattern, returning a pattern object.">
				<Param name="pattern" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.error" func="yes">
			<Overload retVal="" descr="Exception raised for invalid regular expressions.&#10;&#10;Attributes:&#10;&#10;    msg: The unformatted error message&#10;    pattern: The regular expression pattern&#10;    pos: The index in the pattern where compilation failed (may be None)&#10;    lineno: The line corresponding to pos (may be None)&#10;    colno: The column corresponding to pos (may be None)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="re.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="re.escape" func="yes">
			<Overload retVal="" descr="Escape all the characters in pattern except ASCII letters, numbers and '_'.">
				<Param name="pattern" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.findall" func="yes">
			<Overload retVal="" descr="Return a list of all non-overlapping matches in the string.&#10;&#10;If one or more capturing groups are present in the pattern, return&#10;a list of groups; this will be a list of tuples if the pattern&#10;has more than one group.&#10;&#10;Empty matches are included in the result.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.finditer" func="yes">
			<Overload retVal="" descr="Return an iterator over all non-overlapping matches in the&#10;string.  For each match, the iterator returns a match object.&#10;&#10;Empty matches are included in the result.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.fullmatch" func="yes">
			<Overload retVal="" descr="Try to apply the pattern to all of the string, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.match" func="yes">
			<Overload retVal="" descr="Try to apply the pattern at the start of the string, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.purge" func="yes">
			<Overload retVal="" descr="Clear the regular expression caches">
			</Overload>
		</KeyWord>
		<KeyWord name="re.search" func="yes">
			<Overload retVal="" descr="Scan through string looking for a match to the pattern, returning&#10;a match object, or None if no match was found.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.split" func="yes">
			<Overload retVal="" descr="Split the source string by the occurrences of the pattern,&#10;returning a list containing the resulting substrings.  If&#10;capturing parentheses are used in pattern, then the text of all&#10;groups in the pattern are also returned as part of the resulting&#10;list.  If maxsplit is nonzero, at most maxsplit splits occur,&#10;and the remainder of the string is returned as the final element&#10;of the list.">
				<Param name="pattern" />
				<Param name="string" />
				<Param name="[maxsplit=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.sub" func="yes">
			<Overload retVal="" descr="Return the string obtained by replacing the leftmost&#10;non-overlapping occurrences of the pattern in string by the&#10;replacement repl.  repl can be either a string or a callable;&#10;if a string, backslash escapes in it are processed.  If it is&#10;a callable, it's passed the match object and must return&#10;a replacement string to be used.">
				<Param name="pattern" />
				<Param name="repl" />
				<Param name="string" />
				<Param name="[count=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.subn" func="yes">
			<Overload retVal="" descr="Return a 2-tuple containing (new_string, number).&#10;new_string is the string obtained by replacing the leftmost&#10;non-overlapping occurrences of the pattern in the source&#10;string by the replacement repl.  number is the number of&#10;substitutions that were made. repl can be either a string or a&#10;callable; if a string, backslash escapes in it are processed.&#10;If it is a callable, it's passed the match object and must&#10;return a replacement string to be used.">
				<Param name="pattern" />
				<Param name="repl" />
				<Param name="string" />
				<Param name="[count=0" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="re.template" func="yes">
			<Overload retVal="" descr="Compile a template pattern, returning a pattern object">
				<Param name="pattern" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="read" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="read1" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readPlist" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="readPlistFromBytes" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="read_all" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_binary" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_bytes" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="read_bytes1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_bytes4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_bytes8" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_code" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="read_decimalnl_long" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_decimalnl_short" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_eager" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_file" func="yes">
			<Overload retVal="" descr="Function of optparse.Values">
			</Overload>
		</KeyWord>
		<KeyWord name="read_float8" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_floatnl" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_int4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_lazy" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_lines" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_lines_to_eof" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_lines_to_outerboundary" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_long1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_long4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_mime_types" func="yes">
			<Overload retVal="" descr="Function of mimetypes">
			</Overload>
		</KeyWord>
		<KeyWord name="read_module" func="yes">
			<Overload retVal="" descr="Function of optparse.Values">
			</Overload>
		</KeyWord>
		<KeyWord name="read_multi" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_rsrc" func="yes">
			<Overload retVal="" descr="Function of binhex.HexBin">
			</Overload>
		</KeyWord>
		<KeyWord name="read_sb_data" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_single" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_some" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_string1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_string4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_stringnl" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_stringnl_noescape" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_stringnl_noescape_pair" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_text" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="read_token" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="read_uint1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_uint2" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_uint4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_uint8" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_unicodestring1" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_unicodestring4" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_unicodestring8" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_unicodestringnl" func="yes">
			<Overload retVal="" descr="Function of pickletools">
			</Overload>
		</KeyWord>
		<KeyWord name="read_until" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_urlencoded" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="read_very_eager" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_very_lazy" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="read_windows_registry" func="yes">
			<Overload retVal="" descr="Function of mimetypes.MimeTypes">
			</Overload>
		</KeyWord>
		<KeyWord name="readable" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="readall" func="yes">
			<Overload retVal="" descr="Function of io.FileIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readbuffer_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="reader" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="readexactly" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="readfp" func="yes">
			<Overload retVal="" descr="Function of mimetypes.MimeTypes">
			</Overload>
		</KeyWord>
		<KeyWord name="readframes" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="readinto" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readinto1" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readline" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="readlines" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="readlink" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="readmailcapfile" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="readmodule" func="yes">
			<Overload retVal="" descr="Function of pyclbr">
			</Overload>
		</KeyWord>
		<KeyWord name="readmodule_ex" func="yes">
			<Overload retVal="" descr="Function of pyclbr">
			</Overload>
		</KeyWord>
		<KeyWord name="readuntil" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="readwrite" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="real_quick_ratio" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="realpath" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="recent" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="recursive_repr" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="recv" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="recv_into" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="recvfrom" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="recvfrom_into" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="recvmsg" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="recvmsg_into" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="reduce" func="yes">
			<Overload retVal="" descr="Function of enum">
			</Overload>
		</KeyWord>
		<KeyWord name="register" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="registerResult" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="register_X_browsers" func="yes">
			<Overload retVal="" descr="Function of webbrowser">
			</Overload>
		</KeyWord>
		<KeyWord name="register_adapter" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="register_archive_format" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="register_converter" func="yes">
			<Overload retVal="" descr="Function of sqlite3">
			</Overload>
		</KeyWord>
		<KeyWord name="register_dialect" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="register_error" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="register_finder" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="register_loader_type" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="register_namespace_handler" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="register_optionflag" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="register_unpack_format" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="reindent" func="yes">
			<Overload retVal="" descr="Function of timeit">
			</Overload>
		</KeyWord>
		<KeyWord name="reinitialize_command" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="relative_to" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="release" func="yes">
			<Overload retVal="" descr="Release the underlying buffer exposed by the memoryview object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="release_lock" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="reload" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="relpath" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="remainder" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="remainder_near" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="remove" func="yes">
			<Overload retVal="" descr="Remove an element from a set; it must be a member.&#10;&#10;If the element is not a member, raise a KeyError.">
			</Overload>
		</KeyWord>
		<KeyWord name="removeFilter" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="removeHandler" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="removeResult" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_done_callback" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_extension" func="yes">
			<Overload retVal="" descr="Function of copyreg">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_flag" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_folder" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_label" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_option" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_pyc" func="yes">
			<Overload retVal="" descr="Function of msilib.Directory">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_reader" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_sequence" func="yes">
			<Overload retVal="" descr="Function of mailbox.MHMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_signal_handler" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="remove_writer" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="removedirs" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="removeduppaths" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="rename" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="renames" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="render_doc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="repeat" func="yes">
			<Overload retVal="" descr="Function of timeit">
			</Overload>
		</KeyWord>
		<KeyWord name="replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; str&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="replace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="replace_header" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="replace_paths_in_code" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="replace_variables" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="report" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="report_failure" func="yes">
			<Overload retVal="" descr="Function of doctest.DebugRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="report_full_closure" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="report_partial_closure" func="yes">
			<Overload retVal="" descr="Function of filecmp.dircmp">
			</Overload>
		</KeyWord>
		<KeyWord name="report_start" func="yes">
			<Overload retVal="" descr="Function of doctest.DebugRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="report_success" func="yes">
			<Overload retVal="" descr="Function of doctest.DebugRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="report_unexpected_exception" func="yes">
			<Overload retVal="" descr="Function of doctest.DebugRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="repr" func="yes">
			<Overload retVal="" descr="Return the canonical string representation of the object.&#10;&#10;For many object types, including most builtins, eval(repr(obj)) == obj.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="repr1" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_array" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_deque" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_dict" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_frozenset" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_instance" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_int" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_list" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_set" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_str" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_string" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_tuple" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="repr_unicode" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLRepr">
			</Overload>
		</KeyWord>
		<KeyWord name="reprlib" func="yes">
			<Overload retVal="" descr="Redo the builtin repr() (representation) but with limits on most sizes.">
			</Overload>
		</KeyWord>
		<KeyWord name="reprlib.Repr" />
		<KeyWord name="reprlib.Repr.repr" />
		<KeyWord name="reprlib.Repr.repr1" />
		<KeyWord name="reprlib.Repr.repr_array" />
		<KeyWord name="reprlib.Repr.repr_deque" />
		<KeyWord name="reprlib.Repr.repr_dict" />
		<KeyWord name="reprlib.Repr.repr_frozenset" />
		<KeyWord name="reprlib.Repr.repr_instance" />
		<KeyWord name="reprlib.Repr.repr_int" />
		<KeyWord name="reprlib.Repr.repr_list" />
		<KeyWord name="reprlib.Repr.repr_set" />
		<KeyWord name="reprlib.Repr.repr_str" />
		<KeyWord name="reprlib.Repr.repr_tuple" />
		<KeyWord name="reprlib.aRepr" func="yes">
			<Overload retVal="" descr="(Repr)">
			</Overload>
		</KeyWord>
		<KeyWord name="reprlib.get_ident" func="yes">
			<Overload retVal="" descr="get_ident() -&gt; integer&#10;&#10;Return a non-zero integer that uniquely identifies the current thread&#10;amongst other threads that exist simultaneously.&#10;This may be used to identify per-thread resources.&#10;Even though on some platforms threads identities may appear to be&#10;allocated consecutive numbers starting at 1, this behavior should not&#10;be relied upon, and the number should be seen purely as a magic cookie.&#10;A thread's identity may be reused for another thread after it exits.">
			</Overload>
		</KeyWord>
		<KeyWord name="reprlib.islice" func="yes">
			<Overload retVal="" descr="islice(iterable, stop) --&gt; islice object&#10;islice(iterable, start, stop[, step]) --&gt; islice object&#10;&#10;Return an iterator whose next() method returns selected values from an&#10;iterable.  If start is specified, will skip all preceding elements;&#10;otherwise, start defaults to zero.  Step defaults to one.  If&#10;specified as another value, step determines how many values are &#10;skipped between successive calls.  Works like a slice() on a list&#10;but returns an iterator.">
			</Overload>
		</KeyWord>
		<KeyWord name="reprlib.recursive_repr" func="yes">
			<Overload retVal="" descr="Decorator to make a repr function return fillvalue for a recursive call">
				<Param name="[fillvalue=...]" />
			</Overload>
		</KeyWord>
		<KeyWord name="reprlib.repr" />
		<KeyWord name="require" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="requires" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.DistInfoDistribution">
			</Overload>
		</KeyWord>
		<KeyWord name="reset" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="resetbuffer" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="resetlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="resetwarnings" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="resize" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="resolve" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="resource_exists" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="resource_filename" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="resource_isdir" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="resource_listdir" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="resource_stream" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="resource_string" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="response" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="restore" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="result" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="results" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="resume_reading" func="yes">
			<Overload retVal="" descr="Function of asyncio.ReadTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="resume_writing" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseProtocol">
			</Overload>
		</KeyWord>
		<KeyWord name="retr" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="retrbinary" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="retrlines" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="return" />
		<KeyWord name="reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="reverse_order" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="reversed" func="yes">
			<Overload retVal="" descr="reversed(sequence) -&gt; reverse iterator over values of the sequence&#10;&#10;Return a reverse iterator">
			</Overload>
		</KeyWord>
		<KeyWord name="rewind" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub[, start[, end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="rgb_to_hls" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="rgb_to_hsv" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="rgb_to_yiq" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="rglob" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub[, start[, end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Raises ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; str&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter" func="yes">
			<Overload retVal="" descr="Word completion for GNU readline.&#10;&#10;The completer completes keywords, built-ins and globals in a selectable&#10;namespace (which defaults to __main__); when completing NAME.NAME..., it&#10;evaluates (!) the expression up to the last dot and completes its attributes.&#10;&#10;It's very cool to do &quot;import sys&quot; type &quot;sys.&quot;, hit the completion key (twice),&#10;and see the list of names defined by the sys module!&#10;&#10;Tip: to use the tab key as the completion key, call&#10;&#10;    readline.parse_and_bind(&quot;tab: complete&quot;)&#10;&#10;Notes:&#10;&#10;- Exceptions raised by the completer function are *ignored* (and generally cause&#10;  the completion to fail).  This is a feature -- since readline sets the tty&#10;  device in raw (or cbreak) mode, printing a traceback wouldn't work well&#10;  without some complicated hoopla to save, reset and restore the tty state.&#10;&#10;- The evaluation of the NAME.NAME... form may cause arbitrary application&#10;  defined code to be executed if an object with a __getattr__ hook is found.&#10;  Since it is the responsibility of the application (or the user) to enable this&#10;  feature, I consider this an acceptable risk.  More complicated expressions&#10;  (e.g. function calls or indexing operations) are *not* evaluated.&#10;&#10;- When the original stdin is not a tty device, GNU readline is never&#10;  used, and this module (and the readline module) are silently inactive.">
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter.Completer" />
		<KeyWord name="rlcompleter.Completer.attr_matches" func="yes">
			<Overload retVal="" descr="Compute matches when text contains a dot.&#10;&#10;Assuming the text is of the form NAME.NAME....[NAME], and is&#10;evaluable in self.namespace, it will be evaluated and its attributes&#10;(as revealed by dir()) are used as possible completions.  (For class&#10;instances, class members are also considered.)&#10;&#10;WARNING: this can still invoke arbitrary C code, if an object&#10;with a __getattr__ hook is evaluated.">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter.Completer.complete" func="yes">
			<Overload retVal="" descr="Return the next possible completion for 'text'.&#10;&#10;This is called successively with state == 0, 1, 2, ... until it&#10;returns None.  The completion should begin with 'text'.">
				<Param name="self" />
				<Param name="text" />
				<Param name="state" />
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter.Completer.global_matches" func="yes">
			<Overload retVal="" descr="Compute matches when text is a simple name.&#10;&#10;Return a list of all keywords, built-in functions and names currently&#10;defined in self.namespace that match.">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="rlcompleter.get_class_members" />
		<KeyWord name="rmd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="rmdir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="rmtree" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="rollback" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="rollover" func="yes">
			<Overload retVal="" descr="Function of tempfile.SpooledTemporaryFile">
			</Overload>
		</KeyWord>
		<KeyWord name="rotate" func="yes">
			<Overload retVal="" descr="Function of asynchat.deque">
			</Overload>
		</KeyWord>
		<KeyWord name="round" func="yes">
			<Overload retVal="" descr="round(number[, ndigits]) -&gt; number&#10;&#10;Round a number to a given precision in decimal digits (default 0 digits).&#10;This returns an int when called with one argument, otherwise the&#10;same type as the number. ndigits may be negative.">
			</Overload>
		</KeyWord>
		<KeyWord name="rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="rpop" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="rset" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="rshift" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="run" func="yes">
			<Overload retVal="" descr="Function of cProfile">
			</Overload>
		</KeyWord>
		<KeyWord name="runTest" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="runTests" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="run_command" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="run_commands" func="yes">
			<Overload retVal="" descr="Function of setuptools.Distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="run_coroutine_threadsafe" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="run_docstring_examples" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="run_forever" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="run_in_executor" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="run_main" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="run_module" func="yes">
			<Overload retVal="" descr="Function of runpy">
			</Overload>
		</KeyWord>
		<KeyWord name="run_path" func="yes">
			<Overload retVal="" descr="Function of runpy">
			</Overload>
		</KeyWord>
		<KeyWord name="run_script" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="run_until_complete" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="runcall" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="runcode" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="runctx" func="yes">
			<Overload retVal="" descr="Function of cProfile">
			</Overload>
		</KeyWord>
		<KeyWord name="runeval" func="yes">
			<Overload retVal="" descr="Function of pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="runfunc" func="yes">
			<Overload retVal="" descr="Function of trace.Trace">
			</Overload>
		</KeyWord>
		<KeyWord name="runpy" func="yes">
			<Overload retVal="" descr="runpy.py - locating and running Python code using the module namespace&#10;&#10;Provides support for locating and running Python scripts using the Python&#10;module namespace instead of the native filesystem.&#10;&#10;This allows Python code to play nicely with non-filesystem based PEP 302&#10;importers when locating support scripts as well as when importing modules.">
			</Overload>
		</KeyWord>
		<KeyWord name="runpy.get_importer" func="yes">
			<Overload retVal="" descr="Retrieve a finder for the given path item&#10;&#10;The returned finder is cached in sys.path_importer_cache&#10;if it was newly created by a path hook.&#10;&#10;The cache (or part of it) can be cleared manually if a&#10;rescan of sys.path_hooks is necessary.">
				<Param name="path_item" />
			</Overload>
		</KeyWord>
		<KeyWord name="runpy.read_code" />
		<KeyWord name="runpy.run_module" func="yes">
			<Overload retVal="" descr="Execute a module's code without importing it&#10;&#10;Returns the resulting top level namespace dictionary">
				<Param name="mod_name" />
				<Param name="[init_globals=None" />
				<Param name="[run_name=None" />
				<Param name="[alter_sys=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="runpy.run_path" func="yes">
			<Overload retVal="" descr="Execute code located at the specified filesystem location&#10;&#10;Returns the resulting top level namespace dictionary&#10;&#10;The file path may refer directly to a Python script (i.e.&#10;one that could be directly executed with execfile) or else&#10;it may refer to a zipfile or directory containing a top&#10;level __main__.py script.">
				<Param name="path_name" />
				<Param name="[init_globals=None" />
				<Param name="[run_name=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="runsource" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="safe_extra" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="safe_name" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="safe_version" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="safeimport" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="saferepr" func="yes">
			<Overload retVal="" descr="Function of pprint">
			</Overload>
		</KeyWord>
		<KeyWord name="same_quantum" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="samefile" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="sameopenfile" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="samestat" func="yes">
			<Overload retVal="" descr="Function of genericpath">
			</Overload>
		</KeyWord>
		<KeyWord name="sample" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="sanitize" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="scaleb" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="scan" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.AvailableDistributions">
			</Overload>
		</KeyWord>
		<KeyWord name="scan_code" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="scan_opcodes" func="yes">
			<Overload retVal="" descr="Function of modulefinder.ModuleFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="scandir" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="scanvars" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="sched" func="yes">
			<Overload retVal="" descr='A generally useful event scheduler class.&#10;&#10;Each instance of this class manages its own queue.&#10;No multi-threading is implied; you are supposed to hack that&#10;yourself, or use a single instance per application.&#10;&#10;Each instance is parametrized with two functions, one that is&#10;supposed to return the current time, one that is supposed to&#10;implement a delay.  You can implement real-time scheduling by&#10;substituting time and sleep from built-in module time, or you can&#10;implement simulated time by writing your own functions.  This can&#10;also be used to integrate scheduling with STDWIN events; the delay&#10;function is allowed to modify the queue.  Time can be expressed as&#10;integers or floating point numbers, as long as it is consistent.&#10;&#10;Events are specified by tuples (time, priority, action, argument, kwargs).&#10;As in UNIX, lower priority numbers mean higher priority; in this&#10;way the queue can be maintained as a priority queue.  Execution of the&#10;event means calling the action function, passing it the argument&#10;sequence in "argument" (remember that in Python, multiple function&#10;arguments are be packed in a sequence) and keyword parameters in "kwargs".&#10;The action function may be an instance method so it&#10;has another way to reference private data (besides global variables).'>
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event" func="yes">
			<Overload retVal="" descr="Event(time, priority, action, argument, kwargs)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.action" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.argument" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.kwargs" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.priority" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.Event.time" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler" />
		<KeyWord name="sched.scheduler.cancel" func="yes">
			<Overload retVal="" descr="Remove an event from the queue.&#10;&#10;This must be presented the ID as returned by enter().&#10;If the event is not in the queue, this raises ValueError.">
				<Param name="self" />
				<Param name="event" />
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler.empty" func="yes">
			<Overload retVal="" descr="Check whether the queue is empty.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler.enter" func="yes">
			<Overload retVal="" descr="A variant that specifies the time as a relative time.&#10;&#10;This is actually the more commonly used interface.">
				<Param name="self" />
				<Param name="delay" />
				<Param name="priority" />
				<Param name="action" />
				<Param name="[argument=()" />
				<Param name="[kwargs=<object object at 0x0405FC18>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler.enterabs" func="yes">
			<Overload retVal="" descr="Enter a new event in the queue at an absolute time.&#10;&#10;Returns an ID for the event which can be used to remove it,&#10;if necessary.">
				<Param name="self" />
				<Param name="time" />
				<Param name="priority" />
				<Param name="action" />
				<Param name="[argument=()" />
				<Param name="[kwargs=<object object at 0x0405FC18>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler.queue" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sched.scheduler.run" func="yes">
			<Overload retVal="" descr="Execute events until the queue is empty.&#10;If blocking is False executes the scheduled events due to&#10;expire soonest (if any) and then return the deadline of the&#10;next scheduled call in the scheduler.&#10;&#10;When there is a positive delay until the first event, the&#10;delay function is called and the event is left in the queue;&#10;otherwise, the event is removed from the queue and executed&#10;(its action function is called, passing it the argument).  If&#10;the delay function returns prematurely, it is simply&#10;restarted.&#10;&#10;It is legal for both the delay function and the action&#10;function to modify the queue or to raise an exception;&#10;exceptions are not caught but the scheduler's state remains&#10;well-defined so run() may be called again.&#10;&#10;A questionable hack is added to allow other threads to run:&#10;just after an event is executed, a delay of 0 is executed, to&#10;avoid monopolizing the CPU when other threads are also&#10;runnable.">
				<Param name="self" />
				<Param name="[blocking=True]" />
			</Overload>
		</KeyWord>
		<KeyWord name="scheduler" func="yes">
			<Overload retVal="" descr="Function of sched.scheduler">
			</Overload>
		</KeyWord>
		<KeyWord name="script_from_examples" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="search" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="search_function" func="yes">
			<Overload retVal="" descr="Function of encodings">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets" func="yes">
			<Overload retVal="" descr="Generate cryptographically strong pseudo-random numbers suitable for&#10;managing secrets such as account authentication, tokens, and similar.&#10;&#10;See PEP 506 for more information.&#10;https://www.python.org/dev/peps/pep-0506/">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.DEFAULT_ENTROPY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom" func="yes">
			<Overload retVal="" descr="Alternate random number generator using sources provided&#10;by the operating system (such as /dev/urandom on Unix or&#10;CryptGenRandom on Windows).&#10;&#10; Not available on all systems (see os.urandom() for details).">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.betavariate" func="yes">
			<Overload retVal="" descr="Beta distribution.&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;Returned values range between 0 and 1.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.choices" func="yes">
			<Overload retVal="" descr="Return a k sized list of population elements chosen with replacement.&#10;&#10;If the relative weights or cumulative weights are not specified,&#10;the selections are made with equal probability.">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.expovariate" func="yes">
			<Overload retVal="" descr='Exponential distribution.&#10;&#10;lambd is 1.0 divided by the desired mean.  It should be&#10;nonzero.  (The parameter would be called "lambda", but that is&#10;a reserved word in Python.)  Returned values range from 0 to&#10;positive infinity if lambd is positive, and from negative&#10;infinity to 0 if lambd is negative.'>
				<Param name="self" />
				<Param name="lambd" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.gammavariate" func="yes">
			<Overload retVal="" descr="Gamma distribution.  Not the gamma function!&#10;&#10;Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.&#10;&#10;The probability distribution function is:&#10;&#10;            x ** (alpha - 1) * math.exp(-x / beta)&#10;  pdf(x) =  --------------------------------------&#10;              math.gamma(alpha) * beta ** alpha">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.gauss" func="yes">
			<Overload retVal="" descr="Gaussian distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.  This is&#10;slightly faster than the normalvariate() function.&#10;&#10;Not thread-safe without a lock around calls.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.getrandbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates an int with k random bits.">
				<Param name="self" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.getstate" func="yes">
			<Overload retVal="" descr="Method should not be called for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.lognormvariate" func="yes">
			<Overload retVal="" descr="Log normal distribution.&#10;&#10;If you take the natural logarithm of this distribution, you'll get a&#10;normal distribution with mean mu and standard deviation sigma.&#10;mu can have any value, and sigma must be greater than zero.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.normalvariate" func="yes">
			<Overload retVal="" descr="Normal distribution.&#10;&#10;mu is the mean, and sigma is the standard deviation.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="sigma" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.paretovariate" func="yes">
			<Overload retVal="" descr="Pareto distribution.  alpha is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.randint" func="yes">
			<Overload retVal="" descr="Return random integer in range [a, b], including both end points.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.random" func="yes">
			<Overload retVal="" descr="Get the next random number in the range [0.0, 1.0).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.randrange" func="yes">
			<Overload retVal="" descr="Choose a random item from range(start, stop[, step]).&#10;&#10;This fixes the problem with randint() which includes the&#10;endpoint; in Python this is usually not what you want.">
				<Param name="self" />
				<Param name="start" />
				<Param name="[stop=None" />
				<Param name="[step=1" />
				<Param name="[_int=<class 'int'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.sample" func="yes">
			<Overload retVal="" descr="Chooses k unique random elements from a population sequence or set.&#10;&#10;Returns a new list containing elements from the population while&#10;leaving the original population unchanged.  The resulting list is&#10;in selection order so that all sub-slices will also be valid random&#10;samples.  This allows raffle winners (the sample) to be partitioned&#10;into grand prize and second place winners (the subslices).&#10;&#10;Members of the population need not be hashable or unique.  If the&#10;population contains repeats, then each occurrence is a possible&#10;selection in the sample.&#10;&#10;To choose a sample in a range of integers, use range as an argument.&#10;This is especially fast and space efficient for sampling from a&#10;large population:   sample(range(10000000), 60)">
				<Param name="self" />
				<Param name="population" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.seed" func="yes">
			<Overload retVal="" descr="Stub method.  Not used for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.setstate" func="yes">
			<Overload retVal="" descr="Method should not be called for a system random number generator.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.shuffle" func="yes">
			<Overload retVal="" descr="Shuffle list x in place, and return None.&#10;&#10;Optional argument random is a 0-argument function returning a&#10;random float in [0.0, 1.0); if it is the default None, the&#10;standard random.random will be used.">
				<Param name="self" />
				<Param name="x" />
				<Param name="[random=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.triangular" func="yes">
			<Overload retVal="" descr="Triangular distribution.&#10;&#10;Continuous distribution bounded by given lower and upper limits,&#10;and having a given mode value in-between.&#10;&#10;http://en.wikipedia.org/wiki/Triangular_distribution">
				<Param name="self" />
				<Param name="[low=0.0" />
				<Param name="[high=1.0" />
				<Param name="[mode=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.uniform" func="yes">
			<Overload retVal="" descr="Get a random number in the range [a, b) or [a, b] depending on rounding.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.vonmisesvariate" func="yes">
			<Overload retVal="" descr="Circular data distribution.&#10;&#10;mu is the mean angle, expressed in radians between 0 and 2*pi, and&#10;kappa is the concentration parameter, which must be greater than or&#10;equal to zero.  If kappa is equal to zero, this distribution reduces&#10;to a uniform random angle over the range 0 to 2*pi.">
				<Param name="self" />
				<Param name="mu" />
				<Param name="kappa" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.SystemRandom.weibullvariate" func="yes">
			<Overload retVal="" descr="Weibull distribution.&#10;&#10;alpha is the scale parameter and beta is the shape parameter.">
				<Param name="self" />
				<Param name="alpha" />
				<Param name="beta" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.choice" func="yes">
			<Overload retVal="" descr="Choose a random element from a non-empty sequence.">
				<Param name="self" />
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.compare_digest" func="yes">
			<Overload retVal="" descr="compare_digest(a, b) -&gt; bool&#10;&#10;Return 'a == b'.  This function uses an approach designed to prevent&#10;timing analysis, making it appropriate for cryptography.&#10;a and b must both be of the same type: either str (ASCII only),&#10;or any bytes-like object.&#10;&#10;Note: If a and b are of different lengths, or if an error occurs,&#10;a timing attack could theoretically reveal information about the&#10;types and lengths of a and b--but not their values.">
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.randbelow" func="yes">
			<Overload retVal="" descr="Return a random int in the range [0, n).">
				<Param name="exclusive_upper_bound" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.randbits" func="yes">
			<Overload retVal="" descr="getrandbits(k) -&gt; x.  Generates an int with k random bits.">
				<Param name="self" />
				<Param name="k" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.token_bytes" func="yes">
			<Overload retVal="" descr="Return a random byte string containing *nbytes* bytes.&#10;&#10;If *nbytes* is ``None`` or not supplied, a reasonable&#10;default is used.&#10;&#10;&gt;&gt;&gt; token_bytes(16)  #doctest:+SKIP&#10;b'\xebr\x17D*t\xae\xd4\xe3S\xb6\xe2\xebP1\x8b'">
				<Param name="[nbytes=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.token_hex" func="yes">
			<Overload retVal="" descr="Return a random text string, in hexadecimal.&#10;&#10;The string has *nbytes* random bytes, each byte converted to two&#10;hex digits.  If *nbytes* is ``None`` or not supplied, a reasonable&#10;default is used.&#10;&#10;&gt;&gt;&gt; token_hex(16)  #doctest:+SKIP&#10;'f9bf78b9a18ce6d46a0cd2b0b86df9da'">
				<Param name="[nbytes=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="secrets.token_urlsafe" func="yes">
			<Overload retVal="" descr="Return a random URL-safe text string, in Base64 encoding.&#10;&#10;The string has *nbytes* random bytes.  If *nbytes* is ``None``&#10;or not supplied, a reasonable default is used.&#10;&#10;&gt;&gt;&gt; token_urlsafe(16)  #doctest:+SKIP&#10;'Drmhze6EPcv0fN_81Bj-nA'">
				<Param name="[nbytes=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="section" func="yes">
			<Overload retVal="" descr="Function of pydoc.HTMLDoc">
			</Overload>
		</KeyWord>
		<KeyWord name="seed" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="seek" func="yes">
			<Overload retVal="" descr="Function of aifc.Chunk">
			</Overload>
		</KeyWord>
		<KeyWord name="seekable" func="yes">
			<Overload retVal="" descr="Function of cgi.BytesIO">
			</Overload>
		</KeyWord>
		<KeyWord name="select" func="yes">
			<Overload retVal="" descr="This module supports asynchronous I/O on multiple file descriptors.&#10;&#10;*** IMPORTANT NOTICE ***&#10;On Windows, only sockets are supported; on Unix, all file descriptors.">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="select.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="select.select" func="yes">
			<Overload retVal="" descr="select(rlist, wlist, xlist[, timeout]) -&gt; (rlist, wlist, xlist)&#10;&#10;Wait until one or more file descriptors are ready for some kind of I/O.&#10;The first three arguments are sequences of file descriptors to be waited for:&#10;rlist -- wait until ready for reading&#10;wlist -- wait until ready for writing&#10;xlist -- wait for an ``exceptional condition''&#10;If only one kind of condition is required, pass [] for the other lists.&#10;A file descriptor is either a socket or file object, or a small integer&#10;gotten from a fileno() method call on one of those.&#10;&#10;The optional 4th argument specifies a timeout in seconds; it may be&#10;a floating point number to specify fractions of seconds.  If it is absent&#10;or None, the call will never time out.&#10;&#10;The return value is a tuple of three lists corresponding to the first three&#10;arguments; each contains the subset of the corresponding file descriptors&#10;that are ready.&#10;&#10;*** IMPORTANT NOTICE ***&#10;On Windows, only sockets are supported; on Unix, all file&#10;descriptors can be used.">
			</Overload>
		</KeyWord>
		<KeyWord name="selected_alpn_protocol" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="selected_npn_protocol" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors" func="yes">
			<Overload retVal="" descr="Selectors module.&#10;&#10;This module allows high-level and efficient I/O multiplexing, built upon the&#10;`select` module primitives.">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.ABCMeta" func="yes">
			<Overload retVal="" descr="Metaclass for defining Abstract Base Classes (ABCs).&#10;&#10;Use this metaclass to create an ABC.  An ABC can be subclassed&#10;directly, and then acts as a mix-in class.  You can also register&#10;unrelated concrete classes (even built-in classes) and unrelated&#10;ABCs as 'virtual subclasses' -- these and their descendants will&#10;be considered subclasses of the registering ABC by the built-in&#10;issubclass() function, but the registering ABC won't show up in&#10;their MRO (Method Resolution Order) nor will method&#10;implementations defined by the registering ABC be callable (not&#10;even via super()).">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.ABCMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.ABCMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.&#10;&#10;Returns the subclass, to allow usage as a class decorator.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.BaseSelector" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.DefaultSelector" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.EVENT_READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.EVENT_WRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.Mapping" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectSelector" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey" func="yes">
			<Overload retVal="" descr="SelectorKey(fileobj, fd, events, data)&#10;&#10;Object used to associate a file object to its backing&#10;file descriptor, selected event mask, and attached data.">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey.data" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey.events" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey.fd" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey.fileobj" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.SelectorKey.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.abstractmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract methods.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract methods are overridden.&#10;The abstract methods can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractmethod&#10;        def my_abstract_method(self, ...):&#10;            ...">
				<Param name="funcobj" />
			</Overload>
		</KeyWord>
		<KeyWord name="selectors.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="send" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="send_flowing_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="send_hor_rule" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="send_label_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="send_line_break" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="send_literal_data" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="send_message" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="send_paragraph" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="send_signal" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="sendall" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="sendcmd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="sendeprt" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="sendfile" func="yes">
			<Overload retVal="" descr="Function of socket.socket">
			</Overload>
		</KeyWord>
		<KeyWord name="sendmail" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="sendmsg" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLSocket">
			</Overload>
		</KeyWord>
		<KeyWord name="sendport" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="sendto" func="yes">
			<Overload retVal="" descr="Function of asyncio.DatagramTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="serve_forever" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="server_activate" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="server_bind" func="yes">
			<Overload retVal="" descr="Function of socketserver.TCPServer">
			</Overload>
		</KeyWord>
		<KeyWord name="server_close" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="service_actions" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="session_stats" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set" func="yes">
			<Overload retVal="" descr="set() -&gt; new empty set object&#10;set(iterable) -&gt; new set object&#10;&#10;Build an unordered collection of unique elements.">
			</Overload>
		</KeyWord>
		<KeyWord name="setDaemon" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="setFormatter" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="setLevel" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="setLogRecordFactory" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="setLoggerClass" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="setName" func="yes">
			<Overload retVal="" descr="Function of dummy_threading.Thread">
			</Overload>
		</KeyWord>
		<KeyWord name="setUp" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="setUpClass" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="set_alpn_protocols" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_authorizer" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="set_boundary" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_break" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_charset" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_child_watcher" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="set_ciphers" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_cmd" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="set_conflict_handler" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="set_continue" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_current" func="yes">
			<Overload retVal="" descr="Function of msilib.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="set_date" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_debug" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="set_debuglevel" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="set_default" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="set_default_executor" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="set_default_type" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_default_verify_paths" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_defaults" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentParser">
			</Overload>
		</KeyWord>
		<KeyWord name="set_description" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionContainer">
			</Overload>
		</KeyWord>
		<KeyWord name="set_ecdh_curve" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_errno" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="set_event_loop" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="set_event_loop_policy" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="set_exception" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="set_exception_handler" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="set_executable" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="set_extraction_path" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="set_flags" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_forkserver_preload" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="set_from" func="yes">
			<Overload retVal="" descr="Function of mailbox.MMDFMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_handle_inheritable" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="set_info" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_inheritable" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="set_labels" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_last_error" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="set_long_opt_delimiter" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="set_loop" func="yes">
			<Overload retVal="" descr="Function of asyncio.IocpProactor">
			</Overload>
		</KeyWord>
		<KeyWord name="set_name" func="yes">
			<Overload retVal="" descr="Function of logging.FileHandler">
			</Overload>
		</KeyWord>
		<KeyWord name="set_next" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_npn_protocols" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_option_negotiation_callback" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="set_output_charset" func="yes">
			<Overload retVal="" descr="Function of gettext.GNUTranslations">
			</Overload>
		</KeyWord>
		<KeyWord name="set_param" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_parser" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="set_pasv" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="set_payload" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_position" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="set_process_default_values" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="set_progress_handler" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="set_protocol" func="yes">
			<Overload retVal="" descr="Function of asyncio.BaseTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="set_quit" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_raw" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_result" func="yes">
			<Overload retVal="" descr="Function of asyncio.Future">
			</Overload>
		</KeyWord>
		<KeyWord name="set_return" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_reuse_addr" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="set_seq1" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="set_seq2" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="set_seqs" func="yes">
			<Overload retVal="" descr="Function of difflib.SequenceMatcher">
			</Overload>
		</KeyWord>
		<KeyWord name="set_sequences" func="yes">
			<Overload retVal="" descr="Function of mailbox.MH">
			</Overload>
		</KeyWord>
		<KeyWord name="set_servername_callback" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="set_short_opt_delimiter" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="set_socket" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="set_spacing" func="yes">
			<Overload retVal="" descr="Function of formatter.AbstractFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="set_start_method" func="yes">
			<Overload retVal="" descr="Function of multiprocessing">
			</Overload>
		</KeyWord>
		<KeyWord name="set_step" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_subdir" func="yes">
			<Overload retVal="" descr="Function of mailbox.MaildirMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_task_factory" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="set_terminator" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="set_title" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionGroup">
			</Overload>
		</KeyWord>
		<KeyWord name="set_trace" func="yes">
			<Overload retVal="" descr="Function of bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_trace_callback" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Connection">
			</Overload>
		</KeyWord>
		<KeyWord name="set_transport" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamReader">
			</Overload>
		</KeyWord>
		<KeyWord name="set_type" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_undefined_options" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="set_unittest_reportflags" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="set_unixfrom" func="yes">
			<Overload retVal="" descr="Function of cgi.Message">
			</Overload>
		</KeyWord>
		<KeyWord name="set_until" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="set_usage" func="yes">
			<Overload retVal="" descr="Function of optparse.OptionParser">
			</Overload>
		</KeyWord>
		<KeyWord name="set_visible" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="set_wakeup_fd" func="yes">
			<Overload retVal="" descr="Function of signal">
			</Overload>
		</KeyWord>
		<KeyWord name="set_write_buffer_limits" func="yes">
			<Overload retVal="" descr="Function of asyncio.Transport">
			</Overload>
		</KeyWord>
		<KeyWord name="setacl" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="setannotation" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="setattr" func="yes">
			<Overload retVal="" descr="Sets the named attribute on the given object to the specified value.&#10;&#10;setattr(x, 'y', v) is equivalent to ``x.y = v''">
				<Param name="obj" />
				<Param name="name" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="setblocking" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="setcomptype" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="setcontext" func="yes">
			<Overload retVal="" descr="Function of decimal">
			</Overload>
		</KeyWord>
		<KeyWord name="setcopyright" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setdefault" func="yes">
			<Overload retVal="" descr="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D">
			</Overload>
		</KeyWord>
		<KeyWord name="setdefaulttimeout" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="setfirstweekday" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="setframerate" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="sethelper" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setinputsizes" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="setitem" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="setlocale" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="setmark" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="setnchannels" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="setnframes" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="setoutputsize" func="yes">
			<Overload retVal="" descr="Function of sqlite3.Cursor">
			</Overload>
		</KeyWord>
		<KeyWord name="setparams" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="setpassword" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="setpos" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="setprofile" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="setquit" func="yes">
			<Overload retVal="" descr="Function of site">
			</Overload>
		</KeyWord>
		<KeyWord name="setquota" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="setsampwidth" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="setsockopt" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="setstate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="setter" func="yes">
			<Overload retVal="" descr="Descriptor to change the setter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="settimeout" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="settrace" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="setup" func="yes">
			<Overload retVal="" descr="Function of setuptools">
			</Overload>
		</KeyWord>
		<KeyWord name="setup_python" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="setup_scripts" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools" func="yes">
			<Overload retVal="" descr="Extensions to the 'distutils' for large or complex distributions">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command" func="yes">
			<Overload retVal="" descr="Abstract base class for defining command classes, the &quot;worker bees&quot;&#10;of the Distutils.  A useful analogy for command classes is to think of&#10;them as subroutines with local variables called &quot;options&quot;.  The options&#10;are &quot;declared&quot; in 'initialize_options()' and &quot;defined&quot; (given their&#10;final values, aka &quot;finalized&quot;) in 'finalize_options()', both of which&#10;must be defined by every command class.  The distinction between the&#10;two is necessary because option values might come from the outside&#10;world (command line, config file, ...), and any options dependent on&#10;other options must be computed *after* these outside influences have&#10;been processed -- hence 'finalize_options()'.  The &quot;body&quot; of the&#10;subroutine, where it does all its work based on the values of its&#10;options, is the 'run()' method, which must also be implemented by every&#10;command class.">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.announce" func="yes">
			<Overload retVal="" descr="If the current verbosity level is of greater than or equal to&#10;'level' print 'msg' to stdout.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[level=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.copy_file" func="yes">
			<Overload retVal="" descr="Copy a file respecting verbose, dry-run and force flags.  (The&#10;former two default to whatever is in the Distribution object, and&#10;the latter defaults to false for commands that don't define it.)">
				<Param name="self" />
				<Param name="infile" />
				<Param name="outfile" />
				<Param name="[preserve_mode=1" />
				<Param name="[preserve_times=1" />
				<Param name="[link=None" />
				<Param name="[level=1]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.copy_tree" func="yes">
			<Overload retVal="" descr="Copy an entire directory tree respecting verbose, dry-run,&#10;and force flags.">
				<Param name="self" />
				<Param name="infile" />
				<Param name="outfile" />
				<Param name="[preserve_mode=1" />
				<Param name="[preserve_times=1" />
				<Param name="[preserve_symlinks=0" />
				<Param name="[level=1]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.debug_print" func="yes">
			<Overload retVal="" descr="Print 'msg' to stdout if the global DEBUG (taken from the&#10;DISTUTILS_DEBUG environment variable) flag is true.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.dump_options" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[header=None" />
				<Param name="[indent]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.ensure_dirname" />
		<KeyWord name="setuptools.Command.ensure_filename" func="yes">
			<Overload retVal="" descr="Ensure that 'option' is the name of an existing file.">
				<Param name="self" />
				<Param name="option" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.ensure_finalized" />
		<KeyWord name="setuptools.Command.ensure_string" func="yes">
			<Overload retVal="" descr="Ensure that 'option' is a string; if not defined, set it to&#10;'default'.">
				<Param name="self" />
				<Param name="option" />
				<Param name="[default=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.ensure_string_list" func="yes">
			<Overload retVal="" descr="Ensure that 'option' is a list of strings.  If 'option' is&#10;currently a string, we split it either on /,\s*/ or /\s+/, so&#10;&quot;foo bar baz&quot;, &quot;foo,bar,baz&quot;, and &quot;foo,   bar baz&quot; all become&#10;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].">
				<Param name="self" />
				<Param name="option" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.execute" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="args" />
				<Param name="[msg=None" />
				<Param name="[level=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.finalize_options" func="yes">
			<Overload retVal="" descr="Set final values for all the options that this command supports.&#10;This is always called as late as possible, ie.  after any option&#10;assignments from the command-line or from other commands have been&#10;done.  Thus, this is the place to code option dependencies: if&#10;'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as&#10;long as 'foo' still has the same value it was assigned in&#10;'initialize_options()'.&#10;&#10;This method must be implemented by all command classes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.get_command_name" />
		<KeyWord name="setuptools.Command.get_finalized_command" func="yes">
			<Overload retVal="" descr="Wrapper around Distribution's 'get_command_obj()' method: find&#10;(create if necessary and 'create' is true) the command object for&#10;'command', call its 'ensure_finalized()' method, and return the&#10;finalized command object.">
				<Param name="self" />
				<Param name="command" />
				<Param name="[create=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.get_sub_commands" func="yes">
			<Overload retVal="" descr="Determine the sub-commands that are relevant in the current&#10;distribution (ie., that need to be run).  This is based on the&#10;'sub_commands' class attribute: each tuple in that list may include&#10;a method that we call to determine if the subcommand needs to be&#10;run for the current distribution.  Return a list of command names.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.initialize_options" func="yes">
			<Overload retVal="" descr="Set default values for all the options that this command&#10;supports.  Note that these defaults may be overridden by other&#10;commands, by the setup script, by config files, or by the&#10;command-line.  Thus, this is not the place to code dependencies&#10;between options; generally, 'initialize_options()' implementations&#10;are just a bunch of &quot;self.foo = None&quot; assignments.&#10;&#10;This method must be implemented by all command classes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.make_archive" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="base_name" />
				<Param name="format" />
				<Param name="[root_dir=None" />
				<Param name="[base_dir=None" />
				<Param name="[owner=None" />
				<Param name="[group=None]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.make_file" func="yes">
			<Overload retVal="" descr="Special case of 'execute()' for operations that process one or&#10;more input files and generate one output file.  Works just like&#10;'execute()', except the operation is skipped and a different&#10;message printed if 'outfile' already exists and is newer than all&#10;files listed in 'infiles'.  If the command defined 'self.force',&#10;and it is true, then the command is unconditionally run -- does no&#10;timestamp checks.">
				<Param name="self" />
				<Param name="infiles" />
				<Param name="outfile" />
				<Param name="func" />
				<Param name="args" />
				<Param name="[exec_msg=None" />
				<Param name="[skip_msg=None" />
				<Param name="[level=1]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.mkpath" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="name" />
				<Param name="[mode=511]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.move_file" func="yes">
			<Overload retVal="" descr="Move a file respecting dry-run flag.">
				<Param name="self" />
				<Param name="src" />
				<Param name="dst" />
				<Param name="[level=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.reinitialize_command" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="command" />
				<Param name="[reinit_subcommands=0" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.run" func="yes">
			<Overload retVal="" descr="A command's raison d'etre: carry out the action it exists to&#10;perform, controlled by the options initialized in&#10;'initialize_options()', customized by other commands, the setup&#10;script, the command-line, and config files, and finalized in&#10;'finalize_options()'.  All terminal output and filesystem&#10;interaction should be done by 'run()'.&#10;&#10;This method must be implemented by all command classes.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.run_command" func="yes">
			<Overload retVal="" descr="Run some other command: uses the 'run_command()' method of&#10;Distribution, which creates and finalizes the command object if&#10;necessary and then invokes its 'run()' method.">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.set_undefined_options" func="yes">
			<Overload retVal="" descr="Set the values of any &quot;undefined&quot; options from corresponding&#10;option values in some other command object.  &quot;Undefined&quot; here means&#10;&quot;is None&quot;, which is the convention used to indicate that an option&#10;has not been changed between 'initialize_options()' and&#10;'finalize_options()'.  Usually called from 'finalize_options()' for&#10;options that depend on some other command rather than another&#10;option of the same command.  'src_cmd' is the other command from&#10;which option values will be taken (a command object will be created&#10;for it if necessary); the remaining arguments are&#10;'(src_option,dst_option)' tuples which mean &quot;take the value of&#10;'src_option' in the 'src_cmd' command object, and copy it to&#10;'dst_option' in the current command object&quot;.">
				<Param name="self" />
				<Param name="src_cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.spawn" func="yes">
			<Overload retVal="" descr="Spawn an external command respecting dry-run flag.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[search_path=1" />
				<Param name="[level=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Command.warn" />
		<KeyWord name="setuptools.Distribution" func="yes">
			<Overload retVal="" descr="Distribution with support for features, tests, and package data&#10;&#10;This is an enhanced version of 'distutils.dist.Distribution' that&#10;effectively adds the following new optional keyword arguments to 'setup()':&#10;&#10; 'install_requires' -- a string or sequence of strings specifying project&#10;    versions that the distribution requires when installed, in the format&#10;    used by 'pkg_resources.require()'.  They will be installed&#10;    automatically when the package is installed.  If you wish to use&#10;    packages that are not available in PyPI, or want to give your users an&#10;    alternate download location, you can add a 'find_links' option to the&#10;    '[easy_install]' section of your project's 'setup.cfg' file, and then&#10;    setuptools will scan the listed web pages for links that satisfy the&#10;    requirements.&#10;&#10; 'extras_require' -- a dictionary mapping names of optional &quot;extras&quot; to the&#10;    additional requirement(s) that using those extras incurs. For example,&#10;    this::&#10;&#10;        extras_require = dict(reST = [&quot;docutils&gt;=0.3&quot;, &quot;reSTedit&quot;])&#10;&#10;    indicates that the distribution can optionally provide an extra&#10;    capability called &quot;reST&quot;, but it can only be used if docutils and&#10;    reSTedit are installed.  If the user installs your package using&#10;    EasyInstall and requests one of your extras, the corresponding&#10;    additional requirements will be installed if needed.&#10;&#10; 'features' **deprecated** -- a dictionary mapping option names to&#10;    'setuptools.Feature'&#10;    objects.  Features are a portion of the distribution that can be&#10;    included or excluded based on user options, inter-feature dependencies,&#10;    and availability on the current system.  Excluded features are omitted&#10;    from all setup commands, including source and binary distributions, so&#10;    you can create multiple distributions from the same source tree.&#10;    Feature names should be valid Python identifiers, except that they may&#10;    contain the '-' (minus) sign.  Features can be included or excluded&#10;    via the command line options '--with-X' and '--without-X', where 'X' is&#10;    the name of the feature.  Whether a feature is included by default, and&#10;    whether you are allowed to control this from the command line, is&#10;    determined by the Feature object.  See the 'Feature' class for more&#10;    information.&#10;&#10; 'test_suite' -- the name of a test suite to run for the 'test' command.&#10;    If the user runs 'python setup.py test', the package will be installed,&#10;    and the named test suite will be run.  The format is the same as&#10;    would be used on a 'unittest.py' command line.  That is, it is the&#10;    dotted name of an object to import and call to generate a test suite.&#10;&#10; 'package_data' -- a dictionary mapping package names to lists of filenames&#10;    or globs to use to find data files contained in the named packages.&#10;    If the dictionary has filenames or globs listed under '&quot;&quot;' (the empty&#10;    string), those names will be searched for in every package, in addition&#10;    to any names for the specific package.  Data files found using these&#10;    names/globs will be installed along with the package, in the same&#10;    location as the package.  Note that globs are allowed to reference&#10;    the contents of non-package subdirectories, as long as you use '/' as&#10;    a path separator.  (Globs are automatically converted to&#10;    platform-specific paths at runtime.)&#10;&#10;In addition to these new keywords, this class also has several new methods&#10;for manipulating the distribution's contents.  For example, the 'include()'&#10;and 'exclude()' methods can be thought of as in-place add and subtract&#10;commands that add or remove packages, modules, extensions, and so on from&#10;the distribution.  They are used by the feature subsystem to configure the&#10;distribution for the included and excluded features.">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.announce" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="msg" />
				<Param name="[level=2]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.common_usage" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.display_option_names" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.display_options" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.dump_option_dicts" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[header=None" />
				<Param name="[commands=None" />
				<Param name="[indent]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.exclude" func="yes">
			<Overload retVal="" descr="Remove items from distribution that are named in keyword arguments&#10;&#10;For example, 'dist.exclude(py_modules=[&quot;x&quot;])' would remove 'x' from&#10;the distribution's 'py_modules' attribute.  Excluding packages uses&#10;the 'exclude_package()' method, so all of the package's contained&#10;packages, modules, and extensions are also excluded.&#10;&#10;Currently, this method only supports exclusion from attributes that are&#10;lists or tuples.  If you need to add support for excluding from other&#10;attributes in this or a subclass, you can add an '_exclude_X' method,&#10;where 'X' is the name of the attribute.  The method will be called with&#10;the value passed to 'exclude()'.  So, 'dist.exclude(foo={&quot;bar&quot;:&quot;baz&quot;})'&#10;will try to call 'dist._exclude_foo({&quot;bar&quot;:&quot;baz&quot;})', which can then&#10;handle whatever special exclusion logic is needed.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.exclude_package" func="yes">
			<Overload retVal="" descr="Remove packages, modules, and extensions in named package">
				<Param name="self" />
				<Param name="package" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.feature_is_included" func="yes">
			<Overload retVal="" descr="Return 1 if feature is included, 0 if excluded, 'None' if unknown">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.fetch_build_egg" func="yes">
			<Overload retVal="" descr="Fetch an egg needed for building">
				<Param name="self" />
				<Param name="req" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.fetch_build_eggs" func="yes">
			<Overload retVal="" descr="Resolve pre-setup requirements">
				<Param name="self" />
				<Param name="requires" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.finalize_options" func="yes">
			<Overload retVal="" descr="Set final values for all the options on the Distribution&#10;instance, analogous to the .finalize_options() method of Command&#10;objects.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.find_config_files" func="yes">
			<Overload retVal="" descr="Find as many configuration files as should be processed for this&#10;platform, and return a list of filenames in the order in which they&#10;should be parsed.  The filenames returned are guaranteed to exist&#10;(modulo nasty race conditions).&#10;&#10;There are three possible config files: distutils.cfg in the&#10;Distutils installation directory (ie. where the top-level&#10;Distutils __inst__.py file lives), a file in the user's home&#10;directory named .pydistutils.cfg on Unix and pydistutils.cfg&#10;on Windows/Mac; and setup.cfg in the current directory.&#10;&#10;The file in the user's home directory can be disabled with the&#10;--no-user-cfg option.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.get_cmdline_options" func="yes">
			<Overload retVal="" descr="Return a '{cmd: {opt:val}}' map of all command-line options&#10;&#10;Option names are all long, but do not include the leading '--', and&#10;contain dashes rather than underscores.  If the option doesn't take&#10;an argument (e.g. '--quiet'), the 'val' is 'None'.&#10;&#10;Note that options provided by config files are intentionally excluded.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.get_command_class" func="yes">
			<Overload retVal="" descr="Pluggable version of get_command_class()">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.get_command_list" func="yes">
			<Overload retVal="" descr="Get a list of (command, description) tuples.&#10;The list is divided into &quot;standard commands&quot; (listed in&#10;distutils.command.__all__) and &quot;extra commands&quot; (mentioned in&#10;self.cmdclass, but not a standard command).  The descriptions come&#10;from the command class attribute 'description'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.get_command_obj" func="yes">
			<Overload retVal="" descr="Return the command object for 'command'.  Normally this object&#10;is cached on a previous call to 'get_command_obj()'; if no command&#10;object for 'command' is in the cache, then we either create and&#10;return it (if 'create' is true) or return None.">
				<Param name="self" />
				<Param name="command" />
				<Param name="[create=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.get_command_packages" func="yes">
			<Overload retVal="" descr="Return a list of packages from which commands are loaded.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.get_egg_cache_dir" />
		<KeyWord name="setuptools.Distribution.get_option_dict" func="yes">
			<Overload retVal="" descr="Get the option dictionary for a given command.  If that&#10;command's option dictionary hasn't been created yet, then create it&#10;and return the new dictionary; otherwise, return the existing&#10;option dictionary.">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.global_options" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.handle_display_options" func="yes">
			<Overload retVal="" descr='If there were any non-global "display-only" options&#10;(--help-commands or the metadata display options) on the command&#10;line, display the requested info and return true; else return&#10;false.'>
				<Param name="self" />
				<Param name="option_order" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.has_c_libraries" />
		<KeyWord name="setuptools.Distribution.has_contents_for" func="yes">
			<Overload retVal="" descr="Return true if 'exclude_package(package)' would do something">
				<Param name="self" />
				<Param name="package" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.has_data_files" />
		<KeyWord name="setuptools.Distribution.has_ext_modules" />
		<KeyWord name="setuptools.Distribution.has_headers" />
		<KeyWord name="setuptools.Distribution.has_modules" />
		<KeyWord name="setuptools.Distribution.has_pure_modules" />
		<KeyWord name="setuptools.Distribution.has_scripts" />
		<KeyWord name="setuptools.Distribution.include" func="yes">
			<Overload retVal="" descr="Add items to distribution that are named in keyword arguments&#10;&#10;For example, 'dist.exclude(py_modules=[&quot;x&quot;])' would add 'x' to&#10;the distribution's 'py_modules' attribute, if it was not already&#10;there.&#10;&#10;Currently, this method only supports inclusion for attributes that are&#10;lists or tuples.  If you need to add support for adding to other&#10;attributes in this or a subclass, you can add an '_include_X' method,&#10;where 'X' is the name of the attribute.  The method will be called with&#10;the value passed to 'include()'.  So, 'dist.include(foo={&quot;bar&quot;:&quot;baz&quot;})'&#10;will try to call 'dist._include_foo({&quot;bar&quot;:&quot;baz&quot;})', which can then&#10;handle whatever special inclusion logic is needed.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.include_feature" func="yes">
			<Overload retVal="" descr="Request inclusion of feature named 'name'">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.is_pure" />
		<KeyWord name="setuptools.Distribution.iter_distribution_names" func="yes">
			<Overload retVal="" descr="Yield all packages, modules, and extension names in distribution">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.negative_opt" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.parse_command_line" func="yes">
			<Overload retVal="" descr="Process features after parsing command line options">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.parse_config_files" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[filenames=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.patch_missing_pkg_info" />
		<KeyWord name="setuptools.Distribution.print_command_list" func="yes">
			<Overload retVal="" descr="Print a subset of the list of all commands -- used by&#10;'print_commands()'.">
				<Param name="self" />
				<Param name="commands" />
				<Param name="header" />
				<Param name="max_length" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.print_commands" func="yes">
			<Overload retVal="" descr="Print out a help message listing all available commands with a&#10;description of each.  The list is divided into &quot;standard commands&quot;&#10;(listed in distutils.command.__all__) and &quot;extra commands&quot;&#10;(mentioned in self.cmdclass, but not a standard command).  The&#10;descriptions come from the command class attribute&#10;'description'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.reinitialize_command" func="yes">
			<Overload retVal="" descr="Reinitializes a command to the state it was in when first&#10;returned by 'get_command_obj()': ie., initialized but not yet&#10;finalized.  This provides the opportunity to sneak option&#10;values in programmatically, overriding or supplementing&#10;user-supplied values from the config files and command line.&#10;You'll have to re-finalize the command object (by calling&#10;'finalize_options()' or 'ensure_finalized()') before using it for&#10;real.&#10;&#10;'command' should be a command name (string) or command object.  If&#10;'reinit_subcommands' is true, also reinitializes the command's&#10;sub-commands, as declared by the 'sub_commands' class attribute (if&#10;it has one).  See the &quot;install&quot; command for an example.  Only&#10;reinitializes the sub-commands that actually matter, ie. those&#10;whose test predicates return true.&#10;&#10;Returns the reinitialized command object.">
				<Param name="self" />
				<Param name="command" />
				<Param name="[reinit_subcommands=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.run_command" func="yes">
			<Overload retVal="" descr="Do whatever it takes to run a command (including nothing at all,&#10;if the command has already been run).  Specifically: if we have&#10;already created and run the command named by 'command', return&#10;silently without doing anything.  If the command named by 'command'&#10;doesn't even have a command object yet, create one.  Then invoke&#10;'run()' on that command object (or an existing one).">
				<Param name="self" />
				<Param name="command" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Distribution.run_commands" func="yes">
			<Overload retVal="" descr="Run each command that was seen on the setup script command line.&#10;Uses the list of commands found and cache of command objects&#10;created by 'get_command_obj()'.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Extension" func="yes">
			<Overload retVal="" descr="Extension that uses '.c' files in place of '.pyx' files">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Feature" func="yes">
			<Overload retVal="" descr="**deprecated** -- The `Feature` facility was never completely implemented&#10;or supported, `has reported issues&#10;&lt;https://github.com/pypa/setuptools/issues/58&gt;`_ and will be removed in&#10;a future version.&#10;&#10;A subset of the distribution that can be excluded if unneeded/wanted&#10;&#10;Features are created using these keyword arguments:&#10;&#10;  'description' -- a short, human readable description of the feature, to&#10;     be used in error messages, and option help messages.&#10;&#10;  'standard' -- if true, the feature is included by default if it is&#10;     available on the current system.  Otherwise, the feature is only&#10;     included if requested via a command line '--with-X' option, or if&#10;     another included feature requires it.  The default setting is 'False'.&#10;&#10;  'available' -- if true, the feature is available for installation on the&#10;     current system.  The default setting is 'True'.&#10;&#10;  'optional' -- if true, the feature's inclusion can be controlled from the&#10;     command line, using the '--with-X' or '--without-X' options.  If&#10;     false, the feature's inclusion status is determined automatically,&#10;     based on 'availabile', 'standard', and whether any other feature&#10;     requires it.  The default setting is 'True'.&#10;&#10;  'require_features' -- a string or sequence of strings naming features&#10;     that should also be included if this feature is included.  Defaults to&#10;     empty list.  May also contain 'Require' objects that should be&#10;     added/removed from the distribution.&#10;&#10;  'remove' -- a string or list of strings naming packages to be removed&#10;     from the distribution if this feature is *not* included.  If the&#10;     feature *is* included, this argument is ignored.  This argument exists&#10;     to support removing features that &quot;crosscut&quot; a distribution, such as&#10;     defining a 'tests' feature that removes all the 'tests' subpackages&#10;     provided by other features.  The default for this argument is an empty&#10;     list.  (Note: the named package(s) or modules must exist in the base&#10;     distribution when the 'setup()' function is initially called.)&#10;&#10;  other keywords -- any other keyword arguments are saved, and passed to&#10;     the distribution's 'include()' and 'exclude()' methods when the&#10;     feature is included or excluded, respectively.  So, for example, you&#10;     could pass 'packages=[&quot;a&quot;,&quot;b&quot;]' to cause packages 'a' and 'b' to be&#10;     added or removed from the distribution as appropriate.&#10;&#10;A feature must include at least one 'requires', 'remove', or other&#10;keyword argument.  Otherwise, it can't affect the distribution in any way.&#10;Note also that you can subclass 'Feature' to create your own specialized&#10;feature types that modify the distribution in other ways when included or&#10;excluded.  See the docstrings for the various methods here for more detail.&#10;Aside from the methods, the only feature attributes that distributions look&#10;at are 'description' and 'optional'.">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Feature.exclude_from" func="yes">
			<Overload retVal="" descr="Ensure feature is excluded from distribution&#10;&#10;You may override this in a subclass to perform additional operations on&#10;the distribution.  This method will be called at most once per&#10;feature, and only after all included features have been asked to&#10;include themselves.">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Feature.include_by_default" func="yes">
			<Overload retVal="" descr="Should this feature be included by default?">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Feature.include_in" func="yes">
			<Overload retVal="" descr="Ensure feature and its requirements are included in distribution&#10;&#10;You may override this in a subclass to perform additional operations on&#10;the distribution.  Note that this method may be called more than once&#10;per feature, and so should be idempotent.">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Feature.validate" func="yes">
			<Overload retVal="" descr="Verify that feature makes sense in context of distribution&#10;&#10;This method is called by the distribution just before it parses its&#10;command line.  It checks to ensure that the 'remove' attribute, if any,&#10;contains only valid package/module names that are present in the base&#10;distribution when 'setup()' is called.  You may override it in a&#10;subclass to perform any other required validation of the feature&#10;against a target distribution.">
				<Param name="self" />
				<Param name="dist" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Feature.warn_deprecated" />
		<KeyWord name="setuptools.PEP420PackageFinder" func="yes">
			<Overload retVal="" descr="Generate a list of all Python packages found within a directory">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.PEP420PackageFinder.find" func="yes">
			<Overload retVal="" descr="Return a list all Python packages found within directory 'where'&#10;&#10;'where' is the root directory which will be searched for packages.  It&#10;should be supplied as a &quot;cross-platform&quot; (i.e. URL-style) path; it will&#10;be converted to the appropriate local path syntax.&#10;&#10;'exclude' is a sequence of package names to exclude; '*' can be used&#10;as a wildcard in the names, such that 'foo.*' will exclude all&#10;subpackages of 'foo' (but not 'foo' itself).&#10;&#10;'include' is a sequence of package names to include.  If it's&#10;specified, only the named packages will be included.  If it's not&#10;specified, all found packages will be included.  'include' can contain&#10;shell style wildcard patterns just like 'exclude'.">
				<Param name="cls" />
				<Param name="[where=." />
				<Param name="[exclude=()" />
				<Param name="[include=('*',)]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.PackageFinder" func="yes">
			<Overload retVal="" descr="Generate a list of all Python packages found within a directory">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.PackageFinder.find" func="yes">
			<Overload retVal="" descr="Return a list all Python packages found within directory 'where'&#10;&#10;'where' is the root directory which will be searched for packages.  It&#10;should be supplied as a &quot;cross-platform&quot; (i.e. URL-style) path; it will&#10;be converted to the appropriate local path syntax.&#10;&#10;'exclude' is a sequence of package names to exclude; '*' can be used&#10;as a wildcard in the names, such that 'foo.*' will exclude all&#10;subpackages of 'foo' (but not 'foo' itself).&#10;&#10;'include' is a sequence of package names to include.  If it's&#10;specified, only the named packages will be included.  If it's not&#10;specified, all found packages will be included.  'include' can contain&#10;shell style wildcard patterns just like 'exclude'.">
				<Param name="cls" />
				<Param name="[where=." />
				<Param name="[exclude=()" />
				<Param name="[include=('*',)]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Require" func="yes">
			<Overload retVal="" descr="A prerequisite to building or installing a distribution">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Require.full_name" func="yes">
			<Overload retVal="" descr="Return full package/distribution name, w/version">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Require.get_version" func="yes">
			<Overload retVal="" descr="Get version number of installed module, 'None', or 'default'&#10;&#10;Search 'paths' for module.  If not found, return 'None'.  If found,&#10;return the extracted version attribute, or 'default' if no version&#10;attribute was specified, or the value cannot be determined without&#10;importing the module.  The version is formatted according to the&#10;requirement's version format (if any), unless it is 'None' or the&#10;supplied 'default'.">
				<Param name="self" />
				<Param name="[paths=None" />
				<Param name="[default=unknown]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Require.is_current" func="yes">
			<Overload retVal="" descr="Return true if dependency is present and up-to-date on 'paths'">
				<Param name="self" />
				<Param name="[paths=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Require.is_present" func="yes">
			<Overload retVal="" descr="Return true if dependency is present on 'paths'">
				<Param name="self" />
				<Param name="[paths=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.Require.version_ok" func="yes">
			<Overload retVal="" descr="Is 'version' sufficiently up-to-date?">
				<Param name="self" />
				<Param name="version" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.convert_path" func="yes">
			<Overload retVal="" descr="Return 'pathname' as a name that will work on the native filesystem,&#10;i.e. split it on '/' and put it back together again using the current&#10;directory separator.  Needed because filenames in the setup script are&#10;always supplied in Unix style, and have to be converted to the local&#10;convention before we can actually use them in the filesystem.  Raises&#10;ValueError on non-Unix-ish systems if 'pathname' either starts or&#10;ends with a slash.">
				<Param name="pathname" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.filter" func="yes">
			<Overload retVal="" descr="filter(function or None, iterable) --&gt; filter object&#10;&#10;Return an iterator yielding those items of iterable for which function(item)&#10;is true. If function is None, return the items that are true.">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.filterfalse" func="yes">
			<Overload retVal="" descr="filterfalse(function or None, sequence) --&gt; filterfalse object&#10;&#10;Return those items of sequence for which function(item) is false.&#10;If function is None, return the items that are false.">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.find_packages" func="yes">
			<Overload retVal="" descr="Return a list all Python packages found within directory 'where'&#10;&#10;'where' is the root directory which will be searched for packages.  It&#10;should be supplied as a &quot;cross-platform&quot; (i.e. URL-style) path; it will&#10;be converted to the appropriate local path syntax.&#10;&#10;'exclude' is a sequence of package names to exclude; '*' can be used&#10;as a wildcard in the names, such that 'foo.*' will exclude all&#10;subpackages of 'foo' (but not 'foo' itself).&#10;&#10;'include' is a sequence of package names to include.  If it's&#10;specified, only the named packages will be included.  If it's not&#10;specified, all found packages will be included.  'include' can contain&#10;shell style wildcard patterns just like 'exclude'.">
				<Param name="cls" />
				<Param name="[where=." />
				<Param name="[exclude=()" />
				<Param name="[include=('*',)]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.findall" func="yes">
			<Overload retVal="" descr="Find all files under 'dir' and return the list of full filenames.&#10;Unless dir is '.', return full filenames with dir prepended.">
				<Param name="[dir=.]" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.fnmatchcase" func="yes">
			<Overload retVal="" descr="Test whether FILENAME matches PATTERN, including case.&#10;&#10;This is a version of fnmatch() which doesn't case-normalize&#10;its arguments.">
				<Param name="name" />
				<Param name="pat" />
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.lib2to3_fixer_packages" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.map" func="yes">
			<Overload retVal="" descr="map(func, *iterables) --&gt; map object&#10;&#10;Make an iterator that computes the function using arguments from&#10;each of the iterables.  Stops when the shortest iterable is exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.run_2to3_on_doctests" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="setuptools.setup" func="yes">
			<Overload retVal="" descr="The gateway to the Distutils: do everything your setup script needs&#10;to do, in a highly flexible and user-driven way.  Briefly: create a&#10;Distribution instance; find and parse config files; parse the command&#10;line; run each Distutils command found there, customized by the options&#10;supplied to 'setup()' (as keyword arguments), in config files, and on&#10;the command line.&#10;&#10;The Distribution instance might be an instance of a class supplied via&#10;the 'distclass' keyword argument to 'setup'; if no such class is&#10;supplied, then the Distribution class (in dist.py) is instantiated.&#10;All other arguments to 'setup' (except for 'cmdclass') are used to set&#10;attributes of the Distribution instance.&#10;&#10;The 'cmdclass' argument, if supplied, is a dictionary mapping command&#10;names to command classes.  Each command encountered on the command line&#10;will be turned into a command class, which is in turn instantiated; any&#10;class found in 'cmdclass' is used in place of the default, which is&#10;(for command 'foo_bar') class 'foo_bar' in module&#10;'distutils.command.foo_bar'.  The command class must provide a&#10;'user_options' attribute which is a list of option specifiers for&#10;'distutils.fancy_getopt'.  Any command-line options between the current&#10;and the next command are used to set attributes of the current command&#10;object.&#10;&#10;When the entire command-line has been successfully parsed, calls the&#10;'run()' method on each command object in turn.  This method will be&#10;driven entirely by the Distribution object (which each command object&#10;has a reference to, thanks to its constructor), and the&#10;command-specific options that became attributes of each command&#10;object.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sha1" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha224" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha256" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha384" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="sha3_224" func="yes">
			<Overload retVal="" descr="Function of hashlib.sha3_224">
			</Overload>
		</KeyWord>
		<KeyWord name="sha3_256" func="yes">
			<Overload retVal="" descr="Function of hashlib.sha3_256">
			</Overload>
		</KeyWord>
		<KeyWord name="sha3_384" func="yes">
			<Overload retVal="" descr="Function of hashlib.sha3_384">
			</Overload>
		</KeyWord>
		<KeyWord name="sha3_512" func="yes">
			<Overload retVal="" descr="Function of hashlib.sha3_512">
			</Overload>
		</KeyWord>
		<KeyWord name="sha512" func="yes">
			<Overload retVal="" descr="Function of hashlib">
			</Overload>
		</KeyWord>
		<KeyWord name="shake_128" func="yes">
			<Overload retVal="" descr="Function of hashlib.shake_128">
			</Overload>
		</KeyWord>
		<KeyWord name="shake_256" func="yes">
			<Overload retVal="" descr="Function of hashlib.shake_256">
			</Overload>
		</KeyWord>
		<KeyWord name="share" func="yes">
			<Overload retVal="" descr="Function of socket.SocketType">
			</Overload>
		</KeyWord>
		<KeyWord name="shared_ciphers" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLObject">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve" func="yes">
			<Overload retVal="" descr="Manage shelves of pickled objects.&#10;&#10;A &quot;shelf&quot; is a persistent, dictionary-like object.  The difference&#10;with dbm databases is that the values (not the keys!) in a shelf can&#10;be essentially arbitrary Python objects -- anything that the &quot;pickle&quot;&#10;module can handle.  This includes most class instances, recursive data&#10;types, and objects containing lots of shared sub-objects.  The keys&#10;are ordinary strings.&#10;&#10;To summarize the interface (key is a string, data is an arbitrary&#10;object):&#10;&#10;        import shelve&#10;        d = shelve.open(filename) # open, with (g)dbm filename -- no suffix&#10;&#10;        d[key] = data   # store data at key (overwrites old data if&#10;                        # using an existing key)&#10;        data = d[key]   # retrieve a COPY of the data at key (raise&#10;                        # KeyError if no such key) -- NOTE that this&#10;                        # access returns a *copy* of the entry!&#10;        del d[key]      # delete data stored at key (raises KeyError&#10;                        # if no such key)&#10;        flag = key in d # true if the key exists&#10;        list = d.keys() # a list of all existing keys (slow!)&#10;&#10;        d.close()       # close it&#10;&#10;Dependent on the implementation, closing a persistent dictionary may&#10;or may not be necessary to flush changes to disk.&#10;&#10;Normally, d[key] returns a COPY of the entry.  This needs care when&#10;mutable entries are mutated: for example, if d[key] is a list,&#10;        d[key].append(anitem)&#10;does NOT modify the entry d[key] itself, as stored in the persistent&#10;mapping -- it only modifies the copy, which is then immediately&#10;discarded, so that the append has NO effect whatsoever.  To append an&#10;item to d[key] in a way that will affect the persistent mapping, use:&#10;        data = d[key]&#10;        data.append(anitem)&#10;        d[key] = data&#10;&#10;To avoid the problem with mutable entries, you may pass the keyword&#10;argument writeback=True in the call to shelve.open.  When you use:&#10;        d = shelve.open(filename, writeback=True)&#10;then d keeps a cache of all entries you access, and writes them all back&#10;to the persistent mapping when you call d.close().  This ensures that&#10;such usage as d[key].append(anitem) works as intended.&#10;&#10;However, using keyword argument writeback=True may consume vast amount&#10;of memory for the cache, and it may make d.close() very slow, if you&#10;access many of d's entries after opening it in this way: d has no way to&#10;check which of the entries you access are mutable and/or which ones you&#10;actually mutate, so it must cache, and write back at close, all of the&#10;entries that you access.  You can call d.sync() to write back all the&#10;entries in the cache, and empty the cache (d.sync() also synchronizes&#10;the persistent dictionary on disk, if feasible).">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BsdDbShelf" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO" func="yes">
			<Overload retVal="" descr="Buffered I/O implementation using an in-memory bytes buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.close" func="yes">
			<Overload retVal="" descr="Disable all I/O operations.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.flush" func="yes">
			<Overload retVal="" descr="Does nothing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.getbuffer" func="yes">
			<Overload retVal="" descr="Get a read-write view over the contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.isatty" func="yes">
			<Overload retVal="" descr="Always returns False.&#10;&#10;BytesIO objects are not connected to a TTY-like device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.read1" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.readinto" func="yes">
			<Overload retVal="" descr="Read bytes into buffer.&#10;&#10;Returns number of bytes read (0 for EOF), or None if the object&#10;is set not to block and has no data to read.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.readinto1" />
		<KeyWord name="shelve.BytesIO.readline" func="yes">
			<Overload retVal="" descr="Next line from the file, as a bytes object.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.readlines" func="yes">
			<Overload retVal="" descr="List of bytes objects, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to byte offset pos relative to position indicated by whence:&#10;     0  Start of stream (the default).  pos should be &gt;= 0;&#10;     1  Current position - pos may be negative;&#10;     2  End of stream - pos usually negative.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.tell" func="yes">
			<Overload retVal="" descr="Current file position, an integer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is unchanged.  Returns the new size.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.write" func="yes">
			<Overload retVal="" descr="Write bytes to file.&#10;&#10;Return the number of bytes written.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.BytesIO.writelines" func="yes">
			<Overload retVal="" descr="Write lines to the file.&#10;&#10;Note that newlines are not added.  lines can be any iterable object&#10;producing bytes-like objects. This is equivalent to calling write() for&#10;each element.">
				<Param name="self" />
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.DbfilenameShelf" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler" func="yes">
			<Overload retVal="" descr="This takes a binary file for writing a pickle data stream.&#10;&#10;The optional *protocol* argument tells the pickler to use the given&#10;protocol; supported protocols are 0, 1, 2, 3 and 4.  The default&#10;protocol is 3; a backward-incompatible protocol designed for Python 3.&#10;&#10;Specifying a negative protocol version selects the highest protocol&#10;version supported.  The higher the protocol used, the more recent the&#10;version of Python needed to read the pickle produced.&#10;&#10;The *file* argument must have a write() method that accepts a single&#10;bytes argument. It can thus be a file object opened for binary&#10;writing, an io.BytesIO instance, or any other custom object that meets&#10;this interface.&#10;&#10;If *fix_imports* is True and protocol is less than 3, pickle will try&#10;to map the new Python 3 names to the old module names used in Python&#10;2, so that the pickle data stream is readable with Python 2.">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.bin" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.clear_memo" func="yes">
			<Overload retVal="" descr="Clears the pickler's &quot;memo&quot;.&#10;&#10;The memo is the data structure that remembers which objects the&#10;pickler has already seen, so that shared or recursive objects are&#10;pickled by reference and not by value.  This method is useful when&#10;re-using picklers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.dispatch_table" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.dump" func="yes">
			<Overload retVal="" descr="Write a pickled representation of the given object to the open file.">
				<Param name="self" />
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.fast" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.memo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Pickler.persistent_id" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Shelf" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Unpickler" func="yes">
			<Overload retVal="" descr="This takes a binary file for reading a pickle data stream.&#10;&#10;The protocol version of the pickle is detected automatically, so no&#10;protocol argument is needed.  Bytes past the pickled object's&#10;representation are ignored.&#10;&#10;The argument *file* must have two methods, a read() method that takes&#10;an integer argument, and a readline() method that requires no&#10;arguments.  Both methods should return bytes.  Thus *file* can be a&#10;binary file object opened for reading, an io.BytesIO object, or any&#10;other custom object that meets this interface.&#10;&#10;Optional keyword arguments are *fix_imports*, *encoding* and *errors*,&#10;which are used to control compatibility support for pickle stream&#10;generated by Python 2.  If *fix_imports* is True, pickle will try to&#10;map the old Python 2 names to the new names used in Python 3.  The&#10;*encoding* and *errors* tell pickle how to decode 8-bit string&#10;instances pickled by Python 2; these default to 'ASCII' and 'strict',&#10;respectively.  The *encoding* can be 'bytes' to read these 8-bit&#10;string instances as bytes objects.">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Unpickler.find_class" func="yes">
			<Overload retVal="" descr="Return an object from a specified module.&#10;&#10;If necessary, the module will be imported. Subclasses may override&#10;this method (e.g. to restrict unpickling of arbitrary classes and&#10;functions).&#10;&#10;This method is called whenever a class or a function object is&#10;needed.  Both arguments passed are str objects.">
				<Param name="self" />
				<Param name="module_name" />
				<Param name="global_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Unpickler.load" func="yes">
			<Overload retVal="" descr="Load a pickle.&#10;&#10;Read a pickled object representation from the open file object given&#10;in the constructor, and return the reconstituted object hierarchy&#10;specified therein.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Unpickler.memo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.Unpickler.persistent_load" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shelve.open" func="yes">
			<Overload retVal="" descr="Open a persistent dictionary for reading and writing.&#10;&#10;The filename parameter is the base filename for the underlying&#10;database.  As a side-effect, an extension may be added to the&#10;filename and more than one file may be created.  The optional flag&#10;parameter has the same interpretation as the flag parameter of&#10;dbm.open(). The optional protocol parameter specifies the&#10;version of the pickle protocol (0, 1, or 2).&#10;&#10;See the module's __doc__ string for an overview of the interface.">
				<Param name="filename" />
				<Param name="[flag=c" />
				<Param name="[protocol=None" />
				<Param name="[writeback=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shield" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="shift" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex" func="yes">
			<Overload retVal="" descr="A lexical analyzer class for simple shell-like syntaxes.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO" func="yes">
			<Overload retVal="" descr="Text I/O implementation using an in-memory buffer.&#10;&#10;The initial_value argument sets the value of object.  The newline&#10;argument is like the one of TextIOWrapper's constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.close" func="yes">
			<Overload retVal="" descr="Close the IO object.&#10;&#10;Attempting any further operation after the object is closed&#10;will raise a ValueError.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.encoding" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.line_buffering" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.read" func="yes">
			<Overload retVal="" descr="Read at most size characters, returned as a string.&#10;&#10;If the argument is negative or omitted, read until EOF&#10;is reached. Return an empty string at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to character offset pos relative to position indicated by whence:&#10;    0  Start of stream (the default).  pos should be &gt;= 0;&#10;    1  Current position - pos must be 0;&#10;    2  End of stream - pos must be 0.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.tell" func="yes">
			<Overload retVal="" descr="Tell the current file position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate size to pos.&#10;&#10;The pos argument defaults to the current file position, as&#10;returned by tell().  The current file position is unchanged.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.write" func="yes">
			<Overload retVal="" descr="Write string to file.&#10;&#10;Returns the number of characters written, which is always equal to&#10;the length of the string.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.StringIO.writelines" />
		<KeyWord name="shlex.deque" func="yes">
			<Overload retVal="" descr="deque([iterable[, maxlen]]) --&gt; deque object&#10;&#10;A list-like sequence optimized for data accesses near its endpoints.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.append" func="yes">
			<Overload retVal="" descr="Add an element to the right side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.appendleft" func="yes">
			<Overload retVal="" descr="Add an element to the left side of the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.clear" func="yes">
			<Overload retVal="" descr="Remove all elements from the deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.copy" func="yes">
			<Overload retVal="" descr="Return a shallow copy of a deque.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.count" func="yes">
			<Overload retVal="" descr="D.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.extend" func="yes">
			<Overload retVal="" descr="Extend the right side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.extendleft" func="yes">
			<Overload retVal="" descr="Extend the left side of the deque with elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.index" func="yes">
			<Overload retVal="" descr="D.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.insert" func="yes">
			<Overload retVal="" descr="D.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.maxlen" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.pop" func="yes">
			<Overload retVal="" descr="Remove and return the rightmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.popleft" func="yes">
			<Overload retVal="" descr="Remove and return the leftmost element.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.remove" func="yes">
			<Overload retVal="" descr="D.remove(value) -- remove first occurrence of value.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.reverse" func="yes">
			<Overload retVal="" descr="D.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.deque.rotate" func="yes">
			<Overload retVal="" descr="Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.quote" func="yes">
			<Overload retVal="" descr="Return a shell-escaped version of the string *s*.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex" func="yes">
			<Overload retVal="" descr="A lexical analyzer class for simple shell-like syntaxes.">
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex.error_leader" func="yes">
			<Overload retVal="" descr="Emit a C-compiler-like, Emacs-friendly error-message leader.">
				<Param name="self" />
				<Param name="[infile=None" />
				<Param name="[lineno=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex.get_token" func="yes">
			<Overload retVal="" descr="Get a token from the input stream (or from stack if it's nonempty)">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex.pop_source" func="yes">
			<Overload retVal="" descr="Pop the input source stack.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex.push_source" func="yes">
			<Overload retVal="" descr="Push an input source onto the lexer's input source stack.">
				<Param name="self" />
				<Param name="newstream" />
				<Param name="[newfile=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex.push_token" func="yes">
			<Overload retVal="" descr="Push a token onto the stack popped by the get_token method">
				<Param name="self" />
				<Param name="tok" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.shlex.read_token" />
		<KeyWord name="shlex.shlex.sourcehook" func="yes">
			<Overload retVal="" descr="Hook called on a filename to be sourced.">
				<Param name="self" />
				<Param name="newfile" />
			</Overload>
		</KeyWord>
		<KeyWord name="shlex.split" func="yes">
			<Overload retVal="" descr=>
				<Param name="s" />
				<Param name="[comments=False" />
				<Param name="[posix=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shortDescription" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="short_has_arg" func="yes">
			<Overload retVal="" descr="Function of getopt">
			</Overload>
		</KeyWord>
		<KeyWord name="shorten" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="show" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="show_code" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="showsymbol" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="showsyntaxerror" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="showtopic" func="yes">
			<Overload retVal="" descr="Function of pydoc.Helper">
			</Overload>
		</KeyWord>
		<KeyWord name="showtraceback" func="yes">
			<Overload retVal="" descr="Function of code.InteractiveConsole">
			</Overload>
		</KeyWord>
		<KeyWord name="showwarning" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="shuffle" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="shutdown" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="shutdown_asyncgens" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="shutdown_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil" func="yes">
			<Overload retVal="" descr="Utility functions for copying and archiving files and directory trees.&#10;&#10;XXX The functions here don't copy the resource fork or other metadata on Mac.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError" func="yes">
			<Overload retVal="" descr="Raised when a command could not be executed">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ExecError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError" func="yes">
			<Overload retVal="" descr="Raised when an archive cannot be read">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ReadError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.RegistryError" func="yes">
			<Overload retVal="" descr="Raised when a registry operation with the archiving&#10;and unpacking registries fails">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.RegistryError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.RegistryError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError" func="yes">
			<Overload retVal="" descr="Raised when source and destination are the same file.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SameFileError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError" func="yes">
			<Overload retVal="" descr="Raised when trying to do a kind of operation (e.g. copying) which is&#10;not supported on a special file (e.g. a named pipe)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.SpecialFileError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.chown" func="yes">
			<Overload retVal="" descr="Change owner user and group of the given path.&#10;&#10;user and group can be the uid/gid or the user/group names, and in that case,&#10;they are converted to their respective uid/gid.">
				<Param name="path" />
				<Param name="[user=None" />
				<Param name="[group=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copy" func="yes">
			<Overload retVal="" descr="Copy data and mode bits (&quot;cp src dst&quot;). Return the file's destination.&#10;&#10;The destination may be a directory.&#10;&#10;If follow_symlinks is false, symlinks won't be followed. This&#10;resembles GNU's &quot;cp -P src dst&quot;.&#10;&#10;If source and destination are the same file, a SameFileError will be&#10;raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copy2" func="yes">
			<Overload retVal="" descr="Copy data and all stat info (&quot;cp -p src dst&quot;). Return the file's&#10;destination.&quot;&#10;&#10;The destination may be a directory.&#10;&#10;If follow_symlinks is false, symlinks won't be followed. This&#10;resembles GNU's &quot;cp -P src dst&quot;.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copyfile" func="yes">
			<Overload retVal="" descr="Copy data from src to dst.&#10;&#10;If follow_symlinks is not set and src is a symbolic link, a new&#10;symlink will be created instead of copying the file it points to.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copyfileobj" func="yes">
			<Overload retVal="" descr="copy data from file-like object fsrc to file-like object fdst">
				<Param name="fsrc" />
				<Param name="fdst" />
				<Param name="[length=16384]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copymode" func="yes">
			<Overload retVal="" descr="Copy mode bits from src to dst.&#10;&#10;If follow_symlinks is not set, symlinks aren't followed if and only&#10;if both `src` and `dst` are symlinks.  If `lchmod` isn't available&#10;(e.g. Linux) this method does nothing.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copystat" func="yes">
			<Overload retVal="" descr="Copy all stat info (mode bits, atime, mtime, flags) from src to dst.&#10;&#10;If the optional flag `follow_symlinks` is not set, symlinks aren't followed if and&#10;only if both `src` and `dst` are symlinks.">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.copytree" func="yes">
			<Overload retVal="" descr="Recursively copy a directory tree.&#10;&#10;The destination directory must not already exist.&#10;If exception(s) occur, an Error is raised with a list of reasons.&#10;&#10;If the optional symlinks flag is true, symbolic links in the&#10;source tree result in symbolic links in the destination tree; if&#10;it is false, the contents of the files pointed to by symbolic&#10;links are copied. If the file pointed by the symlink doesn't&#10;exist, an exception will be added in the list of errors raised in&#10;an Error exception at the end of the copy process.&#10;&#10;You can set the optional ignore_dangling_symlinks flag to true if you&#10;want to silence this exception. Notice that this has no effect on&#10;platforms that don't support os.symlink.&#10;&#10;The optional ignore argument is a callable. If given, it&#10;is called with the `src` parameter, which is the directory&#10;being visited by copytree(), and `names` which is the list of&#10;`src` contents, as returned by os.listdir():&#10;&#10;    callable(src, names) -&gt; ignored_names&#10;&#10;Since copytree() is called recursively, the callable will be&#10;called once for each directory that is copied. It returns a&#10;list of names relative to the `src` directory that should&#10;not be copied.&#10;&#10;The optional copy_function argument is a callable that will be used&#10;to copy each file. It will be called with the source path and the&#10;destination path as arguments. By default, copy2() is used, but any&#10;function that supports the same signature (like copy()) can be used.">
				<Param name="src" />
				<Param name="dst" />
				<Param name="[symlinks=False" />
				<Param name="[ignore=None" />
				<Param name="[copy_function=<function copy2 at 0x0302FF60>" />
				<Param name="[ignore_dangling_symlinks=False]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.disk_usage" func="yes">
			<Overload retVal="" descr="Return disk usage statistics about the given path.&#10;&#10;Returned values is a named tuple with attributes 'total', 'used' and&#10;'free', which are the amount of total, used and free space, in bytes.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.get_archive_formats" func="yes">
			<Overload retVal="" descr="Returns a list of supported formats for archiving and unarchiving.&#10;&#10;Each element of the returned sequence is a tuple (name, description)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.get_terminal_size" func="yes">
			<Overload retVal="" descr="Get the size of the terminal window.&#10;&#10;For each of the two dimensions, the environment variable, COLUMNS&#10;and LINES respectively, is checked. If the variable is defined and&#10;the value is a positive integer, it is used.&#10;&#10;When COLUMNS or LINES is not defined, which is the common case,&#10;the terminal connected to sys.__stdout__ is queried&#10;by invoking os.get_terminal_size.&#10;&#10;If the terminal size cannot be successfully queried, either because&#10;the system doesn't support querying, or because we are not&#10;connected to a terminal, the value given in fallback parameter&#10;is used. Fallback defaults to (80, 24) which is the default&#10;size used by many terminal emulators.&#10;&#10;The value returned is a named tuple of type os.terminal_size.">
				<Param name="[fallback=(80, 24)]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.get_unpack_formats" func="yes">
			<Overload retVal="" descr="Returns a list of supported formats for unpacking.&#10;&#10;Each element of the returned sequence is a tuple&#10;(name, extensions, description)">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.ignore_patterns" func="yes">
			<Overload retVal="" descr="Function that can be used as copytree() ignore parameter.&#10;&#10;Patterns is a sequence of glob-style patterns&#10;that are used to exclude files">
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.make_archive" func="yes">
			<Overload retVal="" descr="Create an archive file (eg. zip or tar).&#10;&#10;'base_name' is the name of the file to create, minus any format-specific&#10;extension; 'format' is the archive format: one of &quot;zip&quot;, &quot;tar&quot;, &quot;gztar&quot;,&#10;&quot;bztar&quot;, or &quot;xztar&quot;.  Or any other registered format.&#10;&#10;'root_dir' is a directory that will be the root directory of the&#10;archive; ie. we typically chdir into 'root_dir' before creating the&#10;archive.  'base_dir' is the directory where we start archiving from;&#10;ie. 'base_dir' will be the common prefix of all files and&#10;directories in the archive.  'root_dir' and 'base_dir' both default&#10;to the current directory.  Returns the name of the archive file.&#10;&#10;'owner' and 'group' are used when creating a tar archive. By default,&#10;uses the current owner and group.">
				<Param name="base_name" />
				<Param name="format" />
				<Param name="[root_dir=None" />
				<Param name="[base_dir=None" />
				<Param name="[verbose=0" />
				<Param name="[dry_run=0" />
				<Param name="[owner=None" />
				<Param name="[group=None" />
				<Param name="[logger=None]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.move" func="yes">
			<Overload retVal="" descr="Recursively move a file or directory to another location. This is&#10;similar to the Unix &quot;mv&quot; command. Return the file or directory's&#10;destination.&#10;&#10;If the destination is a directory or a symlink to a directory, the source&#10;is moved inside the directory. The destination path must not already&#10;exist.&#10;&#10;If the destination already exists but is not a directory, it may be&#10;overwritten depending on os.rename() semantics.&#10;&#10;If the destination is on our current filesystem, then rename() is used.&#10;Otherwise, src is copied to the destination and then removed. Symlinks are&#10;recreated under the new name if os.rename() fails because of cross&#10;filesystem renames.&#10;&#10;The optional `copy_function` argument is a callable that will be used&#10;to copy the source or it will be delegated to `copytree`.&#10;By default, copy2() is used, but any function that supports the same&#10;signature (like copy()) can be used.&#10;&#10;A lot more could be done here...  A look at a mv.c shows a lot of&#10;the issues this implementation glosses over.">
				<Param name="src" />
				<Param name="dst" />
				<Param name="[copy_function=<function copy2 at 0x0302FF60>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.register_archive_format" func="yes">
			<Overload retVal="" descr="Registers an archive format.&#10;&#10;name is the name of the format. function is the callable that will be&#10;used to create archives. If provided, extra_args is a sequence of&#10;(name, value) tuples that will be passed as arguments to the callable.&#10;description can be provided to describe the format, and will be returned&#10;by the get_archive_formats() function.">
				<Param name="name" />
				<Param name="function" />
				<Param name="[extra_args=None" />
				<Param name="[description]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.register_unpack_format" func="yes">
			<Overload retVal="" descr="Registers an unpack format.&#10;&#10;`name` is the name of the format. `extensions` is a list of extensions&#10;corresponding to the format.&#10;&#10;`function` is the callable that will be&#10;used to unpack archives. The callable will receive archives to unpack.&#10;If it's unable to handle an archive, it needs to raise a ReadError&#10;exception.&#10;&#10;If provided, `extra_args` is a sequence of&#10;(name, value) tuples that will be passed as arguments to the callable.&#10;description can be provided to describe the format, and will be returned&#10;by the get_unpack_formats() function.">
				<Param name="name" />
				<Param name="extensions" />
				<Param name="function" />
				<Param name="[extra_args=None" />
				<Param name="[description]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.rmtree" func="yes">
			<Overload retVal="" descr="Recursively delete a directory tree.&#10;&#10;If ignore_errors is set, errors are ignored; otherwise, if onerror&#10;is set, it is called to handle the error with arguments (func,&#10;path, exc_info) where func is platform and implementation dependent;&#10;path is the argument to that function that caused it to fail; and&#10;exc_info is a tuple returned by sys.exc_info().  If ignore_errors&#10;is false and onerror is None, an exception is raised.">
				<Param name="path" />
				<Param name="[ignore_errors=False" />
				<Param name="[onerror=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.unpack_archive" func="yes">
			<Overload retVal="" descr='Unpack an archive.&#10;&#10;`filename` is the name of the archive.&#10;&#10;`extract_dir` is the name of the target directory, where the archive&#10;is unpacked. If not provided, the current working directory is used.&#10;&#10;`format` is the archive format: one of "zip", "tar", "gztar", "bztar",&#10;or "xztar".  Or any other registered format.  If not provided,&#10;unpack_archive will use the filename extension and see if an unpacker&#10;was registered for that extension.&#10;&#10;In case none is found, a ValueError is raised.'>
				<Param name="filename" />
				<Param name="[extract_dir=None" />
				<Param name="[format=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.unregister_archive_format" />
		<KeyWord name="shutil.unregister_unpack_format" func="yes">
			<Overload retVal="" descr="Removes the pack format from the registry.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="shutil.which" func="yes">
			<Overload retVal="" descr='Given a command, mode, and a PATH string, return the path which&#10;conforms to the given mode on the PATH, or None if there is no such&#10;file.&#10;&#10;`mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result&#10;of os.environ.get("PATH"), or can be overridden with a custom search&#10;path.'>
				<Param name="cmd" />
				<Param name="[mode=1" />
				<Param name="[path=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sigint_handler" func="yes">
			<Overload retVal="" descr="Function of pdb.Pdb">
			</Overload>
		</KeyWord>
		<KeyWord name="signal" />
		<KeyWord name="signal.CTRL_BREAK_EVENT" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.Handlers" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.NSIG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGABRT" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGBREAK" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGFPE" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGILL" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGINT" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGSEGV" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIGTERM" func="yes">
			<Overload retVal="" descr="(Signals)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.SIG_IGN" func="yes">
			<Overload retVal="" descr="(Handlers)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.Signals" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.default_int_handler" func="yes">
			<Overload retVal="" descr="default_int_handler(...)&#10;&#10;The default handler for SIGINT installed by Python.&#10;It raises KeyboardInterrupt.">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.getsignal" func="yes">
			<Overload retVal="" descr="Return the current action for the given signal.&#10;&#10;The return value can be:&#10;  SIG_IGN -- if the signal is being ignored&#10;  SIG_DFL -- if the default action for the signal is in effect&#10;  None    -- if an unknown handler is in effect&#10;  anything else -- the callable Python object used as a handler">
				<Param name="signalnum" />
			</Overload>
		</KeyWord>
		<KeyWord name="signal.set_wakeup_fd" func="yes">
			<Overload retVal="" descr="set_wakeup_fd(fd) -&gt; fd&#10;&#10;Sets the fd to be written to (with the signal number) when a signal&#10;comes in.  A library can use this to wakeup select or poll.&#10;The previous fd or -1 is returned.&#10;&#10;The fd must be non-blocking.">
			</Overload>
		</KeyWord>
		<KeyWord name="signal.signal" func="yes">
			<Overload retVal="" descr="Set the action for the given signal.&#10;&#10;The action can be SIG_DFL, SIG_IGN, or a callable Python object.&#10;The previous action is returned.  See getsignal() for possible return values.&#10;&#10;*** IMPORTANT NOTICE ***&#10;A signal handler function is called with two arguments:&#10;the first is the signal number, the second is the interrupted stack frame.">
				<Param name="signalnum" />
				<Param name="handler" />
			</Overload>
		</KeyWord>
		<KeyWord name="signature" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="simple_producer" func="yes">
			<Overload retVal="" descr="Function of asynchat.simple_producer">
			</Overload>
		</KeyWord>
		<KeyWord name="simplefilter" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="simplegeneric" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="simulate_call" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="simulate_cmd_complete" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="singledispatch" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="site" func="yes">
			<Overload retVal="" descr="Append module search paths for third-party packages to sys.path.&#10;&#10;****************************************************************&#10;* This module is automatically imported during initialization. *&#10;****************************************************************&#10;&#10;This will append site-specific paths to the module search path.  On&#10;Unix (including Mac OSX), it starts with sys.prefix and&#10;sys.exec_prefix (if different) and appends&#10;lib/python&lt;version&gt;/site-packages.&#10;On other platforms (such as Windows), it tries each of the&#10;prefixes directly, as well as with lib/site-packages appended.  The&#10;resulting directories, if they exist, are appended to sys.path, and&#10;also inspected for path configuration files.&#10;&#10;If a file named &quot;pyvenv.cfg&quot; exists one directory above sys.executable,&#10;sys.prefix and sys.exec_prefix are set to that directory and&#10;it is also checked for site-packages (sys.base_prefix and&#10;sys.base_exec_prefix will always be the &quot;real&quot; prefixes of the Python&#10;installation). If &quot;pyvenv.cfg&quot; (a bootstrap configuration file) contains&#10;the key &quot;include-system-site-packages&quot; set to anything other than &quot;false&quot;&#10;(case-insensitive), the system-level prefixes will still also be&#10;searched for site-packages; otherwise they won't.&#10;&#10;All of the resulting site-specific directories, if they exist, are&#10;appended to sys.path, and also inspected for path configuration&#10;files.&#10;&#10;A path configuration file is a file whose name has the form&#10;&lt;package&gt;.pth; its contents are additional directories (one per line)&#10;to be added to sys.path.  Non-existing directories (or&#10;non-directories) are never added to sys.path; no directory is added to&#10;sys.path more than once.  Blank lines and lines beginning with&#10;'#' are skipped. Lines starting with 'import' are executed.&#10;&#10;For example, suppose sys.prefix and sys.exec_prefix are set to&#10;/usr/local and there is a directory /usr/local/lib/python2.5/site-packages&#10;with three subdirectories, foo, bar and spam, and two path&#10;configuration files, foo.pth and bar.pth.  Assume foo.pth contains the&#10;following:&#10;&#10;  # foo package configuration&#10;  foo&#10;  bar&#10;  bletch&#10;&#10;and bar.pth contains:&#10;&#10;  # bar package configuration&#10;  bar&#10;&#10;Then the following directories are added to sys.path, in this order:&#10;&#10;  /usr/local/lib/python2.5/site-packages/bar&#10;  /usr/local/lib/python2.5/site-packages/foo&#10;&#10;Note that bletch is omitted because it doesn't exist; bar precedes foo&#10;because bar.pth comes alphabetically before foo.pth; and spam is&#10;omitted because it is not mentioned in either path configuration file.&#10;&#10;The readline module is also automatically configured to enable&#10;completion for systems that support it.  This can be overridden in&#10;sitecustomize, usercustomize or PYTHONSTARTUP.  Starting Python in&#10;isolated mode (-I) disables automatic readline configuration.&#10;&#10;After these operations, an attempt is made to import a module&#10;named sitecustomize, which can perform arbitrary additional&#10;site-specific customizations.  If this import fails with an&#10;ImportError exception, it is silently ignored.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.ENABLE_USER_SITE" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.PREFIXES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.USER_BASE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.USER_SITE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="site.abs_paths" func="yes">
			<Overload retVal="" descr="Set all module __file__ and __cached__ attributes to an absolute path">
			</Overload>
		</KeyWord>
		<KeyWord name="site.addpackage" func="yes">
			<Overload retVal="" descr="Process a .pth file within the site-packages directory:&#10;For each line in the file, either combine it with sitedir to a path&#10;and add that to known_paths, or execute it if it starts with 'import '.">
				<Param name="sitedir" />
				<Param name="name" />
				<Param name="known_paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.addsitedir" func="yes">
			<Overload retVal="" descr="Add 'sitedir' argument to sys.path if missing and handle .pth files in&#10;'sitedir'">
				<Param name="sitedir" />
				<Param name="[known_paths=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.addsitepackages" func="yes">
			<Overload retVal="" descr="Add site-packages to sys.path">
				<Param name="known_paths" />
				<Param name="[prefixes=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.addusersitepackages" func="yes">
			<Overload retVal="" descr="Add a per user site-package to sys.path&#10;&#10;Each user has its own python directory with site-packages in the&#10;home directory.">
				<Param name="known_paths" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.check_enableusersite" func="yes">
			<Overload retVal="" descr="Check if user site directory is safe for inclusion&#10;&#10;The function tests for the command line flag (including environment var),&#10;process uid/gid equal to effective uid/gid.&#10;&#10;None: Disabled for security reasons&#10;False: Disabled by user (command line option)&#10;True: Safe and enabled">
			</Overload>
		</KeyWord>
		<KeyWord name="site.enablerlcompleter" func="yes">
			<Overload retVal="" descr="Enable default readline configuration on interactive prompts, by&#10;registering a sys.__interactivehook__.&#10;&#10;If the readline module can be imported, the hook will set the Tab key&#10;as completion key and register ~/.python_history as history file.&#10;This can be overridden in the sitecustomize or usercustomize module,&#10;or in a PYTHONSTARTUP file.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.execsitecustomize" func="yes">
			<Overload retVal="" descr="Run custom site specific code, if available.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.execusercustomize" func="yes">
			<Overload retVal="" descr="Run custom user specific code, if available.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.getsitepackages" func="yes">
			<Overload retVal="" descr="Returns a list containing all global site-packages directories.&#10;&#10;For each directory present in ``prefixes`` (or the global ``PREFIXES``),&#10;this function will find its `site-packages` subdirectory depending on the&#10;system environment, and will return a list of full paths.">
				<Param name="[prefixes=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="site.getuserbase" func="yes">
			<Overload retVal="" descr="Returns the `user base` directory path.&#10;&#10;The `user base` directory can be used to store data. If the global&#10;variable ``USER_BASE`` is not initialized yet, this function will also set&#10;it.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.getusersitepackages" func="yes">
			<Overload retVal="" descr="Returns the user-specific site-packages directory path.&#10;&#10;If the global variable ``USER_SITE`` is not initialized yet, this&#10;function will also set it.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.main" func="yes">
			<Overload retVal="" descr="Add standard site-specific directories to the module search path.&#10;&#10;This function is called automatically when this module is imported,&#10;unless the python interpreter was started with the -S flag.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.makepath" />
		<KeyWord name="site.removeduppaths" func="yes">
			<Overload retVal="" descr="Remove duplicate entries from sys.path along with making them&#10;absolute">
			</Overload>
		</KeyWord>
		<KeyWord name="site.setcopyright" func="yes">
			<Overload retVal="" descr="Set 'copyright' and 'credits' in builtins">
			</Overload>
		</KeyWord>
		<KeyWord name="site.sethelper" />
		<KeyWord name="site.setquit" func="yes">
			<Overload retVal="" descr="Define new builtins 'quit' and 'exit'.&#10;&#10;These are objects which make the interpreter exit when called.&#10;The repr of each object contains a hint at how it works.">
			</Overload>
		</KeyWord>
		<KeyWord name="site.venv" />
		<KeyWord name="size" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="sizeof" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="skip" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="skipIf" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="skipTest" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="skipUnless" func="yes">
			<Overload retVal="" descr="Function of unittest">
			</Overload>
		</KeyWord>
		<KeyWord name="skip_lines" func="yes">
			<Overload retVal="" descr="Function of cgi.FieldStorage">
			</Overload>
		</KeyWord>
		<KeyWord name="slave" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="sleep" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="slice" func="yes">
			<Overload retVal="" descr="slice(stop)&#10;slice(start, stop[, step])&#10;&#10;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).">
			</Overload>
		</KeyWord>
		<KeyWord name="small" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_DATA" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_EHLO" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_EXPN" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_HELO" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_HELP" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_MAIL" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_NOOP" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_QUIT" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_RCPT" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_RSET" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtp_VRFY" func="yes">
			<Overload retVal="" descr="Function of smtpd.SMTPChannel">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd" func="yes">
			<Overload retVal="" descr="An RFC 5321 smtp proxy with optional RFC 1870 and RFC 6531 extensions.&#10;&#10;Usage: %(program)s [options] [localhost:localport [remotehost:remoteport]]&#10;&#10;Options:&#10;&#10;    --nosetuid&#10;    -n&#10;        This program generally tries to setuid `nobody', unless this flag is&#10;        set.  The setuid call will fail if this program is not run as root (in&#10;        which case, use this flag).&#10;&#10;    --version&#10;    -V&#10;        Print the version number and exit.&#10;&#10;    --class classname&#10;    -c classname&#10;        Use `classname' as the concrete SMTP proxy class.  Uses `PureProxy' by&#10;        default.&#10;&#10;    --size limit&#10;    -s limit&#10;        Restrict the total size of the incoming message to &quot;limit&quot; number of&#10;        bytes via the RFC 1870 SIZE extension.  Defaults to 33554432 bytes.&#10;&#10;    --smtputf8&#10;    -u&#10;        Enable the SMTPUTF8 extension and behave as an RFC 6531 smtp proxy.&#10;&#10;    --debug&#10;    -d&#10;        Turn on debugging prints.&#10;&#10;    --help&#10;    -h&#10;        Print this message and exit.&#10;&#10;Version: %(__version__)s&#10;&#10;If localhost is not given then `localhost' is used, and if localport is not&#10;given then 8025 is used.  If remotehost is not given then `localhost' is used,&#10;and if remoteport is not given, then 25 is used.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.COMMASPACE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DATA_SIZE_DEFAULT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DEBUGSTREAM" func="yes">
			<Overload retVal="" descr="(Devnull)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer" />
		<KeyWord name="smtpd.DebuggingServer.accept" />
		<KeyWord name="smtpd.DebuggingServer.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.bind" />
		<KeyWord name="smtpd.DebuggingServer.channel_class" func="yes">
			<Overload retVal="" descr="This is an abstract class.  You must derive from this class, and add&#10;the two methods collect_incoming_data() and found_terminator()">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.close" />
		<KeyWord name="smtpd.DebuggingServer.connect" />
		<KeyWord name="smtpd.DebuggingServer.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.handle_accept" />
		<KeyWord name="smtpd.DebuggingServer.handle_accepted" />
		<KeyWord name="smtpd.DebuggingServer.handle_close" />
		<KeyWord name="smtpd.DebuggingServer.handle_connect" />
		<KeyWord name="smtpd.DebuggingServer.handle_connect_event" />
		<KeyWord name="smtpd.DebuggingServer.handle_error" />
		<KeyWord name="smtpd.DebuggingServer.handle_expt" />
		<KeyWord name="smtpd.DebuggingServer.handle_expt_event" />
		<KeyWord name="smtpd.DebuggingServer.handle_read" />
		<KeyWord name="smtpd.DebuggingServer.handle_read_event" />
		<KeyWord name="smtpd.DebuggingServer.handle_write" />
		<KeyWord name="smtpd.DebuggingServer.handle_write_event" />
		<KeyWord name="smtpd.DebuggingServer.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.listen" />
		<KeyWord name="smtpd.DebuggingServer.log" />
		<KeyWord name="smtpd.DebuggingServer.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.process_message" func="yes">
			<Overload retVal="" descr="Override this abstract method to handle messages from the client.&#10;&#10;peer is a tuple containing (ipaddr, port) of the client that made the&#10;socket connection to our smtp port.&#10;&#10;mailfrom is the raw address the client claims the message is coming&#10;from.&#10;&#10;rcpttos is a list of raw addresses the client wishes to deliver the&#10;message to.&#10;&#10;data is a string containing the entire full text of the message,&#10;headers (if supplied) and all.  It has been `de-transparencied'&#10;according to RFC 821, Section 4.5.2.  In other words, a line&#10;containing a `.' followed by other text has had the leading dot&#10;removed.&#10;&#10;kwargs is a dictionary containing additional information.  It is&#10;empty if decode_data=True was given as init parameter, otherwise&#10;it will contain the following keys:&#10;    'mail_options': list of parameters to the mail command.  All&#10;                    elements are uppercase strings.  Example:&#10;                    ['BODY=8BITMIME', 'SMTPUTF8'].&#10;    'rcpt_options': same, for the rcpt command.&#10;&#10;This function should return None for a normal `250 Ok' response;&#10;otherwise, it should return the desired response string in RFC 821&#10;format.">
				<Param name="self" />
				<Param name="peer" />
				<Param name="mailfrom" />
				<Param name="rcpttos" />
				<Param name="data" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.readable" />
		<KeyWord name="smtpd.DebuggingServer.recv" />
		<KeyWord name="smtpd.DebuggingServer.send" />
		<KeyWord name="smtpd.DebuggingServer.set_reuse_addr" />
		<KeyWord name="smtpd.DebuggingServer.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.DebuggingServer.writable" />
		<KeyWord name="smtpd.Devnull" />
		<KeyWord name="smtpd.Devnull.flush" />
		<KeyWord name="smtpd.Devnull.write" />
		<KeyWord name="smtpd.MailmanProxy" />
		<KeyWord name="smtpd.MailmanProxy.accept" />
		<KeyWord name="smtpd.MailmanProxy.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.bind" />
		<KeyWord name="smtpd.MailmanProxy.channel_class" func="yes">
			<Overload retVal="" descr="This is an abstract class.  You must derive from this class, and add&#10;the two methods collect_incoming_data() and found_terminator()">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.close" />
		<KeyWord name="smtpd.MailmanProxy.connect" />
		<KeyWord name="smtpd.MailmanProxy.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.handle_accept" />
		<KeyWord name="smtpd.MailmanProxy.handle_accepted" />
		<KeyWord name="smtpd.MailmanProxy.handle_close" />
		<KeyWord name="smtpd.MailmanProxy.handle_connect" />
		<KeyWord name="smtpd.MailmanProxy.handle_connect_event" />
		<KeyWord name="smtpd.MailmanProxy.handle_error" />
		<KeyWord name="smtpd.MailmanProxy.handle_expt" />
		<KeyWord name="smtpd.MailmanProxy.handle_expt_event" />
		<KeyWord name="smtpd.MailmanProxy.handle_read" />
		<KeyWord name="smtpd.MailmanProxy.handle_read_event" />
		<KeyWord name="smtpd.MailmanProxy.handle_write" />
		<KeyWord name="smtpd.MailmanProxy.handle_write_event" />
		<KeyWord name="smtpd.MailmanProxy.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.listen" />
		<KeyWord name="smtpd.MailmanProxy.log" />
		<KeyWord name="smtpd.MailmanProxy.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.process_message" func="yes">
			<Overload retVal="" descr="Override this abstract method to handle messages from the client.&#10;&#10;peer is a tuple containing (ipaddr, port) of the client that made the&#10;socket connection to our smtp port.&#10;&#10;mailfrom is the raw address the client claims the message is coming&#10;from.&#10;&#10;rcpttos is a list of raw addresses the client wishes to deliver the&#10;message to.&#10;&#10;data is a string containing the entire full text of the message,&#10;headers (if supplied) and all.  It has been `de-transparencied'&#10;according to RFC 821, Section 4.5.2.  In other words, a line&#10;containing a `.' followed by other text has had the leading dot&#10;removed.&#10;&#10;kwargs is a dictionary containing additional information.  It is&#10;empty if decode_data=True was given as init parameter, otherwise&#10;it will contain the following keys:&#10;    'mail_options': list of parameters to the mail command.  All&#10;                    elements are uppercase strings.  Example:&#10;                    ['BODY=8BITMIME', 'SMTPUTF8'].&#10;    'rcpt_options': same, for the rcpt command.&#10;&#10;This function should return None for a normal `250 Ok' response;&#10;otherwise, it should return the desired response string in RFC 821&#10;format.">
				<Param name="self" />
				<Param name="peer" />
				<Param name="mailfrom" />
				<Param name="rcpttos" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.readable" />
		<KeyWord name="smtpd.MailmanProxy.recv" />
		<KeyWord name="smtpd.MailmanProxy.send" />
		<KeyWord name="smtpd.MailmanProxy.set_reuse_addr" />
		<KeyWord name="smtpd.MailmanProxy.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.MailmanProxy.writable" />
		<KeyWord name="smtpd.NEWLINE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.Options" />
		<KeyWord name="smtpd.Options.classname" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.Options.setuid" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy" />
		<KeyWord name="smtpd.PureProxy.accept" />
		<KeyWord name="smtpd.PureProxy.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.bind" />
		<KeyWord name="smtpd.PureProxy.channel_class" func="yes">
			<Overload retVal="" descr="This is an abstract class.  You must derive from this class, and add&#10;the two methods collect_incoming_data() and found_terminator()">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.close" />
		<KeyWord name="smtpd.PureProxy.connect" />
		<KeyWord name="smtpd.PureProxy.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.handle_accept" />
		<KeyWord name="smtpd.PureProxy.handle_accepted" />
		<KeyWord name="smtpd.PureProxy.handle_close" />
		<KeyWord name="smtpd.PureProxy.handle_connect" />
		<KeyWord name="smtpd.PureProxy.handle_connect_event" />
		<KeyWord name="smtpd.PureProxy.handle_error" />
		<KeyWord name="smtpd.PureProxy.handle_expt" />
		<KeyWord name="smtpd.PureProxy.handle_expt_event" />
		<KeyWord name="smtpd.PureProxy.handle_read" />
		<KeyWord name="smtpd.PureProxy.handle_read_event" />
		<KeyWord name="smtpd.PureProxy.handle_write" />
		<KeyWord name="smtpd.PureProxy.handle_write_event" />
		<KeyWord name="smtpd.PureProxy.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.listen" />
		<KeyWord name="smtpd.PureProxy.log" />
		<KeyWord name="smtpd.PureProxy.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.process_message" func="yes">
			<Overload retVal="" descr="Override this abstract method to handle messages from the client.&#10;&#10;peer is a tuple containing (ipaddr, port) of the client that made the&#10;socket connection to our smtp port.&#10;&#10;mailfrom is the raw address the client claims the message is coming&#10;from.&#10;&#10;rcpttos is a list of raw addresses the client wishes to deliver the&#10;message to.&#10;&#10;data is a string containing the entire full text of the message,&#10;headers (if supplied) and all.  It has been `de-transparencied'&#10;according to RFC 821, Section 4.5.2.  In other words, a line&#10;containing a `.' followed by other text has had the leading dot&#10;removed.&#10;&#10;kwargs is a dictionary containing additional information.  It is&#10;empty if decode_data=True was given as init parameter, otherwise&#10;it will contain the following keys:&#10;    'mail_options': list of parameters to the mail command.  All&#10;                    elements are uppercase strings.  Example:&#10;                    ['BODY=8BITMIME', 'SMTPUTF8'].&#10;    'rcpt_options': same, for the rcpt command.&#10;&#10;This function should return None for a normal `250 Ok' response;&#10;otherwise, it should return the desired response string in RFC 821&#10;format.">
				<Param name="self" />
				<Param name="peer" />
				<Param name="mailfrom" />
				<Param name="rcpttos" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.readable" />
		<KeyWord name="smtpd.PureProxy.recv" />
		<KeyWord name="smtpd.PureProxy.send" />
		<KeyWord name="smtpd.PureProxy.set_reuse_addr" />
		<KeyWord name="smtpd.PureProxy.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.PureProxy.writable" />
		<KeyWord name="smtpd.SMTPChannel" func="yes">
			<Overload retVal="" descr="This is an abstract class.  You must derive from this class, and add&#10;the two methods collect_incoming_data() and found_terminator()">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.DATA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.ac_in_buffer_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.ac_out_buffer_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.accept" />
		<KeyWord name="smtpd.SMTPChannel.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.bind" />
		<KeyWord name="smtpd.SMTPChannel.close" />
		<KeyWord name="smtpd.SMTPChannel.close_when_done" func="yes">
			<Overload retVal="" descr="automatically close this channel once the outgoing queue is empty">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.collect_incoming_data" />
		<KeyWord name="smtpd.SMTPChannel.command_size_limit" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.connect" />
		<KeyWord name="smtpd.SMTPChannel.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.discard_buffers" />
		<KeyWord name="smtpd.SMTPChannel.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.found_terminator" />
		<KeyWord name="smtpd.SMTPChannel.get_terminator" />
		<KeyWord name="smtpd.SMTPChannel.handle_accept" />
		<KeyWord name="smtpd.SMTPChannel.handle_accepted" />
		<KeyWord name="smtpd.SMTPChannel.handle_close" />
		<KeyWord name="smtpd.SMTPChannel.handle_connect" />
		<KeyWord name="smtpd.SMTPChannel.handle_connect_event" />
		<KeyWord name="smtpd.SMTPChannel.handle_error" />
		<KeyWord name="smtpd.SMTPChannel.handle_expt" />
		<KeyWord name="smtpd.SMTPChannel.handle_expt_event" />
		<KeyWord name="smtpd.SMTPChannel.handle_read" />
		<KeyWord name="smtpd.SMTPChannel.handle_read_event" />
		<KeyWord name="smtpd.SMTPChannel.handle_write" />
		<KeyWord name="smtpd.SMTPChannel.handle_write_event" />
		<KeyWord name="smtpd.SMTPChannel.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.initiate_send" />
		<KeyWord name="smtpd.SMTPChannel.listen" />
		<KeyWord name="smtpd.SMTPChannel.log" />
		<KeyWord name="smtpd.SMTPChannel.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.max_command_size_limit" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.push" />
		<KeyWord name="smtpd.SMTPChannel.push_with_producer" />
		<KeyWord name="smtpd.SMTPChannel.readable" func="yes">
			<Overload retVal="" descr="predicate for inclusion in the readable for select()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.recv" />
		<KeyWord name="smtpd.SMTPChannel.send" />
		<KeyWord name="smtpd.SMTPChannel.set_reuse_addr" />
		<KeyWord name="smtpd.SMTPChannel.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.set_terminator" func="yes">
			<Overload retVal="" descr="Set the input delimiter.&#10;&#10;Can be a fixed string of any length, an integer, or None.">
				<Param name="self" />
				<Param name="term" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPChannel.smtp_DATA" />
		<KeyWord name="smtpd.SMTPChannel.smtp_EHLO" />
		<KeyWord name="smtpd.SMTPChannel.smtp_EXPN" />
		<KeyWord name="smtpd.SMTPChannel.smtp_HELO" />
		<KeyWord name="smtpd.SMTPChannel.smtp_HELP" />
		<KeyWord name="smtpd.SMTPChannel.smtp_MAIL" />
		<KeyWord name="smtpd.SMTPChannel.smtp_NOOP" />
		<KeyWord name="smtpd.SMTPChannel.smtp_QUIT" />
		<KeyWord name="smtpd.SMTPChannel.smtp_RCPT" />
		<KeyWord name="smtpd.SMTPChannel.smtp_RSET" />
		<KeyWord name="smtpd.SMTPChannel.smtp_VRFY" />
		<KeyWord name="smtpd.SMTPChannel.writable" func="yes">
			<Overload retVal="" descr="predicate for inclusion in the writable for select()">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer" />
		<KeyWord name="smtpd.SMTPServer.accept" />
		<KeyWord name="smtpd.SMTPServer.add_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.bind" />
		<KeyWord name="smtpd.SMTPServer.channel_class" func="yes">
			<Overload retVal="" descr="This is an abstract class.  You must derive from this class, and add&#10;the two methods collect_incoming_data() and found_terminator()">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.close" />
		<KeyWord name="smtpd.SMTPServer.connect" />
		<KeyWord name="smtpd.SMTPServer.create_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.del_channel" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.handle_accept" />
		<KeyWord name="smtpd.SMTPServer.handle_accepted" />
		<KeyWord name="smtpd.SMTPServer.handle_close" />
		<KeyWord name="smtpd.SMTPServer.handle_connect" />
		<KeyWord name="smtpd.SMTPServer.handle_connect_event" />
		<KeyWord name="smtpd.SMTPServer.handle_error" />
		<KeyWord name="smtpd.SMTPServer.handle_expt" />
		<KeyWord name="smtpd.SMTPServer.handle_expt_event" />
		<KeyWord name="smtpd.SMTPServer.handle_read" />
		<KeyWord name="smtpd.SMTPServer.handle_read_event" />
		<KeyWord name="smtpd.SMTPServer.handle_write" />
		<KeyWord name="smtpd.SMTPServer.handle_write_event" />
		<KeyWord name="smtpd.SMTPServer.ignore_log_types" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.listen" />
		<KeyWord name="smtpd.SMTPServer.log" />
		<KeyWord name="smtpd.SMTPServer.log_info" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="message" />
				<Param name="[type=info]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.process_message" func="yes">
			<Overload retVal="" descr="Override this abstract method to handle messages from the client.&#10;&#10;peer is a tuple containing (ipaddr, port) of the client that made the&#10;socket connection to our smtp port.&#10;&#10;mailfrom is the raw address the client claims the message is coming&#10;from.&#10;&#10;rcpttos is a list of raw addresses the client wishes to deliver the&#10;message to.&#10;&#10;data is a string containing the entire full text of the message,&#10;headers (if supplied) and all.  It has been `de-transparencied'&#10;according to RFC 821, Section 4.5.2.  In other words, a line&#10;containing a `.' followed by other text has had the leading dot&#10;removed.&#10;&#10;kwargs is a dictionary containing additional information.  It is&#10;empty if decode_data=True was given as init parameter, otherwise&#10;it will contain the following keys:&#10;    'mail_options': list of parameters to the mail command.  All&#10;                    elements are uppercase strings.  Example:&#10;                    ['BODY=8BITMIME', 'SMTPUTF8'].&#10;    'rcpt_options': same, for the rcpt command.&#10;&#10;This function should return None for a normal `250 Ok' response;&#10;otherwise, it should return the desired response string in RFC 821&#10;format.">
				<Param name="self" />
				<Param name="peer" />
				<Param name="mailfrom" />
				<Param name="rcpttos" />
				<Param name="data" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.readable" />
		<KeyWord name="smtpd.SMTPServer.recv" />
		<KeyWord name="smtpd.SMTPServer.send" />
		<KeyWord name="smtpd.SMTPServer.set_reuse_addr" />
		<KeyWord name="smtpd.SMTPServer.set_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[map=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.SMTPServer.writable" />
		<KeyWord name="smtpd.get_addr_spec" func="yes">
			<Overload retVal="" descr='addr-spec = local-part "@" domain'>
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.get_angle_addr" func="yes">
			<Overload retVal="" descr='angle-addr = [CFWS] "&lt;" addr-spec "&gt;" [CFWS] / obs-angle-addr&#10;obs-angle-addr = [CFWS] "&lt;" obs-route addr-spec "&gt;" [CFWS]'>
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.parseargs" />
		<KeyWord name="smtpd.program" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.usage" func="yes">
			<Overload retVal="" descr=>
				<Param name="code" />
				<Param name="[msg]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtpd.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib" func="yes">
			<Overload retVal="" descr='SMTP/ESMTP client class.&#10;&#10;This should follow RFC 821 (SMTP), RFC 1869 (ESMTP), RFC 2554 (SMTP&#10;Authentication) and RFC 2487 (Secure SMTP over TLS).&#10;&#10;Notes:&#10;&#10;Please remember, when doing ESMTP, that the names of the SMTP service&#10;extensions are NOT the same thing as the option keywords for the RCPT&#10;and MAIL commands!&#10;&#10;Example:&#10;&#10;  &gt;&gt;&gt; import smtplib&#10;  &gt;&gt;&gt; s=smtplib.SMTP("localhost")&#10;  &gt;&gt;&gt; print(s.help())&#10;  This is Sendmail version 8.8.4&#10;  Topics:&#10;      HELO    EHLO    MAIL    RCPT    DATA&#10;      RSET    NOOP    QUIT    HELP    VRFY&#10;      EXPN    VERB    ETRN    DSN&#10;  For more info use "HELP &lt;topic&gt;".&#10;  To report bugs in the implementation send email to&#10;      sendmail-bugs@sendmail.org.&#10;  For local information send email to Postmaster at your site.&#10;  End of HELP info&#10;  &gt;&gt;&gt; s.putcmd("vrfy","someone@here")&#10;  &gt;&gt;&gt; s.getreply()&#10;  (250, "Somebody OverHere &lt;somebody@here.my.org&gt;")&#10;  &gt;&gt;&gt; s.quit()'>
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.CRLF" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP" func="yes">
			<Overload retVal="" descr="LMTP - Local Mail Transfer Protocol&#10;&#10;The LMTP protocol, which is very similar to ESMTP, is heavily based&#10;on the standard SMTP client. It's common to use Unix sockets for&#10;LMTP, so our connect() method must support that as well as a regular&#10;host:port server.  local_hostname and source_address have the same&#10;meaning as they do in the SMTP class.  To specify a Unix socket,&#10;you must use an absolute path as the host, starting with a '/'.&#10;&#10;Authentication is supported, using the regular SMTP mechanism. When&#10;using a Unix socket, LMTP generally don't support or require any&#10;authentication, but your mileage might vary.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.auth" func="yes">
			<Overload retVal="" descr="Authentication command - requires response processing.&#10;&#10;'mechanism' specifies which authentication mechanism is to&#10;be used - the valid values are those listed in the 'auth'&#10;element of 'esmtp_features'.&#10;&#10;'authobject' must be a callable object taking a single argument:&#10;&#10;        data = authobject(challenge)&#10;&#10;It will be called to process the server's challenge response; the&#10;challenge argument it is passed will be a bytes.  It should return&#10;bytes data that will be base64 encoded and sent to the server.&#10;&#10;Keyword arguments:&#10;    - initial_response_ok: Allow sending the RFC 4954 initial-response&#10;      to the AUTH command, if the authentication methods supports it.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.auth_cram_md5" func="yes">
			<Overload retVal="" descr="Authobject to use with CRAM-MD5 authentication. Requires self.user&#10;and self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.auth_login" func="yes">
			<Overload retVal="" descr="Authobject to use with LOGIN authentication. Requires self.user and&#10;self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.auth_plain" func="yes">
			<Overload retVal="" descr="Authobject to use with PLAIN authentication. Requires self.user and&#10;self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.close" func="yes">
			<Overload retVal="" descr="Close the connection to the SMTP server.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.connect" func="yes">
			<Overload retVal="" descr="Connect to the LMTP daemon, on either a Unix or a TCP socket.">
				<Param name="self" />
				<Param name="[host=localhost" />
				<Param name="[port=0" />
				<Param name="[source_address=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.data" func="yes">
			<Overload retVal="" descr="SMTP 'DATA' command -- sends message data to server.&#10;&#10;Automatically quotes lines beginning with a period per rfc821.&#10;Raises SMTPDataError if there is an unexpected reply to the&#10;DATA command; the return value from this method is the final&#10;response code received when the all data is sent.  If msg&#10;is a string, lone '\r' and '\n' characters are converted to&#10;'\r\n' characters.  If msg is bytes, it is transmitted as is.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.default_port" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.docmd" func="yes">
			<Overload retVal="" descr="Send a command, and return its response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.ehlo" func="yes">
			<Overload retVal="" descr="SMTP 'ehlo' command.&#10;Hostname to send for this command defaults to the FQDN of the local&#10;host.">
				<Param name="self" />
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.ehlo_msg" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.ehlo_or_helo_if_needed" func="yes">
			<Overload retVal="" descr="Call self.ehlo() and/or self.helo() if needed.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.expn" func="yes">
			<Overload retVal="" descr="SMTP 'expn' command -- expands a mailing list.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.getreply" func="yes">
			<Overload retVal="" descr="Get a reply from the server.&#10;&#10;Returns a tuple consisting of:&#10;&#10;  - server response code (e.g. '250', or such, if all goes well)&#10;    Note: returns -1 if it can't read response code.&#10;&#10;  - server response string corresponding to response code (multiline&#10;    responses are converted to a single, multiline string).&#10;&#10;Raises SMTPServerDisconnected if end-of-file is reached.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.has_extn" func="yes">
			<Overload retVal="" descr="Does the server support a given SMTP service extension?">
				<Param name="self" />
				<Param name="opt" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.helo" func="yes">
			<Overload retVal="" descr="SMTP 'helo' command.&#10;Hostname to send for this command defaults to the FQDN of the local&#10;host.">
				<Param name="self" />
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.help" func="yes">
			<Overload retVal="" descr="SMTP 'help' command.&#10;Returns help text from server.">
				<Param name="self" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.login" func="yes">
			<Overload retVal="" descr="Log in on an SMTP server that requires authentication.&#10;&#10;The arguments are:&#10;    - user:         The user name to authenticate with.&#10;    - password:     The password for the authentication.&#10;&#10;Keyword arguments:&#10;    - initial_response_ok: Allow sending the RFC 4954 initial-response&#10;      to the AUTH command, if the authentication methods supports it.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;This method will return normally if the authentication was successful.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.&#10; SMTPAuthenticationError  The server didn't accept the username/&#10;                          password combination.&#10; SMTPNotSupportedError    The AUTH command is not supported by the&#10;                          server.&#10; SMTPException            No suitable authentication method was&#10;                          found.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.mail" func="yes">
			<Overload retVal="" descr="SMTP 'mail' command -- begins mail xfer session.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPNotSupportedError  The options parameter includes 'SMTPUTF8'&#10;                        but the SMTPUTF8 extension is not supported by&#10;                        the server.">
				<Param name="self" />
				<Param name="sender" />
				<Param name="[options=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.noop" func="yes">
			<Overload retVal="" descr="SMTP 'noop' command -- doesn't do anything :&gt;">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.putcmd" func="yes">
			<Overload retVal="" descr="Send a command to the server.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.quit" func="yes">
			<Overload retVal="" descr="Terminate the SMTP session.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.rcpt" func="yes">
			<Overload retVal="" descr="SMTP 'rcpt' command -- indicates 1 recipient for this mail.">
				<Param name="self" />
				<Param name="recip" />
				<Param name="[options=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.rset" func="yes">
			<Overload retVal="" descr="SMTP 'rset' command -- resets session.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.send" func="yes">
			<Overload retVal="" descr="Send `s' to the server.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.send_message" func="yes">
			<Overload retVal="" descr="Converts message to a bytestring and passes it to sendmail.&#10;&#10;The arguments are as for sendmail, except that msg is an&#10;email.message.Message object.  If from_addr is None or to_addrs is&#10;None, these arguments are taken from the headers of the Message as&#10;described in RFC 2822 (a ValueError is raised if there is more than&#10;one set of 'Resent-' headers).  Regardless of the values of from_addr and&#10;to_addr, any Bcc field (or Resent-Bcc field, when the Message is a&#10;resent) of the Message object won't be transmitted.  The Message&#10;object is then serialized using email.generator.BytesGenerator and&#10;sendmail is called to transmit the message.  If the sender or any of&#10;the recipient addresses contain non-ASCII and the server advertises the&#10;SMTPUTF8 capability, the policy is cloned with utf8 set to True for the&#10;serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.&#10;If the server does not support SMTPUTF8, an SMTPNotSupported error is&#10;raised.  Otherwise the generator is called without modifying the&#10;policy.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[from_addr=None" />
				<Param name="[to_addrs=None" />
				<Param name="[mail_options=[]" />
				<Param name="[rcpt_options={}]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.sendmail" func="yes">
			<Overload retVal="" descr="This command performs an entire mail transaction.&#10;&#10;The arguments are:&#10;    - from_addr    : The address sending this mail.&#10;    - to_addrs     : A list of addresses to send this mail to.  A bare&#10;                     string will be treated as a list with 1 address.&#10;    - msg          : The message to send.&#10;    - mail_options : List of ESMTP options (such as 8bitmime) for the&#10;                     mail command.&#10;    - rcpt_options : List of ESMTP options (such as DSN commands) for&#10;                     all the rcpt commands.&#10;&#10;msg may be a string containing characters in the ASCII range, or a byte&#10;string.  A string is encoded to bytes using the ascii codec, and lone&#10;\r and \n characters are converted to \r\n characters.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.  If the server does ESMTP, message size&#10;and each of the specified options will be passed to it.  If EHLO&#10;fails, HELO will be tried and ESMTP options suppressed.&#10;&#10;This method will return normally if the mail is accepted for at least&#10;one recipient.  It returns a dictionary, with one entry for each&#10;recipient that was refused.  Each entry contains a tuple of the SMTP&#10;error code and the accompanying error message sent by the server.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError          The server didn't reply properly to&#10;                        the helo greeting.&#10; SMTPRecipientsRefused  The server rejected ALL recipients&#10;                        (no mail was sent).&#10; SMTPSenderRefused      The server didn't accept the from_addr.&#10; SMTPDataError          The server replied with an unexpected&#10;                        error code (other than a refusal of&#10;                        a recipient).&#10; SMTPNotSupportedError  The mail_options parameter includes 'SMTPUTF8'&#10;                        but the SMTPUTF8 extension is not supported by&#10;                        the server.&#10;&#10;Note: the connection will be open even after an exception is raised.&#10;&#10;Example:&#10;&#10; &gt;&gt;&gt; import smtplib&#10; &gt;&gt;&gt; s=smtplib.SMTP(&quot;localhost&quot;)&#10; &gt;&gt;&gt; tolist=[&quot;one@one.org&quot;,&quot;two@two.org&quot;,&quot;three@three.org&quot;,&quot;four@four.org&quot;]&#10; &gt;&gt;&gt; msg = '''\&#10; ... From: Me@my.org&#10; ... Subject: testin'...&#10; ...&#10; ... This is a test '''&#10; &gt;&gt;&gt; s.sendmail(&quot;me@my.org&quot;,tolist,msg)&#10; { &quot;three@three.org&quot; : ( 550 ,&quot;User unknown&quot; ) }&#10; &gt;&gt;&gt; s.quit()&#10;&#10;In the above example, the message was accepted for delivery to three&#10;of the four addresses, and one was rejected, with the error code&#10;550.  If all addresses are accepted, then the method will return an&#10;empty dictionary.">
				<Param name="self" />
				<Param name="from_addr" />
				<Param name="to_addrs" />
				<Param name="msg" />
				<Param name="[mail_options=[]" />
				<Param name="[rcpt_options=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debug output level.&#10;&#10;A non-false value results in debug messages for connection and for all&#10;messages sent to and received from the server.">
				<Param name="self" />
				<Param name="debuglevel" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.starttls" func="yes">
			<Overload retVal="" descr="Puts the connection to the SMTP server into TLS mode.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;If the server supports TLS, this will encrypt the rest of the SMTP&#10;session. If you provide the keyfile and certfile parameters,&#10;the identity of the SMTP server and client can be checked. This,&#10;however, depends on whether the socket module really checks the&#10;certificates.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.">
				<Param name="self" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None" />
				<Param name="[context=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.verify" func="yes">
			<Overload retVal="" descr="SMTP 'verify' command -- checks for address validity.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP.vrfy" func="yes">
			<Overload retVal="" descr="SMTP 'verify' command -- checks for address validity.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.LMTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.OLDSTYLE_AUTH" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP" func="yes">
			<Overload retVal="" descr="This class manages a connection to an SMTP or ESMTP server.&#10;SMTP Objects:&#10;    SMTP objects have the following attributes:&#10;        helo_resp&#10;            This is the message given by the server in response to the&#10;            most recent HELO command.&#10;&#10;        ehlo_resp&#10;            This is the message given by the server in response to the&#10;            most recent EHLO command. This is usually multiline.&#10;&#10;        does_esmtp&#10;            This is a True value _after you do an EHLO command_, if the&#10;            server supports ESMTP.&#10;&#10;        esmtp_features&#10;            This is a dictionary, which, if the server supports ESMTP,&#10;            will _after you do an EHLO command_, contain the names of the&#10;            SMTP service extensions this server supports, and their&#10;            parameters (if any).&#10;&#10;            Note, all extension names are mapped to lower case in the&#10;            dictionary.&#10;&#10;    See each method's docstrings for details.  In general, there is a&#10;    method of the same name to perform each SMTP command.  There is also a&#10;    method called 'sendmail' that will do an entire mail transaction.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.auth" func="yes">
			<Overload retVal="" descr="Authentication command - requires response processing.&#10;&#10;'mechanism' specifies which authentication mechanism is to&#10;be used - the valid values are those listed in the 'auth'&#10;element of 'esmtp_features'.&#10;&#10;'authobject' must be a callable object taking a single argument:&#10;&#10;        data = authobject(challenge)&#10;&#10;It will be called to process the server's challenge response; the&#10;challenge argument it is passed will be a bytes.  It should return&#10;bytes data that will be base64 encoded and sent to the server.&#10;&#10;Keyword arguments:&#10;    - initial_response_ok: Allow sending the RFC 4954 initial-response&#10;      to the AUTH command, if the authentication methods supports it.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.auth_cram_md5" func="yes">
			<Overload retVal="" descr="Authobject to use with CRAM-MD5 authentication. Requires self.user&#10;and self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.auth_login" func="yes">
			<Overload retVal="" descr="Authobject to use with LOGIN authentication. Requires self.user and&#10;self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.auth_plain" func="yes">
			<Overload retVal="" descr="Authobject to use with PLAIN authentication. Requires self.user and&#10;self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.close" func="yes">
			<Overload retVal="" descr="Close the connection to the SMTP server.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.connect" func="yes">
			<Overload retVal="" descr="Connect to a host on a given port.&#10;&#10;If the hostname ends with a colon (`:') followed by a number, and&#10;there is no port specified, that suffix will be stripped off and the&#10;number interpreted as the port number to use.&#10;&#10;Note: This method is automatically invoked by __init__, if a host is&#10;specified during instantiation.">
				<Param name="self" />
				<Param name="[host=localhost" />
				<Param name="[port=0" />
				<Param name="[source_address=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.data" func="yes">
			<Overload retVal="" descr="SMTP 'DATA' command -- sends message data to server.&#10;&#10;Automatically quotes lines beginning with a period per rfc821.&#10;Raises SMTPDataError if there is an unexpected reply to the&#10;DATA command; the return value from this method is the final&#10;response code received when the all data is sent.  If msg&#10;is a string, lone '\r' and '\n' characters are converted to&#10;'\r\n' characters.  If msg is bytes, it is transmitted as is.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.default_port" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.docmd" func="yes">
			<Overload retVal="" descr="Send a command, and return its response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.ehlo" func="yes">
			<Overload retVal="" descr="SMTP 'ehlo' command.&#10;Hostname to send for this command defaults to the FQDN of the local&#10;host.">
				<Param name="self" />
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.ehlo_msg" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.ehlo_or_helo_if_needed" func="yes">
			<Overload retVal="" descr="Call self.ehlo() and/or self.helo() if needed.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.expn" func="yes">
			<Overload retVal="" descr="SMTP 'expn' command -- expands a mailing list.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.getreply" func="yes">
			<Overload retVal="" descr="Get a reply from the server.&#10;&#10;Returns a tuple consisting of:&#10;&#10;  - server response code (e.g. '250', or such, if all goes well)&#10;    Note: returns -1 if it can't read response code.&#10;&#10;  - server response string corresponding to response code (multiline&#10;    responses are converted to a single, multiline string).&#10;&#10;Raises SMTPServerDisconnected if end-of-file is reached.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.has_extn" func="yes">
			<Overload retVal="" descr="Does the server support a given SMTP service extension?">
				<Param name="self" />
				<Param name="opt" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.helo" func="yes">
			<Overload retVal="" descr="SMTP 'helo' command.&#10;Hostname to send for this command defaults to the FQDN of the local&#10;host.">
				<Param name="self" />
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.help" func="yes">
			<Overload retVal="" descr="SMTP 'help' command.&#10;Returns help text from server.">
				<Param name="self" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.login" func="yes">
			<Overload retVal="" descr="Log in on an SMTP server that requires authentication.&#10;&#10;The arguments are:&#10;    - user:         The user name to authenticate with.&#10;    - password:     The password for the authentication.&#10;&#10;Keyword arguments:&#10;    - initial_response_ok: Allow sending the RFC 4954 initial-response&#10;      to the AUTH command, if the authentication methods supports it.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;This method will return normally if the authentication was successful.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.&#10; SMTPAuthenticationError  The server didn't accept the username/&#10;                          password combination.&#10; SMTPNotSupportedError    The AUTH command is not supported by the&#10;                          server.&#10; SMTPException            No suitable authentication method was&#10;                          found.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.mail" func="yes">
			<Overload retVal="" descr="SMTP 'mail' command -- begins mail xfer session.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPNotSupportedError  The options parameter includes 'SMTPUTF8'&#10;                        but the SMTPUTF8 extension is not supported by&#10;                        the server.">
				<Param name="self" />
				<Param name="sender" />
				<Param name="[options=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.noop" func="yes">
			<Overload retVal="" descr="SMTP 'noop' command -- doesn't do anything :&gt;">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.putcmd" func="yes">
			<Overload retVal="" descr="Send a command to the server.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.quit" func="yes">
			<Overload retVal="" descr="Terminate the SMTP session.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.rcpt" func="yes">
			<Overload retVal="" descr="SMTP 'rcpt' command -- indicates 1 recipient for this mail.">
				<Param name="self" />
				<Param name="recip" />
				<Param name="[options=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.rset" func="yes">
			<Overload retVal="" descr="SMTP 'rset' command -- resets session.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.send" func="yes">
			<Overload retVal="" descr="Send `s' to the server.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.send_message" func="yes">
			<Overload retVal="" descr="Converts message to a bytestring and passes it to sendmail.&#10;&#10;The arguments are as for sendmail, except that msg is an&#10;email.message.Message object.  If from_addr is None or to_addrs is&#10;None, these arguments are taken from the headers of the Message as&#10;described in RFC 2822 (a ValueError is raised if there is more than&#10;one set of 'Resent-' headers).  Regardless of the values of from_addr and&#10;to_addr, any Bcc field (or Resent-Bcc field, when the Message is a&#10;resent) of the Message object won't be transmitted.  The Message&#10;object is then serialized using email.generator.BytesGenerator and&#10;sendmail is called to transmit the message.  If the sender or any of&#10;the recipient addresses contain non-ASCII and the server advertises the&#10;SMTPUTF8 capability, the policy is cloned with utf8 set to True for the&#10;serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.&#10;If the server does not support SMTPUTF8, an SMTPNotSupported error is&#10;raised.  Otherwise the generator is called without modifying the&#10;policy.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[from_addr=None" />
				<Param name="[to_addrs=None" />
				<Param name="[mail_options=[]" />
				<Param name="[rcpt_options={}]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.sendmail" func="yes">
			<Overload retVal="" descr="This command performs an entire mail transaction.&#10;&#10;The arguments are:&#10;    - from_addr    : The address sending this mail.&#10;    - to_addrs     : A list of addresses to send this mail to.  A bare&#10;                     string will be treated as a list with 1 address.&#10;    - msg          : The message to send.&#10;    - mail_options : List of ESMTP options (such as 8bitmime) for the&#10;                     mail command.&#10;    - rcpt_options : List of ESMTP options (such as DSN commands) for&#10;                     all the rcpt commands.&#10;&#10;msg may be a string containing characters in the ASCII range, or a byte&#10;string.  A string is encoded to bytes using the ascii codec, and lone&#10;\r and \n characters are converted to \r\n characters.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.  If the server does ESMTP, message size&#10;and each of the specified options will be passed to it.  If EHLO&#10;fails, HELO will be tried and ESMTP options suppressed.&#10;&#10;This method will return normally if the mail is accepted for at least&#10;one recipient.  It returns a dictionary, with one entry for each&#10;recipient that was refused.  Each entry contains a tuple of the SMTP&#10;error code and the accompanying error message sent by the server.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError          The server didn't reply properly to&#10;                        the helo greeting.&#10; SMTPRecipientsRefused  The server rejected ALL recipients&#10;                        (no mail was sent).&#10; SMTPSenderRefused      The server didn't accept the from_addr.&#10; SMTPDataError          The server replied with an unexpected&#10;                        error code (other than a refusal of&#10;                        a recipient).&#10; SMTPNotSupportedError  The mail_options parameter includes 'SMTPUTF8'&#10;                        but the SMTPUTF8 extension is not supported by&#10;                        the server.&#10;&#10;Note: the connection will be open even after an exception is raised.&#10;&#10;Example:&#10;&#10; &gt;&gt;&gt; import smtplib&#10; &gt;&gt;&gt; s=smtplib.SMTP(&quot;localhost&quot;)&#10; &gt;&gt;&gt; tolist=[&quot;one@one.org&quot;,&quot;two@two.org&quot;,&quot;three@three.org&quot;,&quot;four@four.org&quot;]&#10; &gt;&gt;&gt; msg = '''\&#10; ... From: Me@my.org&#10; ... Subject: testin'...&#10; ...&#10; ... This is a test '''&#10; &gt;&gt;&gt; s.sendmail(&quot;me@my.org&quot;,tolist,msg)&#10; { &quot;three@three.org&quot; : ( 550 ,&quot;User unknown&quot; ) }&#10; &gt;&gt;&gt; s.quit()&#10;&#10;In the above example, the message was accepted for delivery to three&#10;of the four addresses, and one was rejected, with the error code&#10;550.  If all addresses are accepted, then the method will return an&#10;empty dictionary.">
				<Param name="self" />
				<Param name="from_addr" />
				<Param name="to_addrs" />
				<Param name="msg" />
				<Param name="[mail_options=[]" />
				<Param name="[rcpt_options=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debug output level.&#10;&#10;A non-false value results in debug messages for connection and for all&#10;messages sent to and received from the server.">
				<Param name="self" />
				<Param name="debuglevel" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.starttls" func="yes">
			<Overload retVal="" descr="Puts the connection to the SMTP server into TLS mode.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;If the server supports TLS, this will encrypt the rest of the SMTP&#10;session. If you provide the keyfile and certfile parameters,&#10;the identity of the SMTP server and client can be checked. This,&#10;however, depends on whether the socket module really checks the&#10;certificates.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.">
				<Param name="self" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None" />
				<Param name="[context=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.verify" func="yes">
			<Overload retVal="" descr="SMTP 'verify' command -- checks for address validity.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP.vrfy" func="yes">
			<Overload retVal="" descr="SMTP 'verify' command -- checks for address validity.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError" func="yes">
			<Overload retVal="" descr="Authentication error.&#10;&#10;Most probably the server didn't accept the username/password&#10;combination provided.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPAuthenticationError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError" func="yes">
			<Overload retVal="" descr="Error during connection establishment.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPConnectError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError" func="yes">
			<Overload retVal="" descr="The SMTP server didn't accept the data.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPDataError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException" func="yes">
			<Overload retVal="" descr="Base class for all exceptions raised by this module.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPException.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError" func="yes">
			<Overload retVal="" descr="The server refused our HELO reply.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPHeloError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError" func="yes">
			<Overload retVal="" descr="The command or option is not supported by the SMTP server.&#10;&#10;This exception is raised when an attempt is made to run a command or a&#10;command with an option which is not supported by the server.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPNotSupportedError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused" func="yes">
			<Overload retVal="" descr="All recipient addresses refused.&#10;&#10;The errors for each recipient are accessible through the attribute&#10;'recipients', which is a dictionary of exactly the same sort as&#10;SMTP.sendmail() returns.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPRecipientsRefused.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException" func="yes">
			<Overload retVal="" descr="Base class for all exceptions that include an SMTP error code.&#10;&#10;These exceptions are generated in some instances when the SMTP&#10;server returns an error code.  The error code is stored in the&#10;`smtp_code' attribute of the error, and the `smtp_error' attribute&#10;is set to the error message.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPResponseException.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused" func="yes">
			<Overload retVal="" descr="Sender address refused.&#10;&#10;In addition to the attributes set by on all SMTPResponseException&#10;exceptions, this sets `sender' to the string that the SMTP refused.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPSenderRefused.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected" func="yes">
			<Overload retVal="" descr="Not connected to any SMTP server.&#10;&#10;This exception is raised when the server unexpectedly disconnects,&#10;or when an attempt is made to use the SMTP instance before&#10;connecting it to a server.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTPServerDisconnected.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL" func="yes">
			<Overload retVal="" descr="This is a subclass derived from SMTP that connects over an SSL&#10;encrypted socket (to use this class you need a socket module that was&#10;compiled with SSL support). If host is not specified, '' (the local&#10;host) is used. If port is omitted, the standard SMTP-over-SSL port&#10;(465) is used.  local_hostname and source_address have the same meaning&#10;as they do in the SMTP class.  keyfile and certfile are also optional -&#10;they can contain a PEM formatted private key and certificate chain file&#10;for the SSL connection. context also optional, can contain a&#10;SSLContext, and is an alternative to keyfile and certfile; If it is&#10;specified both keyfile and certfile must be None.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.auth" func="yes">
			<Overload retVal="" descr="Authentication command - requires response processing.&#10;&#10;'mechanism' specifies which authentication mechanism is to&#10;be used - the valid values are those listed in the 'auth'&#10;element of 'esmtp_features'.&#10;&#10;'authobject' must be a callable object taking a single argument:&#10;&#10;        data = authobject(challenge)&#10;&#10;It will be called to process the server's challenge response; the&#10;challenge argument it is passed will be a bytes.  It should return&#10;bytes data that will be base64 encoded and sent to the server.&#10;&#10;Keyword arguments:&#10;    - initial_response_ok: Allow sending the RFC 4954 initial-response&#10;      to the AUTH command, if the authentication methods supports it.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.auth_cram_md5" func="yes">
			<Overload retVal="" descr="Authobject to use with CRAM-MD5 authentication. Requires self.user&#10;and self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.auth_login" func="yes">
			<Overload retVal="" descr="Authobject to use with LOGIN authentication. Requires self.user and&#10;self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.auth_plain" func="yes">
			<Overload retVal="" descr="Authobject to use with PLAIN authentication. Requires self.user and&#10;self.password to be set.">
				<Param name="self" />
				<Param name="[challenge=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.close" func="yes">
			<Overload retVal="" descr="Close the connection to the SMTP server.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.connect" func="yes">
			<Overload retVal="" descr="Connect to a host on a given port.&#10;&#10;If the hostname ends with a colon (`:') followed by a number, and&#10;there is no port specified, that suffix will be stripped off and the&#10;number interpreted as the port number to use.&#10;&#10;Note: This method is automatically invoked by __init__, if a host is&#10;specified during instantiation.">
				<Param name="self" />
				<Param name="[host=localhost" />
				<Param name="[port=0" />
				<Param name="[source_address=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.data" func="yes">
			<Overload retVal="" descr="SMTP 'DATA' command -- sends message data to server.&#10;&#10;Automatically quotes lines beginning with a period per rfc821.&#10;Raises SMTPDataError if there is an unexpected reply to the&#10;DATA command; the return value from this method is the final&#10;response code received when the all data is sent.  If msg&#10;is a string, lone '\r' and '\n' characters are converted to&#10;'\r\n' characters.  If msg is bytes, it is transmitted as is.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.default_port" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.docmd" func="yes">
			<Overload retVal="" descr="Send a command, and return its response code.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.ehlo" func="yes">
			<Overload retVal="" descr="SMTP 'ehlo' command.&#10;Hostname to send for this command defaults to the FQDN of the local&#10;host.">
				<Param name="self" />
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.ehlo_msg" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.ehlo_or_helo_if_needed" func="yes">
			<Overload retVal="" descr="Call self.ehlo() and/or self.helo() if needed.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.expn" func="yes">
			<Overload retVal="" descr="SMTP 'expn' command -- expands a mailing list.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.getreply" func="yes">
			<Overload retVal="" descr="Get a reply from the server.&#10;&#10;Returns a tuple consisting of:&#10;&#10;  - server response code (e.g. '250', or such, if all goes well)&#10;    Note: returns -1 if it can't read response code.&#10;&#10;  - server response string corresponding to response code (multiline&#10;    responses are converted to a single, multiline string).&#10;&#10;Raises SMTPServerDisconnected if end-of-file is reached.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.has_extn" func="yes">
			<Overload retVal="" descr="Does the server support a given SMTP service extension?">
				<Param name="self" />
				<Param name="opt" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.helo" func="yes">
			<Overload retVal="" descr="SMTP 'helo' command.&#10;Hostname to send for this command defaults to the FQDN of the local&#10;host.">
				<Param name="self" />
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.help" func="yes">
			<Overload retVal="" descr="SMTP 'help' command.&#10;Returns help text from server.">
				<Param name="self" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.login" func="yes">
			<Overload retVal="" descr="Log in on an SMTP server that requires authentication.&#10;&#10;The arguments are:&#10;    - user:         The user name to authenticate with.&#10;    - password:     The password for the authentication.&#10;&#10;Keyword arguments:&#10;    - initial_response_ok: Allow sending the RFC 4954 initial-response&#10;      to the AUTH command, if the authentication methods supports it.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;This method will return normally if the authentication was successful.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.&#10; SMTPAuthenticationError  The server didn't accept the username/&#10;                          password combination.&#10; SMTPNotSupportedError    The AUTH command is not supported by the&#10;                          server.&#10; SMTPException            No suitable authentication method was&#10;                          found.">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.mail" func="yes">
			<Overload retVal="" descr="SMTP 'mail' command -- begins mail xfer session.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPNotSupportedError  The options parameter includes 'SMTPUTF8'&#10;                        but the SMTPUTF8 extension is not supported by&#10;                        the server.">
				<Param name="self" />
				<Param name="sender" />
				<Param name="[options=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.noop" func="yes">
			<Overload retVal="" descr="SMTP 'noop' command -- doesn't do anything :&gt;">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.putcmd" func="yes">
			<Overload retVal="" descr="Send a command to the server.">
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[args]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.quit" func="yes">
			<Overload retVal="" descr="Terminate the SMTP session.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.rcpt" func="yes">
			<Overload retVal="" descr="SMTP 'rcpt' command -- indicates 1 recipient for this mail.">
				<Param name="self" />
				<Param name="recip" />
				<Param name="[options=[]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.rset" func="yes">
			<Overload retVal="" descr="SMTP 'rset' command -- resets session.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.send" func="yes">
			<Overload retVal="" descr="Send `s' to the server.">
				<Param name="self" />
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.send_message" func="yes">
			<Overload retVal="" descr="Converts message to a bytestring and passes it to sendmail.&#10;&#10;The arguments are as for sendmail, except that msg is an&#10;email.message.Message object.  If from_addr is None or to_addrs is&#10;None, these arguments are taken from the headers of the Message as&#10;described in RFC 2822 (a ValueError is raised if there is more than&#10;one set of 'Resent-' headers).  Regardless of the values of from_addr and&#10;to_addr, any Bcc field (or Resent-Bcc field, when the Message is a&#10;resent) of the Message object won't be transmitted.  The Message&#10;object is then serialized using email.generator.BytesGenerator and&#10;sendmail is called to transmit the message.  If the sender or any of&#10;the recipient addresses contain non-ASCII and the server advertises the&#10;SMTPUTF8 capability, the policy is cloned with utf8 set to True for the&#10;serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.&#10;If the server does not support SMTPUTF8, an SMTPNotSupported error is&#10;raised.  Otherwise the generator is called without modifying the&#10;policy.">
				<Param name="self" />
				<Param name="msg" />
				<Param name="[from_addr=None" />
				<Param name="[to_addrs=None" />
				<Param name="[mail_options=[]" />
				<Param name="[rcpt_options={}]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.sendmail" func="yes">
			<Overload retVal="" descr="This command performs an entire mail transaction.&#10;&#10;The arguments are:&#10;    - from_addr    : The address sending this mail.&#10;    - to_addrs     : A list of addresses to send this mail to.  A bare&#10;                     string will be treated as a list with 1 address.&#10;    - msg          : The message to send.&#10;    - mail_options : List of ESMTP options (such as 8bitmime) for the&#10;                     mail command.&#10;    - rcpt_options : List of ESMTP options (such as DSN commands) for&#10;                     all the rcpt commands.&#10;&#10;msg may be a string containing characters in the ASCII range, or a byte&#10;string.  A string is encoded to bytes using the ascii codec, and lone&#10;\r and \n characters are converted to \r\n characters.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.  If the server does ESMTP, message size&#10;and each of the specified options will be passed to it.  If EHLO&#10;fails, HELO will be tried and ESMTP options suppressed.&#10;&#10;This method will return normally if the mail is accepted for at least&#10;one recipient.  It returns a dictionary, with one entry for each&#10;recipient that was refused.  Each entry contains a tuple of the SMTP&#10;error code and the accompanying error message sent by the server.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError          The server didn't reply properly to&#10;                        the helo greeting.&#10; SMTPRecipientsRefused  The server rejected ALL recipients&#10;                        (no mail was sent).&#10; SMTPSenderRefused      The server didn't accept the from_addr.&#10; SMTPDataError          The server replied with an unexpected&#10;                        error code (other than a refusal of&#10;                        a recipient).&#10; SMTPNotSupportedError  The mail_options parameter includes 'SMTPUTF8'&#10;                        but the SMTPUTF8 extension is not supported by&#10;                        the server.&#10;&#10;Note: the connection will be open even after an exception is raised.&#10;&#10;Example:&#10;&#10; &gt;&gt;&gt; import smtplib&#10; &gt;&gt;&gt; s=smtplib.SMTP(&quot;localhost&quot;)&#10; &gt;&gt;&gt; tolist=[&quot;one@one.org&quot;,&quot;two@two.org&quot;,&quot;three@three.org&quot;,&quot;four@four.org&quot;]&#10; &gt;&gt;&gt; msg = '''\&#10; ... From: Me@my.org&#10; ... Subject: testin'...&#10; ...&#10; ... This is a test '''&#10; &gt;&gt;&gt; s.sendmail(&quot;me@my.org&quot;,tolist,msg)&#10; { &quot;three@three.org&quot; : ( 550 ,&quot;User unknown&quot; ) }&#10; &gt;&gt;&gt; s.quit()&#10;&#10;In the above example, the message was accepted for delivery to three&#10;of the four addresses, and one was rejected, with the error code&#10;550.  If all addresses are accepted, then the method will return an&#10;empty dictionary.">
				<Param name="self" />
				<Param name="from_addr" />
				<Param name="to_addrs" />
				<Param name="msg" />
				<Param name="[mail_options=[]" />
				<Param name="[rcpt_options=[]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debug output level.&#10;&#10;A non-false value results in debug messages for connection and for all&#10;messages sent to and received from the server.">
				<Param name="self" />
				<Param name="debuglevel" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.starttls" func="yes">
			<Overload retVal="" descr="Puts the connection to the SMTP server into TLS mode.&#10;&#10;If there has been no previous EHLO or HELO command this session, this&#10;method tries ESMTP EHLO first.&#10;&#10;If the server supports TLS, this will encrypt the rest of the SMTP&#10;session. If you provide the keyfile and certfile parameters,&#10;the identity of the SMTP server and client can be checked. This,&#10;however, depends on whether the socket module really checks the&#10;certificates.&#10;&#10;This method may raise the following exceptions:&#10;&#10; SMTPHeloError            The server didn't reply properly to&#10;                          the helo greeting.">
				<Param name="self" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None" />
				<Param name="[context=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.verify" func="yes">
			<Overload retVal="" descr="SMTP 'verify' command -- checks for address validity.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL.vrfy" func="yes">
			<Overload retVal="" descr="SMTP 'verify' command -- checks for address validity.">
				<Param name="self" />
				<Param name="address" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.SMTP_SSL_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.bCRLF" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.encode_base64" func="yes">
			<Overload retVal="" descr='Encode a string with base64.&#10;&#10;Each line will be wrapped at, at most, maxlinelen characters (defaults to&#10;76 characters).&#10;&#10;Each line of encoded text will end with eol, which defaults to "\n".  Set&#10;this to "\r\n" if you will be using the result of this function directly&#10;in an email.'>
				<Param name="s" />
				<Param name="[maxlinelen=76" />
				<Param name="[eol=
]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.quoteaddr" func="yes">
			<Overload retVal="" descr="Quote a subset of the email addresses defined by RFC 821.&#10;&#10;Should be able to handle anything email.utils.parseaddr can handle.">
				<Param name="addrstring" />
			</Overload>
		</KeyWord>
		<KeyWord name="smtplib.quotedata" func="yes">
			<Overload retVal="" descr="Quote data for email.&#10;&#10;Double leading '.', and change Unix newline '\n', or Mac '\r' into&#10;Internet CRLF end-of-line.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="snapshot_stats" func="yes">
			<Overload retVal="" descr="Function of cProfile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr" func="yes">
			<Overload retVal="" descr="Routines to help recognizing sound files.&#10;&#10;Function whathdr() recognizes various types of sound file headers.&#10;It understands almost all headers that SOX can decode.&#10;&#10;The return tuple contains the following items, in this order:&#10;- file type (as SOX understands it)&#10;- sampling rate (0 if unknown or hard to decode)&#10;- number of channels (0 if unknown or hard to decode)&#10;- number of frames in the file (-1 if unknown or hard to decode)&#10;- number of bits/sample, or 'U' for U-LAW, or 'A' for A-LAW&#10;&#10;If the file doesn't have a recognizable type, it returns None.&#10;If the file can't be opened, OSError is raised.&#10;&#10;To compute the total time, divide the number of frames by the&#10;sampling rate (a frame contains a sample for each channel).&#10;&#10;Function what() calls whathdr().  (It used to also use some&#10;heuristics for raw data, but this doesn't work very well.)&#10;&#10;Finally, the function test() is a simple main program that calls&#10;what() for all files mentioned on the argument list.  For directory&#10;arguments it calls what() for all files in that directory.  Default&#10;argument is &quot;.&quot; (testing all files in the current directory).  The&#10;option -r tells it to recurse down directories found inside&#10;explicitly given directories.">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders" func="yes">
			<Overload retVal="" descr="SndHeaders(filetype, framerate, nchannels, nframes, sampwidth)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.filetype" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.framerate" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.nchannels" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.nframes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.SndHeaders.sampwidth" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.get_long_be" />
		<KeyWord name="sndhdr.get_long_le" />
		<KeyWord name="sndhdr.get_short_be" />
		<KeyWord name="sndhdr.get_short_le" />
		<KeyWord name="sndhdr.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.test" />
		<KeyWord name="sndhdr.test_8svx" />
		<KeyWord name="sndhdr.test_aifc" />
		<KeyWord name="sndhdr.test_au" />
		<KeyWord name="sndhdr.test_hcom" />
		<KeyWord name="sndhdr.test_sndr" />
		<KeyWord name="sndhdr.test_sndt" />
		<KeyWord name="sndhdr.test_voc" />
		<KeyWord name="sndhdr.test_wav" />
		<KeyWord name="sndhdr.testall" />
		<KeyWord name="sndhdr.tests" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.what" func="yes">
			<Overload retVal="" descr="Guess the type of a sound file.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="sndhdr.whathdr" func="yes">
			<Overload retVal="" descr="Recognize sound headers.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="sniff" func="yes">
			<Overload retVal="" descr="Function of csv.Sniffer">
			</Overload>
		</KeyWord>
		<KeyWord name="sock_accept" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="sock_avail" func="yes">
			<Overload retVal="" descr="Function of telnetlib.Telnet">
			</Overload>
		</KeyWord>
		<KeyWord name="sock_connect" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="sock_recv" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="sock_sendall" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="socket" func="yes">
			<Overload retVal="" descr="This module provides socket operations and some related functions.&#10;On Unix, it supports IP (Internet Protocol) and Unix domain sockets.&#10;On other systems, it only supports IP. Functions specific for a&#10;socket are available as methods of the socket object.&#10;&#10;Functions:&#10;&#10;socket() -- create a new socket object&#10;socketpair() -- create a pair of new socket objects [*]&#10;fromfd() -- create a socket object from an open file descriptor [*]&#10;fromshare() -- create a socket object from data received from socket.share() [*]&#10;gethostname() -- return the current hostname&#10;gethostbyname() -- map a hostname to its IP number&#10;gethostbyaddr() -- map an IP number or hostname to DNS info&#10;getservbyname() -- map a service name and a protocol name to a port number&#10;getprotobyname() -- map a protocol name (e.g. 'tcp') to a number&#10;ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order&#10;htons(), htonl() -- convert 16, 32 bit int from host to network byte order&#10;inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format&#10;inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)&#10;socket.getdefaulttimeout() -- get the default timeout value&#10;socket.setdefaulttimeout() -- set the default timeout value&#10;create_connection() -- connects to an address, with an optional timeout and&#10;                       optional source address.&#10;&#10; [*] not available on all platforms!&#10;&#10;Special objects:&#10;&#10;SocketType -- type object for socket objects&#10;error -- exception raised for I/O errors&#10;has_ipv6 -- boolean value indicating if IPv6 is supported&#10;&#10;IntEnum constants:&#10;&#10;AF_INET, AF_UNIX -- socket domains (first argument to socket() call)&#10;SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)&#10;&#10;Integer constants:&#10;&#10;Many other constants may be defined; these may be used in calls to&#10;the setsockopt() and getsockopt() methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_APPLETALK" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_DECnet" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_INET" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_INET6" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_IPX" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_IRDA" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AF_SNA" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_ADDRCONFIG" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_ALL" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_CANONNAME" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_NUMERICHOST" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_NUMERICSERV" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_PASSIVE" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AI_V4MAPPED" func="yes">
			<Overload retVal="" descr="(AddressInfo)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AddressFamily" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.AddressInfo" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAGAIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_AGAIN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_BADFLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_FAIL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_FAMILY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_MEMORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_NODATA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_NONAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_SERVICE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EAI_SOCKTYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EBADF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.EWOULDBLOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_ALLHOSTS_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_BROADCAST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_LOOPBACK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_MAX_LOCAL_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_NONE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.INADDR_UNSPEC_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPORT_RESERVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPORT_USERRESERVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_ICMP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_RAW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_TCP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPPROTO_UDP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_CHECKSUM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_DONTFRAG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_HOPLIMIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_HOPOPTS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_JOIN_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_LEAVE_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_MULTICAST_HOPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_MULTICAST_IF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_MULTICAST_LOOP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_PKTINFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_RECVRTHDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_RECVTCLASS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_RTHDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_TCLASS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_UNICAST_HOPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IPV6_V6ONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_ADD_MEMBERSHIP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_DROP_MEMBERSHIP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_HDRINCL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_MULTICAST_IF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_MULTICAST_LOOP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_MULTICAST_TTL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_OPTIONS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_RECVDSTADDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_TOS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IP_TTL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IntEnum" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.IntFlag" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_BCAST" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_CTRUNC" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_DONTROUTE" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_MCAST" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_OOB" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_PEEK" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_TRUNC" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MSG_WAITALL" func="yes">
			<Overload retVal="" descr="(MsgFlag)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.MsgFlag" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_DGRAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_MAXHOST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_MAXSERV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NAMEREQD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NOFQDN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NUMERICHOST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.NI_NUMERICSERV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RCVALL_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RCVALL_ON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.RCVALL_SOCKETLEVELONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SHUT_RDWR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SHUT_WR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SIO_KEEPALIVE_VALS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SIO_LOOPBACK_FAST_PATH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SIO_RCVALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_DGRAM" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_RAW" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_RDM" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_SEQPACKET" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOCK_STREAM" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOL_SOCKET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOL_TCP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOL_UDP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SOMAXCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_ACCEPTCONN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_BROADCAST" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_DONTROUTE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_ERROR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_EXCLUSIVEADDRUSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_KEEPALIVE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_LINGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_OOBINLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_RCVBUF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_RCVLOWAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_RCVTIMEO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_REUSEADDR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_SNDBUF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_SNDLOWAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_SNDTIMEO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_TYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SO_USELOOPBACK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketIO" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketKind" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType" func="yes">
			<Overload retVal="" descr="socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None) -&gt; socket object&#10;&#10;Open a socket of the given type.  The family argument specifies the&#10;address family; it defaults to AF_INET.  The type argument specifies&#10;whether this is a stream (SOCK_STREAM, this is the default)&#10;or datagram (SOCK_DGRAM) socket.  The protocol argument defaults to 0,&#10;specifying the default protocol.  Keyword arguments are accepted.&#10;The socket is created as non-inheritable.&#10;&#10;A socket object represents one endpoint of a network connection.&#10;&#10;Methods of socket objects (keyword arguments not allowed):&#10;&#10;_accept() -- accept connection, returning new socket fd and client address&#10;bind(addr) -- bind the socket to a local address&#10;close() -- close the socket&#10;connect(addr) -- connect the socket to a remote address&#10;connect_ex(addr) -- connect, return an error code instead of an exception&#10;dup() -- return a new socket fd duplicated from fileno()&#10;fileno() -- return underlying file descriptor&#10;getpeername() -- return remote address [*]&#10;getsockname() -- return local address&#10;getsockopt(level, optname[, buflen]) -- get socket options&#10;gettimeout() -- return timeout or None&#10;listen([n]) -- start listening for incoming connections&#10;recv(buflen[, flags]) -- receive data&#10;recv_into(buffer[, nbytes[, flags]]) -- receive data (into a buffer)&#10;recvfrom(buflen[, flags]) -- receive data and sender's address&#10;recvfrom_into(buffer[, nbytes, [, flags])&#10;  -- receive data and sender's address (into a buffer)&#10;sendall(data[, flags]) -- send all data&#10;send(data[, flags]) -- send data, may not send all of it&#10;sendto(data[, flags], addr) -- send data to a given address&#10;setblocking(0 | 1) -- set or clear the blocking I/O flag&#10;setsockopt(level, optname, value[, optlen]) -- set socket options&#10;settimeout(None | float) -- set or clear the timeout&#10;shutdown(how) -- shut down traffic in one or both directions&#10;if_nameindex() -- return all network interface indices and names&#10;if_nametoindex(name) -- return the corresponding interface index&#10;if_indextoname(index) -- return the corresponding interface name&#10;&#10; [*] not available on all platforms!">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.connect" func="yes">
			<Overload retVal="" descr="connect(address)&#10;&#10;Connect the socket to a remote address.  For IP sockets, the address&#10;is a pair (host, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.connect_ex" func="yes">
			<Overload retVal="" descr="connect_ex(address) -&gt; errno&#10;&#10;This is like connect(address), but returns an error code (the errno value)&#10;instead of raising an exception when an error occurs.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.detach" func="yes">
			<Overload retVal="" descr="detach()&#10;&#10;Close the socket object without closing the underlying file descriptor.&#10;The object cannot be used after this call, but the file descriptor&#10;can be reused for other purposes.  The file descriptor is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.family" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).&#10;SIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.listen" func="yes">
			<Overload retVal="" descr="listen([backlog])&#10;&#10;Enable a server to accept connections.  If backlog is specified, it must be&#10;at least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections. If not specified, a default reasonable value is chosen.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.proto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recv" func="yes">
			<Overload retVal="" descr="recv(buffersize[, flags]) -&gt; data&#10;&#10;Receive up to buffersize bytes from the socket.  For the optional flags&#10;argument, see the Unix manual.  When no data is available, block until&#10;at least one byte is available or until the remote end is closed.  When&#10;the remote end is closed and all data is read, return the empty string.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recv_into" func="yes">
			<Overload retVal="" descr="recv_into(buffer, [nbytes[, flags]]) -&gt; nbytes_read&#10;&#10;A version of recv() that stores its data into a buffer rather than creating &#10;a new string.  Receive up to buffersize bytes from the socket.  If buffersize &#10;is not specified (or 0), receive up to the size available in the given buffer.&#10;&#10;See recv() for documentation about the flags.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recvfrom" func="yes">
			<Overload retVal="" descr="recvfrom(buffersize[, flags]) -&gt; (data, address info)&#10;&#10;Like recv(buffersize, flags) but also return the sender's address info.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.recvfrom_into" func="yes">
			<Overload retVal="" descr="recvfrom_into(buffer[, nbytes[, flags]]) -&gt; (nbytes, address info)&#10;&#10;Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.send" func="yes">
			<Overload retVal="" descr="send(data[, flags]) -&gt; count&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  Return the number of bytes&#10;sent; this may be less than len(data) if the network is busy.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.sendto" func="yes">
			<Overload retVal="" descr="sendto(data[, flags], address) -&gt; count&#10;&#10;Like send(data, flags) but allows specifying the destination address.&#10;For IP sockets, the address is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value: int)&#10;setsockopt(level, option, value: buffer)&#10;setsockopt(level, option, None, optlen: int)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer, a string buffer, or &#10;None, optlen.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.share" func="yes">
			<Overload retVal="" descr="share(process_id) -&gt; bytes&#10;&#10;Share the socket with another process.  The target process id&#10;must be provided and the resulting bytes object passed to the target&#10;process.  There the shared socket can be instantiated by calling&#10;socket.fromshare().">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.timeout" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.SocketType.type" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.TCP_FASTOPEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.TCP_KEEPCNT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.TCP_MAXSEG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.TCP_NODELAY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.create_connection" func="yes">
			<Overload retVal="" descr="Connect to *address* and return the socket object.&#10;&#10;Convenience function.  Connect to *address* (a 2-tuple ``(host,&#10;port)``) and return the socket object.  Passing the optional&#10;*timeout* parameter will set the timeout on the socket instance&#10;before attempting to connect.  If no *timeout* is supplied, the&#10;global default timeout setting returned by :func:`getdefaulttimeout`&#10;is used.  If *source_address* is set it must be a tuple of (host, port)&#10;for the socket to bind as a source address before making the connection.&#10;A host of '' or port 0 tells the OS to use the default.">
				<Param name="address" />
				<Param name="[timeout=<object object at 0x02AC9790>" />
				<Param name="[source_address=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.dup" func="yes">
			<Overload retVal="" descr="dup(integer) -&gt; integer&#10;&#10;Duplicate an integer socket file descriptor.  This is like os.dup(), but for&#10;sockets; on some platforms os.dup() won't work for socket file descriptors.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.errorTab" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.fromfd" func="yes">
			<Overload retVal="" descr="fromfd(fd, family, type[, proto]) -&gt; socket object&#10;&#10;Create a socket object from a duplicate of the given file&#10;descriptor.  The remaining arguments are the same as for socket().">
				<Param name="fd" />
				<Param name="family" />
				<Param name="type" />
				<Param name="[proto=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.fromshare" func="yes">
			<Overload retVal="" descr="fromshare(info) -&gt; socket object&#10;&#10;Create a socket object from the bytes object returned by&#10;socket.share(pid).">
				<Param name="info" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gaierror.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getaddrinfo" func="yes">
			<Overload retVal="" descr="Resolve host and port into list of address info entries.&#10;&#10;Translate the host/port argument into a sequence of 5-tuples that contain&#10;all the necessary arguments for creating a socket connected to that service.&#10;host is a domain name, a string representation of an IPv4/v6 address or&#10;None. port is a string service name such as 'http', a numeric port number or&#10;None. By passing None as the value of host and port, you can pass NULL to&#10;the underlying C API.&#10;&#10;The family, type and proto arguments can be optionally specified in order to&#10;narrow the list of addresses returned. Passing zero as a value for each of&#10;these arguments selects the full range of results.">
				<Param name="host" />
				<Param name="port" />
				<Param name="[family=0" />
				<Param name="[type=0" />
				<Param name="[proto=0" />
				<Param name="[flags=0]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getdefaulttimeout" func="yes">
			<Overload retVal="" descr="getdefaulttimeout() -&gt; timeout&#10;&#10;Returns the default timeout in seconds (float) for new socket objects.&#10;A value of None indicates that new socket objects have no timeout.&#10;When the socket module is first imported, the default is None.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getfqdn" func="yes">
			<Overload retVal="" descr="Get fully qualified domain name from name.&#10;&#10;An empty argument is interpreted as meaning the local host.&#10;&#10;First the hostname returned by gethostbyaddr() is checked, then&#10;possibly existing aliases. In case no FQDN is available, hostname&#10;from gethostname() is returned.">
				<Param name="[name]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostbyaddr" func="yes">
			<Overload retVal="" descr="gethostbyaddr(host) -&gt; (name, aliaslist, addresslist)&#10;&#10;Return the true host name, a list of aliases, and a list of IP addresses,&#10;for a host.  The host argument is a string giving a host name or IP number.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostbyname" func="yes">
			<Overload retVal="" descr="gethostbyname(host) -&gt; address&#10;&#10;Return the IP address (a string of the form '255.255.255.255') for a host.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostbyname_ex" func="yes">
			<Overload retVal="" descr="gethostbyname_ex(host) -&gt; (name, aliaslist, addresslist)&#10;&#10;Return the true host name, a list of aliases, and a list of IP addresses,&#10;for a host.  The host argument is a string giving a host name or IP number.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.gethostname" func="yes">
			<Overload retVal="" descr="gethostname() -&gt; string&#10;&#10;Return the current host name.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getnameinfo" func="yes">
			<Overload retVal="" descr="getnameinfo(sockaddr, flags) --&gt; (host, port)&#10;&#10;Get host and port for a sockaddr.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getprotobyname" func="yes">
			<Overload retVal="" descr="getprotobyname(name) -&gt; integer&#10;&#10;Return the protocol number for the named protocol.  (Rarely used.)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getservbyname" func="yes">
			<Overload retVal="" descr="getservbyname(servicename[, protocolname]) -&gt; integer&#10;&#10;Return a port number from a service name and protocol name.&#10;The optional protocol name, if given, should be 'tcp' or 'udp',&#10;otherwise any protocol will match.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.getservbyport" func="yes">
			<Overload retVal="" descr="getservbyport(port[, protocolname]) -&gt; string&#10;&#10;Return the service name from a port number and protocol name.&#10;The optional protocol name, if given, should be 'tcp' or 'udp',&#10;otherwise any protocol will match.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.has_ipv6" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.herror.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.htonl" func="yes">
			<Overload retVal="" descr="htonl(integer) -&gt; integer&#10;&#10;Convert a 32-bit integer from host to network byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.htons" func="yes">
			<Overload retVal="" descr="htons(integer) -&gt; integer&#10;&#10;Convert a 16-bit integer from host to network byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.inet_aton" func="yes">
			<Overload retVal="" descr="inet_aton(string) -&gt; bytes giving packed 32-bit IP representation&#10;&#10;Convert an IP address in string format (123.45.67.89) to the 32-bit packed&#10;binary format used in low-level network functions.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.inet_ntoa" func="yes">
			<Overload retVal="" descr="inet_ntoa(packed_ip) -&gt; ip_address_string&#10;&#10;Convert an IP address from 32-bit packed binary format to string format">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.inet_ntop" func="yes">
			<Overload retVal="" descr="inet_ntop(af, packed_ip) -&gt; string formatted IP address&#10;&#10;Convert a packed IP address of the given family to string format.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.inet_pton" func="yes">
			<Overload retVal="" descr="inet_pton(af, ip) -&gt; packed IP address string&#10;&#10;Convert an IP address from string format to a packed string suitable&#10;for use with low-level network functions.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.ntohl" func="yes">
			<Overload retVal="" descr="ntohl(integer) -&gt; integer&#10;&#10;Convert a 32-bit integer from network to host byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.ntohs" func="yes">
			<Overload retVal="" descr="ntohs(integer) -&gt; integer&#10;&#10;Convert a 16-bit integer from network to host byte order.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.setdefaulttimeout" func="yes">
			<Overload retVal="" descr="setdefaulttimeout(timeout)&#10;&#10;Set the default timeout in seconds (float) for new socket objects.&#10;A value of None indicates that new socket objects have no timeout.&#10;When the socket module is first imported, the default is None.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket" func="yes">
			<Overload retVal="" descr="A subclass of _socket.socket adding the makefile() method.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.accept" func="yes">
			<Overload retVal="" descr="accept() -&gt; (socket object, address info)&#10;&#10;Wait for an incoming connection.  Return a new socket&#10;representing the connection, and the address of the client.&#10;For IP sockets, the address info is a pair (hostaddr, port).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.connect" func="yes">
			<Overload retVal="" descr="connect(address)&#10;&#10;Connect the socket to a remote address.  For IP sockets, the address&#10;is a pair (host, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.connect_ex" func="yes">
			<Overload retVal="" descr="connect_ex(address) -&gt; errno&#10;&#10;This is like connect(address), but returns an error code (the errno value)&#10;instead of raising an exception when an error occurs.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.detach" func="yes">
			<Overload retVal="" descr="detach() -&gt; file descriptor&#10;&#10;Close the socket object without closing the underlying file descriptor.&#10;The object cannot be used after this call, but the file descriptor&#10;can be reused for other purposes.  The file descriptor is returned.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.dup" func="yes">
			<Overload retVal="" descr="dup() -&gt; socket object&#10;&#10;Duplicate the socket. Return a new socket object connected to the same&#10;system resource. The new socket is non-inheritable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.get_inheritable" func="yes">
			<Overload retVal="" descr="Get the inheritable flag of the socket">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).&#10;SIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.listen" func="yes">
			<Overload retVal="" descr="listen([backlog])&#10;&#10;Enable a server to accept connections.  If backlog is specified, it must be&#10;at least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections. If not specified, a default reasonable value is chosen.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.makefile" func="yes">
			<Overload retVal="" descr="makefile(...) -&gt; an I/O stream connected to the socket&#10;&#10;The arguments are as for io.open() after the filename, except the only&#10;supported mode values are 'r' (default), 'w' and 'b'.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.proto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recv" func="yes">
			<Overload retVal="" descr="recv(buffersize[, flags]) -&gt; data&#10;&#10;Receive up to buffersize bytes from the socket.  For the optional flags&#10;argument, see the Unix manual.  When no data is available, block until&#10;at least one byte is available or until the remote end is closed.  When&#10;the remote end is closed and all data is read, return the empty string.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recv_into" func="yes">
			<Overload retVal="" descr="recv_into(buffer, [nbytes[, flags]]) -&gt; nbytes_read&#10;&#10;A version of recv() that stores its data into a buffer rather than creating &#10;a new string.  Receive up to buffersize bytes from the socket.  If buffersize &#10;is not specified (or 0), receive up to the size available in the given buffer.&#10;&#10;See recv() for documentation about the flags.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recvfrom" func="yes">
			<Overload retVal="" descr="recvfrom(buffersize[, flags]) -&gt; (data, address info)&#10;&#10;Like recv(buffersize, flags) but also return the sender's address info.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.recvfrom_into" func="yes">
			<Overload retVal="" descr="recvfrom_into(buffer[, nbytes[, flags]]) -&gt; (nbytes, address info)&#10;&#10;Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.send" func="yes">
			<Overload retVal="" descr="send(data[, flags]) -&gt; count&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  Return the number of bytes&#10;sent; this may be less than len(data) if the network is busy.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.sendfile" func="yes">
			<Overload retVal="" descr="sendfile(file[, offset[, count]]) -&gt; sent&#10;&#10;Send a file until EOF is reached by using high-performance&#10;os.sendfile() and return the total number of bytes which&#10;were sent.&#10;*file* must be a regular file object opened in binary mode.&#10;If os.sendfile() is not available (e.g. Windows) or file is&#10;not a regular file socket.send() will be used instead.&#10;*offset* tells from where to start reading the file.&#10;If specified, *count* is the total number of bytes to transmit&#10;as opposed to sending the file until EOF is reached.&#10;File position is updated on return or also in case of error in&#10;which case file.tell() can be used to figure out the number of&#10;bytes which were sent.&#10;The socket must be of SOCK_STREAM type.&#10;Non-blocking sockets are not supported.">
				<Param name="self" />
				<Param name="file" />
				<Param name="[offset=0" />
				<Param name="[count=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.sendto" func="yes">
			<Overload retVal="" descr="sendto(data[, flags], address) -&gt; count&#10;&#10;Like send(data, flags) but allows specifying the destination address.&#10;For IP sockets, the address is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.set_inheritable" func="yes">
			<Overload retVal="" descr="Set the inheritable flag of the socket">
				<Param name="self" />
				<Param name="inheritable" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value: int)&#10;setsockopt(level, option, value: buffer)&#10;setsockopt(level, option, None, optlen: int)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer, a string buffer, or &#10;None, optlen.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.share" func="yes">
			<Overload retVal="" descr="share(process_id) -&gt; bytes&#10;&#10;Share the socket with another process.  The target process id&#10;must be provided and the resulting bytes object passed to the target&#10;process.  There the shared socket can be instantiated by calling&#10;socket.fromshare().">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.timeout" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socket.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.socketpair" func="yes">
			<Overload retVal="" descr="socketpair([family[, type[, proto]]]) -&gt; (socket object, socket object)&#10;Create a pair of socket objects from the sockets returned by the platform&#10;socketpair() function.&#10;The arguments are the same as for socket() except the default family is AF_UNIX&#10;if defined on the platform; otherwise, the default is AF_INET.">
				<Param name="[family=AddressFamily.AF_INET" />
				<Param name="[type=SocketKind.SOCK_STREAM" />
				<Param name="[proto=0]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="socket.timeout.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="socket_error" func="yes">
			<Overload retVal="" descr="Function of ssl.socket_error">
			</Overload>
		</KeyWord>
		<KeyWord name="socketpair" func="yes">
			<Overload retVal="" descr="Function of socket">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver" func="yes">
			<Overload retVal="" descr="Generic socket server classes.&#10;&#10;This module tries to capture the various aspects of defining a server:&#10;&#10;For socket-based servers:&#10;&#10;- address family:&#10;        - AF_INET{,6}: IP (Internet Protocol) sockets (default)&#10;        - AF_UNIX: Unix domain sockets&#10;        - others, e.g. AF_DECNET are conceivable (see &lt;socket.h&gt;&#10;- socket type:&#10;        - SOCK_STREAM (reliable stream, e.g. TCP)&#10;        - SOCK_DGRAM (datagrams, e.g. UDP)&#10;&#10;For request-based servers (including socket-based):&#10;&#10;- client address verification before further looking at the request&#10;        (This is actually a hook for any processing that needs to look&#10;         at the request before anything else, e.g. logging)&#10;- how to handle multiple requests:&#10;        - synchronous (one request is handled at a time)&#10;        - forking (each request is handled by a new process)&#10;        - threading (each request is handled by a new thread)&#10;&#10;The classes in this module favor the server type that is simplest to&#10;write: a synchronous TCP/IP server.  This is bad class design, but&#10;save some typing.  (There's also the issue that a deep class hierarchy&#10;slows down method lookups.)&#10;&#10;There are five classes in an inheritance diagram, four of which represent&#10;synchronous servers of four types:&#10;&#10;        +------------+&#10;        | BaseServer |&#10;        +------------+&#10;              |&#10;              v&#10;        +-----------+        +------------------+&#10;        | TCPServer |-------&gt;| UnixStreamServer |&#10;        +-----------+        +------------------+&#10;              |&#10;              v&#10;        +-----------+        +--------------------+&#10;        | UDPServer |-------&gt;| UnixDatagramServer |&#10;        +-----------+        +--------------------+&#10;&#10;Note that UnixDatagramServer derives from UDPServer, not from&#10;UnixStreamServer -- the only difference between an IP and a Unix&#10;stream server is the address family, which is simply repeated in both&#10;unix server classes.&#10;&#10;Forking and threading versions of each type of server can be created&#10;using the ForkingMixIn and ThreadingMixIn mix-in classes.  For&#10;instance, a threading UDP server class is created as follows:&#10;&#10;        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass&#10;&#10;The Mix-in class must come first, since it overrides a method defined&#10;in UDPServer! Setting the various member variables also changes&#10;the behavior of the underlying server mechanism.&#10;&#10;To implement a service, you must derive a class from&#10;BaseRequestHandler and redefine its handle() method.  You can then run&#10;various versions of the service by combining one of the server classes&#10;with your request handler class.&#10;&#10;The request handler class must be different for datagram or stream&#10;services.  This can be hidden by using the request handler&#10;subclasses StreamRequestHandler or DatagramRequestHandler.&#10;&#10;Of course, you still have to use your head!&#10;&#10;For instance, it makes no sense to use a forking server if the service&#10;contains state in memory that can be modified by requests (since the&#10;modifications in the child process would never reach the initial state&#10;kept in the parent process and passed to each child).  In this case,&#10;you can use a threading server, but you will probably have to use&#10;locks to avoid two requests that come in nearly simultaneous to apply&#10;conflicting changes to the server state.&#10;&#10;On the other hand, if you are building e.g. an HTTP server, where all&#10;data is stored externally (e.g. in the file system), a synchronous&#10;class will essentially render the service &quot;deaf&quot; while one request is&#10;being handled -- which may be for a very long time if a client is slow&#10;to read all the data it has requested.  Here a threading or forking&#10;server is appropriate.&#10;&#10;In some cases, it may be appropriate to process part of a request&#10;synchronously, but to finish processing in a forked child depending on&#10;the request data.  This can be implemented by using a synchronous&#10;server and doing an explicit fork in the request handler class&#10;handle() method.&#10;&#10;Another approach to handling multiple simultaneous requests in an&#10;environment that supports neither threads nor fork (or where these are&#10;too expensive or inappropriate for the service) is to maintain an&#10;explicit table of partially finished requests and to use a selector to&#10;decide which request to work on next (or whether to handle a new&#10;incoming request).  This is particularly important for stream services&#10;where each client can potentially be connected for a long time (if&#10;threads or subprocesses cannot be used).&#10;&#10;Future work:&#10;- Standard classes for Sun RPC (which uses either UDP or TCP)&#10;- Standard mix-in classes to implement various authentication&#10;  and encryption schemes&#10;&#10;XXX Open problems:&#10;- What to do with out-of-band data?&#10;&#10;BaseServer:&#10;- split generic &quot;request&quot; functionality out into BaseServer class.&#10;  Copyright (C) 2000  Luke Kenneth Casson Leighton &lt;lkcl@samba.org&gt;&#10;&#10;  example: read entries from a SQL database (requires overriding&#10;  get_request() to return a table entry from the database).&#10;  entry is processed by a RequestHandlerClass.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseRequestHandler" func="yes">
			<Overload retVal="" descr="Base class for request handler classes.&#10;&#10;This class is instantiated for each request to be handled.  The&#10;constructor sets the instance variables request, client_address&#10;and server, and then calls the handle() method.  To implement a&#10;specific service, all you need to do is to derive a class which&#10;defines a handle() method.&#10;&#10;The handle() method can find the request as self.request, the&#10;client address as self.client_address, and the server (in case it&#10;needs access to per-server information) as self.server.  Since a&#10;separate instance is created for each request, the handle() method&#10;can define other arbitrary instance variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseRequestHandler.finish" />
		<KeyWord name="socketserver.BaseRequestHandler.handle" />
		<KeyWord name="socketserver.BaseRequestHandler.setup" />
		<KeyWord name="socketserver.BaseServer" func="yes">
			<Overload retVal="" descr="Base class for server classes.&#10;&#10;Methods for the caller:&#10;&#10;- __init__(server_address, RequestHandlerClass)&#10;- serve_forever(poll_interval=0.5)&#10;- shutdown()&#10;- handle_request()  # if you do not use serve_forever()&#10;- fileno() -&gt; int   # for selector&#10;&#10;Methods that may be overridden:&#10;&#10;- server_bind()&#10;- server_activate()&#10;- get_request() -&gt; request, client_address&#10;- handle_timeout()&#10;- verify_request(request, client_address)&#10;- server_close()&#10;- process_request(request, client_address)&#10;- shutdown_request(request)&#10;- close_request(request)&#10;- service_actions()&#10;- handle_error()&#10;&#10;Methods for derived classes:&#10;&#10;- finish_request(request, client_address)&#10;&#10;Class variables that may be overridden by derived classes or&#10;instances:&#10;&#10;- timeout&#10;- address_family&#10;- socket_type&#10;- allow_reuse_address&#10;&#10;Instance variables:&#10;&#10;- RequestHandlerClass&#10;- socket">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.close_request" func="yes">
			<Overload retVal="" descr="Called to clean up an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.finish_request" func="yes">
			<Overload retVal="" descr="Finish one request by instantiating RequestHandlerClass.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.handle_error" func="yes">
			<Overload retVal="" descr="Handle an error gracefully.  May be overridden.&#10;&#10;The default is to print a traceback and continue.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.handle_request" func="yes">
			<Overload retVal="" descr="Handle one request, possibly blocking.&#10;&#10;Respects self.timeout.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.handle_timeout" func="yes">
			<Overload retVal="" descr="Called if no new request arrives within self.timeout.&#10;&#10;Overridden by ForkingMixIn.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.process_request" func="yes">
			<Overload retVal="" descr="Call finish_request.&#10;&#10;Overridden by ForkingMixIn and ThreadingMixIn.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.serve_forever" func="yes">
			<Overload retVal="" descr="Handle one request at a time until shutdown.&#10;&#10;Polls for shutdown every poll_interval seconds. Ignores&#10;self.timeout. If you need to do periodic tasks, do them in&#10;another thread.">
				<Param name="self" />
				<Param name="[poll_interval=0.5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.server_activate" func="yes">
			<Overload retVal="" descr="Called by constructor to activate the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.server_close" func="yes">
			<Overload retVal="" descr="Called to clean-up the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.service_actions" func="yes">
			<Overload retVal="" descr="Called by the serve_forever() loop.&#10;&#10;May be overridden by a subclass / Mixin to implement any code that&#10;needs to be run during the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.shutdown" func="yes">
			<Overload retVal="" descr="Stops the serve_forever loop.&#10;&#10;Blocks until the loop has finished. This must be called while&#10;serve_forever() is running in another thread, or it will&#10;deadlock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.shutdown_request" func="yes">
			<Overload retVal="" descr="Called to shutdown and close an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BaseServer.verify_request" func="yes">
			<Overload retVal="" descr="Verify the request.  May be overridden.&#10;&#10;Return True if we should proceed with this request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.BufferedIOBase" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.DatagramRequestHandler" func="yes">
			<Overload retVal="" descr="Define self.rfile and self.wfile for datagram sockets.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.DatagramRequestHandler.finish" />
		<KeyWord name="socketserver.DatagramRequestHandler.handle" />
		<KeyWord name="socketserver.DatagramRequestHandler.setup" />
		<KeyWord name="socketserver.StreamRequestHandler" func="yes">
			<Overload retVal="" descr="Define self.rfile and self.wfile for stream sockets.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.StreamRequestHandler.finish" />
		<KeyWord name="socketserver.StreamRequestHandler.handle" />
		<KeyWord name="socketserver.StreamRequestHandler.rbufsize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.StreamRequestHandler.setup" />
		<KeyWord name="socketserver.TCPServer" func="yes">
			<Overload retVal="" descr="Base class for various socket-based server classes.&#10;&#10;Defaults to synchronous IP stream (i.e., TCP).&#10;&#10;Methods for the caller:&#10;&#10;- __init__(server_address, RequestHandlerClass, bind_and_activate=True)&#10;- serve_forever(poll_interval=0.5)&#10;- shutdown()&#10;- handle_request()  # if you don't use serve_forever()&#10;- fileno() -&gt; int   # for selector&#10;&#10;Methods that may be overridden:&#10;&#10;- server_bind()&#10;- server_activate()&#10;- get_request() -&gt; request, client_address&#10;- handle_timeout()&#10;- verify_request(request, client_address)&#10;- process_request(request, client_address)&#10;- shutdown_request(request)&#10;- close_request(request)&#10;- handle_error()&#10;&#10;Methods for derived classes:&#10;&#10;- finish_request(request, client_address)&#10;&#10;Class variables that may be overridden by derived classes or&#10;instances:&#10;&#10;- timeout&#10;- address_family&#10;- socket_type&#10;- request_queue_size (only for stream sockets)&#10;- allow_reuse_address&#10;&#10;Instance variables:&#10;&#10;- server_address&#10;- RequestHandlerClass&#10;- socket">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.address_family" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.close_request" func="yes">
			<Overload retVal="" descr="Called to clean up an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.fileno" func="yes">
			<Overload retVal="" descr="Return socket file number.&#10;&#10;Interface required by selector.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.finish_request" func="yes">
			<Overload retVal="" descr="Finish one request by instantiating RequestHandlerClass.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.get_request" func="yes">
			<Overload retVal="" descr="Get the request and client address from the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.handle_error" func="yes">
			<Overload retVal="" descr="Handle an error gracefully.  May be overridden.&#10;&#10;The default is to print a traceback and continue.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.handle_request" func="yes">
			<Overload retVal="" descr="Handle one request, possibly blocking.&#10;&#10;Respects self.timeout.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.handle_timeout" func="yes">
			<Overload retVal="" descr="Called if no new request arrives within self.timeout.&#10;&#10;Overridden by ForkingMixIn.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.process_request" func="yes">
			<Overload retVal="" descr="Call finish_request.&#10;&#10;Overridden by ForkingMixIn and ThreadingMixIn.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.request_queue_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.serve_forever" func="yes">
			<Overload retVal="" descr="Handle one request at a time until shutdown.&#10;&#10;Polls for shutdown every poll_interval seconds. Ignores&#10;self.timeout. If you need to do periodic tasks, do them in&#10;another thread.">
				<Param name="self" />
				<Param name="[poll_interval=0.5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.server_activate" func="yes">
			<Overload retVal="" descr="Called by constructor to activate the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.server_bind" func="yes">
			<Overload retVal="" descr="Called by constructor to bind the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.server_close" func="yes">
			<Overload retVal="" descr="Called to clean-up the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.service_actions" func="yes">
			<Overload retVal="" descr="Called by the serve_forever() loop.&#10;&#10;May be overridden by a subclass / Mixin to implement any code that&#10;needs to be run during the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.shutdown" func="yes">
			<Overload retVal="" descr="Stops the serve_forever loop.&#10;&#10;Blocks until the loop has finished. This must be called while&#10;serve_forever() is running in another thread, or it will&#10;deadlock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.shutdown_request" func="yes">
			<Overload retVal="" descr="Called to shutdown and close an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.socket_type" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.TCPServer.verify_request" func="yes">
			<Overload retVal="" descr="Verify the request.  May be overridden.&#10;&#10;Return True if we should proceed with this request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingMixIn" func="yes">
			<Overload retVal="" descr="Mix-in class to handle each request in a new thread.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingMixIn.process_request" func="yes">
			<Overload retVal="" descr="Start a new thread to process the request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingMixIn.process_request_thread" func="yes">
			<Overload retVal="" descr="Same as in BaseServer but as a thread.&#10;&#10;In addition, exception handling is done here.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer" func="yes">
			<Overload retVal="" descr="Mix-in class to handle each request in a new thread.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.address_family" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.close_request" func="yes">
			<Overload retVal="" descr="Called to clean up an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.fileno" func="yes">
			<Overload retVal="" descr="Return socket file number.&#10;&#10;Interface required by selector.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.finish_request" func="yes">
			<Overload retVal="" descr="Finish one request by instantiating RequestHandlerClass.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.get_request" func="yes">
			<Overload retVal="" descr="Get the request and client address from the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.handle_error" func="yes">
			<Overload retVal="" descr="Handle an error gracefully.  May be overridden.&#10;&#10;The default is to print a traceback and continue.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.handle_request" func="yes">
			<Overload retVal="" descr="Handle one request, possibly blocking.&#10;&#10;Respects self.timeout.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.handle_timeout" func="yes">
			<Overload retVal="" descr="Called if no new request arrives within self.timeout.&#10;&#10;Overridden by ForkingMixIn.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.process_request" func="yes">
			<Overload retVal="" descr="Start a new thread to process the request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.process_request_thread" func="yes">
			<Overload retVal="" descr="Same as in BaseServer but as a thread.&#10;&#10;In addition, exception handling is done here.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.request_queue_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.serve_forever" func="yes">
			<Overload retVal="" descr="Handle one request at a time until shutdown.&#10;&#10;Polls for shutdown every poll_interval seconds. Ignores&#10;self.timeout. If you need to do periodic tasks, do them in&#10;another thread.">
				<Param name="self" />
				<Param name="[poll_interval=0.5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.server_activate" func="yes">
			<Overload retVal="" descr="Called by constructor to activate the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.server_bind" func="yes">
			<Overload retVal="" descr="Called by constructor to bind the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.server_close" func="yes">
			<Overload retVal="" descr="Called to clean-up the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.service_actions" func="yes">
			<Overload retVal="" descr="Called by the serve_forever() loop.&#10;&#10;May be overridden by a subclass / Mixin to implement any code that&#10;needs to be run during the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.shutdown" func="yes">
			<Overload retVal="" descr="Stops the serve_forever loop.&#10;&#10;Blocks until the loop has finished. This must be called while&#10;serve_forever() is running in another thread, or it will&#10;deadlock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.shutdown_request" func="yes">
			<Overload retVal="" descr="Called to shutdown and close an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.socket_type" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingTCPServer.verify_request" func="yes">
			<Overload retVal="" descr="Verify the request.  May be overridden.&#10;&#10;Return True if we should proceed with this request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer" func="yes">
			<Overload retVal="" descr="Mix-in class to handle each request in a new thread.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.address_family" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.close_request" func="yes">
			<Overload retVal="" descr="Called to clean up an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.fileno" func="yes">
			<Overload retVal="" descr="Return socket file number.&#10;&#10;Interface required by selector.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.finish_request" func="yes">
			<Overload retVal="" descr="Finish one request by instantiating RequestHandlerClass.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.get_request" func="yes">
			<Overload retVal="" descr="Get the request and client address from the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.handle_error" func="yes">
			<Overload retVal="" descr="Handle an error gracefully.  May be overridden.&#10;&#10;The default is to print a traceback and continue.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.handle_request" func="yes">
			<Overload retVal="" descr="Handle one request, possibly blocking.&#10;&#10;Respects self.timeout.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.handle_timeout" func="yes">
			<Overload retVal="" descr="Called if no new request arrives within self.timeout.&#10;&#10;Overridden by ForkingMixIn.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.max_packet_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.process_request" func="yes">
			<Overload retVal="" descr="Start a new thread to process the request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.process_request_thread" func="yes">
			<Overload retVal="" descr="Same as in BaseServer but as a thread.&#10;&#10;In addition, exception handling is done here.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.request_queue_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.serve_forever" func="yes">
			<Overload retVal="" descr="Handle one request at a time until shutdown.&#10;&#10;Polls for shutdown every poll_interval seconds. Ignores&#10;self.timeout. If you need to do periodic tasks, do them in&#10;another thread.">
				<Param name="self" />
				<Param name="[poll_interval=0.5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.server_activate" func="yes">
			<Overload retVal="" descr="Called by constructor to activate the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.server_bind" func="yes">
			<Overload retVal="" descr="Called by constructor to bind the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.server_close" func="yes">
			<Overload retVal="" descr="Called to clean-up the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.service_actions" func="yes">
			<Overload retVal="" descr="Called by the serve_forever() loop.&#10;&#10;May be overridden by a subclass / Mixin to implement any code that&#10;needs to be run during the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.shutdown" func="yes">
			<Overload retVal="" descr="Stops the serve_forever loop.&#10;&#10;Blocks until the loop has finished. This must be called while&#10;serve_forever() is running in another thread, or it will&#10;deadlock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.shutdown_request" func="yes">
			<Overload retVal="" descr="Called to shutdown and close an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.socket_type" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.ThreadingUDPServer.verify_request" func="yes">
			<Overload retVal="" descr="Verify the request.  May be overridden.&#10;&#10;Return True if we should proceed with this request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer" func="yes">
			<Overload retVal="" descr="UDP server class.">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.address_family" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.close_request" func="yes">
			<Overload retVal="" descr="Called to clean up an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.fileno" func="yes">
			<Overload retVal="" descr="Return socket file number.&#10;&#10;Interface required by selector.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.finish_request" func="yes">
			<Overload retVal="" descr="Finish one request by instantiating RequestHandlerClass.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.get_request" func="yes">
			<Overload retVal="" descr="Get the request and client address from the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.handle_error" func="yes">
			<Overload retVal="" descr="Handle an error gracefully.  May be overridden.&#10;&#10;The default is to print a traceback and continue.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.handle_request" func="yes">
			<Overload retVal="" descr="Handle one request, possibly blocking.&#10;&#10;Respects self.timeout.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.handle_timeout" func="yes">
			<Overload retVal="" descr="Called if no new request arrives within self.timeout.&#10;&#10;Overridden by ForkingMixIn.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.max_packet_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.process_request" func="yes">
			<Overload retVal="" descr="Call finish_request.&#10;&#10;Overridden by ForkingMixIn and ThreadingMixIn.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.request_queue_size" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.serve_forever" func="yes">
			<Overload retVal="" descr="Handle one request at a time until shutdown.&#10;&#10;Polls for shutdown every poll_interval seconds. Ignores&#10;self.timeout. If you need to do periodic tasks, do them in&#10;another thread.">
				<Param name="self" />
				<Param name="[poll_interval=0.5]" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.server_activate" func="yes">
			<Overload retVal="" descr="Called by constructor to activate the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.server_bind" func="yes">
			<Overload retVal="" descr="Called by constructor to bind the socket.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.server_close" func="yes">
			<Overload retVal="" descr="Called to clean-up the server.&#10;&#10;May be overridden.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.service_actions" func="yes">
			<Overload retVal="" descr="Called by the serve_forever() loop.&#10;&#10;May be overridden by a subclass / Mixin to implement any code that&#10;needs to be run during the loop.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.shutdown" func="yes">
			<Overload retVal="" descr="Stops the serve_forever loop.&#10;&#10;Blocks until the loop has finished. This must be called while&#10;serve_forever() is running in another thread, or it will&#10;deadlock.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.shutdown_request" func="yes">
			<Overload retVal="" descr="Called to shutdown and close an individual request.">
				<Param name="self" />
				<Param name="request" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.socket_type" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.UDPServer.verify_request" func="yes">
			<Overload retVal="" descr="Verify the request.  May be overridden.&#10;&#10;Return True if we should proceed with this request.">
				<Param name="self" />
				<Param name="request" />
				<Param name="client_address" />
			</Overload>
		</KeyWord>
		<KeyWord name="socketserver.time" func="yes">
			<Overload retVal="" descr="monotonic() -&gt; float&#10;&#10;Monotonic clock, cannot go backward.">
			</Overload>
		</KeyWord>
		<KeyWord name="sort" func="yes">
			<Overload retVal="" descr="L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="sortTestMethodsUsing" func="yes">
			<Overload retVal="" descr="Function of unittest.TestLoader">
			</Overload>
		</KeyWord>
		<KeyWord name="sort_attributes" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="sort_stats" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="sorted" func="yes">
			<Overload retVal="" descr="Return a new list containing all items from the iterable in ascending order.&#10;&#10;A custom key function can be supplied to customize the sort order, and the&#10;reverse flag can be set to request the result in descending order.">
			</Overload>
		</KeyWord>
		<KeyWord name="source_from_cache" func="yes">
			<Overload retVal="" descr="Function of imp">
			</Overload>
		</KeyWord>
		<KeyWord name="source_synopsis" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="sourcehook" func="yes">
			<Overload retVal="" descr="Function of shlex.shlex">
			</Overload>
		</KeyWord>
		<KeyWord name="spawn" func="yes">
			<Overload retVal="" descr="Function of setuptools.Command">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnl" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnle" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnv" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="spawnve" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="split" func="yes">
			<Overload retVal="" descr="S.split(sep=None, maxsplit=-1) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="split_sections" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="splitdoc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="splitdrive" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="splitext" func="yes">
			<Overload retVal="" descr="Function of macpath">
			</Overload>
		</KeyWord>
		<KeyWord name="splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines([keepends]) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="splitunc" func="yes">
			<Overload retVal="" descr="Function of ntpath">
			</Overload>
		</KeyWord>
		<KeyWord name="sql" func="yes">
			<Overload retVal="" descr="Function of msilib.Table">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3" />
		<KeyWord name="sqlite3.Binary" func="yes">
			<Overload retVal="" descr="Create a new memoryview object which references the given object.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.c_contiguous" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.cast" func="yes">
			<Overload retVal="" descr="Cast a memoryview to a new format or shape.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.contiguous" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.f_contiguous" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.format" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.hex" func="yes">
			<Overload retVal="" descr="Return the data in the buffer as a string of hexadecimal numbers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.itemsize" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.nbytes" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.ndim" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.obj" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.readonly" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.release" func="yes">
			<Overload retVal="" descr="Release the underlying buffer exposed by the memoryview object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.shape" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.strides" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.suboffsets" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.tobytes" func="yes">
			<Overload retVal="" descr="Return the data in the buffer as a byte string.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Binary.tolist" func="yes">
			<Overload retVal="" descr="Return the data in the buffer as a list of elements.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cache" />
		<KeyWord name="sqlite3.Cache.display" func="yes">
			<Overload retVal="" descr="For debugging only.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cache.get" func="yes">
			<Overload retVal="" descr="Gets an entry from the cache or calls the factory function to produce one.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection" func="yes">
			<Overload retVal="" descr="SQLite database connection object.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.DataError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.DatabaseError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.Error" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.IntegrityError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.InterfaceError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.InternalError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.NotSupportedError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.OperationalError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.ProgrammingError" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.Warning" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.close" func="yes">
			<Overload retVal="" descr="Closes the connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.commit" func="yes">
			<Overload retVal="" descr="Commit the current transaction.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.create_aggregate" func="yes">
			<Overload retVal="" descr="Creates a new aggregate. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.create_collation" func="yes">
			<Overload retVal="" descr="Creates a collation function. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.create_function" func="yes">
			<Overload retVal="" descr="Creates a new function. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.cursor" func="yes">
			<Overload retVal="" descr="Return a cursor for the connection.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.enable_load_extension" func="yes">
			<Overload retVal="" descr="Enable dynamic loading of SQLite extension modules. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.execute" func="yes">
			<Overload retVal="" descr="Executes a SQL statement. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.executemany" func="yes">
			<Overload retVal="" descr="Repeatedly executes a SQL statement. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.executescript" func="yes">
			<Overload retVal="" descr="Executes a multiple SQL statements at once. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.in_transaction" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.interrupt" func="yes">
			<Overload retVal="" descr="Abort any pending database operation. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.isolation_level" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.iterdump" func="yes">
			<Overload retVal="" descr="Returns iterator to the dump of the database in an SQL text format. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.load_extension" func="yes">
			<Overload retVal="" descr="Load SQLite extension module. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.rollback" func="yes">
			<Overload retVal="" descr="Roll back the current transaction.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.row_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.set_authorizer" func="yes">
			<Overload retVal="" descr="Sets authorizer callback. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.set_progress_handler" func="yes">
			<Overload retVal="" descr="Sets progress handler callback. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.set_trace_callback" func="yes">
			<Overload retVal="" descr="Sets a trace callback called for each SQL statement (passed as unicode). Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.text_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Connection.total_changes" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor" func="yes">
			<Overload retVal="" descr="SQLite database cursor class.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.arraysize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.close" func="yes">
			<Overload retVal="" descr="Closes the cursor.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.connection" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.description" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.execute" func="yes">
			<Overload retVal="" descr="Executes a SQL statement.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.executemany" func="yes">
			<Overload retVal="" descr="Repeatedly executes a SQL statement.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.executescript" func="yes">
			<Overload retVal="" descr="Executes a multiple SQL statements at once. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.fetchall" func="yes">
			<Overload retVal="" descr="Fetches all rows from the resultset.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.fetchmany" func="yes">
			<Overload retVal="" descr="Fetches several rows from the resultset.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.fetchone" func="yes">
			<Overload retVal="" descr="Fetches one row from the resultset.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.lastrowid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.row_factory" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.rowcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.setinputsizes" func="yes">
			<Overload retVal="" descr="Required by DB-API. Does nothing in pysqlite.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Cursor.setoutputsize" func="yes">
			<Overload retVal="" descr="Required by DB-API. Does nothing in pysqlite.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DataError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DataError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DataError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DatabaseError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DatabaseError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DatabaseError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date" func="yes">
			<Overload retVal="" descr="date(year, month, day) --&gt; date object">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp -&gt; local date from a POSIX timestamp (like time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.isoformat" func="yes">
			<Overload retVal="" descr="Return string in ISO 8601 format, YYYY-MM-DD.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.max" func="yes">
			<Overload retVal="" descr="(date)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.min" func="yes">
			<Overload retVal="" descr="(date)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.replace" func="yes">
			<Overload retVal="" descr="Return date with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Date.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.DateFromTicks" />
		<KeyWord name="sqlite3.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.IntegrityError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.IntegrityError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.IntegrityError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InterfaceError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InterfaceError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InterfaceError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InternalError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InternalError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.InternalError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.NotSupportedError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.NotSupportedError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.NotSupportedError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OperationalError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OperationalError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OperationalError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; str&#10;str(bytes_or_buffer[, encoding[, errors]]) -&gt; str&#10;&#10;Create a new string object from the given object. If encoding or&#10;errors is specified, then the object must expose a data buffer&#10;that will be decoded using the given encoding and error handler.&#10;Otherwise, returns the result of object.__str__() (if defined)&#10;or repr(object).&#10;encoding defaults to sys.getdefaultencoding().&#10;errors defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; str&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.casefold" func="yes">
			<Overload retVal="" descr="S.casefold() -&gt; str&#10;&#10;Return a version of S suitable for caseless comparisons.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; str&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.encode" func="yes">
			<Overload retVal="" descr="S.encode(encoding='utf-8', errors='strict') -&gt; bytes&#10;&#10;Encode S using the codec registered for encoding. Default encoding&#10;is 'utf-8'. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs(tabsize=8) -&gt; str&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.find" func="yes">
			<Overload retVal="" descr="S.find(sub[, start[, end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; str&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.format_map" func="yes">
			<Overload retVal="" descr="S.format_map(mapping) -&gt; str&#10;&#10;Return a formatted version of S, using substitutions from mapping.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.index" func="yes">
			<Overload retVal="" descr="S.index(sub[, start[, end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found, &#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Raises ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isidentifier" func="yes">
			<Overload retVal="" descr='S.isidentifier() -&gt; bool&#10;&#10;Return True if S is a valid identifier according&#10;to the language definition.&#10;&#10;Use keyword.iskeyword() to test for reserved identifiers&#10;such as "def" and "class".'>
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isprintable" func="yes">
			<Overload retVal="" descr="S.isprintable() -&gt; bool&#10;&#10;Return True if all characters in S are considered&#10;printable in repr() or S is empty, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; str&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; str&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; str&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.maketrans" func="yes">
			<Overload retVal="" descr="Return a translation table usable for str.translate().&#10;&#10;If there is only one argument, it must be a dictionary mapping Unicode&#10;ordinals (integers) or characters to Unicode ordinals, strings or None.&#10;Character keys will be then converted to ordinals.&#10;If there are two arguments, they must be strings of equal length, and&#10;in the resulting dictionary, each character in x will be mapped to the&#10;character at the same position in y. If there is a third argument, it&#10;must be a string, whose characters will be mapped to None in the result.">
				<Param name="x" />
				<Param name="y" />
				<Param name="z" />
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; str&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub[, start[, end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub[, start[, end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Raises ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; str&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.split" func="yes">
			<Overload retVal="" descr="S.split(sep=None, maxsplit=-1) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines([keepends]) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; str&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; str&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; str&#10;&#10;Return a copy of the string S in which each character has been mapped&#10;through the given translation table. The table must implement&#10;lookup/indexing via __getitem__, for instance a dictionary or list,&#10;mapping Unicode ordinals to Unicode ordinals, strings, or None. If&#10;this operation raises LookupError, the character is left untouched.&#10;Characters mapped to None are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; str&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.OptimizedUnicode.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; str&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.PARSE_COLNAMES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.PARSE_DECLTYPES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.PrepareProtocol" />
		<KeyWord name="sqlite3.ProgrammingError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.ProgrammingError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.ProgrammingError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Row" />
		<KeyWord name="sqlite3.Row.keys" func="yes">
			<Overload retVal="" descr="Returns the keys of the row.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_ALTER_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_ANALYZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_ATTACH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TEMP_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_CREATE_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DELETE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DENY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DETACH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_INDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_TABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TEMP_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_TRIGGER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_DROP_VIEW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_IGNORE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_INSERT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_PRAGMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_READ" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_REINDEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_SELECT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_TRANSACTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.SQLITE_UPDATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Statement" />
		<KeyWord name="sqlite3.Time" func="yes">
			<Overload retVal="" descr="time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) --&gt; a time object&#10;&#10;All arguments are optional. tzinfo may be None, or an instance of&#10;a tzinfo subclass. The remaining arguments may be ints.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.fold" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.isoformat" func="yes">
			<Overload retVal="" descr="Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].&#10;&#10;timespec specifies what components of the time to include.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.max" func="yes">
			<Overload retVal="" descr="(time)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.min" func="yes">
			<Overload retVal="" descr="(time)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.replace" func="yes">
			<Overload retVal="" descr="Return time with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Time.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.TimeFromTicks" />
		<KeyWord name="sqlite3.Timestamp" func="yes">
			<Overload retVal="" descr="datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])&#10;&#10;The year, month and day arguments are required. tzinfo may be None, or an&#10;instance of a tzinfo subclass. The remaining arguments may be ints.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.astimezone" func="yes">
			<Overload retVal="" descr="tz -&gt; convert to local time in new timezone tz">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.combine" func="yes">
			<Overload retVal="" descr="date, time -&gt; datetime with same date and time fields">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.ctime" func="yes">
			<Overload retVal="" descr="Return ctime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.date" func="yes">
			<Overload retVal="" descr="Return date object with same year, month and day.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.day" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.dst" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.dst(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.fold" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.fromordinal" func="yes">
			<Overload retVal="" descr="int -&gt; date corresponding to a proleptic Gregorian ordinal.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.fromtimestamp" func="yes">
			<Overload retVal="" descr="timestamp[, tz] -&gt; tz's local time from POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.hour" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.isocalendar" func="yes">
			<Overload retVal="" descr="Return a 3-tuple containing ISO year, week number, and weekday.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.isoformat" func="yes">
			<Overload retVal="" descr="[sep] -&gt; string in ISO 8601 format, YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].&#10;sep is used to separate the year from the time, and defaults to 'T'.&#10;timespec specifies what components of the time to include (allowed values are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds', and 'microseconds').">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.isoweekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 1 ... Sunday == 7">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.max" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.microsecond" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.min" func="yes">
			<Overload retVal="" descr="(datetime)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.minute" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.month" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.now" func="yes">
			<Overload retVal="" descr="Returns new datetime object representing current time local to tz.&#10;&#10;  tz&#10;    Timezone object.&#10;&#10;If no tz is specified, uses local timezone.">
				<Param name="type" />
				<Param name="[tz=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.replace" func="yes">
			<Overload retVal="" descr="Return datetime with new specified fields.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.resolution" func="yes">
			<Overload retVal="" descr="(timedelta)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.second" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.strftime" func="yes">
			<Overload retVal="" descr="format -&gt; strftime() style string.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.strptime" func="yes">
			<Overload retVal="" descr="string, format -&gt; new datetime parsed from a string (like time.strptime()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.time" func="yes">
			<Overload retVal="" descr="Return time object with same time but with tzinfo=None.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.timestamp" func="yes">
			<Overload retVal="" descr="Return POSIX timestamp as float.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.timetuple" func="yes">
			<Overload retVal="" descr="Return time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.timetz" func="yes">
			<Overload retVal="" descr="Return time object with same time and tzinfo.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.today" func="yes">
			<Overload retVal="" descr="Current date or datetime:  same as self.__class__.fromtimestamp(time.time()).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.toordinal" func="yes">
			<Overload retVal="" descr="Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.tzinfo" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.tzname" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.tzname(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utcfromtimestamp" func="yes">
			<Overload retVal="" descr="Construct a naive UTC datetime from a POSIX timestamp.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utcnow" func="yes">
			<Overload retVal="" descr="Return a new datetime representing UTC day and time.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utcoffset" func="yes">
			<Overload retVal="" descr="Return self.tzinfo.utcoffset(self).">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.utctimetuple" func="yes">
			<Overload retVal="" descr="Return UTC time tuple, compatible with time.localtime().">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.weekday" func="yes">
			<Overload retVal="" descr="Return the day of the week represented by the date.&#10;Monday == 0 ... Sunday == 6">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Timestamp.year" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.TimestampFromTicks" />
		<KeyWord name="sqlite3.Warning" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Warning.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.Warning.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.adapt" func="yes">
			<Overload retVal="" descr="adapt(obj, protocol, alternate) -&gt; adapt obj to given protocol. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.adapters" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.apilevel" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.complete_statement" func="yes">
			<Overload retVal="" descr="complete_statement(sql)&#10;&#10;Checks if a string contains a complete SQL statement. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.connect" func="yes">
			<Overload retVal="" descr='connect(database[, timeout, detect_types, isolation_level,&#10;        check_same_thread, factory, cached_statements, uri])&#10;&#10;Opens a connection to the SQLite database file *database*. You can use&#10;":memory:" to open a database connection to a database that resides in&#10;RAM instead of on disk.'>
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.converters" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.enable_callback_tracebacks" func="yes">
			<Overload retVal="" descr="enable_callback_tracebacks(flag)&#10;&#10;Enable or disable callback functions throwing errors to stderr.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.enable_shared_cache" func="yes">
			<Overload retVal="" descr="enable_shared_cache(do_enable)&#10;&#10;Enable or disable shared cache mode for the calling thread.&#10;Experimental/Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.paramstyle" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.register_adapter" func="yes">
			<Overload retVal="" descr="register_adapter(type, callable)&#10;&#10;Registers an adapter with pysqlite's adapter registry. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.register_converter" func="yes">
			<Overload retVal="" descr="register_converter(typename, callable)&#10;&#10;Registers a converter with pysqlite. Non-standard.">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.sqlite_version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.sqlite_version_info" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.threadsafety" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqlite3.version_info" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="sqrt" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile" func="yes">
			<Overload retVal="" descr="Internal support module for sre">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ANY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ANY_ALL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ASSERT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ASSERT_NOT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.ATCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BEGINNING_LINE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BEGINNING_STRING" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_END" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_END_LINE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_END_STRING" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_LOC_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_LOC_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_MULTILINE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_UNI_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.AT_UNI_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.BIGCHARSET" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.BRANCH" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CALL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_LOC_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_LOC_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_UNI_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CATEGORY_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CHARSET" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CHCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CH_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.CH_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.GROUPREF" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.GROUPREF_EXISTS" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.GROUPREF_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.IN" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.INFO" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.IN_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.JUMP" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.LITERAL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MARK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAXCODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAXGROUPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAXREPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAX_REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MAX_UNTIL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MIN_REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MIN_REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.MIN_UNTIL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.NEGATE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.NOT_LITERAL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.NOT_LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.OPCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.OP_IGNORE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.RANGE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.RANGE_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_ASCII" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_FLAG_VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_INFO_CHARSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_INFO_LITERAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SRE_INFO_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SUBPATTERN" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.SUCCESS" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.compile" func="yes">
			<Overload retVal="" descr=>
				<Param name="p" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.error" func="yes">
			<Overload retVal="" descr="Exception raised for invalid regular expressions.&#10;&#10;Attributes:&#10;&#10;    msg: The unformatted error message&#10;    pattern: The regular expression pattern&#10;    pos: The index in the pattern where compilation failed (may be None)&#10;    lineno: The line corresponding to pos (may be None)&#10;    colno: The column corresponding to pos (may be None)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_compile.isstring" />
		<KeyWord name="sre_constants" func="yes">
			<Overload retVal="" descr="Internal support module for sre">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ANY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ANY_ALL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ASSERT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ASSERT_NOT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.ATCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BEGINNING_LINE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BEGINNING_STRING" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_END" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_END_LINE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_END_STRING" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_LOC_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_LOC_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_MULTILINE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_UNI_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.AT_UNI_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.BIGCHARSET" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.BRANCH" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CALL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_LOC_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_LOC_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_UNI_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CATEGORY_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CHARSET" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CHCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CH_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.CH_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.GROUPREF" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.GROUPREF_EXISTS" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.GROUPREF_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.IN" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.INFO" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.IN_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.JUMP" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.LITERAL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MARK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAXGROUPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAXREPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAX_REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MAX_UNTIL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MIN_REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MIN_REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.MIN_UNTIL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.NEGATE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.NOT_LITERAL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.NOT_LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.OPCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.OP_IGNORE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.RANGE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.RANGE_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_ASCII" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_FLAG_VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_INFO_CHARSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_INFO_LITERAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SRE_INFO_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SUBPATTERN" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.SUCCESS" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.error" func="yes">
			<Overload retVal="" descr="Exception raised for invalid regular expressions.&#10;&#10;Attributes:&#10;&#10;    msg: The unformatted error message&#10;    pattern: The regular expression pattern&#10;    pos: The index in the pattern where compilation failed (may be None)&#10;    lineno: The line corresponding to pos (may be None)&#10;    colno: The column corresponding to pos (may be None)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_constants.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse" func="yes">
			<Overload retVal="" descr="Internal support module for sre">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ANY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ANY_ALL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ASCIILETTERS" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ASSERT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ASSERT_NOT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ATCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BEGINNING_LINE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BEGINNING_STRING" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_END" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_END_LINE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_END_STRING" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_LOC_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_LOC_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_MULTILINE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_UNI_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.AT_UNI_NON_BOUNDARY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.BIGCHARSET" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.BRANCH" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CALL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORIES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_LOC_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_LOC_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_DIGIT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_LINEBREAK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_NOT_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_SPACE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_UNI_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CATEGORY_WORD" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CHARSET" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CHCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CH_LOCALE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.CH_UNICODE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.DIGITS" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.ESCAPES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.FLAGS" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GLOBAL_FLAGS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GROUPREF" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GROUPREF_EXISTS" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.GROUPREF_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.HEXDIGITS" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.IN" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.INFO" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.IN_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.JUMP" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.LITERAL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MARK" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAXGROUPS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAXREPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAX_REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MAX_UNTIL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MIN_REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MIN_REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.MIN_UNTIL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.NEGATE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.NOT_LITERAL" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.NOT_LITERAL_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.OCTDIGITS" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.OPCODES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.OP_IGNORE" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Pattern" />
		<KeyWord name="sre_parse.Pattern.checkgroup" />
		<KeyWord name="sre_parse.Pattern.checklookbehindgroup" />
		<KeyWord name="sre_parse.Pattern.closegroup" />
		<KeyWord name="sre_parse.Pattern.groups" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Pattern.opengroup" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[name=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.RANGE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.RANGE_IGNORE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.REPEAT" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.REPEAT_CHARS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.REPEAT_ONE" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SPECIAL_CHARS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_ASCII" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_DEBUG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_DOTALL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_IGNORECASE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_LOCALE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_MULTILINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_TEMPLATE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_UNICODE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_FLAG_VERBOSE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_INFO_CHARSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_INFO_LITERAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SRE_INFO_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SUBPATTERN" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SUCCESS" func="yes">
			<Overload retVal="" descr="(_NamedIntConstant)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SubPattern" />
		<KeyWord name="sre_parse.SubPattern.append" />
		<KeyWord name="sre_parse.SubPattern.dump" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[level=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.SubPattern.getwidth" />
		<KeyWord name="sre_parse.SubPattern.insert" />
		<KeyWord name="sre_parse.Tokenizer" />
		<KeyWord name="sre_parse.Tokenizer.error" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="msg" />
				<Param name="[offset=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Tokenizer.get" />
		<KeyWord name="sre_parse.Tokenizer.getuntil" />
		<KeyWord name="sre_parse.Tokenizer.getwhile" />
		<KeyWord name="sre_parse.Tokenizer.match" />
		<KeyWord name="sre_parse.Tokenizer.pos" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Tokenizer.seek" />
		<KeyWord name="sre_parse.Tokenizer.tell" />
		<KeyWord name="sre_parse.Verbose" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Verbose.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.Verbose.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.WHITESPACE" func="yes">
			<Overload retVal="" descr="(frozenset)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.error" func="yes">
			<Overload retVal="" descr="Exception raised for invalid regular expressions.&#10;&#10;Attributes:&#10;&#10;    msg: The unformatted error message&#10;    pattern: The regular expression pattern&#10;    pos: The index in the pattern where compilation failed (may be None)&#10;    lineno: The line corresponding to pos (may be None)&#10;    colno: The column corresponding to pos (may be None)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.expand_template" />
		<KeyWord name="sre_parse.fix_flags" />
		<KeyWord name="sre_parse.parse" func="yes">
			<Overload retVal="" descr=>
				<Param name="str" />
				<Param name="[flags=0" />
				<Param name="[pattern=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sre_parse.parse_template" />
		<KeyWord name="ssl" func="yes">
			<Overload retVal="" descr="This module provides some more Pythonic support for SSL.&#10;&#10;Object types:&#10;&#10;  SSLSocket -- subtype of socket.socket which does SSL over the socket&#10;&#10;Exceptions:&#10;&#10;  SSLError -- exception raised for I/O errors&#10;&#10;Functions:&#10;&#10;  cert_time_to_seconds -- convert time string used for certificate&#10;                          notBefore and notAfter functions to integer&#10;                          seconds past the Epoch (the time values&#10;                          returned from time.time())&#10;&#10;  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided&#10;                          by the server running on HOST at port PORT.  No&#10;                          validation of the certificate is performed.&#10;&#10;Integer constants:&#10;&#10;SSL_ERROR_ZERO_RETURN&#10;SSL_ERROR_WANT_READ&#10;SSL_ERROR_WANT_WRITE&#10;SSL_ERROR_WANT_X509_LOOKUP&#10;SSL_ERROR_SYSCALL&#10;SSL_ERROR_SSL&#10;SSL_ERROR_WANT_CONNECT&#10;&#10;SSL_ERROR_EOF&#10;SSL_ERROR_INVALID_ERROR_CODE&#10;&#10;The following group define certificate requirements that one side is&#10;allowing/requiring from the other side:&#10;&#10;CERT_NONE - no certificates from the other side are required (or will&#10;            be looked at if provided)&#10;CERT_OPTIONAL - certificates are not required, but if provided will be&#10;                validated, and if validation fails, the connection will&#10;                also fail&#10;CERT_REQUIRED - certificates are required, and will be validated, and&#10;                if validation fails, the connection will also fail&#10;&#10;The following constants identify various SSL protocol variants:&#10;&#10;PROTOCOL_SSLv2&#10;PROTOCOL_SSLv3&#10;PROTOCOL_SSLv23&#10;PROTOCOL_TLS&#10;PROTOCOL_TLS_CLIENT&#10;PROTOCOL_TLS_SERVER&#10;PROTOCOL_TLSv1&#10;PROTOCOL_TLSv1_1&#10;PROTOCOL_TLSv1_2&#10;&#10;The following constants identify various SSL alert message descriptions as per&#10;http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6&#10;&#10;ALERT_DESCRIPTION_CLOSE_NOTIFY&#10;ALERT_DESCRIPTION_UNEXPECTED_MESSAGE&#10;ALERT_DESCRIPTION_BAD_RECORD_MAC&#10;ALERT_DESCRIPTION_RECORD_OVERFLOW&#10;ALERT_DESCRIPTION_DECOMPRESSION_FAILURE&#10;ALERT_DESCRIPTION_HANDSHAKE_FAILURE&#10;ALERT_DESCRIPTION_BAD_CERTIFICATE&#10;ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE&#10;ALERT_DESCRIPTION_CERTIFICATE_REVOKED&#10;ALERT_DESCRIPTION_CERTIFICATE_EXPIRED&#10;ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN&#10;ALERT_DESCRIPTION_ILLEGAL_PARAMETER&#10;ALERT_DESCRIPTION_UNKNOWN_CA&#10;ALERT_DESCRIPTION_ACCESS_DENIED&#10;ALERT_DESCRIPTION_DECODE_ERROR&#10;ALERT_DESCRIPTION_DECRYPT_ERROR&#10;ALERT_DESCRIPTION_PROTOCOL_VERSION&#10;ALERT_DESCRIPTION_INSUFFICIENT_SECURITY&#10;ALERT_DESCRIPTION_INTERNAL_ERROR&#10;ALERT_DESCRIPTION_USER_CANCELLED&#10;ALERT_DESCRIPTION_NO_RENEGOTIATION&#10;ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION&#10;ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE&#10;ALERT_DESCRIPTION_UNRECOGNIZED_NAME&#10;ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE&#10;ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE&#10;ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.AF_INET" func="yes">
			<Overload retVal="" descr="(AddressFamily)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_ACCESS_DENIED" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_CERTIFICATE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_BAD_RECORD_MAC" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_EXPIRED" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_REVOKED" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_DECODE_ERROR" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_DECOMPRESSION_FAILURE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_DECRYPT_ERROR" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_ILLEGAL_PARAMETER" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_INSUFFICIENT_SECURITY" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_NO_RENEGOTIATION" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_PROTOCOL_VERSION" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_RECORD_OVERFLOW" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNEXPECTED_MESSAGE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNKNOWN_CA" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNRECOGNIZED_NAME" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.ALERT_DESCRIPTION_USER_CANCELLED" func="yes">
			<Overload retVal="" descr="(AlertDescription)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.AlertDescription" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CERT_OPTIONAL" func="yes">
			<Overload retVal="" descr="(VerifyMode)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CERT_REQUIRED" func="yes">
			<Overload retVal="" descr="(VerifyMode)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CHANNEL_BINDING_TYPES" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CertificateError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CertificateError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.CertificateError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DER_cert_to_PEM_cert" func="yes">
			<Overload retVal="" descr="Takes a certificate in binary DER format and returns the&#10;PEM version of it as a string.">
				<Param name="der_cert_bytes" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths" func="yes">
			<Overload retVal="" descr="DefaultVerifyPaths(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.cafile" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.capath" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_cafile" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_cafile_env" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_capath" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.DefaultVerifyPaths.openssl_capath_env" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_ALPN" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_ECDH" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_NPN" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.HAS_SNI" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.MemoryBIO" />
		<KeyWord name="ssl.MemoryBIO.eof" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.MemoryBIO.pending" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.MemoryBIO.read" func="yes">
			<Overload retVal="" descr='Read up to size bytes from the memory BIO.&#10;&#10;If size is not specified, read the entire buffer.&#10;If the return value is an empty bytes instance, this means either&#10;EOF or that no data is available. Use the "eof" property to&#10;distinguish between the two.'>
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.MemoryBIO.write" func="yes">
			<Overload retVal="" descr="Writes the bytes b into the memory BIO.&#10;&#10;Returns the number of bytes written.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.MemoryBIO.write_eof" func="yes">
			<Overload retVal="" descr='Write an EOF marker to the memory BIO.&#10;&#10;When all data has been read, the "eof" property will be True.'>
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OPENSSL_VERSION" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OPENSSL_VERSION_INFO" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OPENSSL_VERSION_NUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_ALL" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_CIPHER_SERVER_PREFERENCE" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_COMPRESSION" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_SSLv2" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_SSLv3" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TICKET" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TLSv1" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TLSv1_1" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_NO_TLSv1_2" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_SINGLE_DH_USE" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.OP_SINGLE_ECDH_USE" func="yes">
			<Overload retVal="" descr="(Options)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Options" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PEM_FOOTER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PEM_HEADER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PEM_cert_to_DER_cert" func="yes">
			<Overload retVal="" descr="Takes a certificate in ASCII PEM format and returns the&#10;DER-encoded version of it as a byte sequence">
				<Param name="pem_cert_string" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_SSLv23" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_SSLv3" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLS" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLS_CLIENT" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLS_SERVER" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLSv1" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLSv1_1" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.PROTOCOL_TLSv1_2" func="yes">
			<Overload retVal="" descr="(_SSLMethod)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.Purpose" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_add" func="yes">
			<Overload retVal="" descr="Mix string into the OpenSSL PRNG state.&#10;&#10;entropy (a float) is a lower bound on the entropy contained in&#10;string.  See RFC 4086.">
				<Param name="string" />
				<Param name="entropy" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_bytes" func="yes">
			<Overload retVal="" descr="Generate n cryptographically strong pseudo-random bytes.">
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_egd" func="yes">
			<Overload retVal="" descr="Queries the entropy gather daemon (EGD) on the socket named by 'path'.&#10;&#10;Returns number of bytes read.  Raises SSLError if connection to EGD&#10;fails or if it does not provide enough data to seed PRNG.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_pseudo_bytes" func="yes">
			<Overload retVal="" descr="Generate n pseudo-random bytes.&#10;&#10;Return a pair (bytes, is_cryptographic).  is_cryptographic is True&#10;if the bytes generated are cryptographically strong.">
				<Param name="n" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.RAND_status" func="yes">
			<Overload retVal="" descr="Returns 1 if the OpenSSL PRNG has been seeded with enough data and 0 if not.&#10;&#10;It is necessary to seed the PRNG with RAND_add() on some platforms before&#10;using the ssl() function.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SOCK_STREAM" func="yes">
			<Overload retVal="" descr="(SocketKind)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SOL_SOCKET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SO_TYPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext" func="yes">
			<Overload retVal="" descr="An SSLContext holds various SSL-related configuration options and&#10;data, such as certificates and possibly a private key.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.cert_store_stats" func="yes">
			<Overload retVal="" descr="Returns quantities of loaded X.509 certificates.&#10;&#10;X.509 certificates with a CA extension and certificate revocation lists&#10;inside the context's cert store.&#10;&#10;NOTE: Certificates in a capath directory aren't loaded unless they have&#10;been used at least once.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.check_hostname" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.get_ca_certs" func="yes">
			<Overload retVal="" descr="Returns a list of dicts with information of loaded CA certs.&#10;&#10;If the optional argument is True, returns a DER-encoded copy of the CA&#10;certificate.&#10;&#10;NOTE: Certificates in a capath directory aren't loaded unless they have&#10;been used at least once.">
				<Param name="self" />
				<Param name="[binary_form=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.get_ciphers" />
		<KeyWord name="ssl.SSLContext.load_cert_chain" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="certfile" />
				<Param name="[keyfile=None" />
				<Param name="[password=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.load_default_certs" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[purpose=Purpose.SERVER_AUTH]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.load_dh_params" />
		<KeyWord name="ssl.SSLContext.load_verify_locations" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[cafile=None" />
				<Param name="[capath=None" />
				<Param name="[cadata=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.options" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.protocol" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.session_stats" />
		<KeyWord name="ssl.SSLContext.set_alpn_protocols" />
		<KeyWord name="ssl.SSLContext.set_ciphers" />
		<KeyWord name="ssl.SSLContext.set_default_verify_paths" />
		<KeyWord name="ssl.SSLContext.set_ecdh_curve" />
		<KeyWord name="ssl.SSLContext.set_npn_protocols" />
		<KeyWord name="ssl.SSLContext.set_servername_callback" func="yes">
			<Overload retVal="" descr="Set a callback that will be called when a server name is provided by the SSL/TLS client in the SNI extension.&#10;&#10;If the argument is None then the callback is disabled. The method is called&#10;with the SSLSocket, the server name as a string, and the SSLContext object.&#10;See RFC 6066 for details of the SNI extension.">
				<Param name="self" />
				<Param name="method" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.verify_flags" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.verify_mode" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.wrap_bio" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="incoming" />
				<Param name="outgoing" />
				<Param name="[server_side=False" />
				<Param name="[server_hostname=None" />
				<Param name="[session=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLContext.wrap_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="sock" />
				<Param name="[server_side=False" />
				<Param name="[do_handshake_on_connect=True" />
				<Param name="[suppress_ragged_eofs=True" />
				<Param name="[server_hostname=None" />
				<Param name="[session=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError" func="yes">
			<Overload retVal="" descr="SSL/TLS connection terminated abruptly.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLEOFError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError" func="yes">
			<Overload retVal="" descr="An error occurred in the SSL implementation.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLErrorNumber" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject" func="yes">
			<Overload retVal="" descr="This class implements an interface on top of a low-level SSL object as&#10;implemented by OpenSSL. This object captures the state of an SSL connection&#10;but does not provide any network IO itself. IO needs to be performed&#10;through separate &quot;BIO&quot; objects which are OpenSSL's IO abstraction layer.&#10;&#10;This class does not have a public constructor. Instances are returned by&#10;``SSLContext.wrap_bio``. This class is typically used by framework authors&#10;that want to implement asynchronous IO for SSL through memory buffers.&#10;&#10;When compared to ``SSLSocket``, this object lacks the following features:&#10;&#10; * Any form of network IO incluging methods such as ``recv`` and ``send``.&#10; * The ``do_handshake_on_connect`` and ``suppress_ragged_eofs`` machinery.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.cipher" func="yes">
			<Overload retVal="" descr="Return the currently selected cipher as a 3-tuple ``(name,&#10;ssl_version, secret_bits)``.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.compression" func="yes">
			<Overload retVal="" descr="Return the current compression algorithm in use, or ``None`` if&#10;compression was not negotiated or not supported by one of the peers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.context" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.do_handshake" func="yes">
			<Overload retVal="" descr="Start the SSL/TLS handshake.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.get_channel_binding" func="yes">
			<Overload retVal="" descr="Get channel binding data for current connection.  Raise ValueError&#10;if the requested `cb_type` is not supported.  Return bytes of the data&#10;or None if the data is not available (e.g. before the handshake).">
				<Param name="self" />
				<Param name="[cb_type=tls-unique]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.getpeercert" func="yes">
			<Overload retVal="" descr="Returns a formatted version of the data in the certificate provided&#10;by the other end of the SSL channel.&#10;&#10;Return None if no certificate was provided, {} if a certificate was&#10;provided, but not validated.">
				<Param name="self" />
				<Param name="[binary_form=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.pending" func="yes">
			<Overload retVal="" descr="Return the number of bytes that can be read immediately.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.read" func="yes">
			<Overload retVal="" descr="Read up to 'len' bytes from the SSL object and return them.&#10;&#10;If 'buffer' is provided, read into this buffer and return the number of&#10;bytes read.">
				<Param name="self" />
				<Param name="[len=1024" />
				<Param name="[buffer=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.selected_alpn_protocol" func="yes">
			<Overload retVal="" descr="Return the currently selected ALPN protocol as a string, or ``None``&#10;if a next protocol was not negotiated or if ALPN is not supported by one&#10;of the peers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.selected_npn_protocol" func="yes">
			<Overload retVal="" descr="Return the currently selected NPN protocol as a string, or ``None``&#10;if a next protocol was not negotiated or if NPN is not supported by one&#10;of the peers.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.server_hostname" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.server_side" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.session" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.session_reused" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.shared_ciphers" func="yes">
			<Overload retVal="" descr="Return a list of ciphers shared by the client during the handshake or&#10;None if this is not a valid server connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.unwrap" func="yes">
			<Overload retVal="" descr="Start the SSL shutdown handshake.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.version" func="yes">
			<Overload retVal="" descr="Return a string identifying the protocol version used by the&#10;current SSL channel.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLObject.write" func="yes">
			<Overload retVal="" descr="Write 'data' to the SSL object and return the number of bytes&#10;written.&#10;&#10;The 'data' argument must support the buffer interface.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSession" />
		<KeyWord name="ssl.SSLSession.has_ticket" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSession.id" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSession.ticket_lifetime_hint" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSession.time" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSession.timeout" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket" func="yes">
			<Overload retVal="" descr="This class implements a subtype of socket.socket that wraps&#10;the underlying OS socket in an SSL context when necessary, and&#10;provides read and write methods over that channel.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.accept" func="yes">
			<Overload retVal="" descr="Accepts a new connection from a remote client, and returns&#10;a tuple containing that new connection wrapped with a server-side&#10;SSL channel, and the address of the remote client.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.cipher" />
		<KeyWord name="ssl.SSLSocket.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.compression" />
		<KeyWord name="ssl.SSLSocket.connect" func="yes">
			<Overload retVal="" descr="Connects to remote ADDR, and then wraps the connection in&#10;an SSL channel.">
				<Param name="self" />
				<Param name="addr" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.connect_ex" func="yes">
			<Overload retVal="" descr="Connects to remote ADDR, and then wraps the connection in&#10;an SSL channel.">
				<Param name="self" />
				<Param name="addr" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.context" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.detach" func="yes">
			<Overload retVal="" descr="detach() -&gt; file descriptor&#10;&#10;Close the socket object without closing the underlying file descriptor.&#10;The object cannot be used after this call, but the file descriptor&#10;can be reused for other purposes.  The file descriptor is returned.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.do_handshake" func="yes">
			<Overload retVal="" descr="Perform a TLS/SSL handshake.">
				<Param name="self" />
				<Param name="[block=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.dup" func="yes">
			<Overload retVal="" descr="dup() -&gt; socket object&#10;&#10;Duplicate the socket. Return a new socket object connected to the same&#10;system resource. The new socket is non-inheritable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.get_channel_binding" func="yes">
			<Overload retVal="" descr="Get channel binding data for current connection.  Raise ValueError&#10;if the requested `cb_type` is not supported.  Return bytes of the data&#10;or None if the data is not available (e.g. before the handshake).">
				<Param name="self" />
				<Param name="[cb_type=tls-unique]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.get_inheritable" func="yes">
			<Overload retVal="" descr="Get the inheritable flag of the socket">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getpeercert" func="yes">
			<Overload retVal="" descr="Returns a formatted version of the data in the&#10;certificate provided by the other end of the SSL channel.&#10;Return None if no certificate was provided, {} if a&#10;certificate was provided, but not validated.">
				<Param name="self" />
				<Param name="[binary_form=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).&#10;SIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.listen" func="yes">
			<Overload retVal="" descr="listen([backlog])&#10;&#10;Enable a server to accept connections.  If backlog is specified, it must be&#10;at least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections. If not specified, a default reasonable value is chosen.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.makefile" func="yes">
			<Overload retVal="" descr="makefile(...) -&gt; an I/O stream connected to the socket&#10;&#10;The arguments are as for io.open() after the filename, except the only&#10;supported mode values are 'r' (default), 'w' and 'b'.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.pending" />
		<KeyWord name="ssl.SSLSocket.proto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.read" func="yes">
			<Overload retVal="" descr="Read up to LEN bytes and return them.&#10;Return zero-length string on EOF.">
				<Param name="self" />
				<Param name="[len=1024" />
				<Param name="[buffer=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recv" func="yes">
			<Overload retVal="" descr="recv(buffersize[, flags]) -&gt; data&#10;&#10;Receive up to buffersize bytes from the socket.  For the optional flags&#10;argument, see the Unix manual.  When no data is available, block until&#10;at least one byte is available or until the remote end is closed.  When&#10;the remote end is closed and all data is read, return the empty string.">
				<Param name="self" />
				<Param name="[buflen=1024" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recv_into" func="yes">
			<Overload retVal="" descr="recv_into(buffer, [nbytes[, flags]]) -&gt; nbytes_read&#10;&#10;A version of recv() that stores its data into a buffer rather than creating &#10;a new string.  Receive up to buffersize bytes from the socket.  If buffersize &#10;is not specified (or 0), receive up to the size available in the given buffer.&#10;&#10;See recv() for documentation about the flags.">
				<Param name="self" />
				<Param name="buffer" />
				<Param name="[nbytes=None" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recvfrom" func="yes">
			<Overload retVal="" descr="recvfrom(buffersize[, flags]) -&gt; (data, address info)&#10;&#10;Like recv(buffersize, flags) but also return the sender's address info.">
				<Param name="self" />
				<Param name="[buflen=1024" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recvfrom_into" func="yes">
			<Overload retVal="" descr="recvfrom_into(buffer[, nbytes[, flags]]) -&gt; (nbytes, address info)&#10;&#10;Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.">
				<Param name="self" />
				<Param name="buffer" />
				<Param name="[nbytes=None" />
				<Param name="[flags=0]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recvmsg" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.recvmsg_into" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.selected_alpn_protocol" />
		<KeyWord name="ssl.SSLSocket.selected_npn_protocol" />
		<KeyWord name="ssl.SSLSocket.send" func="yes">
			<Overload retVal="" descr="send(data[, flags]) -&gt; count&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  Return the number of bytes&#10;sent; this may be less than len(data) if the network is busy.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
				<Param name="self" />
				<Param name="data" />
				<Param name="[flags=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.sendfile" func="yes">
			<Overload retVal="" descr="Send a file, possibly by using os.sendfile() if this is a&#10;clear-text socket.  Return the total number of bytes sent.">
				<Param name="self" />
				<Param name="file" />
				<Param name="[offset=0" />
				<Param name="[count=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.sendmsg" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.sendto" func="yes">
			<Overload retVal="" descr="sendto(data[, flags], address) -&gt; count&#10;&#10;Like send(data, flags) but allows specifying the destination address.&#10;For IP sockets, the address is a pair (hostaddr, port).">
				<Param name="self" />
				<Param name="data" />
				<Param name="flags_or_addr" />
				<Param name="[addr=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.session" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.session_reused" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.set_inheritable" func="yes">
			<Overload retVal="" descr="Set the inheritable flag of the socket">
				<Param name="self" />
				<Param name="inheritable" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value: int)&#10;setsockopt(level, option, value: buffer)&#10;setsockopt(level, option, None, optlen: int)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer, a string buffer, or &#10;None, optlen.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.share" func="yes">
			<Overload retVal="" descr="share(process_id) -&gt; bytes&#10;&#10;Share the socket with another process.  The target process id&#10;must be provided and the resulting bytes object passed to the target&#10;process.  There the shared socket can be instantiated by calling&#10;socket.fromshare().">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.shared_ciphers" />
		<KeyWord name="ssl.SSLSocket.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
				<Param name="self" />
				<Param name="how" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.timeout" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.unwrap" />
		<KeyWord name="ssl.SSLSocket.version" func="yes">
			<Overload retVal="" descr="Return a string identifying the protocol version used by the&#10;current SSL channel, or None if there is no established channel.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSocket.write" func="yes">
			<Overload retVal="" descr="Write DATA to the underlying SSL channel.  Returns&#10;number of bytes of DATA actually transmitted.">
				<Param name="self" />
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError" func="yes">
			<Overload retVal="" descr="System error when attempting SSL operation.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLSyscallError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError" func="yes">
			<Overload retVal="" descr="Non-blocking SSL socket needs to read more data&#10;before the requested operation can be completed.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantReadError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError" func="yes">
			<Overload retVal="" descr="Non-blocking SSL socket needs to write more data&#10;before the requested operation can be completed.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLWantWriteError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError" func="yes">
			<Overload retVal="" descr="SSL/TLS session closed cleanly.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSLZeroReturnError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_EOF" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_INVALID_ERROR_CODE" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_SSL" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_SYSCALL" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_CONNECT" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_READ" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_WRITE" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_WANT_X509_LOOKUP" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.SSL_ERROR_ZERO_RETURN" func="yes">
			<Overload retVal="" descr="(SSLErrorNumber)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_CRL_CHECK_CHAIN" func="yes">
			<Overload retVal="" descr="(VerifyFlags)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_CRL_CHECK_LEAF" func="yes">
			<Overload retVal="" descr="(VerifyFlags)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_X509_STRICT" func="yes">
			<Overload retVal="" descr="(VerifyFlags)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VERIFY_X509_TRUSTED_FIRST" func="yes">
			<Overload retVal="" descr="(VerifyFlags)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VerifyFlags" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.VerifyMode" func="yes">
			<Overload retVal="" descr="(EnumMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.cert_time_to_seconds" func="yes">
			<Overload retVal="" descr='Return the time in seconds since the Epoch, given the timestring&#10;representing the "notBefore" or "notAfter" date from a certificate&#10;in ``"%b %d %H:%M:%S %Y %Z"`` strptime format (C locale).&#10;&#10;"notBefore" or "notAfter" dates must use UTC (RFC 5280).&#10;&#10;Month is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&#10;UTC should be specified as GMT (see ASN1_TIME_print())'>
				<Param name="cert_time" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.create_connection" func="yes">
			<Overload retVal="" descr="Connect to *address* and return the socket object.&#10;&#10;Convenience function.  Connect to *address* (a 2-tuple ``(host,&#10;port)``) and return the socket object.  Passing the optional&#10;*timeout* parameter will set the timeout on the socket instance&#10;before attempting to connect.  If no *timeout* is supplied, the&#10;global default timeout setting returned by :func:`getdefaulttimeout`&#10;is used.  If *source_address* is set it must be a tuple of (host, port)&#10;for the socket to bind as a source address before making the connection.&#10;A host of '' or port 0 tells the OS to use the default.">
				<Param name="address" />
				<Param name="[timeout=<object object at 0x02AC9790>" />
				<Param name="[source_address=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.create_default_context" func="yes">
			<Overload retVal="" descr="Create a SSLContext object with default settings.&#10;&#10;NOTE: The protocol and settings may change anytime without prior&#10;      deprecation. The values represent a fair balance between maximum&#10;      compatibility and security.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.enum_certificates" func="yes">
			<Overload retVal="" descr="Retrieve certificates from Windows' cert store.&#10;&#10;store_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide&#10;more cert storages, too.  The function returns a list of (bytes,&#10;encoding_type, trust) tuples.  The encoding_type flag can be interpreted&#10;with X509_ASN_ENCODING or PKCS_7_ASN_ENCODING. The trust setting is either&#10;a set of OIDs or the boolean True.">
				<Param name="store_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.enum_crls" func="yes">
			<Overload retVal="" descr="Retrieve CRLs from Windows' cert store.&#10;&#10;store_name may be one of 'CA', 'ROOT' or 'MY'.  The system may provide&#10;more cert storages, too.  The function returns a list of (bytes,&#10;encoding_type) tuples.  The encoding_type flag can be interpreted with&#10;X509_ASN_ENCODING or PKCS_7_ASN_ENCODING.">
				<Param name="store_name" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.get_default_verify_paths" func="yes">
			<Overload retVal="" descr="Return paths to default cafile and capath.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.get_protocol_name" />
		<KeyWord name="ssl.get_server_certificate" func="yes">
			<Overload retVal="" descr="Retrieve the certificate from the server at the specified address,&#10;and return it as a PEM-encoded string.&#10;If 'ca_certs' is specified, validate the server cert against it.&#10;If 'ssl_version' is specified, use it in the connection attempt.">
				<Param name="addr" />
				<Param name="[ssl_version=_SSLMethod.PROTOCOL_TLS" />
				<Param name="[ca_certs=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.match_hostname" func="yes">
			<Overload retVal="" descr="Verify that *cert* (in decoded format as returned by&#10;SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125&#10;rules are followed, but IP addresses are not accepted for *hostname*.&#10;&#10;CertificateError is raised on failure. On success, the function&#10;returns nothing.">
				<Param name="cert" />
				<Param name="hostname" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket" func="yes">
			<Overload retVal="" descr="A subclass of _socket.socket adding the makefile() method.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.accept" func="yes">
			<Overload retVal="" descr="accept() -&gt; (socket object, address info)&#10;&#10;Wait for an incoming connection.  Return a new socket&#10;representing the connection, and the address of the client.&#10;For IP sockets, the address info is a pair (hostaddr, port).">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.bind" func="yes">
			<Overload retVal="" descr="bind(address)&#10;&#10;Bind the socket to a local address.  For IP sockets, the address is a&#10;pair (host, port); the host must refer to the local host. For raw packet&#10;sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.close" func="yes">
			<Overload retVal="" descr="close()&#10;&#10;Close the socket.  It cannot be used after this call.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.connect" func="yes">
			<Overload retVal="" descr="connect(address)&#10;&#10;Connect the socket to a remote address.  For IP sockets, the address&#10;is a pair (host, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.connect_ex" func="yes">
			<Overload retVal="" descr="connect_ex(address) -&gt; errno&#10;&#10;This is like connect(address), but returns an error code (the errno value)&#10;instead of raising an exception when an error occurs.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.detach" func="yes">
			<Overload retVal="" descr="detach() -&gt; file descriptor&#10;&#10;Close the socket object without closing the underlying file descriptor.&#10;The object cannot be used after this call, but the file descriptor&#10;can be reused for other purposes.  The file descriptor is returned.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.dup" func="yes">
			<Overload retVal="" descr="dup() -&gt; socket object&#10;&#10;Duplicate the socket. Return a new socket object connected to the same&#10;system resource. The new socket is non-inheritable.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.family" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.fileno" func="yes">
			<Overload retVal="" descr="fileno() -&gt; integer&#10;&#10;Return the integer file descriptor of the socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.get_inheritable" func="yes">
			<Overload retVal="" descr="Get the inheritable flag of the socket">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.getpeername" func="yes">
			<Overload retVal="" descr="getpeername() -&gt; address info&#10;&#10;Return the address of the remote endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.getsockname" func="yes">
			<Overload retVal="" descr="getsockname() -&gt; address info&#10;&#10;Return the address of the local endpoint.  For IP sockets, the address&#10;info is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.getsockopt" func="yes">
			<Overload retVal="" descr="getsockopt(level, option[, buffersize]) -&gt; value&#10;&#10;Get a socket option.  See the Unix manual for level and option.&#10;If a nonzero buffersize argument is given, the return value is a&#10;string of that length; otherwise it is an integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.gettimeout" func="yes">
			<Overload retVal="" descr="gettimeout() -&gt; timeout&#10;&#10;Returns the timeout in seconds (float) associated with socket &#10;operations. A timeout of None indicates that timeouts on socket &#10;operations are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.ioctl" func="yes">
			<Overload retVal="" descr="ioctl(cmd, option) -&gt; long&#10;&#10;Control the socket with WSAIoctl syscall. Currently supported 'cmd' values are&#10;SIO_RCVALL:  'option' must be one of the socket.RCVALL_* constants.&#10;SIO_KEEPALIVE_VALS:  'option' is a tuple of (onoff, timeout, interval).&#10;SIO_LOOPBACK_FAST_PATH: 'option' is a boolean value, and is disabled by default">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.listen" func="yes">
			<Overload retVal="" descr="listen([backlog])&#10;&#10;Enable a server to accept connections.  If backlog is specified, it must be&#10;at least 0 (if it is lower, it is set to 0); it specifies the number of&#10;unaccepted connections that the system will allow before refusing new&#10;connections. If not specified, a default reasonable value is chosen.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.makefile" func="yes">
			<Overload retVal="" descr="makefile(...) -&gt; an I/O stream connected to the socket&#10;&#10;The arguments are as for io.open() after the filename, except the only&#10;supported mode values are 'r' (default), 'w' and 'b'.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.proto" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recv" func="yes">
			<Overload retVal="" descr="recv(buffersize[, flags]) -&gt; data&#10;&#10;Receive up to buffersize bytes from the socket.  For the optional flags&#10;argument, see the Unix manual.  When no data is available, block until&#10;at least one byte is available or until the remote end is closed.  When&#10;the remote end is closed and all data is read, return the empty string.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recv_into" func="yes">
			<Overload retVal="" descr="recv_into(buffer, [nbytes[, flags]]) -&gt; nbytes_read&#10;&#10;A version of recv() that stores its data into a buffer rather than creating &#10;a new string.  Receive up to buffersize bytes from the socket.  If buffersize &#10;is not specified (or 0), receive up to the size available in the given buffer.&#10;&#10;See recv() for documentation about the flags.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recvfrom" func="yes">
			<Overload retVal="" descr="recvfrom(buffersize[, flags]) -&gt; (data, address info)&#10;&#10;Like recv(buffersize, flags) but also return the sender's address info.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.recvfrom_into" func="yes">
			<Overload retVal="" descr="recvfrom_into(buffer[, nbytes[, flags]]) -&gt; (nbytes, address info)&#10;&#10;Like recv_into(buffer[, nbytes[, flags]]) but also return the sender's address info.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.send" func="yes">
			<Overload retVal="" descr="send(data[, flags]) -&gt; count&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  Return the number of bytes&#10;sent; this may be less than len(data) if the network is busy.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.sendall" func="yes">
			<Overload retVal="" descr="sendall(data[, flags])&#10;&#10;Send a data string to the socket.  For the optional flags&#10;argument, see the Unix manual.  This calls send() repeatedly&#10;until all data is sent.  If an error occurs, it's impossible&#10;to tell how much data has been sent.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.sendfile" func="yes">
			<Overload retVal="" descr="sendfile(file[, offset[, count]]) -&gt; sent&#10;&#10;Send a file until EOF is reached by using high-performance&#10;os.sendfile() and return the total number of bytes which&#10;were sent.&#10;*file* must be a regular file object opened in binary mode.&#10;If os.sendfile() is not available (e.g. Windows) or file is&#10;not a regular file socket.send() will be used instead.&#10;*offset* tells from where to start reading the file.&#10;If specified, *count* is the total number of bytes to transmit&#10;as opposed to sending the file until EOF is reached.&#10;File position is updated on return or also in case of error in&#10;which case file.tell() can be used to figure out the number of&#10;bytes which were sent.&#10;The socket must be of SOCK_STREAM type.&#10;Non-blocking sockets are not supported.">
				<Param name="self" />
				<Param name="file" />
				<Param name="[offset=0" />
				<Param name="[count=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.sendto" func="yes">
			<Overload retVal="" descr="sendto(data[, flags], address) -&gt; count&#10;&#10;Like send(data, flags) but allows specifying the destination address.&#10;For IP sockets, the address is a pair (hostaddr, port).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.set_inheritable" func="yes">
			<Overload retVal="" descr="Set the inheritable flag of the socket">
				<Param name="self" />
				<Param name="inheritable" />
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.setblocking" func="yes">
			<Overload retVal="" descr="setblocking(flag)&#10;&#10;Set the socket to blocking (flag is true) or non-blocking (false).&#10;setblocking(True) is equivalent to settimeout(None);&#10;setblocking(False) is equivalent to settimeout(0.0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.setsockopt" func="yes">
			<Overload retVal="" descr="setsockopt(level, option, value: int)&#10;setsockopt(level, option, value: buffer)&#10;setsockopt(level, option, None, optlen: int)&#10;&#10;Set a socket option.  See the Unix manual for level and option.&#10;The value argument can either be an integer, a string buffer, or &#10;None, optlen.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.settimeout" func="yes">
			<Overload retVal="" descr="settimeout(timeout)&#10;&#10;Set a timeout on socket operations.  'timeout' can be a float,&#10;giving in seconds, or None.  Setting a timeout of None disables&#10;the timeout feature and is equivalent to setblocking(1).&#10;Setting a timeout of zero is the same as setblocking(0).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.share" func="yes">
			<Overload retVal="" descr="share(process_id) -&gt; bytes&#10;&#10;Share the socket with another process.  The target process id&#10;must be provided and the resulting bytes object passed to the target&#10;process.  There the shared socket can be instantiated by calling&#10;socket.fromshare().">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.shutdown" func="yes">
			<Overload retVal="" descr="shutdown(flag)&#10;&#10;Shut down the reading side of the socket (flag == SHUT_RD), the writing side&#10;of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.timeout" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error" func="yes">
			<Overload retVal="" descr="Base class for I/O related errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.characters_written" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.errno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.filename2" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.strerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.winerror" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.socket_error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="ssl.wrap_socket" func="yes">
			<Overload retVal="" descr=>
				<Param name="sock" />
				<Param name="[keyfile=None" />
				<Param name="[certfile=None" />
				<Param name="[server_side=False" />
				<Param name="[cert_reqs=VerifyMode.CERT_NONE" />
				<Param name="[ssl_version=_SSLMethod.PROTOCOL_TLS" />
				<Param name="[ca_certs=None" />
				<Param name="[do_handshake_on_connect=True" />
				<Param name="[suppress_ragged_eofs=True" />
				<Param name="[ciphers=None]]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="stack" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="stack_effect" func="yes">
			<Overload retVal="" descr="Function of dis">
			</Overload>
		</KeyWord>
		<KeyWord name="stack_size" func="yes">
			<Overload retVal="" descr="Function of dummy_threading">
			</Overload>
		</KeyWord>
		<KeyWord name="standard_b64decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="standard_b64encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="start" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="startTest" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="startTestRun" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="start_component" func="yes">
			<Overload retVal="" descr="Function of msilib.Directory">
			</Overload>
		</KeyWord>
		<KeyWord name="start_section" func="yes">
			<Overload retVal="" descr="Function of argparse.ArgumentDefaultsHelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="start_server" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="start_serving_pipe" func="yes">
			<Overload retVal="" descr="Function of asyncio.ProactorEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="startfile" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="starttls" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="stat" func="yes">
			<Overload retVal="" descr="Constants/functions for interpreting results of os.stat() and os.lstat().&#10;&#10;Suggested usage: from stat import *">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_ARCHIVE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_COMPRESSED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_DEVICE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_DIRECTORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_ENCRYPTED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_HIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_INTEGRITY_STREAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_NORMAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_NO_SCRUB_DATA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_OFFLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_READONLY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_REPARSE_POINT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_SPARSE_FILE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_SYSTEM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_TEMPORARY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.FILE_ATTRIBUTE_VIRTUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_ARCHIVED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.SF_SNAPSHOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_ATIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_CTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_DEV" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_GID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_INO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_MTIME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_NLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.ST_UID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ENFMT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IEXEC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFBLK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFCHR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFDIR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFIFO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFLNK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFMT" func="yes">
			<Overload retVal="" descr="Return the portion of the file's mode that describes the file type.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFREG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IFSOCK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IMODE" func="yes">
			<Overload retVal="" descr="Return the portion of the file's mode that can be set by os.chmod().">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IREAD" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IROTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRWXG" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRWXO" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IRWXU" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISBLK" func="yes">
			<Overload retVal="" descr="S_ISBLK(mode) -&gt; bool&#10;&#10;Return True if mode is from a block special device file.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISCHR" func="yes">
			<Overload retVal="" descr="S_ISCHR(mode) -&gt; bool&#10;&#10;Return True if mode is from a character special device file.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISDIR" func="yes">
			<Overload retVal="" descr="S_ISDIR(mode) -&gt; bool&#10;&#10;Return True if mode is from a directory.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISDOOR" func="yes">
			<Overload retVal="" descr="S_ISDOOR(mode) -&gt; bool&#10;&#10;Return True if mode is from a door.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISFIFO" func="yes">
			<Overload retVal="" descr="S_ISFIFO(mode) -&gt; bool&#10;&#10;Return True if mode is from a FIFO (named pipe).">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISGID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISLNK" func="yes">
			<Overload retVal="" descr="S_ISLNK(mode) -&gt; bool&#10;&#10;Return True if mode is from a symbolic link.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISPORT" func="yes">
			<Overload retVal="" descr="S_ISPORT(mode) -&gt; bool&#10;&#10;Return True if mode is from an event port.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISREG" func="yes">
			<Overload retVal="" descr="S_ISREG(mode) -&gt; bool&#10;&#10;Return True if mode is from a regular file.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISSOCK" func="yes">
			<Overload retVal="" descr="S_ISSOCK(mode) -&gt; bool&#10;&#10;Return True if mode is from a socket.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISUID" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISVTX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_ISWHT" func="yes">
			<Overload retVal="" descr="S_ISWHT(mode) -&gt; bool&#10;&#10;Return True if mode is from a whiteout.">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWRITE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IWUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IXGRP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IXOTH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.S_IXUSR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_APPEND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_COMPRESSED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_HIDDEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_IMMUTABLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_NODUMP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_NOUNLINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.UF_OPAQUE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="stat.filemode" func="yes">
			<Overload retVal="" descr="Convert a file's mode to a string of the form '-rwxrwxrwx'">
			</Overload>
		</KeyWord>
		<KeyWord name="stat_float_times" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="stat_result" func="yes">
			<Overload retVal="" descr="Function of os.stat_result">
			</Overload>
		</KeyWord>
		<KeyWord name="staticmethod" func="yes">
			<Overload retVal="" descr="staticmethod(function) -&gt; method&#10;&#10;Convert a function to be a static method.&#10;&#10;A static method does not receive an implicit first argument.&#10;To declare a static method, use this idiom:&#10;&#10;     class C:&#10;         @staticmethod&#10;         def f(arg1, arg2, ...):&#10;             ...&#10;&#10;It can be called either on the class (e.g. C.f()) or on an instance&#10;(e.g. C().f()).  The instance is ignored except for its class.&#10;&#10;Static methods in Python are similar to those found in Java or C++.&#10;For a more advanced concept, see the classmethod builtin.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics" func="yes">
			<Overload retVal="" descr='Basic statistics module.&#10;&#10;This module provides functions for calculating statistics of data, including&#10;averages, variance, and standard deviation.&#10;&#10;Calculating averages&#10;--------------------&#10;&#10;==================  =============================================&#10;Function            Description&#10;==================  =============================================&#10;mean                Arithmetic mean (average) of data.&#10;harmonic_mean       Harmonic mean of data.&#10;median              Median (middle value) of data.&#10;median_low          Low median of data.&#10;median_high         High median of data.&#10;median_grouped      Median, or 50th percentile, of grouped data.&#10;mode                Mode (most common value) of data.&#10;==================  =============================================&#10;&#10;Calculate the arithmetic mean ("the average") of data:&#10;&#10;&gt;&gt;&gt; mean([-1.0, 2.5, 3.25, 5.75])&#10;2.625&#10;&#10;&#10;Calculate the standard median of discrete data:&#10;&#10;&gt;&gt;&gt; median([2, 3, 4, 5])&#10;3.5&#10;&#10;&#10;Calculate the median, or 50th percentile, of data grouped into class intervals&#10;centred on the data values provided. E.g. if your data points are rounded to&#10;the nearest whole number:&#10;&#10;&gt;&gt;&gt; median_grouped([2, 2, 3, 3, 3, 4])  #doctest: +ELLIPSIS&#10;2.8333333333...&#10;&#10;This should be interpreted in this way: you have two data points in the class&#10;interval 1.5-2.5, three data points in the class interval 2.5-3.5, and one in&#10;the class interval 3.5-4.5. The median of these data points is 2.8333...&#10;&#10;&#10;Calculating variability or spread&#10;---------------------------------&#10;&#10;==================  =============================================&#10;Function            Description&#10;==================  =============================================&#10;pvariance           Population variance of data.&#10;variance            Sample variance of data.&#10;pstdev              Population standard deviation of data.&#10;stdev               Sample standard deviation of data.&#10;==================  =============================================&#10;&#10;Calculate the standard deviation of sample data:&#10;&#10;&gt;&gt;&gt; stdev([2.5, 3.25, 5.5, 11.25, 11.75])  #doctest: +ELLIPSIS&#10;4.38961843444...&#10;&#10;If you have previously calculated the mean, you can pass it as the optional&#10;second argument to the four "spread" functions to avoid recalculating it:&#10;&#10;&gt;&gt;&gt; data = [1, 2, 2, 4, 4, 4, 5, 6]&#10;&gt;&gt;&gt; mu = mean(data)&#10;&gt;&gt;&gt; pvariance(data, mu)&#10;2.5&#10;&#10;&#10;Exceptions&#10;----------&#10;&#10;A single exception is defined: StatisticsError is a subclass of ValueError.'>
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal" func="yes">
			<Overload retVal="" descr="Construct a new Decimal object. 'value' can be an integer, string, tuple,&#10;or another Decimal object. If no value is given, return Decimal('0'). The&#10;context does not affect the conversion and is only passed to determine if&#10;the InvalidOperation trap is active.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.adjusted" func="yes">
			<Overload retVal="" descr="Return the adjusted exponent of the number.  Defined as exp + digits - 1.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.as_integer_ratio" func="yes">
			<Overload retVal="" descr="Decimal.as_integer_ratio() -&gt; (int, int)&#10;&#10;Return a pair of integers, whose ratio is exactly equal to the original&#10;Decimal and with a positive denominator. The ratio is in lowest terms.&#10;Raise OverflowError on infinities and a ValueError on NaNs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.as_tuple" func="yes">
			<Overload retVal="" descr="Return a tuple representation of the number.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.canonical" func="yes">
			<Overload retVal="" descr="Return the canonical encoding of the argument.  Currently, the encoding&#10;of a Decimal instance is always canonical, so this operation returns its&#10;argument unchanged.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.compare" func="yes">
			<Overload retVal="" descr="Compare self to other.  Return a decimal value:&#10;&#10;a or b is a NaN ==&gt; Decimal('NaN')&#10;a &lt; b           ==&gt; Decimal('-1')&#10;a == b          ==&gt; Decimal('0')&#10;a &gt; b           ==&gt; Decimal('1')">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.compare_signal" func="yes">
			<Overload retVal="" descr="Identical to compare, except that all NaNs signal.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.compare_total" func="yes">
			<Overload retVal="" descr="Compare two operands using their abstract representation rather than&#10;their numerical value.  Similar to the compare() method, but the result&#10;gives a total ordering on Decimal instances.  Two Decimal instances with&#10;the same numeric value but different representations compare unequal&#10;in this ordering:&#10;&#10;    &gt;&gt;&gt; Decimal('12.0').compare_total(Decimal('12'))&#10;    Decimal('-1')&#10;&#10;Quiet and signaling NaNs are also included in the total ordering. The result&#10;of this function is Decimal('0') if both operands have the same representation,&#10;Decimal('-1') if the first operand is lower in the total order than the second,&#10;and Decimal('1') if the first operand is higher in the total order than the&#10;second operand. See the specification for details of the total order.&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.compare_total_mag" func="yes">
			<Overload retVal="" descr="Compare two operands using their abstract representation rather than their&#10;value as in compare_total(), but ignoring the sign of each operand.&#10;&#10;x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()).&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.conjugate" func="yes">
			<Overload retVal="" descr="Return self.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.copy_abs" func="yes">
			<Overload retVal="" descr="Return the absolute value of the argument.  This operation is unaffected by&#10;context and is quiet: no flags are changed and no rounding is performed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.copy_negate" func="yes">
			<Overload retVal="" descr="Return the negation of the argument.  This operation is unaffected by context&#10;and is quiet: no flags are changed and no rounding is performed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.copy_sign" func="yes">
			<Overload retVal="" descr="Return a copy of the first operand with the sign set to be the same as the&#10;sign of the second operand. For example:&#10;&#10;    &gt;&gt;&gt; Decimal('2.3').copy_sign(Decimal('-1.5'))&#10;    Decimal('-2.3')&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.exp" func="yes">
			<Overload retVal="" descr="Return the value of the (natural) exponential function e**x at the given&#10;number.  The function always uses the ROUND_HALF_EVEN mode and the result&#10;is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.fma" func="yes">
			<Overload retVal="" descr="Fused multiply-add.  Return self*other+third with no rounding of the&#10;intermediate product self*other.&#10;&#10;    &gt;&gt;&gt; Decimal(2).fma(3, 5)&#10;    Decimal('11')">
				<Param name="self" />
				<Param name="other" />
				<Param name="third" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.from_float" func="yes">
			<Overload retVal="" descr="Class method that converts a float to a decimal number, exactly.&#10;Since 0.1 is not exactly representable in binary floating point,&#10;Decimal.from_float(0.1) is not the same as Decimal('0.1').&#10;&#10;    &gt;&gt;&gt; Decimal.from_float(0.1)&#10;    Decimal('0.1000000000000000055511151231257827021181583404541015625')&#10;    &gt;&gt;&gt; Decimal.from_float(float('nan'))&#10;    Decimal('NaN')&#10;    &gt;&gt;&gt; Decimal.from_float(float('inf'))&#10;    Decimal('Infinity')&#10;    &gt;&gt;&gt; Decimal.from_float(float('-inf'))&#10;    Decimal('-Infinity')">
				<Param name="type" />
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_canonical" func="yes">
			<Overload retVal="" descr="Return True if the argument is canonical and False otherwise.  Currently,&#10;a Decimal instance is always canonical, so this operation always returns&#10;True.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_finite" func="yes">
			<Overload retVal="" descr="Return True if the argument is a finite number, and False if the argument&#10;is infinite or a NaN.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_infinite" func="yes">
			<Overload retVal="" descr="Return True if the argument is either positive or negative infinity and&#10;False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_nan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a (quiet or signaling) NaN and False&#10;otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_normal" func="yes">
			<Overload retVal="" descr="Return True if the argument is a normal finite non-zero number with an&#10;adjusted exponent greater than or equal to Emin. Return False if the&#10;argument is zero, subnormal, infinite or a NaN.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_qnan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a quiet NaN, and False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_signed" func="yes">
			<Overload retVal="" descr="Return True if the argument has a negative sign and False otherwise.&#10;Note that both zeros and NaNs can carry signs.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_snan" func="yes">
			<Overload retVal="" descr="Return True if the argument is a signaling NaN and False otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_subnormal" func="yes">
			<Overload retVal="" descr="Return True if the argument is subnormal, and False otherwise. A number is&#10;subnormal if it is non-zero, finite, and has an adjusted exponent less&#10;than Emin.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.is_zero" func="yes">
			<Overload retVal="" descr="Return True if the argument is a (positive or negative) zero and False&#10;otherwise.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.ln" func="yes">
			<Overload retVal="" descr="Return the natural (base e) logarithm of the operand. The function always&#10;uses the ROUND_HALF_EVEN mode and the result is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.log10" func="yes">
			<Overload retVal="" descr="Return the base ten logarithm of the operand. The function always uses the&#10;ROUND_HALF_EVEN mode and the result is correctly rounded.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.logb" func="yes">
			<Overload retVal="" descr="For a non-zero number, return the adjusted exponent of the operand as a&#10;Decimal instance.  If the operand is a zero, then Decimal('-Infinity') is&#10;returned and the DivisionByZero condition is raised. If the operand is&#10;an infinity then Decimal('Infinity') is returned.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.logical_and" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'and' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.logical_invert" func="yes">
			<Overload retVal="" descr="Return the digit-wise inversion of the (logical) operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.logical_or" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'or' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.logical_xor" func="yes">
			<Overload retVal="" descr="Return the digit-wise 'exclusive or' of the two (logical) operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.max" func="yes">
			<Overload retVal="" descr="Maximum of self and other.  If one operand is a quiet NaN and the other is&#10;numeric, the numeric operand is returned.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.max_mag" func="yes">
			<Overload retVal="" descr="Similar to the max() method, but the comparison is done using the absolute&#10;values of the operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.min" func="yes">
			<Overload retVal="" descr="Minimum of self and other. If one operand is a quiet NaN and the other is&#10;numeric, the numeric operand is returned.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.min_mag" func="yes">
			<Overload retVal="" descr="Similar to the min() method, but the comparison is done using the absolute&#10;values of the operands.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.next_minus" func="yes">
			<Overload retVal="" descr="Return the largest number representable in the given context (or in the&#10;current default context if no context is given) that is smaller than the&#10;given operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.next_plus" func="yes">
			<Overload retVal="" descr="Return the smallest number representable in the given context (or in the&#10;current default context if no context is given) that is larger than the&#10;given operand.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.next_toward" func="yes">
			<Overload retVal="" descr="If the two operands are unequal, return the number closest to the first&#10;operand in the direction of the second operand.  If both operands are&#10;numerically equal, return a copy of the first operand with the sign set&#10;to be the same as the sign of the second operand.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.normalize" func="yes">
			<Overload retVal="" descr="Normalize the number by stripping the rightmost trailing zeros and&#10;converting any result equal to Decimal('0') to Decimal('0e0').  Used&#10;for producing canonical values for members of an equivalence class.&#10;For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize&#10;to the equivalent value Decimal('32.1').">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.number_class" func="yes">
			<Overload retVal="" descr="Return a string describing the class of the operand.  The returned value&#10;is one of the following ten strings:&#10;&#10;    * '-Infinity', indicating that the operand is negative infinity.&#10;    * '-Normal', indicating that the operand is a negative normal number.&#10;    * '-Subnormal', indicating that the operand is negative and subnormal.&#10;    * '-Zero', indicating that the operand is a negative zero.&#10;    * '+Zero', indicating that the operand is a positive zero.&#10;    * '+Subnormal', indicating that the operand is positive and subnormal.&#10;    * '+Normal', indicating that the operand is a positive normal number.&#10;    * '+Infinity', indicating that the operand is positive infinity.&#10;    * 'NaN', indicating that the operand is a quiet NaN (Not a Number).&#10;    * 'sNaN', indicating that the operand is a signaling NaN.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.quantize" func="yes">
			<Overload retVal="" descr="Return a value equal to the first operand after rounding and having the&#10;exponent of the second operand.&#10;&#10;    &gt;&gt;&gt; Decimal('1.41421356').quantize(Decimal('1.000'))&#10;    Decimal('1.414')&#10;&#10;Unlike other operations, if the length of the coefficient after the quantize&#10;operation would be greater than precision, then an InvalidOperation is signaled.&#10;This guarantees that, unless there is an error condition, the quantized exponent&#10;is always equal to that of the right-hand operand.&#10;&#10;Also unlike other operations, quantize never signals Underflow, even if the&#10;result is subnormal and inexact.&#10;&#10;If the exponent of the second operand is larger than that of the first, then&#10;rounding may be necessary. In this case, the rounding mode is determined by the&#10;rounding argument if given, else by the given context argument; if neither&#10;argument is given, the rounding mode of the current thread's context is used.">
				<Param name="self" />
				<Param name="exp" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.radix" func="yes">
			<Overload retVal="" descr="Return Decimal(10), the radix (base) in which the Decimal class does&#10;all its arithmetic. Included for compatibility with the specification.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.remainder_near" func="yes">
			<Overload retVal="" descr="Return the remainder from dividing self by other.  This differs from&#10;self % other in that the sign of the remainder is chosen so as to minimize&#10;its absolute value. More precisely, the return value is self - n * other&#10;where n is the integer nearest to the exact value of self / other, and&#10;if two integers are equally near then the even one is chosen.&#10;&#10;If the result is zero then its sign will be the sign of self.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.rotate" func="yes">
			<Overload retVal="" descr="Return the result of rotating the digits of the first operand by an amount&#10;specified by the second operand.  The second operand must be an integer in&#10;the range -precision through precision. The absolute value of the second&#10;operand gives the number of places to rotate. If the second operand is&#10;positive then rotation is to the left; otherwise rotation is to the right.&#10;The coefficient of the first operand is padded on the left with zeros to&#10;length precision if necessary. The sign and exponent of the first operand are&#10;unchanged.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.same_quantum" func="yes">
			<Overload retVal="" descr="Test whether self and other have the same exponent or whether both are NaN.&#10;&#10;This operation is unaffected by context and is quiet: no flags are changed&#10;and no rounding is performed. As an exception, the C version may raise&#10;InvalidOperation if the second operand cannot be converted exactly.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.scaleb" func="yes">
			<Overload retVal="" descr="Return the first operand with the exponent adjusted the second.  Equivalently,&#10;return the first operand multiplied by 10**other. The second operand must be&#10;an integer.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.shift" func="yes">
			<Overload retVal="" descr="Return the result of shifting the digits of the first operand by an amount&#10;specified by the second operand.  The second operand must be an integer in&#10;the range -precision through precision. The absolute value of the second&#10;operand gives the number of places to shift. If the second operand is&#10;positive, then the shift is to the left; otherwise the shift is to the&#10;right. Digits shifted into the coefficient are zeros. The sign and exponent&#10;of the first operand are unchanged.">
				<Param name="self" />
				<Param name="other" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.sqrt" func="yes">
			<Overload retVal="" descr="Return the square root of the argument to full precision. The result is&#10;correctly rounded using the ROUND_HALF_EVEN rounding mode.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.to_eng_string" func="yes">
			<Overload retVal="" descr="Convert to an engineering-type string.  Engineering notation has an exponent&#10;which is a multiple of 3, so there are up to 3 digits left of the decimal&#10;place. For example, Decimal('123E+1') is converted to Decimal('1.23E+3').&#10;&#10;The value of context.capitals determines whether the exponent sign is lower&#10;or upper case. Otherwise, the context does not affect the operation.">
				<Param name="self" />
				<Param name="[context=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.to_integral" func="yes">
			<Overload retVal="" descr="Identical to the to_integral_value() method.  The to_integral() name has been&#10;kept for compatibility with older versions.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.to_integral_exact" func="yes">
			<Overload retVal="" descr="Round to the nearest integer, signaling Inexact or Rounded as appropriate if&#10;rounding occurs.  The rounding mode is determined by the rounding parameter&#10;if given, else by the given context. If neither parameter is given, then the&#10;rounding mode of the current default context is used.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Decimal.to_integral_value" func="yes">
			<Overload retVal="" descr="Round to the nearest integer without signaling Inexact or Rounded.  The&#10;rounding mode is determined by the rounding parameter if given, else by&#10;the given context. If neither parameter is given, then the rounding mode&#10;of the current default context is used.">
				<Param name="self" />
				<Param name="[rounding=None" />
				<Param name="[context=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.Fraction" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.StatisticsError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.StatisticsError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.StatisticsError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.bisect_left" func="yes">
			<Overload retVal="" descr="bisect_left(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt; x, and all e in&#10;a[i:] have e &gt;= x.  So if x already appears in the list, i points just&#10;before the leftmost x already there.&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.bisect_right" func="yes">
			<Overload retVal="" descr="bisect_right(a, x[, lo[, hi]]) -&gt; index&#10;&#10;Return the index where to insert item x in list a, assuming a is sorted.&#10;&#10;The return value i is such that all e in a[:i] have e &lt;= x, and all e in&#10;a[i:] have e &gt; x.  So if x already appears in the list, i points just&#10;beyond the rightmost x already there&#10;&#10;Optional args lo (default 0) and hi (default len(a)) bound the&#10;slice of a to be searched.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.chain" func="yes">
			<Overload retVal="" descr="chain(*iterables) --&gt; chain object&#10;&#10;Return a chain object whose .__next__() method returns elements from the&#10;first iterable until it is exhausted, then elements from the next&#10;iterable, until all of the iterables are exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.chain.from_iterable" func="yes">
			<Overload retVal="" descr="chain.from_iterable(iterable) --&gt; chain object&#10;&#10;Alternate chain() constructor taking a single iterable argument&#10;that evaluates lazily.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.groupby" func="yes">
			<Overload retVal="" descr="groupby(iterable, key=None) -&gt; make an iterator that returns consecutive&#10;keys and groups from the iterable.  If the key function is not specified or&#10;is None, the element itself is used for grouping.">
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.harmonic_mean" func="yes">
			<Overload retVal="" descr="Return the harmonic mean of data.&#10;&#10;The harmonic mean, sometimes called the subcontrary mean, is the&#10;reciprocal of the arithmetic mean of the reciprocals of the data,&#10;and is often appropriate when averaging quantities which are rates&#10;or ratios, for example speeds. Example:&#10;&#10;Suppose an investor purchases an equal value of shares in each of&#10;three companies, with P/E (price/earning) ratios of 2.5, 3 and 10.&#10;What is the average P/E ratio for the investor's portfolio?&#10;&#10;&gt;&gt;&gt; harmonic_mean([2.5, 3, 10])  # For an equal investment portfolio.&#10;3.6&#10;&#10;Using the arithmetic mean would give an average of about 5.167, which&#10;is too high.&#10;&#10;If ``data`` is empty, or any element is less than zero,&#10;``harmonic_mean`` will raise ``StatisticsError``.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.mean" func="yes">
			<Overload retVal="" descr="Return the sample arithmetic mean of data.&#10;&#10;&gt;&gt;&gt; mean([1, 2, 3, 4, 4])&#10;2.8&#10;&#10;&gt;&gt;&gt; from fractions import Fraction as F&#10;&gt;&gt;&gt; mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])&#10;Fraction(13, 21)&#10;&#10;&gt;&gt;&gt; from decimal import Decimal as D&#10;&gt;&gt;&gt; mean([D(&quot;0.5&quot;), D(&quot;0.75&quot;), D(&quot;0.625&quot;), D(&quot;0.375&quot;)])&#10;Decimal('0.5625')&#10;&#10;If ``data`` is empty, StatisticsError will be raised.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.median" func="yes">
			<Overload retVal="" descr="Return the median (middle value) of numeric data.&#10;&#10;When the number of data points is odd, return the middle data point.&#10;When the number of data points is even, the median is interpolated by&#10;taking the average of the two middle values:&#10;&#10;&gt;&gt;&gt; median([1, 3, 5])&#10;3&#10;&gt;&gt;&gt; median([1, 3, 5, 7])&#10;4.0">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.median_grouped" func="yes">
			<Overload retVal="" descr="Return the 50th percentile (median) of grouped continuous data.&#10;&#10;&gt;&gt;&gt; median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])&#10;3.7&#10;&gt;&gt;&gt; median_grouped([52, 52, 53, 54])&#10;52.5&#10;&#10;This calculates the median as the 50th percentile, and should be&#10;used when your data is continuous and grouped. In the above example,&#10;the values 1, 2, 3, etc. actually represent the midpoint of classes&#10;0.5-1.5, 1.5-2.5, 2.5-3.5, etc. The middle value falls somewhere in&#10;class 3.5-4.5, and interpolation is used to estimate it.&#10;&#10;Optional argument ``interval`` represents the class interval, and&#10;defaults to 1. Changing the class interval naturally will change the&#10;interpolated 50th percentile value:&#10;&#10;&gt;&gt;&gt; median_grouped([1, 3, 3, 5, 7], interval=1)&#10;3.25&#10;&gt;&gt;&gt; median_grouped([1, 3, 3, 5, 7], interval=2)&#10;3.5&#10;&#10;This function does not check whether the data points are at least&#10;``interval`` apart.">
				<Param name="data" />
				<Param name="[interval=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.median_high" func="yes">
			<Overload retVal="" descr="Return the high median of data.&#10;&#10;When the number of data points is odd, the middle value is returned.&#10;When it is even, the larger of the two middle values is returned.&#10;&#10;&gt;&gt;&gt; median_high([1, 3, 5])&#10;3&#10;&gt;&gt;&gt; median_high([1, 3, 5, 7])&#10;5">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.median_low" func="yes">
			<Overload retVal="" descr="Return the low median of numeric data.&#10;&#10;When the number of data points is odd, the middle value is returned.&#10;When it is even, the smaller of the two middle values is returned.&#10;&#10;&gt;&gt;&gt; median_low([1, 3, 5])&#10;3&#10;&gt;&gt;&gt; median_low([1, 3, 5, 7])&#10;3">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.mode" func="yes">
			<Overload retVal="" descr="Return the most common data point from discrete or nominal data.&#10;&#10;``mode`` assumes discrete data, and returns a single value. This is the&#10;standard treatment of the mode as commonly taught in schools:&#10;&#10;&gt;&gt;&gt; mode([1, 1, 2, 3, 3, 3, 3, 4])&#10;3&#10;&#10;This also works with nominal (non-numeric) data:&#10;&#10;&gt;&gt;&gt; mode([&quot;red&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;red&quot;, &quot;red&quot;])&#10;'red'&#10;&#10;If there is not exactly one most common value, ``mode`` will raise&#10;StatisticsError.">
				<Param name="data" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.pstdev" func="yes">
			<Overload retVal="" descr="Return the square root of the population variance.&#10;&#10;See ``pvariance`` for arguments and other details.&#10;&#10;&gt;&gt;&gt; pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])&#10;0.986893273527251">
				<Param name="data" />
				<Param name="[mu=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.pvariance" func="yes">
			<Overload retVal="" descr="Return the population variance of ``data``.&#10;&#10;data should be an iterable of Real-valued numbers, with at least one&#10;value. The optional argument mu, if given, should be the mean of&#10;the data. If it is missing or None, the mean is automatically calculated.&#10;&#10;Use this function to calculate the variance from the entire population.&#10;To estimate the variance from a sample, the ``variance`` function is&#10;usually a better choice.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]&#10;&gt;&gt;&gt; pvariance(data)&#10;1.25&#10;&#10;If you have already calculated the mean of the data, you can pass it as&#10;the optional second argument to avoid recalculating it:&#10;&#10;&gt;&gt;&gt; mu = mean(data)&#10;&gt;&gt;&gt; pvariance(data, mu)&#10;1.25&#10;&#10;This function does not check that ``mu`` is actually the mean of ``data``.&#10;Giving arbitrary values for ``mu`` may lead to invalid or impossible&#10;results.&#10;&#10;Decimals and Fractions are supported:&#10;&#10;&gt;&gt;&gt; from decimal import Decimal as D&#10;&gt;&gt;&gt; pvariance([D(&quot;27.5&quot;), D(&quot;30.25&quot;), D(&quot;30.25&quot;), D(&quot;34.5&quot;), D(&quot;41.75&quot;)])&#10;Decimal('24.815')&#10;&#10;&gt;&gt;&gt; from fractions import Fraction as F&#10;&gt;&gt;&gt; pvariance([F(1, 4), F(5, 4), F(1, 2)])&#10;Fraction(13, 72)">
				<Param name="data" />
				<Param name="[mu=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.stdev" func="yes">
			<Overload retVal="" descr="Return the square root of the sample variance.&#10;&#10;See ``variance`` for arguments and other details.&#10;&#10;&gt;&gt;&gt; stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])&#10;1.0810874155219827">
				<Param name="data" />
				<Param name="[xbar=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="statistics.variance" func="yes">
			<Overload retVal="" descr="Return the sample variance of data.&#10;&#10;data should be an iterable of Real-valued numbers, with at least two&#10;values. The optional argument xbar, if given, should be the mean of&#10;the data. If it is missing or None, the mean is automatically calculated.&#10;&#10;Use this function when your data is a sample from a population. To&#10;calculate the variance from the entire population, see ``pvariance``.&#10;&#10;Examples:&#10;&#10;&gt;&gt;&gt; data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]&#10;&gt;&gt;&gt; variance(data)&#10;1.3720238095238095&#10;&#10;If you have already calculated the mean of your data, you can pass it as&#10;the optional second argument ``xbar`` to avoid recalculating it:&#10;&#10;&gt;&gt;&gt; m = mean(data)&#10;&gt;&gt;&gt; variance(data, m)&#10;1.3720238095238095&#10;&#10;This function does not check that ``xbar`` is actually the mean of&#10;``data``. Giving arbitrary values for ``xbar`` may lead to invalid or&#10;impossible results.&#10;&#10;Decimals and Fractions are supported:&#10;&#10;&gt;&gt;&gt; from decimal import Decimal as D&#10;&gt;&gt;&gt; variance([D(&quot;27.5&quot;), D(&quot;30.25&quot;), D(&quot;30.25&quot;), D(&quot;34.5&quot;), D(&quot;41.75&quot;)])&#10;Decimal('31.01875')&#10;&#10;&gt;&gt;&gt; from fractions import Fraction as F&#10;&gt;&gt;&gt; variance([F(1, 6), F(1, 2), F(5, 3)])&#10;Fraction(67, 108)">
				<Param name="data" />
				<Param name="[xbar=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="status" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="statvfs_result" func="yes">
			<Overload retVal="" descr="Function of os.statvfs_result">
			</Overload>
		</KeyWord>
		<KeyWord name="stdev" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="stls" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="stn" func="yes">
			<Overload retVal="" descr="Function of tarfile">
			</Overload>
		</KeyWord>
		<KeyWord name="stop" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="stopTest" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="stopTestRun" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="stop_here" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="storbinary" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="store" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="store_option_strings" func="yes">
			<Overload retVal="" descr="Function of optparse.HelpFormatter">
			</Overload>
		</KeyWord>
		<KeyWord name="storlines" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="str" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; str&#10;str(bytes_or_buffer[, encoding[, errors]]) -&gt; str&#10;&#10;Create a new string object from the given object. If encoding or&#10;errors is specified, then the object must expose a data buffer&#10;that will be decoded using the given encoding and error handler.&#10;Otherwise, returns the result of object.__str__() (if defined)&#10;or repr(object).&#10;encoding defaults to sys.getdefaultencoding().&#10;errors defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="strcoll" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="strerror" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="strftime" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="strict_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="string" func="yes">
			<Overload retVal="" descr="A collection of string constants.&#10;&#10;Public module variables:&#10;&#10;whitespace -- a string containing all ASCII whitespace&#10;ascii_lowercase -- a string containing all ASCII lowercase letters&#10;ascii_uppercase -- a string containing all ASCII uppercase letters&#10;ascii_letters -- a string containing all ASCII letters&#10;digits -- a string containing all ASCII decimal digits&#10;hexdigits -- a string containing all ASCII hexadecimal digits&#10;octdigits -- a string containing all ASCII octal digits&#10;punctuation -- a string containing all ASCII punctuation characters&#10;printable -- a string containing all ASCII characters considered printable">
			</Overload>
		</KeyWord>
		<KeyWord name="string.Formatter" />
		<KeyWord name="string.Formatter.check_unused_args" />
		<KeyWord name="string.Formatter.convert_field" />
		<KeyWord name="string.Formatter.format" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.Formatter.format_field" />
		<KeyWord name="string.Formatter.get_field" />
		<KeyWord name="string.Formatter.get_value" />
		<KeyWord name="string.Formatter.parse" />
		<KeyWord name="string.Formatter.vformat" />
		<KeyWord name="string.Template" func="yes">
			<Overload retVal="" descr="(_TemplateMetaclass)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ascii_letters" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ascii_lowercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.ascii_uppercase" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.capwords" func="yes">
			<Overload retVal="" descr="capwords(s [,sep]) -&gt; string&#10;&#10;Split the argument into words using split, capitalize each&#10;word using capitalize, and join the capitalized words using&#10;join.  If the optional second argument sep is absent or None,&#10;runs of whitespace characters are replaced by a single space&#10;and leading and trailing whitespace are removed, otherwise&#10;sep is used to split and join the words.">
				<Param name="s" />
				<Param name="[sep=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="string.digits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.hexdigits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.octdigits" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.printable" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.punctuation" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string.whitespace" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="string_at" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep" func="yes">
			<Overload retVal="" descr="Library that exposes various tables found in the StringPrep RFC 3454.&#10;&#10;There are two kinds of tables: sets, for which a member test is provided,&#10;and mappings, for which a mapping function is provided.">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.b1_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.b3_exceptions" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c22_specials" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c6_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c7_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c8_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.c9_set" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="stringprep.in_table_a1" />
		<KeyWord name="stringprep.in_table_b1" />
		<KeyWord name="stringprep.in_table_c11" />
		<KeyWord name="stringprep.in_table_c11_c12" />
		<KeyWord name="stringprep.in_table_c12" />
		<KeyWord name="stringprep.in_table_c21" />
		<KeyWord name="stringprep.in_table_c21_c22" />
		<KeyWord name="stringprep.in_table_c22" />
		<KeyWord name="stringprep.in_table_c3" />
		<KeyWord name="stringprep.in_table_c4" />
		<KeyWord name="stringprep.in_table_c5" />
		<KeyWord name="stringprep.in_table_c6" />
		<KeyWord name="stringprep.in_table_c7" />
		<KeyWord name="stringprep.in_table_c8" />
		<KeyWord name="stringprep.in_table_c9" />
		<KeyWord name="stringprep.in_table_d1" />
		<KeyWord name="stringprep.in_table_d2" />
		<KeyWord name="stringprep.map_table_b2" />
		<KeyWord name="stringprep.map_table_b3" />
		<KeyWord name="stringprep.unicodedata" func="yes">
			<Overload retVal="" descr="(UCD)">
			</Overload>
		</KeyWord>
		<KeyWord name="strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="strip_dirs" func="yes">
			<Overload retVal="" descr="Function of pstats.Stats">
			</Overload>
		</KeyWord>
		<KeyWord name="stripid" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="strong" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="strptime" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="struct" func="yes">
			<Overload retVal="" descr="Functions to convert between Python values and C structs.&#10;Python bytes objects are used to hold the data representing the C struct&#10;and also as format strings (explained below) to describe the layout of data&#10;in the C struct.&#10;&#10;The optional first format char indicates byte order, size and alignment:&#10;  @: native order, size &amp; alignment (default)&#10;  =: native order, std. size &amp; alignment&#10;  &lt;: little-endian, std. size &amp; alignment&#10;  &gt;: big-endian, std. size &amp; alignment&#10;  !: same as &gt;&#10;&#10;The remaining chars indicate types of args and must match exactly;&#10;these can be preceded by a decimal repeat count:&#10;  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;&#10;  ?: _Bool (requires C99; if not available, char is used instead)&#10;  h:short; H:unsigned short; i:int; I:unsigned int;&#10;  l:long; L:unsigned long; f:float; d:double; e:half-float.&#10;Special cases (preceding decimal count indicates length):&#10;  s:string (array of char); p: pascal string (with count byte).&#10;Special cases (only available in native format):&#10;  n:ssize_t; N:size_t;&#10;  P:an integer type that is wide enough to hold a pointer.&#10;Special case (not in native mode unless 'long long' in platform C):&#10;  q:long long; Q:unsigned long long&#10;Whitespace between formats is ignored.&#10;&#10;The variable struct.error is an exception raised on errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct" func="yes">
			<Overload retVal="" descr="Struct(fmt) --&gt; compiled struct object&#10;&#10;Return a new Struct object which writes and reads binary data according to&#10;the format string fmt.  See help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.format" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.iter_unpack" func="yes">
			<Overload retVal="" descr="S.iter_unpack(buffer) -&gt; iterator(v1, v2, ...)&#10;&#10;Return an iterator yielding tuples unpacked from the given bytes&#10;source, like a repeated invocation of unpack_from().  Requires&#10;that the bytes length be a multiple of the struct size.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.pack" func="yes">
			<Overload retVal="" descr="S.pack(v1, v2, ...) -&gt; bytes&#10;&#10;Return a bytes object containing values v1, v2, ... packed according&#10;to the format string S.format.  See help(struct) for more on format&#10;strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.pack_into" func="yes">
			<Overload retVal="" descr="S.pack_into(buffer, offset, v1, v2, ...)&#10;&#10;Pack the values v1, v2, ... according to the format string S.format&#10;and write the packed bytes into the writable buffer buf starting at&#10;offset.  Note that the offset is a required argument.  See&#10;help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.size" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.unpack" func="yes">
			<Overload retVal="" descr="S.unpack(buffer) -&gt; (v1, v2, ...)&#10;&#10;Return a tuple containing values unpacked according to the format&#10;string S.format.  The buffer's size in bytes must be S.size.  See&#10;help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.Struct.unpack_from" func="yes">
			<Overload retVal="" descr="S.unpack_from(buffer, offset=0) -&gt; (v1, v2, ...)&#10;&#10;Return a tuple containing values unpacked according to the format&#10;string S.format.  The buffer's size in bytes, minus offset, must be at&#10;least S.size.  See help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.calcsize" func="yes">
			<Overload retVal="" descr="calcsize(fmt) -&gt; integer&#10;&#10;Return size in bytes of the struct described by the format string fmt.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.iter_unpack" func="yes">
			<Overload retVal="" descr="iter_unpack(fmt, buffer) -&gt; iterator(v1, v2, ...)&#10;&#10;Return an iterator yielding tuples unpacked from the given bytes&#10;source according to the format string, like a repeated invocation of&#10;unpack_from().  Requires that the bytes length be a multiple of the&#10;format struct size.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.pack" func="yes">
			<Overload retVal="" descr="pack(fmt, v1, v2, ...) -&gt; bytes&#10;&#10;Return a bytes object containing the values v1, v2, ... packed according&#10;to the format string fmt.  See help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.pack_into" func="yes">
			<Overload retVal="" descr="pack_into(fmt, buffer, offset, v1, v2, ...)&#10;&#10;Pack the values v1, v2, ... according to the format string fmt and write&#10;the packed bytes into the writable buffer buf starting at offset.  Note&#10;that the offset is a required argument.  See help(struct) for more&#10;on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.unpack" func="yes">
			<Overload retVal="" descr="unpack(fmt, buffer) -&gt; (v1, v2, ...)&#10;&#10;Return a tuple containing values unpacked according to the format string&#10;fmt.  The buffer's size in bytes must be calcsize(fmt). See help(struct)&#10;for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="struct.unpack_from" func="yes">
			<Overload retVal="" descr="unpack_from(fmt, buffer, offset=0) -&gt; (v1, v2, ...)&#10;&#10;Return a tuple containing values unpacked according to the format string&#10;fmt.  The buffer's size, minus offset, must be at least calcsize(fmt).&#10;See help(struct) for more on format strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="strxfrm" func="yes">
			<Overload retVal="" descr="Function of locale">
			</Overload>
		</KeyWord>
		<KeyWord name="sub" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="subTest" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="submit" func="yes">
			<Overload retVal="" descr="Function of compileall.ProcessPoolExecutor">
			</Overload>
		</KeyWord>
		<KeyWord name="subn" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="subnets" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess" func="yes">
			<Overload retVal="" descr="Subprocesses with accessible I/O streams&#10;&#10;This module allows you to spawn processes, connect to their&#10;input/output/error pipes, and obtain their return codes.&#10;&#10;For a complete description of this module see the Python documentation.&#10;&#10;Main API&#10;========&#10;run(...): Runs a command, waits for it to complete, then returns a&#10;          CompletedProcess instance.&#10;Popen(...): A class for flexibly executing a command in a new process&#10;&#10;Constants&#10;---------&#10;DEVNULL: Special value that indicates that os.devnull should be used&#10;PIPE:    Special value that indicates a pipe should be created&#10;STDOUT:  Special value that indicates that stderr should go to stdout&#10;&#10;&#10;Older API&#10;=========&#10;call(...): Runs a command, waits for it to complete, then returns&#10;    the return code.&#10;check_call(...): Same as call() but raises CalledProcessError()&#10;    if return code is not 0&#10;check_output(...): Same as check_call() but returns the contents of&#10;    stdout instead of a return code&#10;getoutput(...): Runs a command in the shell, waits for it to complete,&#10;    then returns the output&#10;getstatusoutput(...): Runs a command in the shell, waits for it to complete,&#10;    then returns a (exitcode, output) tuple">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CREATE_NEW_CONSOLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CREATE_NEW_PROCESS_GROUP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError" func="yes">
			<Overload retVal="" descr="Raised when run() is called with check=True and the process&#10;returns a non-zero exit status.&#10;&#10;Attributes:&#10;  cmd, returncode, stdout, stderr, output">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError.stdout" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CalledProcessError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CompletedProcess" func="yes">
			<Overload retVal="" descr="A process that has finished running.&#10;&#10;This is returned by run().&#10;&#10;Attributes:&#10;  args: The list or str args passed to run().&#10;  returncode: The exit code of the process, negative for signals.&#10;  stdout: The standard output (None if not captured).&#10;  stderr: The standard error (None if not captured).">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.CompletedProcess.check_returncode" func="yes">
			<Overload retVal="" descr="Raise CalledProcessError if the exit code is non-zero.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.DEVNULL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle" func="yes">
			<Overload retVal="" descr="int(x=0) -&gt; integer&#10;int(x, base=10) -&gt; integer&#10;&#10;Convert a number or string to an integer, or return 0 if no arguments&#10;are given.  If x is a number, return x.__int__().  For floating point&#10;numbers, this truncates towards zero.&#10;&#10;If x is not a number or if base is given, then x must be a string,&#10;bytes, or bytearray instance representing an integer literal in the&#10;given base.  The literal can be preceded by '+' or '-' and be surrounded&#10;by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.&#10;Base 0 means to interpret the base from the string as an integer literal.&#10;&gt;&gt;&gt; int('0b100', base=0)&#10;4">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.Close" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[CloseHandle=<built-in function CloseHandle>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.Detach" />
		<KeyWord name="subprocess.Handle.bit_length" func="yes">
			<Overload retVal="" descr="int.bit_length() -&gt; int&#10;&#10;Number of bits necessary to represent self in binary.&#10;&gt;&gt;&gt; bin(37)&#10;'0b100101'&#10;&gt;&gt;&gt; (37).bit_length()&#10;6">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.conjugate" func="yes">
			<Overload retVal="" descr="Returns self, the complex conjugate of any int.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.denominator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.from_bytes" func="yes">
			<Overload retVal="" descr="int.from_bytes(bytes, byteorder, *, signed=False) -&gt; int&#10;&#10;Return the integer represented by the given array of bytes.&#10;&#10;The bytes argument must be a bytes-like object (e.g. bytes or bytearray).&#10;&#10;The byteorder argument determines the byte order used to represent the&#10;integer.  If byteorder is 'big', the most significant byte is at the&#10;beginning of the byte array.  If byteorder is 'little', the most&#10;significant byte is at the end of the byte array.  To request the native&#10;byte order of the host system, use `sys.byteorder' as the byte order value.&#10;&#10;The signed keyword-only argument indicates whether two's complement is&#10;used to represent the integer.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.imag" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.numerator" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.real" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Handle.to_bytes" func="yes">
			<Overload retVal="" descr="int.to_bytes(length, byteorder, *, signed=False) -&gt; bytes&#10;&#10;Return an array of bytes representing an integer.&#10;&#10;The integer is represented using length bytes.  An OverflowError is&#10;raised if the integer is not representable with the given number of&#10;bytes.&#10;&#10;The byteorder argument determines the byte order used to represent the&#10;integer.  If byteorder is 'big', the most significant byte is at the&#10;beginning of the byte array.  If byteorder is 'little', the most&#10;significant byte is at the end of the byte array.  To request the native&#10;byte order of the host system, use `sys.byteorder' as the byte order value.&#10;&#10;The signed keyword-only argument determines whether two's complement is&#10;used to represent the integer.  If signed is False and a negative integer&#10;is given, an OverflowError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.PIPE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen" func="yes">
			<Overload retVal="" descr="Execute a child program in a new process.&#10;&#10;For a complete description of the arguments see the Python documentation.&#10;&#10;Arguments:&#10;  args: A string, or a sequence of program arguments.&#10;&#10;  bufsize: supplied as the buffering argument to the open() function when&#10;      creating the stdin/stdout/stderr pipe file objects&#10;&#10;  executable: A replacement program to execute.&#10;&#10;  stdin, stdout and stderr: These specify the executed programs' standard&#10;      input, standard output and standard error file handles, respectively.&#10;&#10;  preexec_fn: (POSIX only) An object to be called in the child process&#10;      just before the child is executed.&#10;&#10;  close_fds: Controls closing or inheriting of file descriptors.&#10;&#10;  shell: If true, the command will be executed through the shell.&#10;&#10;  cwd: Sets the current directory before the child is executed.&#10;&#10;  env: Defines the environment variables for the new process.&#10;&#10;  universal_newlines: If true, use universal line endings for file&#10;      objects stdin, stdout and stderr.&#10;&#10;  startupinfo and creationflags (Windows only)&#10;&#10;  restore_signals (POSIX only)&#10;&#10;  start_new_session (POSIX only)&#10;&#10;  pass_fds (POSIX only)&#10;&#10;  encoding and errors: Text mode encoding and error handling to use for&#10;      file objects stdin, stdout and stderr.&#10;&#10;Attributes:&#10;    stdin, stdout, stderr, pid, returncode">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.communicate" func="yes">
			<Overload retVal="" descr='Interact with process: Send data to stdin.  Read data from&#10;stdout and stderr, until end-of-file is reached.  Wait for&#10;process to terminate.&#10;&#10;The optional "input" argument should be data to be sent to the&#10;child process (if self.universal_newlines is True, this should&#10;be a string; if it is False, "input" should be bytes), or&#10;None, if no data should be sent to the child.&#10;&#10;communicate() returns a tuple (stdout, stderr).  These will be&#10;bytes or, if self.universal_newlines was True, a string.'>
				<Param name="self" />
				<Param name="[input=None" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.kill" func="yes">
			<Overload retVal="" descr="Terminates the process.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.poll" func="yes">
			<Overload retVal="" descr="Check if child process has terminated. Set and return returncode&#10;attribute.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.send_signal" func="yes">
			<Overload retVal="" descr="Send a signal to the process.">
				<Param name="self" />
				<Param name="sig" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.terminate" func="yes">
			<Overload retVal="" descr="Terminates the process.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.Popen.wait" func="yes">
			<Overload retVal="" descr="Wait for child process to terminate.  Returns returncode&#10;attribute.">
				<Param name="self" />
				<Param name="[timeout=None" />
				<Param name="[endtime=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STARTF_USESHOWWINDOW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STARTF_USESTDHANDLES" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STARTUPINFO" />
		<KeyWord name="subprocess.STDOUT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STD_ERROR_HANDLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STD_INPUT_HANDLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.STD_OUTPUT_HANDLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.SubprocessError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.SubprocessError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.SubprocessError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.TimeoutExpired" func="yes">
			<Overload retVal="" descr="This exception is raised when the timeout expires while waiting for a&#10;child process.&#10;&#10;Attributes:&#10;    cmd, output, stdout, stderr, timeout">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.TimeoutExpired.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.TimeoutExpired.stdout" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.TimeoutExpired.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.call" func="yes">
			<Overload retVal="" descr='Run command with arguments.  Wait for command to complete or&#10;timeout, then return the returncode attribute.&#10;&#10;The arguments are the same as for the Popen constructor.  Example:&#10;&#10;retcode = call(["ls", "-l"])'>
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.check_call" func="yes">
			<Overload retVal="" descr='Run command with arguments.  Wait for command to complete.  If&#10;the exit code was zero then return, otherwise raise&#10;CalledProcessError.  The CalledProcessError object will have the&#10;return code in the returncode attribute.&#10;&#10;The arguments are the same as for the call function.  Example:&#10;&#10;check_call(["ls", "-l"])'>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.check_output" func="yes">
			<Overload retVal="" descr="Run command with arguments and return its output.&#10;&#10;If the exit code was non-zero it raises a CalledProcessError.  The&#10;CalledProcessError object will have the return code in the returncode&#10;attribute and output in the output attribute.&#10;&#10;The arguments are the same as for the Popen constructor.  Example:&#10;&#10;&gt;&gt;&gt; check_output([&quot;ls&quot;, &quot;-l&quot;, &quot;/dev/null&quot;])&#10;b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'&#10;&#10;The stdout argument is not allowed as it is used internally.&#10;To capture standard error in the result, use stderr=STDOUT.&#10;&#10;&gt;&gt;&gt; check_output([&quot;/bin/sh&quot;, &quot;-c&quot;,&#10;...               &quot;ls -l non_existent_file ; exit 0&quot;],&#10;...              stderr=STDOUT)&#10;b'ls: non_existent_file: No such file or directory\n'&#10;&#10;There is an additional optional argument, &quot;input&quot;, allowing you to&#10;pass a string to the subprocess's stdin.  If you use this argument&#10;you may not also use the Popen constructor's &quot;stdin&quot; argument, as&#10;it too will be used internally.  Example:&#10;&#10;&gt;&gt;&gt; check_output([&quot;sed&quot;, &quot;-e&quot;, &quot;s/foo/bar/&quot;],&#10;...              input=b&quot;when in the course of fooman events\n&quot;)&#10;b'when in the course of barman events\n'&#10;&#10;If universal_newlines=True is passed, the &quot;input&quot; argument must be a&#10;string and the return value will be a string rather than bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.getoutput" func="yes">
			<Overload retVal="" descr="Return output (stdout or stderr) of executing cmd in a shell.&#10;&#10;Like getstatusoutput(), except the exit status is ignored and the return&#10;value is a string containing the command's output.  Example:&#10;&#10;&gt;&gt;&gt; import subprocess&#10;&gt;&gt;&gt; subprocess.getoutput('ls /bin/ls')&#10;'/bin/ls'">
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.getstatusoutput" func="yes">
			<Overload retVal="" descr="Return (exitcode, output) of executing cmd in a shell.&#10;&#10;Execute the string 'cmd' in a shell with 'check_output' and&#10;return a 2-tuple (status, output). The locale encoding is used&#10;to decode the output and process newlines.&#10;&#10;A trailing newline is stripped from the output.&#10;The exit status for the command can be interpreted&#10;according to the rules for the function 'wait'. Example:&#10;&#10;&gt;&gt;&gt; import subprocess&#10;&gt;&gt;&gt; subprocess.getstatusoutput('ls /bin/ls')&#10;(0, '/bin/ls')&#10;&gt;&gt;&gt; subprocess.getstatusoutput('cat /bin/junk')&#10;(1, 'cat: /bin/junk: No such file or directory')&#10;&gt;&gt;&gt; subprocess.getstatusoutput('/bin/junk')&#10;(127, 'sh: /bin/junk: not found')&#10;&gt;&gt;&gt; subprocess.getstatusoutput('/bin/kill $$')&#10;(-15, '')">
				<Param name="cmd" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.list2cmdline" func="yes">
			<Overload retVal="" descr="Translate a sequence of arguments into a command line&#10;string, using the same rules as the MS C runtime:&#10;&#10;1) Arguments are delimited by white space, which is either a&#10;   space or a tab.&#10;&#10;2) A string surrounded by double quotation marks is&#10;   interpreted as a single argument, regardless of white space&#10;   contained within.  A quoted string can be embedded in an&#10;   argument.&#10;&#10;3) A double quotation mark preceded by a backslash is&#10;   interpreted as a literal double quotation mark.&#10;&#10;4) Backslashes are interpreted literally, unless they&#10;   immediately precede a double quotation mark.&#10;&#10;5) If backslashes immediately precede a double quotation mark,&#10;   every pair of backslashes is interpreted as a literal&#10;   backslash.  If the number of backslashes is odd, the last&#10;   backslash escapes the next double quotation mark as&#10;   described in rule 3.">
				<Param name="seq" />
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess.run" func="yes">
			<Overload retVal="" descr="Run command with arguments and return a CompletedProcess instance.&#10;&#10;The returned instance will have attributes args, returncode, stdout and&#10;stderr. By default, stdout and stderr are not captured, and those attributes&#10;will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.&#10;&#10;If check is True and the exit code was non-zero, it raises a&#10;CalledProcessError. The CalledProcessError object will have the return code&#10;in the returncode attribute, and output &amp; stderr attributes if those streams&#10;were captured.&#10;&#10;If timeout is given, and the process takes too long, a TimeoutExpired&#10;exception will be raised.&#10;&#10;There is an optional argument &quot;input&quot;, allowing you to&#10;pass a string to the subprocess's stdin.  If you use this argument&#10;you may not also use the Popen constructor's &quot;stdin&quot; argument, as&#10;it will be used internally.&#10;&#10;The other arguments are the same as for the Popen constructor.&#10;&#10;If universal_newlines=True is passed, the &quot;input&quot; argument must be a&#10;string and stdout/stderr in the returned object will be strings rather than&#10;bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess_exec" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="subprocess_shell" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractEventLoop">
			</Overload>
		</KeyWord>
		<KeyWord name="subscribe" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="subst" func="yes">
			<Overload retVal="" descr="Function of mailcap">
			</Overload>
		</KeyWord>
		<KeyWord name="subtract" func="yes">
			<Overload retVal="" descr="Function of collections.Counter">
			</Overload>
		</KeyWord>
		<KeyWord name="sum" func="yes">
			<Overload retVal="" descr="Return the sum of a 'start' value (default: 0) plus an iterable of numbers&#10;&#10;When the iterable is empty, return the start value.&#10;This function is intended specifically for use with numeric values and may&#10;reject non-numeric types.">
				<Param name="iterable" />
				<Param name="start" />
			</Overload>
		</KeyWord>
		<KeyWord name="summarize" func="yes">
			<Overload retVal="" descr="Function of doctest.DebugRunner">
			</Overload>
		</KeyWord>
		<KeyWord name="summarize_address_range" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau" func="yes">
			<Overload retVal="" descr="Stuff to parse Sun and NeXT audio files.&#10;&#10;An audio file consists of a header followed by the data.  The structure&#10;of the header is as follows.&#10;&#10;        +---------------+&#10;        | magic word    |&#10;        +---------------+&#10;        | header size   |&#10;        +---------------+&#10;        | data size     |&#10;        +---------------+&#10;        | encoding      |&#10;        +---------------+&#10;        | sample rate   |&#10;        +---------------+&#10;        | # of channels |&#10;        +---------------+&#10;        | info          |&#10;        |               |&#10;        +---------------+&#10;&#10;The magic word consists of the 4 characters '.snd'.  Apart from the&#10;info field, all header fields are 4 bytes in size.  They are all&#10;32-bit unsigned integers encoded in big-endian byte order.&#10;&#10;The header size really gives the start of the data.&#10;The data size is the physical size of the data.  From the other&#10;parameters the number of frames can be calculated.&#10;The encoding gives the way in which audio samples are encoded.&#10;Possible values are listed below.&#10;The info field currently consists of an ASCII string giving a&#10;human-readable description of the audio file.  The info field is&#10;padded with NUL bytes to the header size.&#10;&#10;Usage.&#10;&#10;Reading audio files:&#10;        f = sunau.open(file, 'r')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods read(), seek(), and close().&#10;When the setpos() and rewind() methods are not used, the seek()&#10;method is not  necessary.&#10;&#10;This returns an instance of a class with the following public methods:&#10;        getnchannels()  -- returns number of audio channels (1 for&#10;                           mono, 2 for stereo)&#10;        getsampwidth()  -- returns sample width in bytes&#10;        getframerate()  -- returns sampling frequency&#10;        getnframes()    -- returns number of audio frames&#10;        getcomptype()   -- returns compression type ('NONE' or 'ULAW')&#10;        getcompname()   -- returns human-readable version of&#10;                           compression type ('not compressed' matches 'NONE')&#10;        getparams()     -- returns a namedtuple consisting of all of the&#10;                           above in the above order&#10;        getmarkers()    -- returns None (for compatibility with the&#10;                           aifc module)&#10;        getmark(id)     -- raises an error since the mark does not&#10;                           exist (for compatibility with the aifc module)&#10;        readframes(n)   -- returns at most n frames of audio&#10;        rewind()        -- rewind to the beginning of the audio stream&#10;        setpos(pos)     -- seek to the specified position&#10;        tell()          -- return the current position&#10;        close()         -- close the instance (make it unusable)&#10;The position returned by tell() and the position given to setpos()&#10;are compatible and have nothing to do with the actual position in the&#10;file.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;Writing audio files:&#10;        f = sunau.open(file, 'w')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods write(), tell(), seek(), and&#10;close().&#10;&#10;This returns an instance of a class with the following public methods:&#10;        setnchannels(n) -- set the number of channels&#10;        setsampwidth(n) -- set the sample width&#10;        setframerate(n) -- set the frame rate&#10;        setnframes(n)   -- set the number of frames&#10;        setcomptype(type, name)&#10;                        -- set the compression type and the&#10;                           human-readable compression type&#10;        setparams(tuple)-- set all parameters at once&#10;        tell()          -- return current position in output file&#10;        writeframesraw(data)&#10;                        -- write audio frames without pathing up the&#10;                           file header&#10;        writeframes(data)&#10;                        -- write audio frames and patch up the file header&#10;        close()         -- patch up the file header and close the&#10;                           output file&#10;You should set the parameters before the first writeframesraw or&#10;writeframes.  The total number of frames does not need to be set,&#10;but when it is set to the correct value, the header does not have to&#10;be patched up.&#10;It is best to first set all parameters, perhaps possibly the&#10;compression type, and then write audio frames using writeframesraw.&#10;When all frames have been written, either call writeframes(b'') or&#10;close() to patch up the sizes in the header.&#10;The close() method is called automatically when the class instance&#10;is destroyed.">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G721" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G722" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G723_3" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ADPCM_G723_5" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_ALAW_8" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_DOUBLE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_FLOAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_16" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_24" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_32" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_LINEAR_8" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_ENCODING_MULAW_8" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_FILE_MAGIC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.AUDIO_UNKNOWN_SIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Au_read" />
		<KeyWord name="sunau.Au_read.close" />
		<KeyWord name="sunau.Au_read.getcompname" />
		<KeyWord name="sunau.Au_read.getcomptype" />
		<KeyWord name="sunau.Au_read.getfp" />
		<KeyWord name="sunau.Au_read.getframerate" />
		<KeyWord name="sunau.Au_read.getmark" />
		<KeyWord name="sunau.Au_read.getmarkers" />
		<KeyWord name="sunau.Au_read.getnchannels" />
		<KeyWord name="sunau.Au_read.getnframes" />
		<KeyWord name="sunau.Au_read.getparams" />
		<KeyWord name="sunau.Au_read.getsampwidth" />
		<KeyWord name="sunau.Au_read.initfp" />
		<KeyWord name="sunau.Au_read.readframes" />
		<KeyWord name="sunau.Au_read.rewind" />
		<KeyWord name="sunau.Au_read.setpos" />
		<KeyWord name="sunau.Au_read.tell" />
		<KeyWord name="sunau.Au_write" />
		<KeyWord name="sunau.Au_write.close" />
		<KeyWord name="sunau.Au_write.getcompname" />
		<KeyWord name="sunau.Au_write.getcomptype" />
		<KeyWord name="sunau.Au_write.getframerate" />
		<KeyWord name="sunau.Au_write.getnchannels" />
		<KeyWord name="sunau.Au_write.getnframes" />
		<KeyWord name="sunau.Au_write.getparams" />
		<KeyWord name="sunau.Au_write.getsampwidth" />
		<KeyWord name="sunau.Au_write.initfp" />
		<KeyWord name="sunau.Au_write.setcomptype" />
		<KeyWord name="sunau.Au_write.setframerate" />
		<KeyWord name="sunau.Au_write.setnchannels" />
		<KeyWord name="sunau.Au_write.setnframes" />
		<KeyWord name="sunau.Au_write.setparams" />
		<KeyWord name="sunau.Au_write.setsampwidth" />
		<KeyWord name="sunau.Au_write.tell" />
		<KeyWord name="sunau.Au_write.writeframes" />
		<KeyWord name="sunau.Au_write.writeframesraw" />
		<KeyWord name="sunau.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sunau.openfp" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="super" func="yes">
			<Overload retVal="" descr="super() -&gt; same as super(__class__, &lt;first argument&gt;)&#10;super(type) -&gt; unbound super object&#10;super(type, obj) -&gt; bound super object; requires isinstance(obj, type)&#10;super(type, type2) -&gt; bound super object; requires issubclass(type2, type)&#10;Typical use to call a cooperative superclass method:&#10;class C(B):&#10;    def meth(self, arg):&#10;        super().meth(arg)&#10;This works for class methods too:&#10;class C(B):&#10;    @classmethod&#10;    def cmeth(cls, arg):&#10;        super().cmeth(arg)">
			</Overload>
		</KeyWord>
		<KeyWord name="supernet" func="yes">
			<Overload retVal="" descr="Function of ipaddress.IPv4Network">
			</Overload>
		</KeyWord>
		<KeyWord name="swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; str&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol" func="yes">
			<Overload retVal="" descr='Non-terminal symbols of Python grammar (from "graminit.h").'>
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.and_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.and_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.annassign" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.arglist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.argument" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.arith_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.assert_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.async_funcdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.async_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.atom" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.atom_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.augassign" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.break_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.classdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_for" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_if" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_iter" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comp_op" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.comparison" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.compound_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.continue_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.decorated" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.decorator" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.decorators" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.del_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dictorsetmaker" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dotted_as_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dotted_as_names" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.dotted_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.encoding_decl" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.eval_input" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.except_clause" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.expr_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.exprlist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.factor" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.file_input" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.flow_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.for_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.funcdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.global_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.if_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_as_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_as_names" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_from" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_name" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.import_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.lambdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.lambdef_nocond" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.nonlocal_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.not_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.or_test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.parameters" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.pass_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.power" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.raise_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.return_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.shift_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.simple_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.single_input" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.sliceop" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.small_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.star_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.subscript" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.subscriptlist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.suite" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.sym_name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.term" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.test" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.test_nocond" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist_comp" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.testlist_star_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.tfpdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.trailer" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.try_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.typedargslist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.varargslist" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.vfpdef" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.while_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.with_item" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.with_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.xor_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.yield_arg" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.yield_expr" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symbol.yield_stmt" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symlink" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="symlink_or_copy" func="yes">
			<Overload retVal="" descr="Function of venv.EnvBuilder">
			</Overload>
		</KeyWord>
		<KeyWord name="symlink_to" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="symmetric_difference" func="yes">
			<Overload retVal="" descr="Return the symmetric difference of two sets as a new set.&#10;&#10;(i.e. all elements that are in exactly one of the sets.)">
			</Overload>
		</KeyWord>
		<KeyWord name="symmetric_difference_update" func="yes">
			<Overload retVal="" descr="Update a set with the symmetric difference of itself and another.">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable" func="yes">
			<Overload retVal="" descr="Interface to the compiler's internal symbol tables">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.CELL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Class" />
		<KeyWord name="symtable.Class.get_children" />
		<KeyWord name="symtable.Class.get_id" />
		<KeyWord name="symtable.Class.get_identifiers" />
		<KeyWord name="symtable.Class.get_lineno" />
		<KeyWord name="symtable.Class.get_methods" />
		<KeyWord name="symtable.Class.get_name" />
		<KeyWord name="symtable.Class.get_symbols" />
		<KeyWord name="symtable.Class.get_type" />
		<KeyWord name="symtable.Class.has_children" />
		<KeyWord name="symtable.Class.has_exec" func="yes">
			<Overload retVal="" descr="Return true if the scope uses exec.  Deprecated method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Class.is_nested" />
		<KeyWord name="symtable.Class.is_optimized" />
		<KeyWord name="symtable.Class.lookup" />
		<KeyWord name="symtable.DEF_ANNOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_BOUND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_GLOBAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_IMPORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_LOCAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.DEF_PARAM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.FREE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Function" />
		<KeyWord name="symtable.Function.get_children" />
		<KeyWord name="symtable.Function.get_frees" />
		<KeyWord name="symtable.Function.get_globals" />
		<KeyWord name="symtable.Function.get_id" />
		<KeyWord name="symtable.Function.get_identifiers" />
		<KeyWord name="symtable.Function.get_lineno" />
		<KeyWord name="symtable.Function.get_locals" />
		<KeyWord name="symtable.Function.get_name" />
		<KeyWord name="symtable.Function.get_parameters" />
		<KeyWord name="symtable.Function.get_symbols" />
		<KeyWord name="symtable.Function.get_type" />
		<KeyWord name="symtable.Function.has_children" />
		<KeyWord name="symtable.Function.has_exec" func="yes">
			<Overload retVal="" descr="Return true if the scope uses exec.  Deprecated method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Function.is_nested" />
		<KeyWord name="symtable.Function.is_optimized" />
		<KeyWord name="symtable.Function.lookup" />
		<KeyWord name="symtable.GLOBAL_EXPLICIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.GLOBAL_IMPLICIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.LOCAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SCOPE_MASK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SCOPE_OFF" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol" />
		<KeyWord name="symtable.Symbol.get_name" />
		<KeyWord name="symtable.Symbol.get_namespace" func="yes">
			<Overload retVal="" descr="Returns the single namespace bound to this name.&#10;&#10;Raises ValueError if the name is bound to multiple namespaces.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol.get_namespaces" func="yes">
			<Overload retVal="" descr="Return a list of namespaces bound to this name">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol.is_annotated" />
		<KeyWord name="symtable.Symbol.is_assigned" />
		<KeyWord name="symtable.Symbol.is_declared_global" />
		<KeyWord name="symtable.Symbol.is_free" />
		<KeyWord name="symtable.Symbol.is_global" />
		<KeyWord name="symtable.Symbol.is_imported" />
		<KeyWord name="symtable.Symbol.is_local" />
		<KeyWord name="symtable.Symbol.is_namespace" func="yes">
			<Overload retVal="" descr="Returns true if name binding introduces new namespace.&#10;&#10;If the name is used as the target of a function or class&#10;statement, this will be true.&#10;&#10;Note that a single name can be bound to multiple objects.  If&#10;is_namespace() is true, the name may also be bound to other&#10;objects, like an int or list, that does not introduce a new&#10;namespace.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.Symbol.is_parameter" />
		<KeyWord name="symtable.Symbol.is_referenced" />
		<KeyWord name="symtable.SymbolTable" />
		<KeyWord name="symtable.SymbolTable.get_children" />
		<KeyWord name="symtable.SymbolTable.get_id" />
		<KeyWord name="symtable.SymbolTable.get_identifiers" />
		<KeyWord name="symtable.SymbolTable.get_lineno" />
		<KeyWord name="symtable.SymbolTable.get_name" />
		<KeyWord name="symtable.SymbolTable.get_symbols" />
		<KeyWord name="symtable.SymbolTable.get_type" />
		<KeyWord name="symtable.SymbolTable.has_children" />
		<KeyWord name="symtable.SymbolTable.has_exec" func="yes">
			<Overload retVal="" descr="Return true if the scope uses exec.  Deprecated method.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.SymbolTable.is_nested" />
		<KeyWord name="symtable.SymbolTable.is_optimized" />
		<KeyWord name="symtable.SymbolTable.lookup" />
		<KeyWord name="symtable.SymbolTableFactory" />
		<KeyWord name="symtable.SymbolTableFactory.new" />
		<KeyWord name="symtable.USE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="symtable.symtable" />
		<KeyWord name="synopsis" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig" func="yes">
			<Overload retVal="" descr="Access to Python's configuration information.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_config_h_filename" func="yes">
			<Overload retVal="" descr="Return the path of pyconfig.h.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_config_var" func="yes">
			<Overload retVal="" descr="Return the value of a single variable using the dictionary returned by&#10;'get_config_vars()'.&#10;&#10;Equivalent to get_config_vars().get(name)">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_config_vars" func="yes">
			<Overload retVal="" descr="With no arguments, return a dictionary of all configuration&#10;variables relevant for the current platform.&#10;&#10;On Unix, this means every variable defined in Python's installed Makefile;&#10;On Windows it's a much smaller set.&#10;&#10;With arguments, return a list of values that result from looking up&#10;each argument in the configuration variable dictionary.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_makefile_filename" func="yes">
			<Overload retVal="" descr="Return the path of the Makefile.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_path" func="yes">
			<Overload retVal="" descr="Return a path corresponding to the scheme.&#10;&#10;``scheme`` is the install scheme name.">
				<Param name="name" />
				<Param name="[scheme=nt" />
				<Param name="[vars=None" />
				<Param name="[expand=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_path_names" func="yes">
			<Overload retVal="" descr="Return a tuple containing the paths names.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_paths" func="yes">
			<Overload retVal="" descr="Return a mapping containing an install scheme.&#10;&#10;``scheme`` is the install scheme name. If not provided, it will&#10;return the default scheme for the current platform.">
				<Param name="[scheme=nt" />
				<Param name="[vars=None" />
				<Param name="[expand=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_platform" func="yes">
			<Overload retVal="" descr="Return a string that identifies the current platform.&#10;&#10;This is used mainly to distinguish platform-specific build directories and&#10;platform-specific built distributions.  Typically includes the OS name&#10;and version and the architecture (as supplied by 'os.uname()'),&#10;although the exact information included depends on the OS; eg. for IRIX&#10;the architecture isn't particularly important (IRIX only runs on SGI&#10;hardware), but for Linux the kernel version isn't particularly&#10;important.&#10;&#10;Examples of returned values:&#10;   linux-i586&#10;   linux-alpha (?)&#10;   solaris-2.6-sun4u&#10;   irix-5.3&#10;   irix64-6.2&#10;&#10;Windows will return one of:&#10;   win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)&#10;   win-ia64 (64bit Windows on Itanium)&#10;   win32 (all others - specifically, sys.platform is returned)&#10;&#10;For other non-POSIX platforms, currently just returns 'sys.platform'.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.get_python_version" />
		<KeyWord name="sysconfig.get_scheme_names" func="yes">
			<Overload retVal="" descr="Return a tuple containing the schemes names.">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.is_python_build" func="yes">
			<Overload retVal="" descr=>
				<Param name="[check_home=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.pardir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.parse_config_h" func="yes">
			<Overload retVal="" descr="Parse a config.h-style file.&#10;&#10;A dictionary containing name/value pairs is returned.  If an&#10;optional dictionary is passed in as the second argument, it is&#10;used instead of a new dictionary.">
				<Param name="fp" />
				<Param name="[vars=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="sysconfig.realpath" func="yes">
			<Overload retVal="" descr="Return the absolute version of a path.">
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="system" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="system_alias" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny" func="yes">
			<Overload retVal="" descr="The Tab Nanny despises ambiguous indentation.  She knows no mercy.&#10;&#10;tabnanny -- Detection of ambiguous indentation&#10;&#10;For the time being this module is intended to be called as a script.&#10;However it is possible to import it into an IDE and use the function&#10;check() described below.&#10;&#10;Warning: The API provided by this module is likely to change in future&#10;releases; such changes may not be backward compatible.">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.NannyNag" func="yes">
			<Overload retVal="" descr="Raised by process_tokens() if detecting an ambiguous indent.&#10;Captured and handled in check().">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.NannyNag.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.NannyNag.get_line" />
		<KeyWord name="tabnanny.NannyNag.get_lineno" />
		<KeyWord name="tabnanny.NannyNag.get_msg" />
		<KeyWord name="tabnanny.NannyNag.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.Whitespace" />
		<KeyWord name="tabnanny.Whitespace.S" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.Whitespace.T" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.Whitespace.equal" />
		<KeyWord name="tabnanny.Whitespace.indent_level" />
		<KeyWord name="tabnanny.Whitespace.less" />
		<KeyWord name="tabnanny.Whitespace.longest_run_of_spaces" />
		<KeyWord name="tabnanny.Whitespace.not_equal_witness" />
		<KeyWord name="tabnanny.Whitespace.not_less_witness" />
		<KeyWord name="tabnanny.check" func="yes">
			<Overload retVal="" descr="check(file_or_dir)&#10;&#10;If file_or_dir is a directory and not a symbolic link, then recursively&#10;descend the directory tree named by file_or_dir, checking all .py files&#10;along the way. If file_or_dir is an ordinary Python source file, it is&#10;checked for whitespace related problems. The diagnostic messages are&#10;written to standard output using the print statement.">
				<Param name="file" />
			</Overload>
		</KeyWord>
		<KeyWord name="tabnanny.errprint" />
		<KeyWord name="tabnanny.format_witnesses" />
		<KeyWord name="tabnanny.main" />
		<KeyWord name="tabnanny.process_tokens" />
		<KeyWord name="take_action" func="yes">
			<Overload retVal="" descr="Function of optparse.Option">
			</Overload>
		</KeyWord>
		<KeyWord name="take_snapshot" func="yes">
			<Overload retVal="" descr="Function of tracemalloc">
			</Overload>
		</KeyWord>
		<KeyWord name="takes_value" func="yes">
			<Overload retVal="" descr="Function of optparse.Option">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile" func="yes">
			<Overload retVal="" descr="Read from and write to tar format archives.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.AREGTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.BLKTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.BLOCKSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CHRTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CONTTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CompressionError" func="yes">
			<Overload retVal="" descr="Exception for unavailable compression methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CompressionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.CompressionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.DEFAULT_FORMAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.DIRTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ENCODING" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EOFHeaderError" func="yes">
			<Overload retVal="" descr="Exception for end of file headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EOFHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EOFHeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EmptyHeaderError" func="yes">
			<Overload retVal="" descr="Exception for empty headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EmptyHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.EmptyHeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject" func="yes">
			<Overload retVal="" descr="Create a new buffered reader using the given readable raw IO object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.mode" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.peek" />
		<KeyWord name="tarfile.ExFileObject.raw" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.read" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes.&#10;&#10;If the argument is omitted, None, or negative, reads and&#10;returns all data until EOF.&#10;&#10;If the argument is positive, and the underlying raw stream is&#10;not 'interactive', multiple raw reads may be issued to satisfy&#10;the byte count (unless EOF is reached first).  But for&#10;interactive raw streams (as well as sockets and pipes), at most&#10;one raw read will be issued, and a short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.&#10;&#10;Returns None if the underlying raw stream was open in non-blocking&#10;mode and no data is available at the moment.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.read1" func="yes">
			<Overload retVal="" descr="Read and return up to n bytes, with at most one read() call&#10;to the underlying raw stream. A short result does not imply&#10;that EOF is imminent.&#10;&#10;Returns an empty bytes object on EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.readinto" />
		<KeyWord name="tarfile.ExFileObject.readinto1" />
		<KeyWord name="tarfile.ExFileObject.readline" func="yes">
			<Overload retVal="" descr="Read and return a line from the stream.&#10;&#10;If size is specified, at most size bytes will be read.&#10;&#10;The line terminator is always b'\n' for binary files; for text&#10;files, the newlines argument to open can be used to select the line&#10;terminator(s) recognized.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="target" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.write" func="yes">
			<Overload retVal="" descr="Write the given buffer to the IO stream.&#10;&#10;Returns the number of bytes written, which is always the length of b&#10;in bytes.&#10;&#10;Raises BlockingIOError if the buffer is full and the&#10;underlying raw stream cannot accept more data at the moment.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExFileObject.writelines" />
		<KeyWord name="tarfile.ExtractError" func="yes">
			<Overload retVal="" descr="General exception for extract errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExtractError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ExtractError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.FIFOTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNUTYPE_LONGLINK" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNUTYPE_LONGNAME" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNUTYPE_SPARSE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNU_FORMAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNU_MAGIC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.GNU_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.HeaderError" func="yes">
			<Overload retVal="" descr="Base exception for header errors.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.HeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.HeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.InvalidHeaderError" func="yes">
			<Overload retVal="" descr="Exception for invalid headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.InvalidHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.InvalidHeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LENGTH_LINK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LENGTH_NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LENGTH_PREFIX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.LNKTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.NUL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_FIELDS" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_FORMAT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_NAME_FIELDS" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.PAX_NUMBER_FIELDS" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.POSIX_MAGIC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.RECORDSIZE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.REGTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.REGULAR_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ReadError" func="yes">
			<Overload retVal="" descr="Exception for unreadable tar archives.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ReadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.ReadError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SOLARIS_XHDTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SUPPORTED_TYPES" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SYMTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.StreamError" func="yes">
			<Overload retVal="" descr="Exception for unsupported operations on stream-like TarFiles.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.StreamError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.StreamError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SubsequentHeaderError" func="yes">
			<Overload retVal="" descr="Exception for missing and invalid extended headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SubsequentHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.SubsequentHeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarError" func="yes">
			<Overload retVal="" descr="Base exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile" func="yes">
			<Overload retVal="" descr="The TarFile Class provides an interface to tar archives.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.OPEN_METH" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.add" func="yes">
			<Overload retVal="" descr="Add the file `name' to the archive. `name' may be any type of file&#10;(directory, fifo, symbolic link, etc.). If given, `arcname'&#10;specifies an alternative name for the file in the archive.&#10;Directories are added recursively by default. This can be avoided by&#10;setting `recursive' to False. `exclude' is a function that should&#10;return True for each filename to be excluded. `filter' is a function&#10;that expects a TarInfo object argument and returns the changed&#10;TarInfo object, if it returns None the TarInfo object will be&#10;excluded from the archive.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.addfile" func="yes">
			<Overload retVal="" descr="Add the TarInfo object `tarinfo' to the archive. If `fileobj' is&#10;given, it should be a binary file, and tarinfo.size bytes are read&#10;from it and added to the archive. You can create TarInfo objects&#10;directly, or by using gettarinfo().">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="[fileobj=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.bz2open" func="yes">
			<Overload retVal="" descr="Open bzip2 compressed tar archive name for reading or writing.&#10;Appending is not allowed.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[compresslevel=9" />
				<Param name="[**]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.chmod" func="yes">
			<Overload retVal="" descr="Set file permissions of targetpath according to tarinfo.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.chown" func="yes">
			<Overload retVal="" descr="Set owner of targetpath according to tarinfo. If numeric_owner&#10;is True, use .gid/.uid instead of .gname/.uname. If numeric_owner&#10;is False, fall back to .gid/.uid when the search based on name&#10;fails.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
				<Param name="numeric_owner" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.close" func="yes">
			<Overload retVal="" descr="Close the TarFile. In write-mode, two finishing zero blocks are&#10;appended to the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.errorlevel" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a TarInfo object. You can&#10;specify a different directory using `path'. File attributes (owner,&#10;mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`&#10;is True, only the numbers for user/group names are used and not&#10;the names.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory and set owner, modification time and permissions on&#10;directories afterwards. `path' specifies a different directory&#10;to extract to. `members' is optional and must be a subset of the&#10;list returned by getmembers(). If `numeric_owner` is True, only&#10;the numbers for user/group names are used and not the names.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.extractfile" func="yes">
			<Overload retVal="" descr="Extract a member from the archive as a file object. `member' may be&#10;a filename or a TarInfo object. If `member' is a regular file or a&#10;link, an io.BufferedReader object is returned. Otherwise, None is&#10;returned.">
				<Param name="self" />
				<Param name="member" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.fileobject" func="yes">
			<Overload retVal="" descr="Create a new buffered reader using the given readable raw IO object.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.format" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.getmember" func="yes">
			<Overload retVal="" descr="Return a TarInfo object for member `name'. If `name' can not be&#10;found in the archive, KeyError is raised. If a member occurs more&#10;than once in the archive, its last occurrence is assumed to be the&#10;most up-to-date version.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.getmembers" func="yes">
			<Overload retVal="" descr="Return the members of the archive as a list of TarInfo objects. The&#10;list has the same order as the members in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.getnames" func="yes">
			<Overload retVal="" descr="Return the members of the archive as a list of their names. It has&#10;the same order as the list returned by getmembers().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.gettarinfo" func="yes">
			<Overload retVal="" descr="Create a TarInfo object from the result of os.stat or equivalent&#10;on an existing file. The file is either named by `name', or&#10;specified as a file object `fileobj' with a file descriptor. If&#10;given, `arcname' specifies an alternative name for the file in the&#10;archive, otherwise, the name is taken from the 'name' attribute of&#10;'fileobj', or the 'name' argument. The name should be a text&#10;string.">
				<Param name="self" />
				<Param name="[name=None" />
				<Param name="[arcname=None" />
				<Param name="[fileobj=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.gzopen" func="yes">
			<Overload retVal="" descr="Open gzip compressed tar archive name for reading or writing.&#10;Appending is not allowed.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[compresslevel=9" />
				<Param name="[**]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.list" func="yes">
			<Overload retVal="" descr="Print a table of contents to sys.stdout. If `verbose' is False, only&#10;the names of the members are printed. If it is True, an `ls -l'-like&#10;output is produced. `members' is optional and must be a subset of the&#10;list returned by getmembers().">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makedev" func="yes">
			<Overload retVal="" descr="Make a character or block device called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makedir" func="yes">
			<Overload retVal="" descr="Make a directory called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makefifo" func="yes">
			<Overload retVal="" descr="Make a fifo called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makefile" func="yes">
			<Overload retVal="" descr="Make a file called targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makelink" func="yes">
			<Overload retVal="" descr="Make a (symbolic) link called targetpath. If it cannot be created&#10;(platform limitation), we try to make a copy of the referenced file&#10;instead of a link.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.makeunknown" func="yes">
			<Overload retVal="" descr="Make a file from a TarInfo object with an unknown type&#10;at targetpath.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.next" func="yes">
			<Overload retVal="" descr="Return the next member of the archive as a TarInfo object, when&#10;TarFile is opened for reading. Return None if there is no more&#10;available.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.open" func="yes">
			<Overload retVal="" descr="Open a tar archive for reading, writing or appending. Return&#10;an appropriate TarFile class.&#10;&#10;mode:&#10;'r' or 'r:*' open for reading with transparent compression&#10;'r:'         open for reading exclusively uncompressed&#10;'r:gz'       open for reading with gzip compression&#10;'r:bz2'      open for reading with bzip2 compression&#10;'r:xz'       open for reading with lzma compression&#10;'a' or 'a:'  open for appending, creating the file if necessary&#10;'w' or 'w:'  open for writing without compression&#10;'w:gz'       open for writing with gzip compression&#10;'w:bz2'      open for writing with bzip2 compression&#10;'w:xz'       open for writing with lzma compression&#10;&#10;'x' or 'x:'  create a tarfile exclusively without compression, raise&#10;             an exception if the file is already created&#10;'x:gz'       create a gzip compressed tarfile, raise an exception&#10;             if the file is already created&#10;'x:bz2'      create a bzip2 compressed tarfile, raise an exception&#10;             if the file is already created&#10;'x:xz'       create an lzma compressed tarfile, raise an exception&#10;             if the file is already created&#10;&#10;'r|*'        open a stream of tar blocks with transparent compression&#10;'r|'         open an uncompressed stream of tar blocks for reading&#10;'r|gz'       open a gzip compressed stream of tar blocks&#10;'r|bz2'      open a bzip2 compressed stream of tar blocks&#10;'r|xz'       open an lzma compressed stream of tar blocks&#10;'w|'         open an uncompressed stream for writing&#10;'w|gz'       open a gzip compressed stream for writing&#10;'w|bz2'      open a bzip2 compressed stream for writing&#10;'w|xz'       open an lzma compressed stream for writing">
				<Param name="cls" />
				<Param name="[name=None" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[bufsize=10240" />
				<Param name="[**]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.tarinfo" func="yes">
			<Overload retVal="" descr="Informational class which holds the details about an&#10;archive member given by a tar header block.&#10;TarInfo objects are returned by TarFile.getmember(),&#10;TarFile.getmembers() and TarFile.gettarinfo() and are&#10;usually created internally.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.taropen" func="yes">
			<Overload retVal="" descr="Open uncompressed tar archive name for reading or writing.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[**]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.utime" func="yes">
			<Overload retVal="" descr="Set modification time of targetpath according to tarinfo.">
				<Param name="self" />
				<Param name="tarinfo" />
				<Param name="targetpath" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarFile.xzopen" func="yes">
			<Overload retVal="" descr="Open lzma compressed tar archive name for reading or writing.&#10;Appending is not allowed.">
				<Param name="cls" />
				<Param name="name" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[preset=None" />
				<Param name="[**]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo" func="yes">
			<Overload retVal="" descr="Informational class which holds the details about an&#10;archive member given by a tar header block.&#10;TarInfo objects are returned by TarFile.getmember(),&#10;TarFile.getmembers() and TarFile.gettarinfo() and are&#10;usually created internally.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.chksum" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_gnu_header" func="yes">
			<Overload retVal="" descr="Return the object as a GNU header block sequence.">
				<Param name="self" />
				<Param name="info" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_pax_global_header" func="yes">
			<Overload retVal="" descr="Return the object as a pax global header block sequence.">
				<Param name="cls" />
				<Param name="pax_headers" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_pax_header" func="yes">
			<Overload retVal="" descr="Return the object as a ustar header block. If it cannot be&#10;represented this way, prepend a pax extended header sequence&#10;with supplement information.">
				<Param name="self" />
				<Param name="info" />
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.create_ustar_header" func="yes">
			<Overload retVal="" descr="Return the object as a ustar header block.">
				<Param name="self" />
				<Param name="info" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.devmajor" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.devminor" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.frombuf" func="yes">
			<Overload retVal="" descr="Construct a TarInfo object from a 512 byte bytes object.">
				<Param name="cls" />
				<Param name="buf" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.fromtarfile" func="yes">
			<Overload retVal="" descr="Return the next TarInfo object from TarFile object&#10;tarfile.">
				<Param name="cls" />
				<Param name="tarfile" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.get_info" func="yes">
			<Overload retVal="" descr="Return the TarInfo's attributes as a dictionary.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.gid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.gname" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.isblk" />
		<KeyWord name="tarfile.TarInfo.ischr" />
		<KeyWord name="tarfile.TarInfo.isdev" />
		<KeyWord name="tarfile.TarInfo.isdir" />
		<KeyWord name="tarfile.TarInfo.isfifo" />
		<KeyWord name="tarfile.TarInfo.isfile" />
		<KeyWord name="tarfile.TarInfo.islnk" />
		<KeyWord name="tarfile.TarInfo.isreg" />
		<KeyWord name="tarfile.TarInfo.issparse" />
		<KeyWord name="tarfile.TarInfo.issym" />
		<KeyWord name="tarfile.TarInfo.linkname" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.linkpath" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.mode" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.mtime" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.offset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.offset_data" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.path" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.pax_headers" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.sparse" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.tarfile" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.tobuf" func="yes">
			<Overload retVal="" descr="Return a tar header as a string of 512 byte blocks.">
				<Param name="self" />
				<Param name="[format=1" />
				<Param name="[encoding=utf-8" />
				<Param name="[errors=surrogateescape]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.type" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.uid" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TarInfo.uname" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TruncatedHeaderError" func="yes">
			<Overload retVal="" descr="Exception for truncated headers.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TruncatedHeaderError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.TruncatedHeaderError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.XGLTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.XHDTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.bltn_open" func="yes">
			<Overload retVal="" descr="Open file and return a stream.  Raise IOError upon failure.&#10;&#10;file is either a text or byte string giving the name (and the path&#10;if the file isn't in the current working directory) of the file to&#10;be opened or an integer file descriptor of the file to be&#10;wrapped. (If a file descriptor is given, it is closed when the&#10;returned I/O object is closed, unless closefd is set to False.)&#10;&#10;mode is an optional string that specifies the mode in which the file&#10;is opened. It defaults to 'r' which means open for reading in text&#10;mode.  Other common values are 'w' for writing (truncating the file if&#10;it already exists), 'x' for creating and writing to a new file, and&#10;'a' for appending (which on some Unix systems, means that all writes&#10;append to the end of the file regardless of the current seek position).&#10;In text mode, if encoding is not specified the encoding used is platform&#10;dependent: locale.getpreferredencoding(False) is called to get the&#10;current locale encoding. (For reading and writing raw bytes use binary&#10;mode and leave encoding unspecified.) The available modes are:&#10;&#10;========= ===============================================================&#10;Character Meaning&#10;--------- ---------------------------------------------------------------&#10;'r'       open for reading (default)&#10;'w'       open for writing, truncating the file first&#10;'x'       create a new file and open it for writing&#10;'a'       open for writing, appending to the end of the file if it exists&#10;'b'       binary mode&#10;'t'       text mode (default)&#10;'+'       open a disk file for updating (reading and writing)&#10;'U'       universal newline mode (deprecated)&#10;========= ===============================================================&#10;&#10;The default mode is 'rt' (open for reading text). For binary random&#10;access, the mode 'w+b' opens and truncates the file to 0 bytes, while&#10;'r+b' opens the file without truncation. The 'x' mode implies 'w' and&#10;raises an `FileExistsError` if the file already exists.&#10;&#10;Python distinguishes between files opened in binary and text modes,&#10;even when the underlying operating system doesn't. Files opened in&#10;binary mode (appending 'b' to the mode argument) return contents as&#10;bytes objects without any decoding. In text mode (the default, or when&#10;'t' is appended to the mode argument), the contents of the file are&#10;returned as strings, the bytes having been first decoded using a&#10;platform-dependent encoding or using the specified encoding if given.&#10;&#10;'U' mode is deprecated and will raise an exception in future versions&#10;of Python.  It has no effect in Python 3.  Use newline to control&#10;universal newlines mode.&#10;&#10;buffering is an optional integer used to set the buffering policy.&#10;Pass 0 to switch buffering off (only allowed in binary mode), 1 to select&#10;line buffering (only usable in text mode), and an integer &gt; 1 to indicate&#10;the size of a fixed-size chunk buffer.  When no buffering argument is&#10;given, the default buffering policy works as follows:&#10;&#10;* Binary files are buffered in fixed-size chunks; the size of the buffer&#10;  is chosen using a heuristic trying to determine the underlying device's&#10;  &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.&#10;  On many systems, the buffer will typically be 4096 or 8192 bytes long.&#10;&#10;* &quot;Interactive&quot; text files (files for which isatty() returns True)&#10;  use line buffering.  Other text files use the policy described above&#10;  for binary files.&#10;&#10;encoding is the name of the encoding used to decode or encode the&#10;file. This should only be used in text mode. The default encoding is&#10;platform dependent, but any encoding supported by Python can be&#10;passed.  See the codecs module for the list of supported encodings.&#10;&#10;errors is an optional string that specifies how encoding errors are to&#10;be handled---this argument should not be used in binary mode. Pass&#10;'strict' to raise a ValueError exception if there is an encoding error&#10;(the default of None has the same effect), or pass 'ignore' to ignore&#10;errors. (Note that ignoring encoding errors can lead to data loss.)&#10;See the documentation for codecs.register or run 'help(codecs.Codec)'&#10;for a list of the permitted encoding error strings.&#10;&#10;newline controls how universal newlines works (it only applies to text&#10;mode). It can be None, '', '\n', '\r', and '\r\n'.  It works as&#10;follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If closefd is False, the underlying file descriptor will be kept open&#10;when the file is closed. This does not work when a file name is given&#10;and must be True in that case.&#10;&#10;A custom opener can be used by passing a callable as *opener*. The&#10;underlying file descriptor for the file object is then obtained by&#10;calling *opener* with (*file*, *flags*). *opener* must return an open&#10;file descriptor (passing os.open as *opener* results in functionality&#10;similar to passing None).&#10;&#10;open() returns a file object whose type depends on the mode, and&#10;through which the standard file operations such as reading and writing&#10;are performed. When open() is used to open a file in a text mode ('w',&#10;'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open&#10;a file in a binary mode, the returned class varies: in read binary&#10;mode, it returns a BufferedReader; in write binary and append binary&#10;modes, it returns a BufferedWriter, and in read/write mode, it returns&#10;a BufferedRandom.&#10;&#10;It is also possible to use a string or bytearray as a file for both&#10;reading and writing. For strings StringIO can be used like a file&#10;opened in a text mode, and for bytes a BytesIO can be used like a file&#10;opened in a binary mode.">
				<Param name="file" />
				<Param name="[mode=r" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[errors=None" />
				<Param name="[newline=None" />
				<Param name="[closefd=True" />
				<Param name="[opener=None]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.calc_chksums" func="yes">
			<Overload retVal="" descr="Calculate the checksum for a member's header by summing up all&#10;characters except for the chksum field which is treated as if&#10;it was filled with spaces. According to the GNU tar sources,&#10;some tars (Sun and NeXT) calculate chksum with signed char,&#10;which will be different if there are chars in the buffer with&#10;the high bit set. So we calculate two checksums, unsigned and&#10;signed.">
				<Param name="buf" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.copyfileobj" func="yes">
			<Overload retVal="" descr="Copy length bytes from fileobj src to fileobj dst.&#10;If length is None, copy the entire content.">
				<Param name="src" />
				<Param name="dst" />
				<Param name="[length=None" />
				<Param name="[exception=<class 'OSError'>" />
				<Param name="[bufsize=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.filemode" func="yes">
			<Overload retVal="" descr="Deprecated in this location; use stat.filemode.">
				<Param name="mode" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.is_tarfile" func="yes">
			<Overload retVal="" descr="Return True if name points to a tar archive that we&#10;are able to handle, else return False.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.itn" func="yes">
			<Overload retVal="" descr="Convert a python number to a number field.">
				<Param name="n" />
				<Param name="[digits=8" />
				<Param name="[format=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.main" />
		<KeyWord name="tarfile.nti" func="yes">
			<Overload retVal="" descr="Convert a number field to a python number.">
				<Param name="s" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.nts" func="yes">
			<Overload retVal="" descr="Convert a null-terminated bytes object to a string.">
				<Param name="s" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.open" func="yes">
			<Overload retVal="" descr="Open a tar archive for reading, writing or appending. Return&#10;an appropriate TarFile class.&#10;&#10;mode:&#10;'r' or 'r:*' open for reading with transparent compression&#10;'r:'         open for reading exclusively uncompressed&#10;'r:gz'       open for reading with gzip compression&#10;'r:bz2'      open for reading with bzip2 compression&#10;'r:xz'       open for reading with lzma compression&#10;'a' or 'a:'  open for appending, creating the file if necessary&#10;'w' or 'w:'  open for writing without compression&#10;'w:gz'       open for writing with gzip compression&#10;'w:bz2'      open for writing with bzip2 compression&#10;'w:xz'       open for writing with lzma compression&#10;&#10;'x' or 'x:'  create a tarfile exclusively without compression, raise&#10;             an exception if the file is already created&#10;'x:gz'       create a gzip compressed tarfile, raise an exception&#10;             if the file is already created&#10;'x:bz2'      create a bzip2 compressed tarfile, raise an exception&#10;             if the file is already created&#10;'x:xz'       create an lzma compressed tarfile, raise an exception&#10;             if the file is already created&#10;&#10;'r|*'        open a stream of tar blocks with transparent compression&#10;'r|'         open an uncompressed stream of tar blocks for reading&#10;'r|gz'       open a gzip compressed stream of tar blocks&#10;'r|bz2'      open a bzip2 compressed stream of tar blocks&#10;'r|xz'       open an lzma compressed stream of tar blocks&#10;'w|'         open an uncompressed stream for writing&#10;'w|gz'       open a gzip compressed stream for writing&#10;'w|bz2'      open a bzip2 compressed stream for writing&#10;'w|xz'       open an lzma compressed stream for writing">
				<Param name="cls" />
				<Param name="[name=None" />
				<Param name="[mode=r" />
				<Param name="[fileobj=None" />
				<Param name="[bufsize=10240" />
				<Param name="[**]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.stn" func="yes">
			<Overload retVal="" descr="Convert a string to a null-terminated bytes object.">
				<Param name="s" />
				<Param name="length" />
				<Param name="encoding" />
				<Param name="errors" />
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.symlink_exception" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="tarfile.version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="taropen" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="task_done" func="yes">
			<Overload retVal="" descr="Function of asyncio.LifoQueue">
			</Overload>
		</KeyWord>
		<KeyWord name="tearDown" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="tearDownClass" func="yes">
			<Overload retVal="" descr="Function of doctest.DocFileCase">
			</Overload>
		</KeyWord>
		<KeyWord name="tell" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_read">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib" func="yes">
			<Overload retVal="" descr="TELNET client class.&#10;&#10;Based on RFC 854: TELNET Protocol Specification, by J. Postel and&#10;J. Reynolds&#10;&#10;Example:&#10;&#10;&gt;&gt;&gt; from telnetlib import Telnet&#10;&gt;&gt;&gt; tn = Telnet('www.python.org', 79)   # connect to finger port&#10;&gt;&gt;&gt; tn.write(b'guido\r\n')&#10;&gt;&gt;&gt; print(tn.read_all())&#10;Login       Name               TTY         Idle    When    Where&#10;guido    Guido van Rossum      pts/2        &lt;Dec  2 11:10&gt; snag.cnri.reston..&#10;&#10;&gt;&gt;&gt;&#10;&#10;Note that read_all() won't read until eof -- it just reads some data&#10;-- but it guarantees to read at least one byte unless EOF is hit.&#10;&#10;It is possible to pass a Telnet object to a selector in order to wait until&#10;more data is available.  Note that in this case, read_eager() may return b''&#10;even if there was data on the socket, because the protocol negotiation may have&#10;eaten the data.  This is why EOFError is needed in some cases to distinguish&#10;between &quot;no data&quot; and &quot;connection closed&quot; (since the socket also appears ready&#10;for reading when it is closed).&#10;&#10;To do:&#10;- option negotiation&#10;- timeout should be intrinsic to the connection object instead of an&#10;  option on one of the read calls only">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.AO" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.AUTHENTICATION" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.AYT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.BINARY" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.BM" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.BRK" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.CHARSET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.COM_PORT_OPTION" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DET" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DM" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DO" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.DONT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.ECHO" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.ENCRYPT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EOR" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.EXOPL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.FORWARD_X" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.GA" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.IAC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.IP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.KERMIT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.LFLOW" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.LINEMODE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.LOGOUT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAMS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOCRD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOFFD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOHTD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOHTS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOLFD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOVTD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAOVTS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NAWS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NEW_ENVIRON" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NOOPT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.NOP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.OLD_ENVIRON" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.OUTMRK" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.PRAGMA_HEARTBEAT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.PRAGMA_LOGON" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.RCP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.RCTE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.RSP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SB" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SEND_URL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SGA" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SNDLOC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SSPI_LOGON" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.STATUS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SUPDUP" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SUPDUPOUTPUT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.SUPPRESS_LOCAL_ECHO" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TELNET_PORT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TLS" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TM" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TN3270E" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TSPEED" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TTYLOC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TTYPE" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.TUID" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet" func="yes">
			<Overload retVal="" descr="Telnet interface class.&#10;&#10;An instance of this class represents a connection to a telnet&#10;server.  The instance is initially not connected; the open()&#10;method must be used to establish a connection.  Alternatively, the&#10;host name and optional port number can be passed to the&#10;constructor, too.&#10;&#10;Don't try to reopen an already connected instance.&#10;&#10;This class has many read_*() methods.  Note that some of them&#10;raise EOFError when the end of the connection is read, because&#10;they can return an empty string for other reasons.  See the&#10;individual doc strings.&#10;&#10;read_until(expected, [timeout])&#10;    Read until the expected string has been seen, or a timeout is&#10;    hit (default is no timeout); may block.&#10;&#10;read_all()&#10;    Read all data until EOF; may block.&#10;&#10;read_some()&#10;    Read at least one byte or EOF; may block.&#10;&#10;read_very_eager()&#10;    Read all data available already queued or on the socket,&#10;    without blocking.&#10;&#10;read_eager()&#10;    Read either data already queued or some data available on the&#10;    socket, without blocking.&#10;&#10;read_lazy()&#10;    Read all data in the raw queue (processing it first), without&#10;    doing any socket I/O.&#10;&#10;read_very_lazy()&#10;    Reads all data in the cooked queue, without doing any socket&#10;    I/O.&#10;&#10;read_sb_data()&#10;    Reads available data between SB ... SE sequence. Don't block.&#10;&#10;set_option_negotiation_callback(callback)&#10;    Each time a telnet option is read on the input flow, this callback&#10;    (if set) is called with the following parameters :&#10;    callback(telnet socket, command, option)&#10;        option will be chr(0) when there is no option.&#10;    No other action is done afterwards by telnetlib.">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.close" func="yes">
			<Overload retVal="" descr="Close the connection.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.expect" func="yes">
			<Overload retVal="" descr="Read until one from a list of a regular expressions matches.&#10;&#10;The first argument is a list of regular expressions, either&#10;compiled (re.RegexObject instances) or uncompiled (strings).&#10;The optional second argument is a timeout, in seconds; default&#10;is no timeout.&#10;&#10;Return a tuple of three items: the index in the list of the&#10;first regular expression that matches; the match object&#10;returned; and the text read up till and including the match.&#10;&#10;If EOF is read and no text was read, raise EOFError.&#10;Otherwise, when nothing matches, return (-1, None, text) where&#10;text is the text received so far (may be the empty string if a&#10;timeout happened).&#10;&#10;If a regular expression ends with a greedy match (e.g. '.*')&#10;or if more than one expression can match the same input, the&#10;results are undeterministic, and may depend on the I/O timing.">
				<Param name="self" />
				<Param name="list" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.fileno" func="yes">
			<Overload retVal="" descr="Return the fileno() of the socket object used internally.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.fill_rawq" func="yes">
			<Overload retVal="" descr="Fill raw queue from exactly one recv() system call.&#10;&#10;Block if no data is immediately available.  Set self.eof when&#10;connection is closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.get_socket" func="yes">
			<Overload retVal="" descr="Return the socket object used internally.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.interact" func="yes">
			<Overload retVal="" descr="Interaction function, emulates a very dumb telnet client.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.listener" func="yes">
			<Overload retVal="" descr="Helper for mt_interact() -- this executes in the other thread.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.msg" func="yes">
			<Overload retVal="" descr="Print a debug message, when the debug level is &gt; 0.&#10;&#10;If extra arguments are present, they are substituted in the&#10;message using the standard string formatting operator.">
				<Param name="self" />
				<Param name="msg" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.mt_interact" func="yes">
			<Overload retVal="" descr="Multithreaded version of interact().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.open" func="yes">
			<Overload retVal="" descr="Connect to a host.&#10;&#10;The optional second argument is the port number, which&#10;defaults to the standard telnet port (23).&#10;&#10;Don't try to reopen an already connected instance.">
				<Param name="self" />
				<Param name="host" />
				<Param name="[port=0" />
				<Param name="[timeout=<object object at 0x02AC9790>]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.process_rawq" func="yes">
			<Overload retVal="" descr="Transfer from raw queue to cooked queue.&#10;&#10;Set self.eof when connection is closed.  Don't block unless in&#10;the midst of an IAC sequence.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.rawq_getchar" func="yes">
			<Overload retVal="" descr="Get next char from raw queue.&#10;&#10;Block if no data is immediately available.  Raise EOFError&#10;when connection is closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_all" func="yes">
			<Overload retVal="" descr="Read all data until EOF; block until connection closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_eager" func="yes">
			<Overload retVal="" descr="Read readily available data.&#10;&#10;Raise EOFError if connection closed and no cooked data&#10;available.  Return b'' if no cooked data available otherwise.&#10;Don't block unless in the midst of an IAC sequence.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_lazy" func="yes">
			<Overload retVal="" descr="Process and return data that's already in the queues (lazy).&#10;&#10;Raise EOFError if connection closed and no data available.&#10;Return b'' if no cooked data available otherwise.  Don't block&#10;unless in the midst of an IAC sequence.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_sb_data" func="yes">
			<Overload retVal="" descr="Return any data available in the SB ... SE queue.&#10;&#10;Return b'' if no SB ... SE available. Should only be called&#10;after seeing a SB or SE command. When a new SB command is&#10;found, old unread SB data will be discarded. Don't block.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_some" func="yes">
			<Overload retVal="" descr="Read at least one byte of cooked data unless EOF is hit.&#10;&#10;Return b'' if EOF is hit.  Block if no data is immediately&#10;available.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_until" func="yes">
			<Overload retVal="" descr="Read until a given string is encountered or until timeout.&#10;&#10;When no match is found, return whatever is available instead,&#10;possibly the empty string.  Raise EOFError if the connection&#10;is closed and no cooked data is available.">
				<Param name="self" />
				<Param name="match" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_very_eager" func="yes">
			<Overload retVal="" descr="Read everything that's possible without blocking in I/O (eager).&#10;&#10;Raise EOFError if connection closed and no cooked data&#10;available.  Return b'' if no cooked data available otherwise.&#10;Don't block unless in the midst of an IAC sequence.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.read_very_lazy" func="yes">
			<Overload retVal="" descr="Return any data available in the cooked queue (very lazy).&#10;&#10;Raise EOFError if connection closed and no data available.&#10;Return b'' if no cooked data available otherwise.  Don't block.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.set_debuglevel" func="yes">
			<Overload retVal="" descr="Set the debug level.&#10;&#10;The higher it is, the more debug output you get (on sys.stdout).">
				<Param name="self" />
				<Param name="debuglevel" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.set_option_negotiation_callback" func="yes">
			<Overload retVal="" descr="Provide a callback function called after each receipt of a telnet option.">
				<Param name="self" />
				<Param name="callback" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.sock_avail" func="yes">
			<Overload retVal="" descr="Test whether data is available on the socket.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.Telnet.write" func="yes">
			<Overload retVal="" descr="Write a string to the socket, doubling any IAC characters.&#10;&#10;Can block if the connection is blocked.  May raise&#10;OSError if the connection is closed.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.VT3270REGIME" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.WILL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.WONT" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.X3PAD" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.XASCII" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.XAUTH" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.XDISPLOC" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.test" func="yes">
			<Overload retVal="" descr="Test program for telnetlib.&#10;&#10;Usage: python telnetlib.py [-d] ... [host [port]]&#10;&#10;Default host is localhost; default port is 23.">
			</Overload>
		</KeyWord>
		<KeyWord name="telnetlib.theNULL" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile" func="yes">
			<Overload retVal="" descr="Temporary files.&#10;&#10;This module provides generic, low- and high-level interfaces for&#10;creating temporary files and directories.  All of the interfaces&#10;provided by this module can be used without fear of race conditions&#10;except for 'mktemp'.  'mktemp' is subject to race conditions and&#10;should not be used; it is provided for backward compatibility only.&#10;&#10;The default path names are returned as str.  If you supply bytes as&#10;input, all return values will be in bytes.  Ex:&#10;&#10;    &gt;&gt;&gt; tempfile.mkstemp()&#10;    (4, '/tmp/tmptpu9nin8')&#10;    &gt;&gt;&gt; tempfile.mkdtemp(suffix=b'')&#10;    b'/tmp/tmppbi8f0hy'&#10;&#10;This module also provides some data items to the user:&#10;&#10;  TMP_MAX  - maximum number of names that will be tried before&#10;             giving up.&#10;  tempdir  - If this is set to a string before the first use of&#10;             any routine from this module, it will be considered as&#10;             another candidate location to store temporary files.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.NamedTemporaryFile" func="yes">
			<Overload retVal="" descr="Create and return a temporary file.&#10;Arguments:&#10;'prefix', 'suffix', 'dir' -- as for mkstemp.&#10;'mode' -- the mode argument to io.open (default &quot;w+b&quot;).&#10;'buffering' -- the buffer size argument to io.open (default -1).&#10;'encoding' -- the encoding argument to io.open (default None)&#10;'newline' -- the newline argument to io.open (default None)&#10;'delete' -- whether the file is deleted on close (default True).&#10;The file is created as mkstemp() would do it.&#10;&#10;Returns an object with a file-like interface; the name of the file&#10;is accessible as its 'name' attribute.  The file will be automatically&#10;deleted when it is closed unless the 'delete' argument is set to False.">
				<Param name="[mode=w+b" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[newline=None" />
				<Param name="[suffix=None" />
				<Param name="[prefix=None" />
				<Param name="[dir=None" />
				<Param name="[delete=True]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile" func="yes">
			<Overload retVal="" descr="Temporary file wrapper, specialized to switch from BytesIO&#10;or StringIO to a real file when it exceeds a certain size or&#10;when a fileno is needed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.close" />
		<KeyWord name="tempfile.SpooledTemporaryFile.closed" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.encoding" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.fileno" />
		<KeyWord name="tempfile.SpooledTemporaryFile.flush" />
		<KeyWord name="tempfile.SpooledTemporaryFile.isatty" />
		<KeyWord name="tempfile.SpooledTemporaryFile.mode" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.newlines" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.read" />
		<KeyWord name="tempfile.SpooledTemporaryFile.readline" />
		<KeyWord name="tempfile.SpooledTemporaryFile.readlines" />
		<KeyWord name="tempfile.SpooledTemporaryFile.rollover" />
		<KeyWord name="tempfile.SpooledTemporaryFile.seek" />
		<KeyWord name="tempfile.SpooledTemporaryFile.softspace" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.tell" />
		<KeyWord name="tempfile.SpooledTemporaryFile.truncate" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[size=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.SpooledTemporaryFile.write" />
		<KeyWord name="tempfile.SpooledTemporaryFile.writelines" />
		<KeyWord name="tempfile.TMP_MAX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.TemporaryDirectory" func="yes">
			<Overload retVal="" descr="Create and return a temporary directory.  This has the same&#10;behavior as mkdtemp but can be used as a context manager.  For&#10;example:&#10;&#10;    with TemporaryDirectory() as tmpdir:&#10;        ...&#10;&#10;Upon exiting the context, the directory and everything contained&#10;in it are removed.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.TemporaryDirectory.cleanup" />
		<KeyWord name="tempfile.TemporaryFile" func="yes">
			<Overload retVal="" descr="Create and return a temporary file.&#10;Arguments:&#10;'prefix', 'suffix', 'dir' -- as for mkstemp.&#10;'mode' -- the mode argument to io.open (default &quot;w+b&quot;).&#10;'buffering' -- the buffer size argument to io.open (default -1).&#10;'encoding' -- the encoding argument to io.open (default None)&#10;'newline' -- the newline argument to io.open (default None)&#10;'delete' -- whether the file is deleted on close (default True).&#10;The file is created as mkstemp() would do it.&#10;&#10;Returns an object with a file-like interface; the name of the file&#10;is accessible as its 'name' attribute.  The file will be automatically&#10;deleted when it is closed unless the 'delete' argument is set to False.">
				<Param name="[mode=w+b" />
				<Param name="[buffering=-1" />
				<Param name="[encoding=None" />
				<Param name="[newline=None" />
				<Param name="[suffix=None" />
				<Param name="[prefix=None" />
				<Param name="[dir=None" />
				<Param name="[delete=True]]]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.gettempdir" func="yes">
			<Overload retVal="" descr="Accessor for tempfile.tempdir.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.gettempdirb" func="yes">
			<Overload retVal="" descr="A bytes version of tempfile.gettempdir().">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.gettempprefix" func="yes">
			<Overload retVal="" descr="The default prefix for temporary directories.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.gettempprefixb" func="yes">
			<Overload retVal="" descr="The default prefix for temporary directories as bytes.">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.mkdtemp" func="yes">
			<Overload retVal="" descr="User-callable function to create and return a unique temporary&#10;directory.  The return value is the pathname of the directory.&#10;&#10;Arguments are as for mkstemp, except that the 'text' argument is&#10;not accepted.&#10;&#10;The directory is readable, writable, and searchable only by the&#10;creating user.&#10;&#10;Caller is responsible for deleting the directory when done with it.">
				<Param name="[suffix=None" />
				<Param name="[prefix=None" />
				<Param name="[dir=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.mkstemp" func="yes">
			<Overload retVal="" descr="User-callable function to create and return a unique temporary&#10;file.  The return value is a pair (fd, name) where fd is the&#10;file descriptor returned by os.open, and name is the filename.&#10;&#10;If 'suffix' is not None, the file name will end with that suffix,&#10;otherwise there will be no suffix.&#10;&#10;If 'prefix' is not None, the file name will begin with that prefix,&#10;otherwise a default prefix is used.&#10;&#10;If 'dir' is not None, the file will be created in that directory,&#10;otherwise a default directory is used.&#10;&#10;If 'text' is specified and true, the file is opened in text&#10;mode.  Else (the default) the file is opened in binary mode.  On&#10;some operating systems, this makes no difference.&#10;&#10;If any of 'suffix', 'prefix' and 'dir' are not None, they must be the&#10;same type.  If they are bytes, the returned name will be bytes; str&#10;otherwise.&#10;&#10;The file is readable and writable only by the creating user ID.&#10;If the operating system uses permission bits to indicate whether a&#10;file is executable, the file is executable by no one. The file&#10;descriptor is not inherited by children of this process.&#10;&#10;Caller is responsible for deleting the file when done with it.">
				<Param name="[suffix=None" />
				<Param name="[prefix=None" />
				<Param name="[dir=None" />
				<Param name="[text=False]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.mktemp" func="yes">
			<Overload retVal="" descr="User-callable function to return a unique temporary file name.  The&#10;file is not created.&#10;&#10;Arguments are similar to mkstemp, except that the 'text' argument is&#10;not accepted, and suffix=None, prefix=None and bytes file names are not&#10;supported.&#10;&#10;THIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may&#10;refer to a file that did not exist at some point, but by the time&#10;you get around to creating it, someone else may have beaten you to&#10;the punch.">
				<Param name="[suffix" />
				<Param name="[prefix=tmp" />
				<Param name="[dir=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tempfile.template" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tempfilepager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="template" func="yes">
			<Overload retVal="" descr="Function of re">
			</Overload>
		</KeyWord>
		<KeyWord name="terminal_size" func="yes">
			<Overload retVal="" descr="Function of os.terminal_size">
			</Overload>
		</KeyWord>
		<KeyWord name="terminate" func="yes">
			<Overload retVal="" descr="Function of asyncio.SubprocessTransport">
			</Overload>
		</KeyWord>
		<KeyWord name="test" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="test_8svx" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_aifc" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_au" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_bmp" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_exr" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_gif" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_hcom" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_jpeg" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_pbm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_pgm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_png" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_ppm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_rast" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_rgb" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_skip" func="yes">
			<Overload retVal="" descr="Function of doctest.SkipDocTestCase">
			</Overload>
		</KeyWord>
		<KeyWord name="test_sndr" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_sndt" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_tiff" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_voc" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_wav" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_webp" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="test_xbm" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="testall" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="testfile" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="testmod" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="testsource" func="yes">
			<Overload retVal="" descr="Function of doctest">
			</Overload>
		</KeyWord>
		<KeyWord name="testzip" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="text" func="yes">
			<Overload retVal="" descr="Function of cgitb">
			</Overload>
		</KeyWord>
		<KeyWord name="textdomain" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap" func="yes">
			<Overload retVal="" descr="Text wrapping and filling.">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper" func="yes">
			<Overload retVal="" descr="Object for wrapping/filling text.  The public interface consists of&#10;the wrap() and fill() methods; the other methods are just there for&#10;subclasses to override in order to tweak the default behaviour.&#10;If you want to completely replace the main wrapping algorithm,&#10;you'll probably have to override _wrap_chunks().&#10;&#10;Several instance attributes control various aspects of wrapping:&#10;  width (default: 70)&#10;    the maximum width of wrapped lines (unless break_long_words&#10;    is false)&#10;  initial_indent (default: &quot;&quot;)&#10;    string that will be prepended to the first line of wrapped&#10;    output.  Counts towards the line's width.&#10;  subsequent_indent (default: &quot;&quot;)&#10;    string that will be prepended to all lines save the first&#10;    of wrapped output; also counts towards each line's width.&#10;  expand_tabs (default: true)&#10;    Expand tabs in input text to spaces before further processing.&#10;    Each tab will become 0 .. 'tabsize' spaces, depending on its position&#10;    in its line.  If false, each tab is treated as a single character.&#10;  tabsize (default: 8)&#10;    Expand tabs in input text to 0 .. 'tabsize' spaces, unless&#10;    'expand_tabs' is false.&#10;  replace_whitespace (default: true)&#10;    Replace all whitespace characters in the input text by spaces&#10;    after tab expansion.  Note that if expand_tabs is false and&#10;    replace_whitespace is true, every tab will be converted to a&#10;    single space!&#10;  fix_sentence_endings (default: false)&#10;    Ensure that sentence-ending punctuation is always followed&#10;    by two spaces.  Off by default because the algorithm is&#10;    (unavoidably) imperfect.&#10;  break_long_words (default: true)&#10;    Break words longer than 'width'.  If false, those words will not&#10;    be broken, and some lines might be longer than 'width'.&#10;  break_on_hyphens (default: true)&#10;    Allow breaking hyphenated words. If true, wrapping will occur&#10;    preferably on whitespaces and right after hyphens part of&#10;    compound words.&#10;  drop_whitespace (default: true)&#10;    Drop leading and trailing whitespace from lines.&#10;  max_lines (default: None)&#10;    Truncate wrapped lines.&#10;  placeholder (default: ' [...]')&#10;    Append to the last line of truncated text.">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.fill" func="yes">
			<Overload retVal="" descr="fill(text : string) -&gt; string&#10;&#10;Reformat the single paragraph in 'text' to fit in lines of no&#10;more than 'self.width' columns, and return a new string&#10;containing the entire wrapped paragraph.">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.sentence_end_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.unicode_whitespace_trans" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.uspace" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.wordsep_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.wordsep_simple_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.wrap" func="yes">
			<Overload retVal="" descr="wrap(text : string) -&gt; [string]&#10;&#10;Reformat the single paragraph in 'text' so it fits in lines of&#10;no more than 'self.width' columns, and return a list of wrapped&#10;lines.  Tabs in 'text' are expanded with string.expandtabs(),&#10;and all other whitespace characters (including newline) are&#10;converted to space.">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.TextWrapper.x" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.dedent" func="yes">
			<Overload retVal="" descr='Remove any common leading whitespace from every line in `text`.&#10;&#10;This can be used to make triple-quoted strings line up with the left&#10;edge of the display, while still presenting them in the source code&#10;in indented form.&#10;&#10;Note that tabs and spaces are both treated as whitespace, but they&#10;are not equal: the lines "  hello" and "\thello" are&#10;considered to have no common leading whitespace.  (This behaviour is&#10;new in Python 2.5; older versions of this module incorrectly&#10;expanded tabs before searching for common leading whitespace.)'>
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.fill" func="yes">
			<Overload retVal="" descr="Fill a single paragraph of text, returning a new string.&#10;&#10;Reformat the single paragraph in 'text' to fit in lines of no more&#10;than 'width' columns, and return a new string containing the entire&#10;wrapped paragraph.  As with wrap(), tabs are expanded and other&#10;whitespace characters converted to space.  See TextWrapper class for&#10;available keyword args to customize wrapping behaviour.">
				<Param name="text" />
				<Param name="[width=70" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.indent" func="yes">
			<Overload retVal="" descr="Adds 'prefix' to the beginning of selected lines in 'text'.&#10;&#10;If 'predicate' is provided, 'prefix' will only be added to the lines&#10;where 'predicate(line)' is True. If 'predicate' is not provided,&#10;it will default to adding 'prefix' to all non-empty lines that do not&#10;consist solely of whitespace characters.">
				<Param name="text" />
				<Param name="prefix" />
				<Param name="[predicate=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.shorten" func="yes">
			<Overload retVal="" descr="Collapse and truncate the given text to fit in the given width.&#10;&#10;The text first has its whitespace collapsed.  If it then fits in&#10;the *width*, it is returned as is.  Otherwise, as many words&#10;as possible are joined and then the placeholder is appended::&#10;&#10;    &gt;&gt;&gt; textwrap.shorten(&quot;Hello  world!&quot;, width=12)&#10;    'Hello world!'&#10;    &gt;&gt;&gt; textwrap.shorten(&quot;Hello  world!&quot;, width=11)&#10;    'Hello [...]'">
				<Param name="text" />
				<Param name="width" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="textwrap.wrap" func="yes">
			<Overload retVal="" descr="Wrap a single paragraph of text, returning a list of wrapped lines.&#10;&#10;Reformat the single paragraph in 'text' so it fits in lines of no&#10;more than 'width' columns, and return a list of wrapped lines.  By&#10;default, tabs in 'text' are expanded with string.expandtabs(), and&#10;all other whitespace characters (including newline) are converted to&#10;space.  See TextWrapper class for available keyword args to customize&#10;wrapping behaviour.">
				<Param name="text" />
				<Param name="[width=70" />
				<Param name="[**]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="thread" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="threading" func="yes">
			<Overload retVal="" descr="Thread module emulating a subset of Java's threading model.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier" func="yes">
			<Overload retVal="" descr="Implements a Barrier.&#10;&#10;Useful for synchronizing a fixed number of threads at known synchronization&#10;points.  Threads block on 'wait()' and are simultaneously once they have all&#10;made that call.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier.abort" func="yes">
			<Overload retVal="" descr="Place the barrier into a 'broken' state.&#10;&#10;Useful in case of error.  Any currently waiting threads and threads&#10;attempting to 'wait()' will have BrokenBarrierError raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier.broken" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier.n_waiting" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier.parties" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier.reset" func="yes">
			<Overload retVal="" descr="Reset the barrier to the initial state.&#10;&#10;Any threads currently waiting will get the BrokenBarrier exception&#10;raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Barrier.wait" func="yes">
			<Overload retVal="" descr="Wait for the barrier.&#10;&#10;When the specified number of threads have started waiting, they are all&#10;simultaneously awoken. If an 'action' was provided for the barrier, one&#10;of the threads will have executed that callback prior to returning.&#10;Returns an individual index number from 0 to 'parties-1'.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BoundedSemaphore" func="yes">
			<Overload retVal="" descr="Implements a bounded semaphore.&#10;&#10;A bounded semaphore checks to make sure its current value doesn't exceed its&#10;initial value. If it does, ValueError is raised. In most situations&#10;semaphores are used to guard resources with limited capacity.&#10;&#10;If the semaphore is released too many times it's a sign of a bug. If not&#10;given, value defaults to 1.&#10;&#10;Like regular semaphores, bounded semaphores manage a counter representing&#10;the number of release() calls minus the number of acquire() calls, plus an&#10;initial value. The acquire() method blocks if necessary until it can return&#10;without making the counter negative. If not given, value defaults to 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BoundedSemaphore.acquire" func="yes">
			<Overload retVal="" descr="Acquire a semaphore, decrementing the internal counter by one.&#10;&#10;When invoked without arguments: if the internal counter is larger than&#10;zero on entry, decrement it by one and return immediately. If it is zero&#10;on entry, block, waiting until some other thread has called release() to&#10;make it larger than zero. This is done with proper interlocking so that&#10;if multiple acquire() calls are blocked, release() will wake exactly one&#10;of them up. The implementation may pick one at random, so the order in&#10;which blocked threads are awakened should not be relied on. There is no&#10;return value in this case.&#10;&#10;When invoked with blocking set to true, do the same thing as when called&#10;without arguments, and return true.&#10;&#10;When invoked with blocking set to false, do not block. If a call without&#10;an argument would block, return false immediately; otherwise, do the&#10;same thing as when called without arguments, and return true.&#10;&#10;When invoked with a timeout other than None, it will block for at&#10;most timeout seconds.  If acquire does not complete successfully in&#10;that interval, return false.  Return true otherwise.">
				<Param name="self" />
				<Param name="[blocking=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BoundedSemaphore.release" func="yes">
			<Overload retVal="" descr="Release a semaphore, incrementing the internal counter by one.&#10;&#10;When the counter is zero on entry and another thread is waiting for it&#10;to become larger than zero again, wake up that thread.&#10;&#10;If the number of releases exceeds the number of acquires,&#10;raise a ValueError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BrokenBarrierError" func="yes">
			<Overload retVal="" descr="Unspecified run-time error.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BrokenBarrierError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.BrokenBarrierError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition" func="yes">
			<Overload retVal="" descr="Class that implements a condition variable.&#10;&#10;A condition variable allows one or more threads to wait until they are&#10;notified by another thread.&#10;&#10;If the lock argument is given and not None, it must be a Lock or RLock&#10;object, and it is used as the underlying lock. Otherwise, a new RLock object&#10;is created and used as the underlying lock.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition.notify" func="yes">
			<Overload retVal="" descr="Wake up one or more threads waiting on this condition, if any.&#10;&#10;If the calling thread has not acquired the lock when this method is&#10;called, a RuntimeError is raised.&#10;&#10;This method wakes up at most n of the threads waiting for the condition&#10;variable; it is a no-op if no threads are waiting.">
				<Param name="self" />
				<Param name="[n=1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition.notifyAll" func="yes">
			<Overload retVal="" descr="Wake up all threads waiting on this condition.&#10;&#10;If the calling thread has not acquired the lock when this method&#10;is called, a RuntimeError is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition.notify_all" func="yes">
			<Overload retVal="" descr="Wake up all threads waiting on this condition.&#10;&#10;If the calling thread has not acquired the lock when this method&#10;is called, a RuntimeError is raised.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition.wait" func="yes">
			<Overload retVal="" descr="Wait until notified or until a timeout occurs.&#10;&#10;If the calling thread has not acquired the lock when this method is&#10;called, a RuntimeError is raised.&#10;&#10;This method releases the underlying lock, and then blocks until it is&#10;awakened by a notify() or notify_all() call for the same condition&#10;variable in another thread, or until the optional timeout occurs. Once&#10;awakened or timed out, it re-acquires the lock and returns.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof).&#10;&#10;When the underlying lock is an RLock, it is not released using its&#10;release() method, since this may not actually unlock the lock when it&#10;was acquired multiple times recursively. Instead, an internal interface&#10;of the RLock class is used, which really unlocks it even when it has&#10;been recursively acquired several times. Another internal interface is&#10;then used to restore the recursion level when the lock is reacquired.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Condition.wait_for" func="yes">
			<Overload retVal="" descr="Wait until a condition evaluates to True.&#10;&#10;predicate should be a callable which result will be interpreted as a&#10;boolean value.  A timeout may be provided giving the maximum time to&#10;wait.">
				<Param name="self" />
				<Param name="predicate" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event" func="yes">
			<Overload retVal="" descr="Class implementing event objects.&#10;&#10;Events manage a flag that can be set to true with the set() method and reset&#10;to false with the clear() method. The wait() method blocks until the flag is&#10;true.  The flag is initially false.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event.clear" func="yes">
			<Overload retVal="" descr="Reset the internal flag to false.&#10;&#10;Subsequently, threads calling wait() will block until set() is called to&#10;set the internal flag to true again.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event.isSet" func="yes">
			<Overload retVal="" descr="Return true if and only if the internal flag is true.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event.is_set" func="yes">
			<Overload retVal="" descr="Return true if and only if the internal flag is true.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event.set" func="yes">
			<Overload retVal="" descr="Set the internal flag to true.&#10;&#10;All threads waiting for it to become true are awakened. Threads&#10;that call wait() once the flag is true will not block at all.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Event.wait" func="yes">
			<Overload retVal="" descr="Block until the internal flag is true.&#10;&#10;If the internal flag is true on entry, return immediately. Otherwise,&#10;block until another thread calls set() to set the flag to true, or until&#10;the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof).&#10;&#10;This method returns the internal flag on exit, so it will always return&#10;True except if a timeout is given and the operation times out.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Lock" func="yes">
			<Overload retVal="" descr="allocate_lock() -&gt; lock object&#10;(allocate() is an obsolete synonym)&#10;&#10;Create a new lock object. See help(type(threading.Lock())) for&#10;information about locks.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.RLock" func="yes">
			<Overload retVal="" descr="Factory function that returns a new reentrant lock.&#10;&#10;A reentrant lock must be released by the thread that acquired it. Once a&#10;thread has acquired a reentrant lock, the same thread may acquire it again&#10;without blocking; the thread must release it once for each time it has&#10;acquired it.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Semaphore" func="yes">
			<Overload retVal="" descr="This class implements semaphore objects.&#10;&#10;Semaphores manage a counter representing the number of release() calls minus&#10;the number of acquire() calls, plus an initial value. The acquire() method&#10;blocks if necessary until it can return without making the counter&#10;negative. If not given, value defaults to 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Semaphore.acquire" func="yes">
			<Overload retVal="" descr="Acquire a semaphore, decrementing the internal counter by one.&#10;&#10;When invoked without arguments: if the internal counter is larger than&#10;zero on entry, decrement it by one and return immediately. If it is zero&#10;on entry, block, waiting until some other thread has called release() to&#10;make it larger than zero. This is done with proper interlocking so that&#10;if multiple acquire() calls are blocked, release() will wake exactly one&#10;of them up. The implementation may pick one at random, so the order in&#10;which blocked threads are awakened should not be relied on. There is no&#10;return value in this case.&#10;&#10;When invoked with blocking set to true, do the same thing as when called&#10;without arguments, and return true.&#10;&#10;When invoked with blocking set to false, do not block. If a call without&#10;an argument would block, return false immediately; otherwise, do the&#10;same thing as when called without arguments, and return true.&#10;&#10;When invoked with a timeout other than None, it will block for at&#10;most timeout seconds.  If acquire does not complete successfully in&#10;that interval, return false.  Return true otherwise.">
				<Param name="self" />
				<Param name="[blocking=True" />
				<Param name="[timeout=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Semaphore.release" func="yes">
			<Overload retVal="" descr="Release a semaphore, incrementing the internal counter by one.&#10;&#10;When the counter is zero on entry and another thread is waiting for it&#10;to become larger than zero again, wake up that thread.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.TIMEOUT_MAX" func="yes">
			<Overload retVal="" descr="(float)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread" func="yes">
			<Overload retVal="" descr="A class that represents a thread of control.&#10;&#10;This class can be safely subclassed in a limited fashion. There are two ways&#10;to specify the activity: by passing a callable object to the constructor, or&#10;by overriding the run() method in a subclass.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.getName" />
		<KeyWord name="threading.Thread.get_name" />
		<KeyWord name="threading.Thread.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.isAlive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.isDaemon" />
		<KeyWord name="threading.Thread.is_alive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.join" func="yes">
			<Overload retVal="" descr="Wait until the thread terminates.&#10;&#10;This blocks the calling thread until the thread whose join() method is&#10;called terminates -- either normally or through an unhandled exception&#10;or until the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof). As join() always returns None, you must call&#10;isAlive() after join() to decide whether a timeout happened -- if the&#10;thread is still alive, the join() call timed out.&#10;&#10;When the timeout argument is not present or None, the operation will&#10;block until the thread terminates.&#10;&#10;A thread can be join()ed many times.&#10;&#10;join() raises a RuntimeError if an attempt is made to join the current&#10;thread as that would cause a deadlock. It is also an error to join() a&#10;thread before it has been started and attempts to do so raises the same&#10;exception.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.run" func="yes">
			<Overload retVal="" descr="Method representing the thread's activity.&#10;&#10;You may override this method in a subclass. The standard run() method&#10;invokes the callable object passed to the object's constructor as the&#10;target argument, if any, with sequential and keyword arguments taken&#10;from the args and kwargs arguments, respectively.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Thread.setDaemon" />
		<KeyWord name="threading.Thread.setName" />
		<KeyWord name="threading.Thread.start" func="yes">
			<Overload retVal="" descr="Start the thread's activity.&#10;&#10;It must be called at most once per thread object. It arranges for the&#10;object's run() method to be invoked in a separate thread of control.&#10;&#10;This method will raise a RuntimeError if called more than once on the&#10;same thread object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.ThreadError" func="yes">
			<Overload retVal="" descr="Unspecified run-time error.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.ThreadError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.ThreadError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer" func="yes">
			<Overload retVal="" descr="Call a function after a specified number of seconds:&#10;&#10;t = Timer(30.0, f, args=None, kwargs=None)&#10;t.start()&#10;t.cancel()     # stop the timer's action if it's still waiting">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.cancel" func="yes">
			<Overload retVal="" descr="Stop the timer if it hasn't finished yet.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.daemon" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.getName" />
		<KeyWord name="threading.Timer.get_name" />
		<KeyWord name="threading.Timer.ident" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.isAlive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.isDaemon" />
		<KeyWord name="threading.Timer.is_alive" func="yes">
			<Overload retVal="" descr="Return whether the thread is alive.&#10;&#10;This method returns True just before the run() method starts until just&#10;after the run() method terminates. The module function enumerate()&#10;returns a list of all alive threads.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.join" func="yes">
			<Overload retVal="" descr="Wait until the thread terminates.&#10;&#10;This blocks the calling thread until the thread whose join() method is&#10;called terminates -- either normally or through an unhandled exception&#10;or until the optional timeout occurs.&#10;&#10;When the timeout argument is present and not None, it should be a&#10;floating point number specifying a timeout for the operation in seconds&#10;(or fractions thereof). As join() always returns None, you must call&#10;isAlive() after join() to decide whether a timeout happened -- if the&#10;thread is still alive, the join() call timed out.&#10;&#10;When the timeout argument is not present or None, the operation will&#10;block until the thread terminates.&#10;&#10;A thread can be join()ed many times.&#10;&#10;join() raises a RuntimeError if an attempt is made to join the current&#10;thread as that would cause a deadlock. It is also an error to join() a&#10;thread before it has been started and attempts to do so raises the same&#10;exception.">
				<Param name="self" />
				<Param name="[timeout=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.name" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.run" func="yes">
			<Overload retVal="" descr="Method representing the thread's activity.&#10;&#10;You may override this method in a subclass. The standard run() method&#10;invokes the callable object passed to the object's constructor as the&#10;target argument, if any, with sequential and keyword arguments taken&#10;from the args and kwargs arguments, respectively.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.Timer.setDaemon" />
		<KeyWord name="threading.Timer.setName" />
		<KeyWord name="threading.Timer.start" func="yes">
			<Overload retVal="" descr="Start the thread's activity.&#10;&#10;It must be called at most once per thread object. It arranges for the&#10;object's run() method to be invoked in a separate thread of control.&#10;&#10;This method will raise a RuntimeError if called more than once on the&#10;same thread object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.WeakSet" />
		<KeyWord name="threading.WeakSet.add" />
		<KeyWord name="threading.WeakSet.clear" />
		<KeyWord name="threading.WeakSet.copy" />
		<KeyWord name="threading.WeakSet.difference" />
		<KeyWord name="threading.WeakSet.difference_update" />
		<KeyWord name="threading.WeakSet.discard" />
		<KeyWord name="threading.WeakSet.intersection" />
		<KeyWord name="threading.WeakSet.intersection_update" />
		<KeyWord name="threading.WeakSet.isdisjoint" />
		<KeyWord name="threading.WeakSet.issubset" />
		<KeyWord name="threading.WeakSet.issuperset" />
		<KeyWord name="threading.WeakSet.pop" />
		<KeyWord name="threading.WeakSet.remove" />
		<KeyWord name="threading.WeakSet.symmetric_difference" />
		<KeyWord name="threading.WeakSet.symmetric_difference_update" />
		<KeyWord name="threading.WeakSet.union" />
		<KeyWord name="threading.WeakSet.update" />
		<KeyWord name="threading.activeCount" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.active_count" func="yes">
			<Overload retVal="" descr="Return the number of Thread objects currently alive.&#10;&#10;The returned count is equal to the length of the list returned by&#10;enumerate().">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.currentThread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.current_thread" func="yes">
			<Overload retVal="" descr="Return the current Thread object, corresponding to the caller's thread of control.&#10;&#10;If the caller's thread of control was not created through the threading&#10;module, a dummy thread object with limited functionality is returned.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.enumerate" func="yes">
			<Overload retVal="" descr="Return a list of all Thread objects currently alive.&#10;&#10;The list includes daemonic threads, dummy thread objects created by&#10;current_thread(), and the main thread. It excludes terminated threads and&#10;threads that have not yet been started.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.get_ident" func="yes">
			<Overload retVal="" descr="get_ident() -&gt; integer&#10;&#10;Return a non-zero integer that uniquely identifies the current thread&#10;amongst other threads that exist simultaneously.&#10;This may be used to identify per-thread resources.&#10;Even though on some platforms threads identities may appear to be&#10;allocated consecutive numbers starting at 1, this behavior should not&#10;be relied upon, and the number should be seen purely as a magic cookie.&#10;A thread's identity may be reused for another thread after it exits.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.local" func="yes">
			<Overload retVal="" descr="Thread-local data">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.main_thread" func="yes">
			<Overload retVal="" descr="Return the main thread object.&#10;&#10;In normal conditions, the main thread is the thread from which the&#10;Python interpreter was started.">
			</Overload>
		</KeyWord>
		<KeyWord name="threading.setprofile" func="yes">
			<Overload retVal="" descr="Set a profile function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.setprofile() for each thread, before its&#10;run() method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.settrace" func="yes">
			<Overload retVal="" descr="Set a trace function for all threads started from the threading module.&#10;&#10;The func will be passed to sys.settrace() for each thread, before its run()&#10;method is called.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="threading.stack_size" func="yes">
			<Overload retVal="" descr="stack_size([size]) -&gt; size&#10;&#10;Return the thread stack size used when creating new threads.  The&#10;optional size argument specifies the stack size (in bytes) to be used&#10;for subsequently created threads, and must be 0 (use platform or&#10;configured default) or a positive integer value of at least 32,768 (32k).&#10;If changing the thread stack size is unsupported, a ThreadError&#10;exception is raised.  If the specified size is invalid, a ValueError&#10;exception is raised, and the stack size is unmodified.  32k bytes&#10; currently the minimum supported stack size value to guarantee&#10;sufficient stack space for the interpreter itself.&#10;&#10;Note that some platforms may have particular restrictions on values for&#10;the stack size, such as requiring a minimum stack size larger than 32kB or&#10;requiring allocation in multiples of the system memory page size&#10;- platform documentation should be referred to for more information&#10;(4kB pages are common; using multiples of 4096 for the stack size is&#10;the suggested approach in the absence of more specific information).">
			</Overload>
		</KeyWord>
		<KeyWord name="throw" func="yes">
			<Overload retVal="" descr="Function of types.CoroutineType">
			</Overload>
		</KeyWord>
		<KeyWord name="time" func="yes">
			<Overload retVal="" descr="Function of queue">
			</Overload>
		</KeyWord>
		<KeyWord name="timedelta" func="yes">
			<Overload retVal="" descr="Function of datetime.timedelta">
			</Overload>
		</KeyWord>
		<KeyWord name="timegm" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit" func="yes">
			<Overload retVal="" descr="Tool for measuring execution time of small code snippets.&#10;&#10;This module avoids a number of common traps for measuring execution&#10;times.  See also Tim Peters' introduction to the Algorithms chapter in&#10;the Python Cookbook, published by O'Reilly.&#10;&#10;Library usage: see the Timer class.&#10;&#10;Command line usage:&#10;    python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-p] [-h] [--] [statement]&#10;&#10;Options:&#10;  -n/--number N: how many times to execute 'statement' (default: see below)&#10;  -r/--repeat N: how many times to repeat the timer (default 3)&#10;  -s/--setup S: statement to be executed once initially (default 'pass').&#10;                Execution time of this setup statement is NOT timed.&#10;  -p/--process: use time.process_time() (default is time.perf_counter())&#10;  -t/--time: use time.time() (deprecated)&#10;  -c/--clock: use time.clock() (deprecated)&#10;  -v/--verbose: print raw timing results; repeat for more digits precision&#10;  -u/--unit: set the output time unit (usec, msec, or sec)&#10;  -h/--help: print this usage message and exit&#10;  --: separate options from statement, use when statement starts with -&#10;  statement: statement to be timed (default 'pass')&#10;&#10;A multi-line statement may be given by specifying each line as a&#10;separate argument; indented lines are possible by enclosing an&#10;argument in quotes and using leading spaces.  Multiple -s options are&#10;treated similarly.&#10;&#10;If -n is not given, a suitable number of loops is calculated by trying&#10;successive powers of 10 until the total time is at least 0.2 seconds.&#10;&#10;Note: there is a certain baseline overhead associated with executing a&#10;pass statement.  It differs between versions.  The code here doesn't try&#10;to hide it, but you should be aware of it.  The baseline overhead can be&#10;measured by invoking the program without arguments.&#10;&#10;Classes:&#10;&#10;    Timer&#10;&#10;Functions:&#10;&#10;    timeit(string, string) -&gt; float&#10;    repeat(string, string) -&gt; list&#10;    default_timer() -&gt; float">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.Timer" func="yes">
			<Overload retVal="" descr="Class for timing execution speed of small code snippets.&#10;&#10;The constructor takes a statement to be timed, an additional&#10;statement used for setup, and a timer function.  Both statements&#10;default to 'pass'; the timer function is platform-dependent (see&#10;module doc string).  If 'globals' is specified, the code will be&#10;executed within that namespace (as opposed to inside timeit's&#10;namespace).&#10;&#10;To measure the execution time of the first statement, use the&#10;timeit() method.  The repeat() method is a convenience to call&#10;timeit() multiple times and return a list of results.&#10;&#10;The statements may contain newlines, as long as they don't contain&#10;multi-line string literals.">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.Timer.autorange" func="yes">
			<Overload retVal="" descr="Return the number of loops and time taken so that total time &gt;= 0.2.&#10;&#10;Calls the timeit method with *number* set to successive powers of&#10;ten (10, 100, 1000, ...) up to a maximum of one billion, until&#10;the time taken is at least 0.2 second, or the maximum is reached.&#10;Returns ``(number, time_taken)``.&#10;&#10;If *callback* is given and is not None, it will be called after&#10;each trial with two arguments: ``callback(number, time_taken)``.">
				<Param name="self" />
				<Param name="[callback=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.Timer.print_exc" func="yes">
			<Overload retVal="" descr="Helper to print a traceback from the timed code.&#10;&#10;Typical use:&#10;&#10;    t = Timer(...)       # outside the try/except&#10;    try:&#10;        t.timeit(...)    # or t.repeat(...)&#10;    except:&#10;        t.print_exc()&#10;&#10;The advantage over the standard traceback is that source lines&#10;in the compiled template will be displayed.&#10;&#10;The optional file argument directs where the traceback is&#10;sent; it defaults to sys.stderr.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.Timer.repeat" func="yes">
			<Overload retVal="" descr="Call timeit() a few times.&#10;&#10;This is a convenience function that calls the timeit()&#10;repeatedly, returning a list of results.  The first argument&#10;specifies how many times to call timeit(), defaulting to 3;&#10;the second argument specifies the timer argument, defaulting&#10;to one million.&#10;&#10;Note: it's tempting to calculate mean and standard deviation&#10;from the result vector and report these.  However, this is not&#10;very useful.  In a typical case, the lowest value gives a&#10;lower bound for how fast your machine can run the given code&#10;snippet; higher values in the result vector are typically not&#10;caused by variability in Python's speed, but by other&#10;processes interfering with your timing accuracy.  So the min()&#10;of the result is probably the only number you should be&#10;interested in.  After that, you should look at the entire&#10;vector and apply common sense rather than statistics.">
				<Param name="self" />
				<Param name="[repeat=3" />
				<Param name="[number=1000000]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.Timer.timeit" func="yes">
			<Overload retVal="" descr="Time 'number' executions of the main statement.&#10;&#10;To be precise, this executes the setup statement once, and&#10;then returns the time it takes to execute the main statement&#10;a number of times, as a float measured in seconds.  The&#10;argument is the number of times through the loop, defaulting&#10;to one million.  The main statement, the setup statement and&#10;the timer function to be used are passed to the constructor.">
				<Param name="self" />
				<Param name="[number=1000000]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.default_number" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.default_repeat" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.default_timer" func="yes">
			<Overload retVal="" descr="perf_counter() -&gt; float&#10;&#10;Performance counter for benchmarking.">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.dummy_src_name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.main" func="yes">
			<Overload retVal="" descr="Main program, used when run as a script.&#10;&#10;The optional 'args' argument specifies the command line to be parsed,&#10;defaulting to sys.argv[1:].&#10;&#10;The return value is an exit code to be passed to sys.exit(); it&#10;may be None to indicate success.&#10;&#10;When an exception happens during timing, a traceback is printed to&#10;stderr and the return value is 1.  Exceptions at other times&#10;(including the template compilation) are not caught.&#10;&#10;'_wrap_timer' is an internal interface used for unit testing.  If it&#10;is not None, it must be a callable that accepts a timer function&#10;and returns another timer function (used for unit testing).">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.reindent" func="yes">
			<Overload retVal="" descr="Helper to reindent a multi-line statement.">
				<Param name="src" />
				<Param name="indent" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.repeat" func="yes">
			<Overload retVal="" descr="Convenience function to create Timer object and call repeat method.">
				<Param name="[stmt=pass" />
				<Param name="[setup=pass" />
				<Param name="[timer=<built-in function perf_counter>" />
				<Param name="[repeat=3" />
				<Param name="[number=1000000" />
				<Param name="[globals=None]]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.template" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="timeit.timeit" func="yes">
			<Overload retVal="" descr="Convenience function to create Timer object and call timeit method.">
				<Param name="[stmt=pass" />
				<Param name="[setup=pass" />
				<Param name="[timer=<built-in function perf_counter>" />
				<Param name="[number=1000000" />
				<Param name="[globals=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="timeout" func="yes">
			<Overload retVal="" descr="Function of socket.timeout">
			</Overload>
		</KeyWord>
		<KeyWord name="times" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="times_result" func="yes">
			<Overload retVal="" descr="Function of os.times_result">
			</Overload>
		</KeyWord>
		<KeyWord name="timestamp" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="timetuple" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="timetz" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="timezone" func="yes">
			<Overload retVal="" descr="Function of datetime.timezone">
			</Overload>
		</KeyWord>
		<KeyWord name="title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; str&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="to_bytes" func="yes">
			<Overload retVal="" descr="int.to_bytes(length, byteorder, *, signed=False) -&gt; bytes&#10;&#10;Return an array of bytes representing an integer.&#10;&#10;The integer is represented using length bytes.  An OverflowError is&#10;raised if the integer is not representable with the given number of&#10;bytes.&#10;&#10;The byteorder argument determines the byte order used to represent the&#10;integer.  If byteorder is 'big', the most significant byte is at the&#10;beginning of the byte array.  If byteorder is 'little', the most&#10;significant byte is at the end of the byte array.  To request the native&#10;byte order of the host system, use `sys.byteorder' as the byte order value.&#10;&#10;The signed keyword-only argument determines whether two's complement is&#10;used to represent the integer.  If signed is False and a negative integer&#10;is given, an OverflowError is raised.">
			</Overload>
		</KeyWord>
		<KeyWord name="to_eng_string" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_filename" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="to_integral" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_integral_exact" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_integral_value" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="to_sci_string" func="yes">
			<Overload retVal="" descr="Function of decimal.Context">
			</Overload>
		</KeyWord>
		<KeyWord name="tobuf" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarInfo">
			</Overload>
		</KeyWord>
		<KeyWord name="tobytes" func="yes">
			<Overload retVal="" descr="Return the data in the buffer as a byte string.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="today" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="token" func="yes">
			<Overload retVal="" descr='Token constants (from "token.h").'>
			</Overload>
		</KeyWord>
		<KeyWord name="token.AMPER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.AMPEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ASYNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.AT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ATEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.AWAIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.CIRCUMFLEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.CIRCUMFLEXEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.COLON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.COMMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESTAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.DOUBLESTAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ELLIPSIS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.EQEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.EQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ERRORTOKEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.GREATER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.GREATEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.INDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.ISEOF" />
		<KeyWord name="token.ISNONTERMINAL" />
		<KeyWord name="token.ISTERMINAL" />
		<KeyWord name="token.LBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LEFTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LEFTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LESS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LESSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.LSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.MINEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.MINUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NEWLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NOTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NT_OFFSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.NUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.N_TOKENS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.OP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PERCENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PERCENTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PLUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.PLUSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RARROW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RIGHTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RIGHTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.RSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.SEMI" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.SLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.SLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.STAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.STAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.STRING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.TILDE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.VBAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.VBAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="token.tok_name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="token_bytes" func="yes">
			<Overload retVal="" descr="Function of secrets">
			</Overload>
		</KeyWord>
		<KeyWord name="token_hex" func="yes">
			<Overload retVal="" descr="Function of secrets">
			</Overload>
		</KeyWord>
		<KeyWord name="token_urlsafe" func="yes">
			<Overload retVal="" descr="Function of secrets">
			</Overload>
		</KeyWord>
		<KeyWord name="tokeneater" func="yes">
			<Overload retVal="" descr="Function of inspect.BlockFinder">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize" func="yes">
			<Overload retVal="" descr='Tokenization help for Python programs.&#10;&#10;tokenize(readline) is a generator that breaks a stream of bytes into&#10;Python tokens.  It decodes the bytes according to PEP-0263 for&#10;determining source file encoding.&#10;&#10;It accepts a readline-like method which is called repeatedly to get the&#10;next line of input (or b"" for EOF).  It generates 5-tuples with these&#10;members:&#10;&#10;    the token type (see token.py)&#10;    the token (a string)&#10;    the starting (row, column) indices of the token (a 2-tuple of ints)&#10;    the ending (row, column) indices of the token (a 2-tuple of ints)&#10;    the original line (string)&#10;&#10;It is designed to match the working of the Python tokenizer exactly, except&#10;that it produces COMMENT tokens for comments and gives type OP for all&#10;operators.  Additionally, all token lists start with an ENCODING token&#10;which tells you which encoding was used to decode the bytes stream.'>
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AMPER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AMPEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ASYNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ATEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.AWAIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.BOM_UTF8" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Binnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Bracket" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.CIRCUMFLEX" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.CIRCUMFLEXEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.COLON" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.COMMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.COMMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Comment" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ContStr" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DEDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESTAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.DOUBLESTAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Decnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Double" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Double3" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ELLIPSIS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ENCODING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.EQEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.EQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ERRORTOKEN" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.EXACT_TOKEN_TYPES" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Expfloat" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Exponent" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Floatnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Funny" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.GREATER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.GREATEREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Hexnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.INDENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.ISEOF" />
		<KeyWord name="tokenize.ISNONTERMINAL" />
		<KeyWord name="tokenize.ISTERMINAL" />
		<KeyWord name="tokenize.Ignore" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Imagnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Intnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LEFTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LEFTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LESS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LESSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.LSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.MINEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.MINUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NEWLINE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NOTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NT_OFFSET" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.NUMBER" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.N_TOKENS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Name" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Number" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.OP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Octnumber" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Operator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PERCENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PERCENTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PLUS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PLUSEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PlainToken" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Pointfloat" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PseudoExtras" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.PseudoToken" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RARROW" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RBRACE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RIGHTSHIFT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RIGHTSHIFTEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RPAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.RSQB" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.SEMI" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.SLASH" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.SLASHEQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.STAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.STAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.STRING" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Single" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Single3" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Special" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.StopTokenizing" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.StopTokenizing.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.StopTokenizing.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.String" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.StringPrefix" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TILDE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper" func="yes">
			<Overload retVal="" descr="Character and line based layer over a BufferedIOBase object, buffer.&#10;&#10;encoding gives the name of the encoding that the stream will be&#10;decoded or encoded with. It defaults to locale.getpreferredencoding(False).&#10;&#10;errors determines the strictness of encoding and decoding (see&#10;help(codecs.Codec) or the documentation for codecs.register) and&#10;defaults to &quot;strict&quot;.&#10;&#10;newline controls how line endings are handled. It can be None, '',&#10;'\n', '\r', and '\r\n'.  It works as follows:&#10;&#10;* On input, if newline is None, universal newlines mode is&#10;  enabled. Lines in the input can end in '\n', '\r', or '\r\n', and&#10;  these are translated into '\n' before being returned to the&#10;  caller. If it is '', universal newline mode is enabled, but line&#10;  endings are returned to the caller untranslated. If it has any of&#10;  the other legal values, input lines are only terminated by the given&#10;  string, and the line ending is returned to the caller untranslated.&#10;&#10;* On output, if newline is None, any '\n' characters written are&#10;  translated to the system default line separator, os.linesep. If&#10;  newline is '' or '\n', no translation takes place. If newline is any&#10;  of the other legal values, any '\n' characters written are translated&#10;  to the given string.&#10;&#10;If line_buffering is True, a call to flush is implied when a call to&#10;write contains a newline character.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.buffer" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.close" func="yes">
			<Overload retVal="" descr="Flush and close the IO object.&#10;&#10;This method has no effect if the file is already closed.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.detach" func="yes">
			<Overload retVal="" descr="Separate the underlying buffer from the TextIOBase and return it.&#10;&#10;After the underlying buffer has been detached, the TextIO is in an&#10;unusable state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.encoding" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.errors" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.flush" func="yes">
			<Overload retVal="" descr="Flush write buffers, if applicable.&#10;&#10;This is not implemented for read-only and non-blocking streams.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.isatty" func="yes">
			<Overload retVal="" descr="Return whether this is an 'interactive' stream.&#10;&#10;Return False if it can't be determined.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.line_buffering" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.name" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.newlines" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.read" func="yes">
			<Overload retVal="" descr="Read at most n characters from stream.&#10;&#10;Read from underlying buffer until we have n characters or we hit EOF.&#10;If n is negative or omitted, read until EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.readable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for reading.&#10;&#10;If False, read() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.readline" func="yes">
			<Overload retVal="" descr="Read until newline or EOF.&#10;&#10;Returns an empty string if EOF is hit immediately.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.readlines" func="yes">
			<Overload retVal="" descr="Return a list of lines from the stream.&#10;&#10;hint can be specified to control the number of lines read: no more&#10;lines will be read if the total size (in bytes/characters) of all&#10;lines so far exceeds hint.">
				<Param name="self" />
				<Param name="hint" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Change the stream position to the given byte offset. The offset is&#10;interpreted relative to the position indicated by whence.  Values&#10;for whence are:&#10;&#10;* 0 -- start of stream (the default); offset should be zero or positive&#10;* 1 -- current stream position; offset may be negative&#10;* 2 -- end of stream; offset is usually negative&#10;&#10;Return the new absolute position.">
				<Param name="self" />
				<Param name="cookie" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.seekable" func="yes">
			<Overload retVal="" descr="Return whether object supports random access.&#10;&#10;If False, seek(), tell() and truncate() will raise OSError.&#10;This method may need to do a test seek().">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.tell" func="yes">
			<Overload retVal="" descr="Return current stream position.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.truncate" func="yes">
			<Overload retVal="" descr="Truncate file to size bytes.&#10;&#10;File pointer is left unchanged.  Size defaults to the current IO&#10;position as reported by tell().  Returns the new size.">
				<Param name="self" />
				<Param name="pos" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.writable" func="yes">
			<Overload retVal="" descr="Return whether object was opened for writing.&#10;&#10;If False, write() will raise OSError.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.write" func="yes">
			<Overload retVal="" descr="Write string to stream.&#10;Returns the number of characters written (which is always equal to&#10;the length of the string).">
				<Param name="self" />
				<Param name="text" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TextIOWrapper.writelines" />
		<KeyWord name="tokenize.Token" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenError" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo" func="yes">
			<Overload retVal="" descr="TokenInfo(type, string, start, end, line)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.count" func="yes">
			<Overload retVal="" descr="T.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.end" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.exact_type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.index" func="yes">
			<Overload retVal="" descr="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.line" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.start" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.string" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.TokenInfo.type" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Triple" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Untokenizer" />
		<KeyWord name="tokenize.Untokenizer.add_whitespace" />
		<KeyWord name="tokenize.Untokenizer.compat" />
		<KeyWord name="tokenize.Untokenizer.untokenize" />
		<KeyWord name="tokenize.VBAR" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.VBAREQUAL" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.Whitespace" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.any" />
		<KeyWord name="tokenize.blank_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.chain" func="yes">
			<Overload retVal="" descr="chain(*iterables) --&gt; chain object&#10;&#10;Return a chain object whose .__next__() method returns elements from the&#10;first iterable until it is exhausted, then elements from the next&#10;iterable, until all of the iterables are exhausted.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.chain.from_iterable" func="yes">
			<Overload retVal="" descr="chain.from_iterable(iterable) --&gt; chain object&#10;&#10;Alternate chain() constructor taking a single iterable argument&#10;that evaluates lazily.">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.cookie_re" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.detect_encoding" func="yes">
			<Overload retVal="" descr="The detect_encoding() function is used to detect the encoding that should&#10;be used to decode a Python source file.  It requires one argument, readline,&#10;in the same way as the tokenize() generator.&#10;&#10;It will call readline a maximum of twice, and return the encoding used&#10;(as a string) and a list of any lines (left as bytes) it has read in.&#10;&#10;It detects the encoding from the presence of a utf-8 bom or an encoding&#10;cookie as specified in pep-0263.  If both a bom and a cookie are present,&#10;but disagree, a SyntaxError will be raised.  If the encoding cookie is an&#10;invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,&#10;'utf-8-sig' is returned.&#10;&#10;If no encoding is specified, then the default of 'utf-8' will be returned.">
				<Param name="readline" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.endpats" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.generate_tokens" />
		<KeyWord name="tokenize.group" />
		<KeyWord name="tokenize.lookup" func="yes">
			<Overload retVal="" descr="Looks up a codec tuple in the Python codec registry and returns a CodecInfo object.">
				<Param name="encoding" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.main" />
		<KeyWord name="tokenize.maybe" />
		<KeyWord name="tokenize.open" func="yes">
			<Overload retVal="" descr="Open a file in read only mode using the encoding detected by&#10;detect_encoding().">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.single_quoted" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.t" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tabsize" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tok_name" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.tokenize" func="yes">
			<Overload retVal="" descr="The tokenize() generator requires one argument, readline, which&#10;must be a callable object which provides the same interface as the&#10;readline() method of built-in file objects.  Each call to the function&#10;should return one line of input as bytes.  Alternatively, readline&#10;can be a callable function terminating with StopIteration:&#10;    readline = open(myfile, 'rb').__next__  # Example of alternate readline&#10;&#10;The generator produces 5-tuples with these members: the token type; the&#10;token string; a 2-tuple (srow, scol) of ints specifying the row and&#10;column where the token begins in the source; a 2-tuple (erow, ecol) of&#10;ints specifying the row and column where the token ends in the source;&#10;and the line on which the token was found.  The line passed is the&#10;logical line; continuation lines are included.&#10;&#10;The first token sequence will always be an ENCODING token&#10;which tells you which encoding was used to decode the bytes stream.">
				<Param name="readline" />
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.triple_quoted" func="yes">
			<Overload retVal="" descr="(set)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.u" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="tokenize.untokenize" func="yes">
			<Overload retVal="" descr="Transform tokens back into Python source code.&#10;It returns a bytes object, encoded using the ENCODING&#10;token, which is the first token sequence output by tokenize.&#10;&#10;Each element returned by the iterable must be a token sequence&#10;with at least two elements, a token number and token value.  If&#10;only two tokens are passed, the resulting output is poor.&#10;&#10;Round-trip invariant for full input:&#10;    Untokenized source will match input source exactly&#10;&#10;Round-trip invariant for limited input:&#10;    # Output bytes will tokenize back to the input&#10;    t1 = [tok[:2] for tok in tokenize(f.readline)]&#10;    newcode = untokenize(t1)&#10;    readline = BytesIO(newcode).readline&#10;    t2 = [tok[:2] for tok in tokenize(readline)]&#10;    assert t1 == t2">
				<Param name="iterable" />
			</Overload>
		</KeyWord>
		<KeyWord name="tolist" func="yes">
			<Overload retVal="" descr="Return the data in the buffer as a list of elements.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="toordinal" func="yes">
			<Overload retVal="" descr="Function of datetime.date">
			</Overload>
		</KeyWord>
		<KeyWord name="top" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="total_ordering" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="total_seconds" func="yes">
			<Overload retVal="" descr="Function of datetime.timedelta">
			</Overload>
		</KeyWord>
		<KeyWord name="touch" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="trace" func="yes">
			<Overload retVal="" descr="program/module to trace Python program or function execution&#10;&#10;Sample use, command line:&#10;  trace.py -c -f counts --ignore-dir '$prefix' spam.py eggs&#10;  trace.py -t --ignore-dir '$prefix' spam.py eggs&#10;  trace.py --trackcalls spam.py eggs&#10;&#10;Sample use, programmatically&#10;  import sys&#10;&#10;  # create a Trace object, telling it what to ignore, and whether to&#10;  # do tracing or line-counting or both.&#10;  tracer = trace.Trace(ignoredirs=[sys.base_prefix, sys.base_exec_prefix,],&#10;                       trace=0, count=1)&#10;  # run the new command using the given tracer&#10;  tracer.run('main()')&#10;  # make a report, placing output in /tmp&#10;  r = tracer.results()&#10;  r.write_results(show_missing=True, coverdir=&quot;/tmp&quot;)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.CoverageResults" />
		<KeyWord name="trace.CoverageResults.is_ignored_filename" func="yes">
			<Overload retVal="" descr="Return True if the filename does not refer to a file&#10;we want to have reported.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.CoverageResults.update" func="yes">
			<Overload retVal="" descr="Merge in the data from another CoverageResults">
				<Param name="self" />
				<Param name="other" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.CoverageResults.write_results" func="yes">
			<Overload retVal="" descr="Write the coverage results.&#10;&#10;:param show_missing: Show lines that had no hits.&#10;:param summary: Include coverage summary per module.&#10;:param coverdir: If None, the results of each module are placed in its&#10;                 directory, otherwise it is included in the directory&#10;                 specified.">
				<Param name="self" />
				<Param name="[show_missing=True" />
				<Param name="[summary=False" />
				<Param name="[coverdir=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.CoverageResults.write_results_file" func="yes">
			<Overload retVal="" descr="Return a coverage results file in path.">
				<Param name="self" />
				<Param name="path" />
				<Param name="lines" />
				<Param name="lnotab" />
				<Param name="lines_hit" />
				<Param name="[encoding=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.PRAGMA_NOCOVER" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Trace" />
		<KeyWord name="trace.Trace.file_module_function_of" />
		<KeyWord name="trace.Trace.globaltrace_countfuncs" func="yes">
			<Overload retVal="" descr="Handler for call events.&#10;&#10;Adds (filename, modulename, funcname) to the self._calledfuncs dict.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="why" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Trace.globaltrace_lt" func="yes">
			<Overload retVal="" descr="Handler for call events.&#10;&#10;If the code block being entered is to be ignored, returns `None',&#10;else returns self.localtrace.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="why" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Trace.globaltrace_trackcallers" func="yes">
			<Overload retVal="" descr="Handler for call events.&#10;&#10;Adds information about who called who to the self._callers dict.">
				<Param name="self" />
				<Param name="frame" />
				<Param name="why" />
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Trace.localtrace_count" />
		<KeyWord name="trace.Trace.localtrace_trace" />
		<KeyWord name="trace.Trace.localtrace_trace_and_count" />
		<KeyWord name="trace.Trace.results" />
		<KeyWord name="trace.Trace.run" />
		<KeyWord name="trace.Trace.runctx" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="cmd" />
				<Param name="[globals=None" />
				<Param name="[locals=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.Trace.runfunc" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="func" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="trace.main" />
		<KeyWord name="trace.rx_blank" func="yes">
			<Overload retVal="" descr="(SRE_Pattern)">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_c_call" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_call" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_exception" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_i" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_l" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_mac" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="trace_dispatch_return" func="yes">
			<Overload retVal="" descr="Function of profile.Profile">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback" func="yes">
			<Overload retVal="" descr="Extract, format and print information about Python stack traces.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.FrameSummary" func="yes">
			<Overload retVal="" descr="A single frame from a traceback.&#10;&#10;- :attr:`filename` The filename for the frame.&#10;- :attr:`lineno` The line within filename for the frame that was&#10;  active when the frame was captured.&#10;- :attr:`name` The name of the function or method that was executing&#10;  when the frame was captured.&#10;- :attr:`line` The text from the linecache module for the&#10;  of code that was running when the frame was captured.&#10;- :attr:`locals` Either None if locals were not supplied, or a dict&#10;  mapping the name to the repr() of the variable.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.FrameSummary.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.FrameSummary.line" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.FrameSummary.lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.FrameSummary.locals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.FrameSummary.name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary" func="yes">
			<Overload retVal="" descr="A stack of frames.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.append" func="yes">
			<Overload retVal="" descr="L.append(object) -&gt; None -- append object to end">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.clear" func="yes">
			<Overload retVal="" descr="L.clear() -&gt; None -- remove all items from L">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.copy" func="yes">
			<Overload retVal="" descr="L.copy() -&gt; list -- a shallow copy of L">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.count" func="yes">
			<Overload retVal="" descr="L.count(value) -&gt; integer -- return number of occurrences of value">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.extend" func="yes">
			<Overload retVal="" descr="L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.extract" func="yes">
			<Overload retVal="" descr="Create a StackSummary from a traceback or stack object.&#10;&#10;:param frame_gen: A generator that yields (frame, lineno) tuples to&#10;    include in the stack.&#10;:param limit: None to include all frames or the number of frames to&#10;    include.&#10;:param lookup_lines: If True, lookup lines for each frame immediately,&#10;    otherwise lookup is deferred until the frame is rendered.&#10;:param capture_locals: If True, the local variables from each frame will&#10;    be captured as object representations into the FrameSummary.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.format" func="yes">
			<Overload retVal="" descr="Format the stack ready for printing.&#10;&#10;Returns a list of strings ready for printing.  Each string in the&#10;resulting list corresponds to a single frame from the stack.&#10;Each string ends in a newline; the strings may contain internal&#10;newlines as well, for those items with source text lines.&#10;&#10;For long sequences of the same frame and line, the first few&#10;repetitions are shown, followed by a summary line stating the exact&#10;number of further repetitions.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.from_list" func="yes">
			<Overload retVal="" descr="Create a StackSummary from a simple list of tuples.&#10;&#10;This method supports the older Python API. Each tuple should be a&#10;4-tuple with (filename, lineno, name, line) elements.">
				<Param name="klass" />
				<Param name="a_list" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.index" func="yes">
			<Overload retVal="" descr="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.insert" func="yes">
			<Overload retVal="" descr="L.insert(index, object) -- insert object before index">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.pop" func="yes">
			<Overload retVal="" descr="L.pop([index]) -&gt; item -- remove and return item at index (default last).&#10;Raises IndexError if list is empty or index is out of range.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.remove" func="yes">
			<Overload retVal="" descr="L.remove(value) -&gt; None -- remove first occurrence of value.&#10;Raises ValueError if the value is not present.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.reverse" func="yes">
			<Overload retVal="" descr="L.reverse() -- reverse *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.StackSummary.sort" func="yes">
			<Overload retVal="" descr="L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.TracebackException" func="yes">
			<Overload retVal="" descr="An exception ready for rendering.&#10;&#10;The traceback module captures enough attributes from the original exception&#10;to this intermediary form to ensure that no references are held, while&#10;still being able to fully print or format it.&#10;&#10;Use `from_exception` to create TracebackException instances from exception&#10;objects, or the constructor to create TracebackException instances from&#10;individual components.&#10;&#10;- :attr:`__cause__` A TracebackException of the original *__cause__*.&#10;- :attr:`__context__` A TracebackException of the original *__context__*.&#10;- :attr:`__suppress_context__` The *__suppress_context__* value from the&#10;  original exception.&#10;- :attr:`stack` A `StackSummary` representing the traceback.&#10;- :attr:`exc_type` The class of the original traceback.&#10;- :attr:`filename` For syntax errors - the filename where the error&#10;  occurred.&#10;- :attr:`lineno` For syntax errors - the linenumber where the error&#10;  occurred.&#10;- :attr:`text` For syntax errors - the text where the error&#10;  occurred.&#10;- :attr:`offset` For syntax errors - the offset into the text where the&#10;  error occurred.&#10;- :attr:`msg` For syntax errors - the compiler error message.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.TracebackException.format" func="yes">
			<Overload retVal="" descr="Format the exception.&#10;&#10;If chain is not *True*, *__cause__* and *__context__* will not be formatted.&#10;&#10;The return value is a generator of strings, each ending in a newline and&#10;some containing internal newlines. `print_exception` is a wrapper around&#10;this method which just prints the lines to a file.&#10;&#10;The message indicating which exception occurred is always the last&#10;string in the output.">
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.TracebackException.format_exception_only" func="yes">
			<Overload retVal="" descr="Format the exception part of the traceback.&#10;&#10;The return value is a generator of strings, each ending in a newline.&#10;&#10;Normally, the generator emits a single string; however, for&#10;SyntaxError exceptions, it emites several lines that (when&#10;printed) display detailed information about where the syntax&#10;error occurred.&#10;&#10;The message indicating which exception occurred is always the last&#10;string in the output.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.TracebackException.from_exception" func="yes">
			<Overload retVal="" descr="Create a TracebackException from an exception.">
				<Param name="cls" />
				<Param name="exc" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.clear_frames" func="yes">
			<Overload retVal="" descr="Clear all references to local variables in the frames of a traceback.">
				<Param name="tb" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.extract_stack" func="yes">
			<Overload retVal="" descr="Extract the raw traceback from the current stack frame.&#10;&#10;The return value has the same format as for extract_tb().  The&#10;optional 'f' and 'limit' arguments have the same meaning as for&#10;print_stack().  Each item in the list is a quadruple (filename,&#10;line number, function name, text), and the entries are in order&#10;from oldest to newest stack frame.">
				<Param name="[f=None" />
				<Param name="[limit=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.extract_tb" func="yes">
			<Overload retVal="" descr="Return list of up to limit pre-processed entries from traceback.&#10;&#10;This is useful for alternate formatting of stack traces.  If&#10;'limit' is omitted or None, all entries are extracted.  A&#10;pre-processed stack trace entry is a quadruple (filename, line&#10;number, function name, text) representing the information that is&#10;usually printed for a stack trace.  The text is a string with&#10;leading and trailing whitespace stripped; if the source is not&#10;available it is None.">
				<Param name="tb" />
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_exc" func="yes">
			<Overload retVal="" descr="Like print_exc() but return a string.">
				<Param name="[limit=None" />
				<Param name="[chain=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_exception" func="yes">
			<Overload retVal="" descr="Format a stack trace and the exception information.&#10;&#10;The arguments have the same meaning as the corresponding arguments&#10;to print_exception().  The return value is a list of strings, each&#10;ending in a newline and some containing internal newlines.  When&#10;these lines are concatenated and printed, exactly the same text is&#10;printed as does print_exception().">
				<Param name="etype" />
				<Param name="value" />
				<Param name="tb" />
				<Param name="[limit=None" />
				<Param name="[chain=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_exception_only" func="yes">
			<Overload retVal="" descr="Format the exception part of a traceback.&#10;&#10;The arguments are the exception type and value such as given by&#10;sys.last_type and sys.last_value. The return value is a list of&#10;strings, each ending in a newline.&#10;&#10;Normally, the list contains a single string; however, for&#10;SyntaxError exceptions, it contains several lines that (when&#10;printed) display detailed information about where the syntax&#10;error occurred.&#10;&#10;The message indicating which exception occurred is always the last&#10;string in the list.">
				<Param name="etype" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_list" func="yes">
			<Overload retVal="" descr="Format a list of traceback entry tuples for printing.&#10;&#10;Given a list of tuples as returned by extract_tb() or&#10;extract_stack(), return a list of strings ready for printing.&#10;Each string in the resulting list corresponds to the item with the&#10;same index in the argument list.  Each string ends in a newline;&#10;the strings may contain internal newlines as well, for those items&#10;whose source text line is not None.">
				<Param name="extracted_list" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_stack" func="yes">
			<Overload retVal="" descr="Shorthand for 'format_list(extract_stack(f, limit))'.">
				<Param name="[f=None" />
				<Param name="[limit=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.format_tb" func="yes">
			<Overload retVal="" descr="A shorthand for 'format_list(extract_tb(tb, limit))'.">
				<Param name="tb" />
				<Param name="[limit=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_exc" func="yes">
			<Overload retVal="" descr="Shorthand for 'print_exception(*sys.exc_info(), limit, file)'.">
				<Param name="[limit=None" />
				<Param name="[file=None" />
				<Param name="[chain=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_exception" func="yes">
			<Overload retVal="" descr="Print exception up to 'limit' stack trace entries from 'tb' to 'file'.&#10;&#10;This differs from print_tb() in the following ways: (1) if&#10;traceback is not None, it prints a header &quot;Traceback (most recent&#10;call last):&quot;; (2) it prints the exception type and value after the&#10;stack trace; (3) if type is SyntaxError and value has the&#10;appropriate format, it prints the line where the syntax error&#10;occurred with a caret on the next line indicating the approximate&#10;position of the error.">
				<Param name="etype" />
				<Param name="value" />
				<Param name="tb" />
				<Param name="[limit=None" />
				<Param name="[file=None" />
				<Param name="[chain=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_last" func="yes">
			<Overload retVal="" descr="This is a shorthand for 'print_exception(sys.last_type,&#10;sys.last_value, sys.last_traceback, limit, file)'.">
				<Param name="[limit=None" />
				<Param name="[file=None" />
				<Param name="[chain=True]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_list" func="yes">
			<Overload retVal="" descr="Print the list of tuples as returned by extract_tb() or&#10;extract_stack() as a formatted stack trace to the given file.">
				<Param name="extracted_list" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_stack" func="yes">
			<Overload retVal="" descr="Print a stack trace from its invocation point.&#10;&#10;The optional 'f' argument can be used to specify an alternate&#10;stack frame at which to start. The optional 'limit' and 'file'&#10;arguments have the same meaning as for print_exception().">
				<Param name="[f=None" />
				<Param name="[limit=None" />
				<Param name="[file=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.print_tb" func="yes">
			<Overload retVal="" descr="Print up to 'limit' stack trace entries from the traceback 'tb'.&#10;&#10;If 'limit' is omitted or None, all entries are printed.  If 'file'&#10;is omitted or None, the output goes to sys.stderr; otherwise&#10;'file' should be an open file or file-like object with a write()&#10;method.">
				<Param name="tb" />
				<Param name="[limit=None" />
				<Param name="[file=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.walk_stack" func="yes">
			<Overload retVal="" descr="Walk a stack yielding the frame and line number for each frame.&#10;&#10;This will follow f.f_back from the given frame. If no frame is given, the&#10;current stack is used. Usually used with StackSummary.extract.">
				<Param name="f" />
			</Overload>
		</KeyWord>
		<KeyWord name="traceback.walk_tb" func="yes">
			<Overload retVal="" descr="Walk a traceback yielding the frame and line number for each frame.&#10;&#10;This will follow tb.tb_next (and thus is in the opposite order to&#10;walk_stack). Usually used with StackSummary.extract.">
				<Param name="tb" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc" />
		<KeyWord name="tracemalloc.BaseFilter" />
		<KeyWord name="tracemalloc.DomainFilter" />
		<KeyWord name="tracemalloc.DomainFilter.domain" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Filter" />
		<KeyWord name="tracemalloc.Filter.filename_pattern" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Frame" func="yes">
			<Overload retVal="" descr="Frame of a traceback.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Frame.filename" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Frame.lineno" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Iterable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Sequence" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Snapshot" func="yes">
			<Overload retVal="" descr="Snapshot of traces of memory blocks allocated by Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Snapshot.compare_to" func="yes">
			<Overload retVal="" descr="Compute the differences with an old snapshot old_snapshot. Get&#10;statistics as a sorted list of StatisticDiff instances, grouped by&#10;group_by.">
				<Param name="self" />
				<Param name="old_snapshot" />
				<Param name="key_type" />
				<Param name="[cumulative=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Snapshot.dump" func="yes">
			<Overload retVal="" descr="Write the snapshot into a file.">
				<Param name="self" />
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Snapshot.filter_traces" func="yes">
			<Overload retVal="" descr="Create a new Snapshot instance with a filtered traces sequence, filters&#10;is a list of Filter or DomainFilter instances.  If filters is an empty&#10;list, return a new Snapshot instance with a copy of the traces.">
				<Param name="self" />
				<Param name="filters" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Snapshot.load" func="yes">
			<Overload retVal="" descr="Load a snapshot from a file.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Snapshot.statistics" func="yes">
			<Overload retVal="" descr="Group statistics by key_type. Return a sorted list of Statistic&#10;instances.">
				<Param name="self" />
				<Param name="key_type" />
				<Param name="[cumulative=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Statistic" func="yes">
			<Overload retVal="" descr="Statistic difference on memory allocations between two Snapshot instance.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Statistic.count" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Statistic.size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Statistic.traceback" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.StatisticDiff" func="yes">
			<Overload retVal="" descr="Statistic difference on memory allocations between an old and a new&#10;Snapshot instance.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.StatisticDiff.count" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.StatisticDiff.count_diff" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.StatisticDiff.size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.StatisticDiff.size_diff" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.StatisticDiff.traceback" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Trace" func="yes">
			<Overload retVal="" descr="Trace of a memory block.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Trace.domain" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Trace.size" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Trace.traceback" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.Traceback" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.clear_traces" func="yes">
			<Overload retVal="" descr="clear_traces()&#10;&#10;Clear traces of memory blocks allocated by Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.get_object_traceback" func="yes">
			<Overload retVal="" descr="Get the traceback where the Python object *obj* was allocated.&#10;Return a Traceback instance.&#10;&#10;Return None if the tracemalloc module is not tracing memory allocations or&#10;did not trace the allocation of the object.">
				<Param name="obj" />
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.get_traceback_limit" func="yes">
			<Overload retVal="" descr="get_traceback_limit() -&gt; int&#10;&#10;Get the maximum number of frames stored in the traceback&#10;of a trace.&#10;&#10;By default, a trace of an allocated memory block only stores&#10;the most recent frame: the limit is 1.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.get_traced_memory" func="yes">
			<Overload retVal="" descr="get_traced_memory() -&gt; (int, int)&#10;&#10;Get the current size and peak size of memory blocks traced&#10;by the tracemalloc module as a tuple: (current: int, peak: int).">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.get_tracemalloc_memory" func="yes">
			<Overload retVal="" descr="get_tracemalloc_memory() -&gt; int&#10;&#10;Get the memory usage in bytes of the tracemalloc module&#10;used internally to trace memory allocations.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.is_tracing" func="yes">
			<Overload retVal="" descr="is_tracing()-&gt;bool&#10;&#10;True if the tracemalloc module is tracing Python memory allocations,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.start" func="yes">
			<Overload retVal="" descr="start(nframe: int=1)&#10;&#10;Start tracing Python memory allocations. Set also the maximum number &#10;of frames stored in the traceback of a trace to nframe.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.stop" func="yes">
			<Overload retVal="" descr="stop()&#10;&#10;Stop tracing Python memory allocations and clear traces&#10;of memory blocks allocated by Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.take_snapshot" func="yes">
			<Overload retVal="" descr="Take a snapshot of traces of memory blocks allocated by Python.">
			</Overload>
		</KeyWord>
		<KeyWord name="tracemalloc.total_ordering" func="yes">
			<Overload retVal="" descr="Class decorator that fills in missing ordering methods">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="transfercmd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; str&#10;&#10;Return a copy of the string S in which each character has been mapped&#10;through the given translation table. The table must implement&#10;lookup/indexing via __getitem__, for instance a dictionary or list,&#10;mapping Unicode ordinals to Unicode ordinals, strings, or None. If&#10;this operation raises LookupError, the character is left untouched.&#10;Characters mapped to None are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="translation" func="yes">
			<Overload retVal="" descr="Function of gettext">
			</Overload>
		</KeyWord>
		<KeyWord name="triangular" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="truediv" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="truncate" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="truth" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="try" />
		<KeyWord name="ttypager" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="tuple" func="yes">
			<Overload retVal="" descr="tuple() -&gt; empty tuple&#10;tuple(iterable) -&gt; tuple initialized from iterable's items&#10;&#10;If the argument is a tuple, the return value is the same object.">
			</Overload>
		</KeyWord>
		<KeyWord name="type" func="yes">
			<Overload retVal="" descr="type(object_or_name, bases, dict)&#10;type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="types" func="yes">
			<Overload retVal="" descr="Define names for built-in types that aren't directly accessible as a builtin.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType" />
		<KeyWord name="types.AsyncGeneratorType.aclose" func="yes">
			<Overload retVal="" descr="aclose() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType.ag_await" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType.ag_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType.ag_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType.ag_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType.asend" func="yes">
			<Overload retVal="" descr="asend(v) -&gt; send 'v' in generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.AsyncGeneratorType.athrow" func="yes">
			<Overload retVal="" descr="athrow(typ[,val[,tb]]) -&gt; raise exception in generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.BuiltinFunctionType" />
		<KeyWord name="types.BuiltinMethodType" />
		<KeyWord name="types.CodeType" func="yes">
			<Overload retVal="" descr="code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,&#10;      constants, names, varnames, filename, name, firstlineno,&#10;      lnotab[, freevars[, cellvars]])&#10;&#10;Create a code object.  Not for the faint of heart.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_argcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_cellvars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_consts" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_firstlineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_flags" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_freevars" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_kwonlyargcount" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_lnotab" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_name" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_names" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_nlocals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_stacksize" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CodeType.co_varnames" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType" />
		<KeyWord name="types.CoroutineType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside coroutine.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType.cr_await" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType.cr_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType.cr_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType.cr_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into coroutine,&#10;return next iterated value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.CoroutineType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in coroutine,&#10;return next iterated value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DynamicClassAttribute" func="yes">
			<Overload retVal="" descr="Route attribute access on a class to __getattr__.&#10;&#10;This is a descriptor, used to define attributes that act differently when&#10;accessed through an instance and through a class.  Instance access remains&#10;normal, but access to an attribute through a class will be routed to the&#10;class's __getattr__ method; this is done by raising AttributeError.&#10;&#10;This allows one to have properties active on an instance, and have virtual&#10;attributes on the class with the same name (see Enum for an example).">
			</Overload>
		</KeyWord>
		<KeyWord name="types.DynamicClassAttribute.deleter" />
		<KeyWord name="types.DynamicClassAttribute.getter" />
		<KeyWord name="types.DynamicClassAttribute.setter" />
		<KeyWord name="types.FrameType" />
		<KeyWord name="types.FrameType.clear" func="yes">
			<Overload retVal="" descr="F.clear(): clear most references held by the frame">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_back" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_builtins" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_globals" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_lineno" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_locals" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FrameType.f_trace" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.FunctionType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType" />
		<KeyWord name="types.GeneratorType.close" func="yes">
			<Overload retVal="" descr="close() -&gt; raise GeneratorExit inside generator.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_code" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_running" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.gi_yieldfrom" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.send" func="yes">
			<Overload retVal="" descr="send(arg) -&gt; send 'arg' into generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GeneratorType.throw" func="yes">
			<Overload retVal="" descr="throw(typ[,val[,tb]]) -&gt; raise exception in generator,&#10;return next yielded value or raise StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.GetSetDescriptorType" />
		<KeyWord name="types.LambdaType" func="yes">
			<Overload retVal="" descr="function(code, globals[, name[, argdefs[, closure]]])&#10;&#10;Create a function object from a code object and a dictionary.&#10;The optional name string overrides the name from the code object.&#10;The optional argdefs tuple specifies the default argument values.&#10;The optional closure tuple supplies the bindings for free variables.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MappingProxyType" />
		<KeyWord name="types.MappingProxyType.copy" func="yes">
			<Overload retVal="" descr="D.copy() -&gt; a shallow copy of D">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MappingProxyType.get" func="yes">
			<Overload retVal="" descr="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MappingProxyType.items" func="yes">
			<Overload retVal="" descr="D.items() -&gt; list of D's (key, value) pairs, as 2-tuples">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MappingProxyType.keys" func="yes">
			<Overload retVal="" descr="D.keys() -&gt; list of D's keys">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MappingProxyType.values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; list of D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="types.MemberDescriptorType" />
		<KeyWord name="types.MethodType" func="yes">
			<Overload retVal="" descr="method(function, instance)&#10;&#10;Create a bound instance method object.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.ModuleType" func="yes">
			<Overload retVal="" descr="module(name[, doc])&#10;&#10;Create a module object.&#10;The name must be a string; the optional doc argument can have any type.">
			</Overload>
		</KeyWord>
		<KeyWord name="types.SimpleNamespace" func="yes">
			<Overload retVal="" descr="A simple attribute-based namespace.&#10;&#10;SimpleNamespace(**kwargs)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType" />
		<KeyWord name="types.TracebackType.tb_frame" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType.tb_lasti" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType.tb_lineno" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.TracebackType.tb_next" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="types.coroutine" func="yes">
			<Overload retVal="" descr="Convert regular generator function to a coroutine.">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="types.new_class" func="yes">
			<Overload retVal="" descr="Create a class object dynamically using the appropriate metaclass.">
				<Param name="name" />
				<Param name="[bases=()" />
				<Param name="[kwds=None" />
				<Param name="[exec_body=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="types.prepare_class" func="yes">
			<Overload retVal="" descr="Call the __prepare__ method of the appropriate metaclass.&#10;&#10;Returns (metaclass, namespace, kwds) as a 3-tuple&#10;&#10;*metaclass* is the appropriate metaclass&#10;*namespace* is the prepared class namespace&#10;*kwds* is an updated copy of the passed in kwds argument with any&#10;'metaclass' entry removed. If no kwds argument is passed in, this will&#10;be an empty dict.">
				<Param name="name" />
				<Param name="[bases=()" />
				<Param name="[kwds=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing" />
		<KeyWord name="typing.AbstractSet" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Any" func="yes">
			<Overload retVal="" descr="(_Any)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.AnyStr" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.AsyncContextManager" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.AsyncGenerator" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.AsyncIterable" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.AsyncIterator" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Awaitable" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.BinaryIO" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.ByteString" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.CT_co" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Callable" func="yes">
			<Overload retVal="" descr="(CallableMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.CallableMeta" func="yes">
			<Overload retVal="" descr="Metaclass for Callable (internal).">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.CallableMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.CallableMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.&#10;&#10;Returns the subclass, to allow usage as a class decorator.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.ChainMap" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.ClassVar" func="yes">
			<Overload retVal="" descr="(_ClassVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Collection" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Container" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.ContextManager" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Coroutine" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Counter" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.DefaultDict" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Deque" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Dict" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.FrozenSet" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Generator" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Generic" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.GenericMeta" func="yes">
			<Overload retVal="" descr="Metaclass for generic types.&#10;&#10;This is a metaclass for typing.Generic and generic ABCs defined in&#10;typing module. User defined subclasses of GenericMeta can override&#10;__new__ and invoke super().__new__. Note that GenericMeta.__new__&#10;has strict rules on what is allowed in its bases argument:&#10;* plain Generic is disallowed in bases;&#10;* Generic[...] should appear in bases at most once;&#10;* if Generic[...] is present, then it should list all type variables&#10;  that appear in other bases.&#10;In addition, type of all generic bases is erased, e.g., C[int] is&#10;stripped to plain C.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.GenericMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.GenericMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.&#10;&#10;Returns the subclass, to allow usage as a class decorator.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Hashable" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.IO" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.ItemsView" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Iterable" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Iterator" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.KT" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.KeysView" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.List" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Mapping" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.MappingView" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Match" func="yes">
			<Overload retVal="" descr="(_TypeAlias)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.MethodDescriptorType" />
		<KeyWord name="typing.MethodWrapperType" />
		<KeyWord name="typing.MutableMapping" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.MutableSequence" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.MutableSet" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.NamedTuple" func="yes">
			<Overload retVal="" descr="(NamedTupleMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.NamedTupleMeta" func="yes">
			<Overload retVal="" descr="type(object_or_name, bases, dict)&#10;type(object) -&gt; the object's type&#10;type(name, bases, dict) -&gt; a new type">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.NamedTupleMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.NewType" func="yes">
			<Overload retVal="" descr="NewType creates simple unique types with almost zero&#10;runtime overhead. NewType(name, tp) is considered a subtype of tp&#10;by static type checkers. At runtime, NewType(name, tp) returns&#10;a dummy function that simply returns its argument. Usage::&#10;&#10;    UserId = NewType('UserId', int)&#10;&#10;    def name_by_id(user_id: UserId) -&gt; str:&#10;        ...&#10;&#10;    UserId('user')          # Fails type check&#10;&#10;    name_by_id(42)          # Fails type check&#10;    name_by_id(UserId(42))  # OK&#10;&#10;    num = UserId(5) + 1     # type: int">
				<Param name="name" />
				<Param name="tp" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.NoReturn" func="yes">
			<Overload retVal="" descr="(_NoReturn)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Optional" func="yes">
			<Overload retVal="" descr="(_Optional)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Pattern" func="yes">
			<Overload retVal="" descr="(_TypeAlias)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Reversible" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Sequence" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Set" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Sized" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.SupportsAbs" func="yes">
			<Overload retVal="" descr="(_ProtocolMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.SupportsBytes" func="yes">
			<Overload retVal="" descr="(_ProtocolMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.SupportsComplex" func="yes">
			<Overload retVal="" descr="(_ProtocolMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.SupportsFloat" func="yes">
			<Overload retVal="" descr="(_ProtocolMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.SupportsInt" func="yes">
			<Overload retVal="" descr="(_ProtocolMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.SupportsRound" func="yes">
			<Overload retVal="" descr="(_ProtocolMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.T" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.T_co" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.T_contra" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text" func="yes">
			<Overload retVal="" descr="str(object='') -&gt; str&#10;str(bytes_or_buffer[, encoding[, errors]]) -&gt; str&#10;&#10;Create a new string object from the given object. If encoding or&#10;errors is specified, then the object must expose a data buffer&#10;that will be decoded using the given encoding and error handler.&#10;Otherwise, returns the result of object.__str__() (if defined)&#10;or repr(object).&#10;encoding defaults to sys.getdefaultencoding().&#10;errors defaults to 'strict'.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.capitalize" func="yes">
			<Overload retVal="" descr="S.capitalize() -&gt; str&#10;&#10;Return a capitalized version of S, i.e. make the first character&#10;have upper case and the rest lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.casefold" func="yes">
			<Overload retVal="" descr="S.casefold() -&gt; str&#10;&#10;Return a version of S suitable for caseless comparisons.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.center" func="yes">
			<Overload retVal="" descr="S.center(width[, fillchar]) -&gt; str&#10;&#10;Return S centered in a string of length width. Padding is&#10;done using the specified fill character (default is a space)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.count" func="yes">
			<Overload retVal="" descr="S.count(sub[, start[, end]]) -&gt; int&#10;&#10;Return the number of non-overlapping occurrences of substring sub in&#10;string S[start:end].  Optional arguments start and end are&#10;interpreted as in slice notation.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.encode" func="yes">
			<Overload retVal="" descr="S.encode(encoding='utf-8', errors='strict') -&gt; bytes&#10;&#10;Encode S using the codec registered for encoding. Default encoding&#10;is 'utf-8'. errors may be given to set a different error&#10;handling scheme. Default is 'strict' meaning that encoding errors raise&#10;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#10;'xmlcharrefreplace' as well as any other name registered with&#10;codecs.register_error that can handle UnicodeEncodeErrors.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.endswith" func="yes">
			<Overload retVal="" descr="S.endswith(suffix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S ends with the specified suffix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;suffix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.expandtabs" func="yes">
			<Overload retVal="" descr="S.expandtabs(tabsize=8) -&gt; str&#10;&#10;Return a copy of S where all tab characters are expanded using spaces.&#10;If tabsize is not given, a tab size of 8 characters is assumed.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.find" func="yes">
			<Overload retVal="" descr="S.find(sub[, start[, end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.format" func="yes">
			<Overload retVal="" descr="S.format(*args, **kwargs) -&gt; str&#10;&#10;Return a formatted version of S, using substitutions from args and kwargs.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.format_map" func="yes">
			<Overload retVal="" descr="S.format_map(mapping) -&gt; str&#10;&#10;Return a formatted version of S, using substitutions from mapping.&#10;The substitutions are identified by braces ('{' and '}').">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.index" func="yes">
			<Overload retVal="" descr="S.index(sub[, start[, end]]) -&gt; int&#10;&#10;Return the lowest index in S where substring sub is found, &#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Raises ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isalnum" func="yes">
			<Overload retVal="" descr="S.isalnum() -&gt; bool&#10;&#10;Return True if all characters in S are alphanumeric&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isalpha" func="yes">
			<Overload retVal="" descr="S.isalpha() -&gt; bool&#10;&#10;Return True if all characters in S are alphabetic&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isdecimal" func="yes">
			<Overload retVal="" descr="S.isdecimal() -&gt; bool&#10;&#10;Return True if there are only decimal characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isdigit" func="yes">
			<Overload retVal="" descr="S.isdigit() -&gt; bool&#10;&#10;Return True if all characters in S are digits&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isidentifier" func="yes">
			<Overload retVal="" descr='S.isidentifier() -&gt; bool&#10;&#10;Return True if S is a valid identifier according&#10;to the language definition.&#10;&#10;Use keyword.iskeyword() to test for reserved identifiers&#10;such as "def" and "class".'>
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.islower" func="yes">
			<Overload retVal="" descr="S.islower() -&gt; bool&#10;&#10;Return True if all cased characters in S are lowercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isnumeric" func="yes">
			<Overload retVal="" descr="S.isnumeric() -&gt; bool&#10;&#10;Return True if there are only numeric characters in S,&#10;False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isprintable" func="yes">
			<Overload retVal="" descr="S.isprintable() -&gt; bool&#10;&#10;Return True if all characters in S are considered&#10;printable in repr() or S is empty, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isspace" func="yes">
			<Overload retVal="" descr="S.isspace() -&gt; bool&#10;&#10;Return True if all characters in S are whitespace&#10;and there is at least one character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.istitle" func="yes">
			<Overload retVal="" descr="S.istitle() -&gt; bool&#10;&#10;Return True if S is a titlecased string and there is at least one&#10;character in S, i.e. upper- and titlecase characters may only&#10;follow uncased characters and lowercase characters only cased ones.&#10;Return False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.isupper" func="yes">
			<Overload retVal="" descr="S.isupper() -&gt; bool&#10;&#10;Return True if all cased characters in S are uppercase and there is&#10;at least one cased character in S, False otherwise.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.join" func="yes">
			<Overload retVal="" descr="S.join(iterable) -&gt; str&#10;&#10;Return a string which is the concatenation of the strings in the&#10;iterable.  The separator between elements is S.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.ljust" func="yes">
			<Overload retVal="" descr="S.ljust(width[, fillchar]) -&gt; str&#10;&#10;Return S left-justified in a Unicode string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.lower" func="yes">
			<Overload retVal="" descr="S.lower() -&gt; str&#10;&#10;Return a copy of the string S converted to lowercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.lstrip" func="yes">
			<Overload retVal="" descr="S.lstrip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with leading whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.maketrans" func="yes">
			<Overload retVal="" descr="Return a translation table usable for str.translate().&#10;&#10;If there is only one argument, it must be a dictionary mapping Unicode&#10;ordinals (integers) or characters to Unicode ordinals, strings or None.&#10;Character keys will be then converted to ordinals.&#10;If there are two arguments, they must be strings of equal length, and&#10;in the resulting dictionary, each character in x will be mapped to the&#10;character at the same position in y. If there is a third argument, it&#10;must be a string, whose characters will be mapped to None in the result.">
				<Param name="x" />
				<Param name="y" />
				<Param name="z" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.partition" func="yes">
			<Overload retVal="" descr="S.partition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, and return the part before it,&#10;the separator itself, and the part after it.  If the separator is not&#10;found, return S and two empty strings.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.replace" func="yes">
			<Overload retVal="" descr="S.replace(old, new[, count]) -&gt; str&#10;&#10;Return a copy of S with all occurrences of substring&#10;old replaced by new.  If the optional argument count is&#10;given, only the first count occurrences are replaced.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.rfind" func="yes">
			<Overload retVal="" descr="S.rfind(sub[, start[, end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Return -1 on failure.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.rindex" func="yes">
			<Overload retVal="" descr="S.rindex(sub[, start[, end]]) -&gt; int&#10;&#10;Return the highest index in S where substring sub is found,&#10;such that sub is contained within S[start:end].  Optional&#10;arguments start and end are interpreted as in slice notation.&#10;&#10;Raises ValueError when the substring is not found.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.rjust" func="yes">
			<Overload retVal="" descr="S.rjust(width[, fillchar]) -&gt; str&#10;&#10;Return S right-justified in a string of length width. Padding is&#10;done using the specified fill character (default is a space).">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.rpartition" func="yes">
			<Overload retVal="" descr="S.rpartition(sep) -&gt; (head, sep, tail)&#10;&#10;Search for the separator sep in S, starting at the end of S, and return&#10;the part before it, the separator itself, and the part after it.  If the&#10;separator is not found, return two empty strings and S.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.rsplit" func="yes">
			<Overload retVal="" descr="S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string, starting at the end of the string and&#10;working to the front.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified, any whitespace string&#10;is a separator.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.rstrip" func="yes">
			<Overload retVal="" descr="S.rstrip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with trailing whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.split" func="yes">
			<Overload retVal="" descr="S.split(sep=None, maxsplit=-1) -&gt; list of strings&#10;&#10;Return a list of the words in S, using sep as the&#10;delimiter string.  If maxsplit is given, at most maxsplit&#10;splits are done. If sep is not specified or is None, any&#10;whitespace string is a separator and empty strings are&#10;removed from the result.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.splitlines" func="yes">
			<Overload retVal="" descr="S.splitlines([keepends]) -&gt; list of strings&#10;&#10;Return a list of the lines in S, breaking at line boundaries.&#10;Line breaks are not included in the resulting list unless keepends&#10;is given and true.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.startswith" func="yes">
			<Overload retVal="" descr="S.startswith(prefix[, start[, end]]) -&gt; bool&#10;&#10;Return True if S starts with the specified prefix, False otherwise.&#10;With optional start, test S beginning at that position.&#10;With optional end, stop comparing S at that position.&#10;prefix can also be a tuple of strings to try.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.strip" func="yes">
			<Overload retVal="" descr="S.strip([chars]) -&gt; str&#10;&#10;Return a copy of the string S with leading and trailing&#10;whitespace removed.&#10;If chars is given and not None, remove characters in chars instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.swapcase" func="yes">
			<Overload retVal="" descr="S.swapcase() -&gt; str&#10;&#10;Return a copy of S with uppercase characters converted to lowercase&#10;and vice versa.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.title" func="yes">
			<Overload retVal="" descr="S.title() -&gt; str&#10;&#10;Return a titlecased version of S, i.e. words start with title case&#10;characters, all remaining cased characters have lower case.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.translate" func="yes">
			<Overload retVal="" descr="S.translate(table) -&gt; str&#10;&#10;Return a copy of the string S in which each character has been mapped&#10;through the given translation table. The table must implement&#10;lookup/indexing via __getitem__, for instance a dictionary or list,&#10;mapping Unicode ordinals to Unicode ordinals, strings, or None. If&#10;this operation raises LookupError, the character is left untouched.&#10;Characters mapped to None are deleted.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; str&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Text.zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; str&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TextIO" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Tuple" func="yes">
			<Overload retVal="" descr="(TupleMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TupleMeta" func="yes">
			<Overload retVal="" descr="Metaclass for Tuple (internal).">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TupleMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TupleMeta.register" func="yes">
			<Overload retVal="" descr="Register a virtual subclass of an ABC.&#10;&#10;Returns the subclass, to allow usage as a class decorator.">
				<Param name="cls" />
				<Param name="subclass" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Type" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TypeVar" func="yes">
			<Overload retVal="" descr="(TypingMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TypingMeta" func="yes">
			<Overload retVal="" descr="Metaclass for most types defined in typing module&#10;(not a part of public API).&#10;&#10;This overrides __new__() to require an extra keyword parameter&#10;'_root', which serves as a guard against naive subclassing of the&#10;typing classes.  Any legitimate class defined using a metaclass&#10;derived from TypingMeta must pass _root=True.&#10;&#10;This also defines a dummy constructor (all the work for most typing&#10;constructs is done in __new__) and a nicer repr().">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.TypingMeta.mro" func="yes">
			<Overload retVal="" descr="mro() -&gt; list&#10;return a type's method resolution order">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.Union" func="yes">
			<Overload retVal="" descr="(_Union)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.VT" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.VT_co" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.V_co" func="yes">
			<Overload retVal="" descr="(TypeVar)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.ValuesView" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.WrapperDescriptorType" />
		<KeyWord name="typing.abstractmethod" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract methods.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract methods are overridden.&#10;The abstract methods can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractmethod&#10;        def my_abstract_method(self, ...):&#10;            ...">
				<Param name="funcobj" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty" func="yes">
			<Overload retVal="" descr="A decorator indicating abstract properties.&#10;&#10;Requires that the metaclass is ABCMeta or derived from it.  A&#10;class that has a metaclass derived from ABCMeta cannot be&#10;instantiated unless all of its abstract properties are overridden.&#10;The abstract properties can be called using any of the normal&#10;'super' call mechanisms.&#10;&#10;Usage:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        @abstractproperty&#10;        def my_abstract_property(self):&#10;            ...&#10;&#10;This defines a read-only property; you can also define a read-write&#10;abstract property using the 'long' form of property declaration:&#10;&#10;    class C(metaclass=ABCMeta):&#10;        def getx(self): ...&#10;        def setx(self, value): ...&#10;        x = abstractproperty(getx, setx)&#10;&#10;'abstractproperty' is deprecated. Use 'property' with 'abstractmethod'&#10;instead.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty.deleter" func="yes">
			<Overload retVal="" descr="Descriptor to change the deleter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty.fdel" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty.fget" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty.fset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty.getter" func="yes">
			<Overload retVal="" descr="Descriptor to change the getter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.abstractproperty.setter" func="yes">
			<Overload retVal="" descr="Descriptor to change the setter on a property.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.cast" func="yes">
			<Overload retVal="" descr="Cast a value to a type.&#10;&#10;This returns the value unchanged.  To the type checker this&#10;signals that the return value has the designated type, but at&#10;runtime we intentionally don't check anything (we want this&#10;to be as fast as possible).">
				<Param name="typ" />
				<Param name="val" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.get_type_hints" func="yes">
			<Overload retVal="" descr="Return type hints for an object.&#10;&#10;This is often the same as obj.__annotations__, but it handles&#10;forward references encoded as string literals, and if necessary&#10;adds Optional[t] if a default value equal to None is set.&#10;&#10;The argument may be a module, class, method, or function. The annotations&#10;are returned as a dictionary. For classes, annotations include also&#10;inherited members.&#10;&#10;TypeError is raised if the argument is not of a type that can contain&#10;annotations, and an empty dictionary is returned if no annotations are&#10;present.&#10;&#10;BEWARE -- the behavior of globalns and localns is counterintuitive&#10;(unless you are familiar with how eval() and exec() work).  The&#10;search order is locals first, then globals.&#10;&#10;- If no dict arguments are passed, an attempt is made to use the&#10;  globals from obj (or the respective module's globals for classes),&#10;  and these are also used as the locals.  If the object does not appear&#10;  to have globals, an empty dictionary is used.&#10;&#10;- If one dict argument is passed, it is used for both globals and&#10;  locals.&#10;&#10;- If two dict arguments are passed, they specify globals and&#10;  locals, respectively.">
				<Param name="obj" />
				<Param name="[globalns=None" />
				<Param name="[localns=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.io" func="yes">
			<Overload retVal="" descr="Wrapper namespace for IO generic classes.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.io.BinaryIO" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.io.IO" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.io.TextIO" func="yes">
			<Overload retVal="" descr="(GenericMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.no_type_check" func="yes">
			<Overload retVal="" descr="Decorator to indicate that annotations are not type hints.&#10;&#10;The argument must be a class or function; if it is a class, it&#10;applies recursively to all methods and classes defined in that class&#10;(but not to methods defined in its superclasses or subclasses).&#10;&#10;This mutates the function(s) or class(es) in place.">
				<Param name="arg" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.no_type_check_decorator" func="yes">
			<Overload retVal="" descr="Decorator to give another decorator the @no_type_check effect.&#10;&#10;This wraps the decorator with something that wraps the decorated&#10;function in @no_type_check.">
				<Param name="decorator" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.overload" func="yes">
			<Overload retVal="" descr="Decorator for overloaded functions/methods.&#10;&#10;In a stub file, place two or more stub definitions for the same&#10;function in a row, each decorated with @overload.  For example:&#10;&#10;  @overload&#10;  def utf8(value: None) -&gt; None: ...&#10;  @overload&#10;  def utf8(value: bytes) -&gt; bytes: ...&#10;  @overload&#10;  def utf8(value: str) -&gt; bytes: ...&#10;&#10;In a non-stub file (i.e. a regular .py file), do the same but&#10;follow it with an implementation.  The implementation should *not*&#10;be decorated with @overload.  For example:&#10;&#10;  @overload&#10;  def utf8(value: None) -&gt; None: ...&#10;  @overload&#10;  def utf8(value: bytes) -&gt; bytes: ...&#10;  @overload&#10;  def utf8(value: str) -&gt; bytes: ...&#10;  def utf8(value):&#10;      # implementation goes here">
				<Param name="func" />
			</Overload>
		</KeyWord>
		<KeyWord name="typing.re" func="yes">
			<Overload retVal="" descr="Wrapper namespace for re type aliases.">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.re.Match" func="yes">
			<Overload retVal="" descr="(_TypeAlias)">
			</Overload>
		</KeyWord>
		<KeyWord name="typing.re.Pattern" func="yes">
			<Overload retVal="" descr="(_TypeAlias)">
			</Overload>
		</KeyWord>
		<KeyWord name="tzinfo" func="yes">
			<Overload retVal="" descr="Function of datetime.tzinfo">
			</Overload>
		</KeyWord>
		<KeyWord name="tzname" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="uid" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="uidl" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="umask" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="uname" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="uname_result" func="yes">
			<Overload retVal="" descr="Function of os.uname_result">
			</Overload>
		</KeyWord>
		<KeyWord name="unescape" func="yes">
			<Overload retVal="" descr="Function of html">
			</Overload>
		</KeyWord>
		<KeyWord name="unhex" func="yes">
			<Overload retVal="" descr="Function of quopri">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_escape_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_escape_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_internal_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicode_internal_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata" func="yes">
			<Overload retVal="" descr="This module provides access to the Unicode Character Database which&#10;defines character properties for all Unicode characters. The data in&#10;this database is based on the UnicodeData.txt file version&#10;9.0.0 which is publically available from ftp://ftp.unicode.org/.&#10;&#10;The module uses the same names and symbols as defined by the&#10;UnicodeData File Format 9.0.0.">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD" />
		<KeyWord name="unicodedata.UCD.bidirectional" func="yes">
			<Overload retVal="" descr="Returns the bidirectional class assigned to the character chr as string.&#10;&#10;If no such value is defined, an empty string is returned.">
				<Param name="self" />
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.category" func="yes">
			<Overload retVal="" descr="Returns the general category assigned to the character chr as string.">
				<Param name="self" />
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.combining" func="yes">
			<Overload retVal="" descr="Returns the canonical combining class assigned to the character chr as integer.&#10;&#10;Returns 0 if no combining class is defined.">
				<Param name="self" />
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.decimal" func="yes">
			<Overload retVal="" descr="Converts a Unicode character into its equivalent decimal value.&#10;&#10;Returns the decimal value assigned to the character chr as integer.&#10;If no such value is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="self" />
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.decomposition" func="yes">
			<Overload retVal="" descr="Returns the character decomposition mapping assigned to the character chr as string.&#10;&#10;An empty string is returned in case no such mapping is defined.">
				<Param name="self" />
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.digit" func="yes">
			<Overload retVal="" descr="Converts a Unicode character into its equivalent digit value.&#10;&#10;Returns the digit value assigned to the character chr as integer.&#10;If no such value is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="self" />
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.east_asian_width" func="yes">
			<Overload retVal="" descr="Returns the east asian width assigned to the character chr as string.">
				<Param name="self" />
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.lookup" func="yes">
			<Overload retVal="" descr="Look up character by name.&#10;&#10;If a character with the given name is found, return the&#10;corresponding character.  If not found, KeyError is raised.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.mirrored" func="yes">
			<Overload retVal="" descr='Returns the mirrored property assigned to the character chr as integer.&#10;&#10;Returns 1 if the character has been identified as a "mirrored"&#10;character in bidirectional text, 0 otherwise.'>
				<Param name="self" />
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.name" func="yes">
			<Overload retVal="" descr="Returns the name assigned to the character chr as a string.&#10;&#10;If no name is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="self" />
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.normalize" func="yes">
			<Overload retVal="" descr="Return the normal form 'form' for the Unicode string unistr.&#10;&#10;Valid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.">
				<Param name="self" />
				<Param name="form" />
				<Param name="unistr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.numeric" func="yes">
			<Overload retVal="" descr="Converts a Unicode character into its equivalent numeric value.&#10;&#10;Returns the numeric value assigned to the character chr as float.&#10;If no such value is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="self" />
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.UCD.unidata_version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.bidirectional" func="yes">
			<Overload retVal="" descr="Returns the bidirectional class assigned to the character chr as string.&#10;&#10;If no such value is defined, an empty string is returned.">
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.category" func="yes">
			<Overload retVal="" descr="Returns the general category assigned to the character chr as string.">
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.combining" func="yes">
			<Overload retVal="" descr="Returns the canonical combining class assigned to the character chr as integer.&#10;&#10;Returns 0 if no combining class is defined.">
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.decimal" func="yes">
			<Overload retVal="" descr="Converts a Unicode character into its equivalent decimal value.&#10;&#10;Returns the decimal value assigned to the character chr as integer.&#10;If no such value is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.decomposition" func="yes">
			<Overload retVal="" descr="Returns the character decomposition mapping assigned to the character chr as string.&#10;&#10;An empty string is returned in case no such mapping is defined.">
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.digit" func="yes">
			<Overload retVal="" descr="Converts a Unicode character into its equivalent digit value.&#10;&#10;Returns the digit value assigned to the character chr as integer.&#10;If no such value is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.east_asian_width" func="yes">
			<Overload retVal="" descr="Returns the east asian width assigned to the character chr as string.">
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.lookup" func="yes">
			<Overload retVal="" descr="Look up character by name.&#10;&#10;If a character with the given name is found, return the&#10;corresponding character.  If not found, KeyError is raised.">
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.mirrored" func="yes">
			<Overload retVal="" descr='Returns the mirrored property assigned to the character chr as integer.&#10;&#10;Returns 1 if the character has been identified as a "mirrored"&#10;character in bidirectional text, 0 otherwise.'>
				<Param name="chr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.name" func="yes">
			<Overload retVal="" descr="Returns the name assigned to the character chr as a string.&#10;&#10;If no name is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.normalize" func="yes">
			<Overload retVal="" descr="Return the normal form 'form' for the Unicode string unistr.&#10;&#10;Valid values for form are 'NFC', 'NFKC', 'NFD', and 'NFKD'.">
				<Param name="form" />
				<Param name="unistr" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.numeric" func="yes">
			<Overload retVal="" descr="Converts a Unicode character into its equivalent numeric value.&#10;&#10;Returns the numeric value assigned to the character chr as float.&#10;If no such value is defined, default is returned, or, if not given,&#10;ValueError is raised.">
				<Param name="chr" />
				<Param name="default" />
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.ucd_3_2_0" func="yes">
			<Overload retVal="" descr="(UCD)">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.ucnhash_CAPI" func="yes">
			<Overload retVal="" descr="(PyCapsule)">
			</Overload>
		</KeyWord>
		<KeyWord name="unicodedata.unidata_version" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unified_diff" func="yes">
			<Overload retVal="" descr="Function of difflib">
			</Overload>
		</KeyWord>
		<KeyWord name="uniform" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="union" func="yes">
			<Overload retVal="" descr="Return the union of sets as a new set.&#10;&#10;(i.e. all elements that are in either set.)">
			</Overload>
		</KeyWord>
		<KeyWord name="unique" func="yes">
			<Overload retVal="" descr="Function of enum">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest" func="yes">
			<Overload retVal="" descr="Python unit testing framework, based on Erich Gamma's JUnit and Kent Beck's&#10;Smalltalk testing framework (used with permission).&#10;&#10;This module contains the core framework classes that form the basis of&#10;specific test cases and suites (TestCase, TestSuite etc.), and also a&#10;text-based utility class for running the tests and reporting the results&#10; (TextTestRunner).&#10;&#10;Simple usage:&#10;&#10;    import unittest&#10;&#10;    class IntegerArithmeticTestCase(unittest.TestCase):&#10;        def testAdd(self):  # test method names begin with 'test'&#10;            self.assertEqual((1 + 2), 3)&#10;            self.assertEqual(0 + 1, 1)&#10;        def testMultiply(self):&#10;            self.assertEqual((0 * 10), 0)&#10;            self.assertEqual((5 * 8), 40)&#10;&#10;    if __name__ == '__main__':&#10;        unittest.main()&#10;&#10;Further information is available in the bundled documentation, and from&#10;&#10;  http://docs.python.org/library/unittest.html&#10;&#10;Copyright (c) 1999-2003 Steve Purcell&#10;Copyright (c) 2003-2010 Python Software Foundation&#10;This module is free software, and you may redistribute it and/or modify&#10;it under the same terms as Python itself, so long as this copyright message&#10;and disclaimer are retained in their original form.&#10;&#10;IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,&#10;SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF&#10;THIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH&#10;DAMAGE.&#10;&#10;THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT&#10;LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A&#10;PARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS,&#10;AND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,&#10;SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.BaseTestSuite" func="yes">
			<Overload retVal="" descr="A simple test suite that doesn't provide class or module shared fixtures.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.BaseTestSuite.addTest" />
		<KeyWord name="unittest.BaseTestSuite.addTests" />
		<KeyWord name="unittest.BaseTestSuite.countTestCases" />
		<KeyWord name="unittest.BaseTestSuite.debug" func="yes">
			<Overload retVal="" descr="Run the tests without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.BaseTestSuite.run" />
		<KeyWord name="unittest.FunctionTestCase" func="yes">
			<Overload retVal="" descr="A test case that wraps a test function.&#10;&#10;This is useful for slipping pre-existing test functions into the&#10;unittest framework. Optionally, set-up and tidy-up functions can be&#10;supplied. As with TestCase, the tidy-up ('tearDown') function will&#10;always be called if the set-up ('setUp') function ran successfully.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is more than the given&#10;delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertCountEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence comparison asserting that the same elements,&#10;regardless of order.  If the same element occurs more than once,&#10;it verifies that the elements occur the same number of times.&#10;&#10;    self.assertEqual(Counter(list(first)),&#10;                     Counter(list(second)))&#10;&#10; Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether dictionary is a superset of subset.">
				<Param name="self" />
				<Param name="subset" />
				<Param name="dictionary" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertLogs" func="yes">
			<Overload retVal="" descr="Fail unless a log message of level *level* or higher is emitted&#10;on *logger_name* or its children.  If omitted, *level* defaults to&#10;INFO and *logger* defaults to the root logger.&#10;&#10;This method must be used as a context manager, and will yield&#10;a recording object with two attributes: `output` and `records`.&#10;At the end of the context manager, the `output` attribute will&#10;be a list of the matching formatted log messages and the&#10;`records` attribute will be a list of the corresponding LogRecord&#10;objects.&#10;&#10;Example::&#10;&#10;    with self.assertLogs('foo', level='INFO') as cm:&#10;        logging.getLogger('foo').info('first message')&#10;        logging.getLogger('foo.bar').error('second message')&#10;    self.assertEqual(cm.output, ['INFO:foo:first message',&#10;                                 'ERROR:foo.bar:second message'])">
				<Param name="self" />
				<Param name="[logger=None" />
				<Param name="[level=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotRegex" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class expected_exception is raised&#10;by the callable when invoked with specified positional and&#10;keyword arguments. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertRaises&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRaisesRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regex.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertRaisesRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRegex" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertWarns" func="yes">
			<Overload retVal="" descr="Fail unless a warning of class warnClass is triggered&#10;by the callable when invoked with specified positional and&#10;keyword arguments.  If a different type of warning is&#10;triggered, it will not be handled: depending on the other&#10;warning filtering rules in effect, it might be silenced, printed&#10;out, or raised as an exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertWarns(SomeWarning):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertWarns&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the first matching&#10;warning as the 'warning' attribute; similarly, the 'filename'&#10;and 'lineno' attributes give you information about the line&#10;of Python code from which the warning was triggered.&#10;This allows you to inspect the warning after the assertion::&#10;&#10;    with self.assertWarns(SomeWarning) as cm:&#10;        do_something()&#10;    the_warning = cm.warning&#10;    self.assertEqual(the_warning.some_attribute, 147)">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.assertWarnsRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a triggered warning matches a regexp.&#10;Basic functioning is similar to assertWarns() with the addition&#10;that only warnings whose messages also match the regular expression&#10;are considered successful matches.&#10;&#10;Args:&#10;    expected_warning: Warning class expected to be triggered.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertWarnsRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.countTestCases" />
		<KeyWord name="unittest.FunctionTestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.defaultTestResult" />
		<KeyWord name="unittest.FunctionTestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.id" />
		<KeyWord name="unittest.FunctionTestCase.longMessage" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.runTest" />
		<KeyWord name="unittest.FunctionTestCase.setUp" func="yes">
			<Overload retVal="" descr="Hook method for setting up the test fixture before exercising it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.shortDescription" func="yes">
			<Overload retVal="" descr="Returns a one-line description of the test, or None if no&#10;description has been provided.&#10;&#10;The default implementation of this method returns the first line of&#10;the specified test method's docstring.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.subTest" func="yes">
			<Overload retVal="" descr="Return a context manager that will return the enclosed block&#10;of code in a subtest identified by the optional message and&#10;keyword parameters.  A failure in the subtest marks the test&#10;case as failed but resumes execution at the end of the enclosed&#10;block, allowing further test code to be executed.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.tearDown" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the test fixture after testing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.FunctionTestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.SkipTest" func="yes">
			<Overload retVal="" descr="Raise this exception in a test to skip it.&#10;&#10;Usually you can use TestCase.skipTest() or one of the skipping decorators&#10;instead of raising this directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.SkipTest.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.SkipTest.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase" func="yes">
			<Overload retVal="" descr="A class whose instances are single test cases.&#10;&#10;By default, the test code itself should be placed in a method named&#10;'runTest'.&#10;&#10;If the fixture may be used for many test cases, create as&#10;many test methods as are needed. When instantiating such a TestCase&#10;subclass, specify in the constructor arguments the name of the test method&#10;that the instance is to execute.&#10;&#10;Test authors should subclass TestCase for their own tests. Construction&#10;and deconstruction of the test's environment ('fixture') can be&#10;implemented by overriding the 'setUp' and 'tearDown' methods respectively.&#10;&#10;If it is necessary to override the __init__ method, the base class&#10;__init__ method must always be called. It is important that subclasses&#10;should not change the signature of their __init__ method, since instances&#10;of the classes are instantiated automatically by parts of the framework&#10;in order to be run.&#10;&#10;When subclassing TestCase, you can set these attributes:&#10;* failureException: determines which exception will be raised when&#10;    the instance's assertion methods fail; test methods raising this&#10;    exception will be deemed to have 'failed' rather than 'errored'.&#10;* longMessage: determines whether long messages (including repr of&#10;    objects used in assert methods) will be printed on failure in *addition*&#10;    to any explicit message passed.&#10;* maxDiff: sets the maximum length of a diff in failure messages&#10;    by assert methods using difflib. It is looked up as an instance&#10;    attribute so can be configured by individual tests if required.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.addCleanup" func="yes">
			<Overload retVal="" descr="Add a function, with arguments, to be called when the test is&#10;completed. Functions added are called on a LIFO basis and are&#10;called after tearDown on test failure or success.&#10;&#10;Cleanup items are called even if setUp fails (unlike tearDown).">
				<Param name="self" />
				<Param name="function" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.addTypeEqualityFunc" func="yes">
			<Overload retVal="" descr="Add a type specific assertEqual style function to compare a type.&#10;&#10;This method is for use by TestCase subclasses that need to register&#10;their own type equality functions to provide nicer error messages.&#10;&#10;Args:&#10;    typeobj: The data type to call this function on when both values&#10;            are of the same type in assertEqual().&#10;    function: The callable taking two arguments and an optional&#10;            msg= argument that raises self.failureException with a&#10;            useful error message when the two arguments are not equal.">
				<Param name="self" />
				<Param name="typeobj" />
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is more than the given&#10;delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;If the two objects compare equal then they will automatically&#10;compare almost equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertCountEqual" func="yes">
			<Overload retVal="" descr="An unordered sequence comparison asserting that the same elements,&#10;regardless of order.  If the same element occurs more than once,&#10;it verifies that the elements occur the same number of times.&#10;&#10;    self.assertEqual(Counter(list(first)),&#10;                     Counter(list(second)))&#10;&#10; Example:&#10;    - [0, 1, 1] and [1, 0, 1] compare equal.&#10;    - [0, 0, 1] and [0, 1] compare unequal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertDictContainsSubset" func="yes">
			<Overload retVal="" descr="Checks whether dictionary is a superset of subset.">
				<Param name="self" />
				<Param name="subset" />
				<Param name="dictionary" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertDictEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="d1" />
				<Param name="d2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are unequal as determined by the '=='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertFalse" func="yes">
			<Overload retVal="" descr="Check that the expression is false.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertGreater" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertGreaterEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &gt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIs" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsInstance" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(isinstance(obj, cls)), with a nicer&#10;default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsNone" func="yes">
			<Overload retVal="" descr="Same as self.assertTrue(obj is None), with a nicer default message.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsNot" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a is not b), but with a nicer default message.">
				<Param name="self" />
				<Param name="expr1" />
				<Param name="expr2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertIsNotNone" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsNone.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertLess" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt; b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertLessEqual" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a &lt;= b), but with a nicer default message.">
				<Param name="self" />
				<Param name="a" />
				<Param name="b" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertListEqual" func="yes">
			<Overload retVal="" descr="A list-specific equality assertion.&#10;&#10;Args:&#10;    list1: The first list to compare.&#10;    list2: The second list to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="list1" />
				<Param name="list2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertLogs" func="yes">
			<Overload retVal="" descr="Fail unless a log message of level *level* or higher is emitted&#10;on *logger_name* or its children.  If omitted, *level* defaults to&#10;INFO and *logger* defaults to the root logger.&#10;&#10;This method must be used as a context manager, and will yield&#10;a recording object with two attributes: `output` and `records`.&#10;At the end of the context manager, the `output` attribute will&#10;be a list of the matching formatted log messages and the&#10;`records` attribute will be a list of the corresponding LogRecord&#10;objects.&#10;&#10;Example::&#10;&#10;    with self.assertLogs('foo', level='INFO') as cm:&#10;        logging.getLogger('foo').info('first message')&#10;        logging.getLogger('foo.bar').error('second message')&#10;    self.assertEqual(cm.output, ['INFO:foo:first message',&#10;                                 'ERROR:foo.bar:second message'])">
				<Param name="self" />
				<Param name="[logger=None" />
				<Param name="[level=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertMultiLineEqual" func="yes">
			<Overload retVal="" descr="Assert that two multi-line strings are equal.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotAlmostEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by their&#10;difference rounded to the given number of decimal places&#10;(default 7) and comparing to zero, or by comparing that the&#10;difference between the two objects is less than the given delta.&#10;&#10;Note that decimal places (from zero) are usually not the same&#10;as significant digits (measured from the most significant digit).&#10;&#10;Objects that are equal automatically fail.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[places=None" />
				<Param name="[msg=None" />
				<Param name="[delta=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotAlmostEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotEqual" func="yes">
			<Overload retVal="" descr="Fail if the two objects are equal as determined by the '!='&#10;operator.">
				<Param name="self" />
				<Param name="first" />
				<Param name="second" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotEquals" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotIn" func="yes">
			<Overload retVal="" descr="Just like self.assertTrue(a not in b), but with a nicer default message.">
				<Param name="self" />
				<Param name="member" />
				<Param name="container" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotIsInstance" func="yes">
			<Overload retVal="" descr="Included for symmetry with assertIsInstance.">
				<Param name="self" />
				<Param name="obj" />
				<Param name="cls" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotRegex" func="yes">
			<Overload retVal="" descr="Fail the test if the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="unexpected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertNotRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRaises" func="yes">
			<Overload retVal="" descr="Fail unless an exception of class expected_exception is raised&#10;by the callable when invoked with specified positional and&#10;keyword arguments. If a different type of exception is&#10;raised, it will not be caught, and the test case will be&#10;deemed to have suffered an error, exactly as for an&#10;unexpected exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertRaises(SomeException):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertRaises&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the exception as&#10;the 'exception' attribute. This allows you to inspect the&#10;exception after the assertion::&#10;&#10;    with self.assertRaises(SomeException) as cm:&#10;        do_something()&#10;    the_exception = cm.exception&#10;    self.assertEqual(the_exception.error_code, 3)">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRaisesRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a raised exception matches a regex.&#10;&#10;Args:&#10;    expected_exception: Exception class expected to be raised.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertRaisesRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_exception" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRaisesRegexp" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRegex" func="yes">
			<Overload retVal="" descr="Fail the test unless the text matches the regular expression.">
				<Param name="self" />
				<Param name="text" />
				<Param name="expected_regex" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertRegexpMatches" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertSequenceEqual" func="yes">
			<Overload retVal="" descr="An equality assertion for ordered sequences (like lists and tuples).&#10;&#10;For the purposes of this function, a valid ordered sequence type is one&#10;which can be indexed, has a length, and has an equality operator.&#10;&#10;Args:&#10;    seq1: The first sequence to compare.&#10;    seq2: The second sequence to compare.&#10;    seq_type: The expected datatype of the sequences, or None if no&#10;            datatype should be enforced.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="seq1" />
				<Param name="seq2" />
				<Param name="[msg=None" />
				<Param name="[seq_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertSetEqual" func="yes">
			<Overload retVal="" descr="A set-specific equality assertion.&#10;&#10;Args:&#10;    set1: The first set to compare.&#10;    set2: The second set to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.&#10;&#10;assertSetEqual uses ducktyping to support different types of sets, and&#10;is optimized for sets specifically (parameters must support a&#10;difference method).">
				<Param name="self" />
				<Param name="set1" />
				<Param name="set2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertTrue" func="yes">
			<Overload retVal="" descr="Check that the expression is true.">
				<Param name="self" />
				<Param name="expr" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertTupleEqual" func="yes">
			<Overload retVal="" descr="A tuple-specific equality assertion.&#10;&#10;Args:&#10;    tuple1: The first tuple to compare.&#10;    tuple2: The second tuple to compare.&#10;    msg: Optional message to use on failure instead of a list of&#10;            differences.">
				<Param name="self" />
				<Param name="tuple1" />
				<Param name="tuple2" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertWarns" func="yes">
			<Overload retVal="" descr="Fail unless a warning of class warnClass is triggered&#10;by the callable when invoked with specified positional and&#10;keyword arguments.  If a different type of warning is&#10;triggered, it will not be handled: depending on the other&#10;warning filtering rules in effect, it might be silenced, printed&#10;out, or raised as an exception.&#10;&#10;If called with the callable and arguments omitted, will return a&#10;context object used like this::&#10;&#10;     with self.assertWarns(SomeWarning):&#10;         do_something()&#10;&#10;An optional keyword argument 'msg' can be provided when assertWarns&#10;is used as a context object.&#10;&#10;The context manager keeps a reference to the first matching&#10;warning as the 'warning' attribute; similarly, the 'filename'&#10;and 'lineno' attributes give you information about the line&#10;of Python code from which the warning was triggered.&#10;This allows you to inspect the warning after the assertion::&#10;&#10;    with self.assertWarns(SomeWarning) as cm:&#10;        do_something()&#10;    the_warning = cm.warning&#10;    self.assertEqual(the_warning.some_attribute, 147)">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.assertWarnsRegex" func="yes">
			<Overload retVal="" descr="Asserts that the message in a triggered warning matches a regexp.&#10;Basic functioning is similar to assertWarns() with the addition&#10;that only warnings whose messages also match the regular expression&#10;are considered successful matches.&#10;&#10;Args:&#10;    expected_warning: Warning class expected to be triggered.&#10;    expected_regex: Regex (re pattern object or string) expected&#10;            to be found in error message.&#10;    args: Function to be called and extra positional args.&#10;    kwargs: Extra kwargs.&#10;    msg: Optional message used in case of failure. Can only be used&#10;            when assertWarnsRegex is used as a context manager.">
				<Param name="self" />
				<Param name="expected_warning" />
				<Param name="expected_regex" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.countTestCases" />
		<KeyWord name="unittest.TestCase.debug" func="yes">
			<Overload retVal="" descr="Run the test without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.defaultTestResult" />
		<KeyWord name="unittest.TestCase.doCleanups" func="yes">
			<Overload retVal="" descr="Execute all cleanup functions. Normally called for you after&#10;tearDown.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.fail" func="yes">
			<Overload retVal="" descr="Fail immediately, with the given message.">
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failIf" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failIfAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failIfEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnless" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnlessAlmostEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnlessEqual" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failUnlessRaises" func="yes">
			<Overload retVal="" descr=>
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.failureException" func="yes">
			<Overload retVal="" descr="Assertion failed.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.id" />
		<KeyWord name="unittest.TestCase.longMessage" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.maxDiff" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[result=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.setUp" func="yes">
			<Overload retVal="" descr="Hook method for setting up the test fixture before exercising it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.setUpClass" func="yes">
			<Overload retVal="" descr="Hook method for setting up class fixture before running tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.shortDescription" func="yes">
			<Overload retVal="" descr="Returns a one-line description of the test, or None if no&#10;description has been provided.&#10;&#10;The default implementation of this method returns the first line of&#10;the specified test method's docstring.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.skipTest" func="yes">
			<Overload retVal="" descr="Skip this test.">
				<Param name="self" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.subTest" func="yes">
			<Overload retVal="" descr="Return a context manager that will return the enclosed block&#10;of code in a subtest identified by the optional message and&#10;keyword parameters.  A failure in the subtest marks the test&#10;case as failed but resumes execution at the end of the enclosed&#10;block, allowing further test code to be executed.">
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.tearDown" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the test fixture after testing it.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestCase.tearDownClass" func="yes">
			<Overload retVal="" descr="Hook method for deconstructing the class fixture after running all tests in the class.">
				<Param name="cls" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader" func="yes">
			<Overload retVal="" descr="This class is responsible for loading tests according to various criteria&#10;and returning them wrapped in a TestSuite">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.discover" func="yes">
			<Overload retVal="" descr="Find and return all test modules from the specified start&#10;directory, recursing into subdirectories to find them and return all&#10;tests found within them. Only test files that match the pattern will&#10;be loaded. (Using shell style pattern matching.)&#10;&#10;All test modules must be importable from the top level of the project.&#10;If the start directory is not the top level directory then the top&#10;level directory must be specified separately.&#10;&#10;If a test package name (directory with '__init__.py') matches the&#10;pattern then the package will be checked for a 'load_tests' function. If&#10;this exists then it will be called with (loader, tests, pattern) unless&#10;the package has already had load_tests called from the same discovery&#10;invocation, in which case the package module object is not scanned for&#10;tests - this ensures that when a package uses discover to further&#10;discover child tests that infinite recursion does not happen.&#10;&#10;If load_tests exists then discovery does *not* recurse into the package,&#10;load_tests is responsible for loading all tests in the package.&#10;&#10;The pattern is deliberately not stored as a loader attribute so that&#10;packages can continue discovery themselves. top_level_dir is stored so&#10;load_tests does not need to pass this argument in to loader.discover().&#10;&#10;Paths are sorted before being imported to ensure reproducible execution&#10;order even on filesystems with non-alphabetical ordering like ext3/4.">
				<Param name="self" />
				<Param name="start_dir" />
				<Param name="[pattern=test*.py" />
				<Param name="[top_level_dir=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.getTestCaseNames" func="yes">
			<Overload retVal="" descr="Return a sorted sequence of method names found within testCaseClass">
				<Param name="self" />
				<Param name="testCaseClass" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromModule" func="yes">
			<Overload retVal="" descr="Return a suite of all test cases contained in the given module">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromName" func="yes">
			<Overload retVal="" descr="Return a suite of all test cases given a string specifier.&#10;&#10;The name may resolve either to a module, a test case class, a&#10;test method within a test case class, or a callable object which&#10;returns a TestCase or TestSuite instance.&#10;&#10;The method optionally resolves the names relative to a given module.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[module=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromNames" func="yes">
			<Overload retVal="" descr="Return a suite of all test cases found using the given sequence&#10;of string specifiers. See 'loadTestsFromName()'.">
				<Param name="self" />
				<Param name="names" />
				<Param name="[module=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.loadTestsFromTestCase" func="yes">
			<Overload retVal="" descr="Return a suite of all test cases contained in testCaseClass">
				<Param name="self" />
				<Param name="testCaseClass" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.sortTestMethodsUsing" func="yes">
			<Overload retVal="" descr="Return -1 if x &lt; y, 0 if x == y and 1 if x &gt; y">
				<Param name="x" />
				<Param name="y" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.suiteClass" func="yes">
			<Overload retVal="" descr="A test suite is a composite test consisting of a number of TestCases.&#10;&#10;For use, create an instance of TestSuite, then add test case instances.&#10;When all tests have been added, the suite can be passed to a test&#10;runner, such as TextTestRunner. It will run the individual test cases&#10;in the order in which they were added, aggregating the results. When&#10;subclassing, do not forget to call the base class constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestLoader.testMethodPrefix" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestProgram" func="yes">
			<Overload retVal="" descr="A command-line program that runs a set of tests; this is primarily&#10;for making test modules conveniently executable.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestProgram.createTests" />
		<KeyWord name="unittest.TestProgram.parseArgs" />
		<KeyWord name="unittest.TestProgram.runTests" />
		<KeyWord name="unittest.TestProgram.usageExit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestProgram.verbosity" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult" func="yes">
			<Overload retVal="" descr="Holder for test result information.&#10;&#10;Test results are automatically managed by the TestCase and TestSuite&#10;classes, and do not need to be explicitly manipulated by writers of tests.&#10;&#10;Each instance holds the total number of tests run, and collections of&#10;failures and errors that occurred among those test runs. The collections&#10;contain tuples of (testcase, exceptioninfo), where exceptioninfo is the&#10;formatted traceback of the error that occurred.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addError" func="yes">
			<Overload retVal="" descr="Called when an error has occurred. 'err' is a tuple of values as&#10;returned by sys.exc_info().">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addExpectedFailure" func="yes">
			<Overload retVal="" descr="Called when an expected failure/error occurred.">
				<Param name="self" />
				<Param name="test" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addFailure" func="yes">
			<Overload retVal="" descr="Called when an error has occurred. 'err' is a tuple of values as&#10;returned by sys.exc_info().">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addSkip" func="yes">
			<Overload retVal="" descr="Called when a test is skipped.">
				<Param name="self" />
				<Param name="test" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addSubTest" func="yes">
			<Overload retVal="" descr="Called at the end of a subtest.&#10;'err' is None if the subtest ended successfully, otherwise it's a&#10;tuple of values as returned by sys.exc_info().">
				<Param name="self" />
				<Param name="test" />
				<Param name="subtest" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addSuccess" func="yes">
			<Overload retVal="" descr="Called when a test has completed successfully">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.addUnexpectedSuccess" func="yes">
			<Overload retVal="" descr="Called when a test was expected to fail, but succeed.">
				<Param name="self" />
				<Param name="[**]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.printErrors" func="yes">
			<Overload retVal="" descr="Called by TestRunner after test run">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.startTest" func="yes">
			<Overload retVal="" descr="Called when the given test is about to be run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.startTestRun" func="yes">
			<Overload retVal="" descr="Called once before any tests are executed.&#10;&#10;See startTest for a method called before each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.stop" func="yes">
			<Overload retVal="" descr="Indicates that the tests should be aborted.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.stopTest" func="yes">
			<Overload retVal="" descr="Called when the given test has been run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.stopTestRun" func="yes">
			<Overload retVal="" descr="Called once after all tests are executed.&#10;&#10;See stopTest for a method called after each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestResult.wasSuccessful" func="yes">
			<Overload retVal="" descr="Tells whether or not this result was a success.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestSuite" func="yes">
			<Overload retVal="" descr="A test suite is a composite test consisting of a number of TestCases.&#10;&#10;For use, create an instance of TestSuite, then add test case instances.&#10;When all tests have been added, the suite can be passed to a test&#10;runner, such as TextTestRunner. It will run the individual test cases&#10;in the order in which they were added, aggregating the results. When&#10;subclassing, do not forget to call the base class constructor.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestSuite.addTest" />
		<KeyWord name="unittest.TestSuite.addTests" />
		<KeyWord name="unittest.TestSuite.countTestCases" />
		<KeyWord name="unittest.TestSuite.debug" func="yes">
			<Overload retVal="" descr="Run the tests without collecting errors in a TestResult">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TestSuite.run" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="result" />
				<Param name="[debug=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult" func="yes">
			<Overload retVal="" descr="A test result class that can print formatted text results to a stream.&#10;&#10;Used by TextTestRunner.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addError" func="yes">
			<Overload retVal="" descr="Called when an error has occurred. 'err' is a tuple of values as&#10;returned by sys.exc_info().">
				<Param name="self" />
				<Param name="test" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addExpectedFailure" func="yes">
			<Overload retVal="" descr="Called when an expected failure/error occurred.">
				<Param name="self" />
				<Param name="test" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addFailure" func="yes">
			<Overload retVal="" descr="Called when an error has occurred. 'err' is a tuple of values as&#10;returned by sys.exc_info().">
				<Param name="self" />
				<Param name="test" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addSkip" func="yes">
			<Overload retVal="" descr="Called when a test is skipped.">
				<Param name="self" />
				<Param name="test" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addSubTest" func="yes">
			<Overload retVal="" descr="Called at the end of a subtest.&#10;'err' is None if the subtest ended successfully, otherwise it's a&#10;tuple of values as returned by sys.exc_info().">
				<Param name="self" />
				<Param name="test" />
				<Param name="subtest" />
				<Param name="err" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addSuccess" func="yes">
			<Overload retVal="" descr="Called when a test has completed successfully">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.addUnexpectedSuccess" func="yes">
			<Overload retVal="" descr="Called when a test was expected to fail, but succeed.">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.getDescription" />
		<KeyWord name="unittest.TextTestResult.printErrorList" />
		<KeyWord name="unittest.TextTestResult.printErrors" func="yes">
			<Overload retVal="" descr="Called by TestRunner after test run">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.separator1" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.separator2" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.startTest" func="yes">
			<Overload retVal="" descr="Called when the given test is about to be run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.startTestRun" func="yes">
			<Overload retVal="" descr="Called once before any tests are executed.&#10;&#10;See startTest for a method called before each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.stop" func="yes">
			<Overload retVal="" descr="Indicates that the tests should be aborted.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.stopTest" func="yes">
			<Overload retVal="" descr="Called when the given test has been run">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.stopTestRun" func="yes">
			<Overload retVal="" descr="Called once after all tests are executed.&#10;&#10;See stopTest for a method called after each test.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestResult.wasSuccessful" func="yes">
			<Overload retVal="" descr="Tells whether or not this result was a success.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestRunner" func="yes">
			<Overload retVal="" descr="A test runner class that displays results in textual form.&#10;&#10;It prints out the names of tests as they are run, errors as they&#10;occur, and a summary of the results at the end of the test run.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestRunner.resultclass" func="yes">
			<Overload retVal="" descr="A test result class that can print formatted text results to a stream.&#10;&#10;Used by TextTestRunner.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.TextTestRunner.run" func="yes">
			<Overload retVal="" descr="Run the given test case or test suite.">
				<Param name="self" />
				<Param name="test" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.defaultTestLoader" func="yes">
			<Overload retVal="" descr="(TestLoader)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.expectedFailure" />
		<KeyWord name="unittest.findTestCases" func="yes">
			<Overload retVal="" descr=>
				<Param name="module" />
				<Param name="[prefix=test" />
				<Param name="[sortUsing=<function three_way_cmp at 0x03735978>" />
				<Param name="[suiteClass=<class 'unittest.suite.TestSuite'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.getTestCaseNames" func="yes">
			<Overload retVal="" descr=>
				<Param name="testCaseClass" />
				<Param name="prefix" />
				<Param name="[sortUsing=<function three_way_cmp at 0x03735978>]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.installHandler" />
		<KeyWord name="unittest.load_tests" />
		<KeyWord name="unittest.main" func="yes">
			<Overload retVal="" descr="A command-line program that runs a set of tests; this is primarily&#10;for making test modules conveniently executable.">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.main.createTests" />
		<KeyWord name="unittest.main.parseArgs" />
		<KeyWord name="unittest.main.runTests" />
		<KeyWord name="unittest.main.usageExit" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="[msg=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.main.verbosity" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.makeSuite" func="yes">
			<Overload retVal="" descr=>
				<Param name="testCaseClass" />
				<Param name="[prefix=test" />
				<Param name="[sortUsing=<function three_way_cmp at 0x03735978>" />
				<Param name="[suiteClass=<class 'unittest.suite.TestSuite'>]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.registerResult" />
		<KeyWord name="unittest.removeHandler" func="yes">
			<Overload retVal="" descr=>
				<Param name="[method=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.removeResult" />
		<KeyWord name="unittest.skip" func="yes">
			<Overload retVal="" descr="Unconditionally skip a test.">
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.skipIf" func="yes">
			<Overload retVal="" descr="Skip a test if the condition is true.">
				<Param name="condition" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unittest.skipUnless" func="yes">
			<Overload retVal="" descr="Skip a test unless the condition is true.">
				<Param name="condition" />
				<Param name="reason" />
			</Overload>
		</KeyWord>
		<KeyWord name="unix_getpass" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="unlink" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="unlock" func="yes">
			<Overload retVal="" descr="Function of mailbox.Babyl">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_archive" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_array" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_bool" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_bytes" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_double" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_enum" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_farray" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_float" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_fopaque" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_from" func="yes">
			<Overload retVal="" descr="Function of struct">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_fstring" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_hyper" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_int" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_list" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_opaque" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_string" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_uhyper" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unpack_uint" func="yes">
			<Overload retVal="" descr="Function of xdrlib.Unpacker">
			</Overload>
		</KeyWord>
		<KeyWord name="unregister_archive_format" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="unregister_dialect" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="unregister_unpack_format" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="unsubscribe" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="untokenize" func="yes">
			<Overload retVal="" descr="Function of tokenize">
			</Overload>
		</KeyWord>
		<KeyWord name="unwrap" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="update" func="yes">
			<Overload retVal="" descr="Update a set with the union of itself and others.">
			</Overload>
		</KeyWord>
		<KeyWord name="update_visible" func="yes">
			<Overload retVal="" descr="Function of mailbox.BabylMessage">
			</Overload>
		</KeyWord>
		<KeyWord name="update_wrapper" func="yes">
			<Overload retVal="" descr="Function of functools">
			</Overload>
		</KeyWord>
		<KeyWord name="updatecache" func="yes">
			<Overload retVal="" descr="Function of linecache">
			</Overload>
		</KeyWord>
		<KeyWord name="upper" func="yes">
			<Overload retVal="" descr="S.upper() -&gt; str&#10;&#10;Return a copy of S converted to uppercase.">
			</Overload>
		</KeyWord>
		<KeyWord name="urandom" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="url2pathname" func="yes">
			<Overload retVal="" descr="Function of macurl2path">
			</Overload>
		</KeyWord>
		<KeyWord name="urllib" />
		<KeyWord name="urlquote_from_bytes" func="yes">
			<Overload retVal="" descr="Function of pathlib">
			</Overload>
		</KeyWord>
		<KeyWord name="urlsafe_b64decode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="urlsafe_b64encode" func="yes">
			<Overload retVal="" descr="Function of base64">
			</Overload>
		</KeyWord>
		<KeyWord name="usage" func="yes">
			<Overload retVal="" descr="Function of smtpd">
			</Overload>
		</KeyWord>
		<KeyWord name="usageExit" func="yes">
			<Overload retVal="" descr="Function of unittest.TestProgram">
			</Overload>
		</KeyWord>
		<KeyWord name="user" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="user_call" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="user_exception" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="user_line" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="user_return" func="yes">
			<Overload retVal="" descr="Function of bdb.Bdb">
			</Overload>
		</KeyWord>
		<KeyWord name="usesTime" func="yes">
			<Overload retVal="" descr="Function of logging.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="utcfromtimestamp" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="utcnow" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="utcoffset" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="utctimetuple" func="yes">
			<Overload retVal="" descr="Function of datetime.datetime">
			</Overload>
		</KeyWord>
		<KeyWord name="utf8" func="yes">
			<Overload retVal="" descr="Function of poplib.POP3">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_be_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_be_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_ex_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_le_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_16_le_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_be_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_be_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_ex_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_le_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_32_le_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_7_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_7_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_8_decode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utf_8_encode" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="utime" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="uu" func="yes">
			<Overload retVal="" descr="Implementation of the UUencode and UUdecode functions.&#10;&#10;encode(in_file, out_file [,name, mode])&#10;decode(in_file [, out_file, mode])">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="uu.decode" func="yes">
			<Overload retVal="" descr="Decode uuencoded file">
				<Param name="in_file" />
				<Param name="[out_file=None" />
				<Param name="[mode=None" />
				<Param name="[quiet=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="uu.encode" func="yes">
			<Overload retVal="" descr="Uuencode file">
				<Param name="in_file" />
				<Param name="out_file" />
				<Param name="[name=None" />
				<Param name="[mode=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="uu.test" func="yes">
			<Overload retVal="" descr="uuencode/uudecode main program">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid" func="yes">
			<Overload retVal="" descr="UUID objects (universally unique identifiers) according to RFC 4122.&#10;&#10;This module provides immutable UUID objects (class UUID) and the functions&#10;uuid1(), uuid3(), uuid4(), uuid5() for generating version 1, 3, 4, and 5&#10;UUIDs as specified in RFC 4122.&#10;&#10;If all you want is a unique ID, you should probably call uuid1() or uuid4().&#10;Note that uuid1() may compromise privacy since it creates a UUID containing&#10;the computer's network address.  uuid4() creates a random UUID.&#10;&#10;Typical usage:&#10;&#10;    &gt;&gt;&gt; import uuid&#10;&#10;    # make a UUID based on the host ID and current time&#10;    &gt;&gt;&gt; uuid.uuid1()    # doctest: +SKIP&#10;    UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')&#10;&#10;    # make a UUID using an MD5 hash of a namespace UUID and a name&#10;    &gt;&gt;&gt; uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')&#10;    UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')&#10;&#10;    # make a random UUID&#10;    &gt;&gt;&gt; uuid.uuid4()    # doctest: +SKIP&#10;    UUID('16fd2706-8baf-433b-82eb-8c7fada847da')&#10;&#10;    # make a UUID using a SHA-1 hash of a namespace UUID and a name&#10;    &gt;&gt;&gt; uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')&#10;    UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')&#10;&#10;    # make a UUID from a string of hex digits (braces and hyphens ignored)&#10;    &gt;&gt;&gt; x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')&#10;&#10;    # convert a UUID to a string of hex digits in standard form&#10;    &gt;&gt;&gt; str(x)&#10;    '00010203-0405-0607-0809-0a0b0c0d0e0f'&#10;&#10;    # get the raw 16 bytes of the UUID&#10;    &gt;&gt;&gt; x.bytes&#10;    b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'&#10;&#10;    # make a UUID from a 16-byte string&#10;    &gt;&gt;&gt; uuid.UUID(bytes=x.bytes)&#10;    UUID('00010203-0405-0607-0809-0a0b0c0d0e0f')">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_DNS" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_OID" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_URL" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.NAMESPACE_X500" func="yes">
			<Overload retVal="" descr="(UUID)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RESERVED_FUTURE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RESERVED_MICROSOFT" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RESERVED_NCS" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.RFC_4122" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID" func="yes">
			<Overload retVal="" descr="Instances of the UUID class represent UUIDs as specified in RFC 4122.&#10;UUID objects are immutable, hashable, and usable as dictionary keys.&#10;Converting a UUID to a string with str() yields something in the form&#10;'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts&#10;five possible forms: a similar string of hexadecimal digits, or a tuple&#10;of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and&#10;48-bit values respectively) as an argument named 'fields', or a string&#10;of 16 bytes (with all the integer fields in big-endian order) as an&#10;argument named 'bytes', or a string of 16 bytes (with the first three&#10;fields in little-endian order) as an argument named 'bytes_le', or a&#10;single 128-bit integer as an argument named 'int'.&#10;&#10;UUIDs have these read-only attributes:&#10;&#10;    bytes       the UUID as a 16-byte string (containing the six&#10;                integer fields in big-endian byte order)&#10;&#10;    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,&#10;                and time_hi_version in little-endian byte order)&#10;&#10;    fields      a tuple of the six integer fields of the UUID,&#10;                which are also available as six individual attributes&#10;                and two derived attributes:&#10;&#10;        time_low                the first 32 bits of the UUID&#10;        time_mid                the next 16 bits of the UUID&#10;        time_hi_version         the next 16 bits of the UUID&#10;        clock_seq_hi_variant    the next 8 bits of the UUID&#10;        clock_seq_low           the next 8 bits of the UUID&#10;        node                    the last 48 bits of the UUID&#10;&#10;        time                    the 60-bit timestamp&#10;        clock_seq               the 14-bit sequence number&#10;&#10;    hex         the UUID as a 32-character hexadecimal string&#10;&#10;    int         the UUID as a 128-bit integer&#10;&#10;    urn         the UUID as a URN as specified in RFC 4122&#10;&#10;    variant     the UUID variant (one of the constants RESERVED_NCS,&#10;                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)&#10;&#10;    version     the UUID version number (1 through 5, meaningful only&#10;                when the variant is RFC_4122)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.bytes" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.bytes_le" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.clock_seq" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.clock_seq_hi_variant" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.clock_seq_low" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.fields" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.hex" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.node" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time_hi_version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time_low" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.time_mid" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.urn" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.variant" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.UUID.version" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.getnode" func="yes">
			<Overload retVal="" descr="Get the hardware address as a 48-bit positive integer.&#10;&#10;The first time this runs, it may launch a separate program, which could&#10;be quite slow.  If all attempts to obtain the hardware address fail, we&#10;choose a random 48-bit number with its eighth bit set to 1 as recommended&#10;in RFC 4122.">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.lib" func="yes">
			<Overload retVal="" descr="(WinDLL)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.libname" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid1" func="yes">
			<Overload retVal="" descr="Generate a UUID from a host ID, sequence number, and the current time.&#10;If 'node' is not given, getnode() is used to obtain the hardware&#10;address.  If 'clock_seq' is given, it is used as the sequence number;&#10;otherwise a random 14-bit sequence number is chosen.">
				<Param name="[node=None" />
				<Param name="[clock_seq=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid3" func="yes">
			<Overload retVal="" descr="Generate a UUID from the MD5 hash of a namespace UUID and a name.">
				<Param name="namespace" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid4" func="yes">
			<Overload retVal="" descr="Generate a random UUID.">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid.uuid5" func="yes">
			<Overload retVal="" descr="Generate a UUID from the SHA-1 hash of a namespace UUID and a name.">
				<Param name="namespace" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="uuid1" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid3" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid4" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="uuid5" func="yes">
			<Overload retVal="" descr="Function of uuid">
			</Overload>
		</KeyWord>
		<KeyWord name="v4_int_to_packed" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="v6_int_to_packed" func="yes">
			<Overload retVal="" descr="Function of ipaddress">
			</Overload>
		</KeyWord>
		<KeyWord name="valid_boundary" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="validate" func="yes">
			<Overload retVal="" descr="Function of setuptools.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="values" func="yes">
			<Overload retVal="" descr="D.values() -&gt; an object providing a view on D's values">
			</Overload>
		</KeyWord>
		<KeyWord name="variance" func="yes">
			<Overload retVal="" descr="Function of statistics">
			</Overload>
		</KeyWord>
		<KeyWord name="vars" func="yes">
			<Overload retVal="" descr="vars([object]) -&gt; dictionary&#10;&#10;Without arguments, equivalent to locals().&#10;With an argument, equivalent to object.__dict__.">
			</Overload>
		</KeyWord>
		<KeyWord name="venv" func="yes">
			<Overload retVal="" descr="Virtual environment (venv) package for Python. Based on PEP 405.&#10;&#10;Copyright (C) 2011-2014 Vinay Sajip.&#10;Licensed to the PSF under a contributor agreement.">
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder" func="yes">
			<Overload retVal="" descr="This class exists to allow virtual environment creation to be&#10;customized. The constructor parameters determine the builder's&#10;behaviour when called upon to create a virtual environment.&#10;&#10;By default, the builder makes the system (global) site-packages dir&#10;*un*available to the created environment.&#10;&#10;If invoked using the Python -m option, the default is to use copying&#10;on Windows platforms but symlinks elsewhere. If instantiated some&#10;other way, the default is to *not* use symlinks.&#10;&#10;:param system_site_packages: If True, the system (global) site-packages&#10;                             dir is available to created environments.&#10;:param clear: If True, delete the contents of the environment directory if&#10;              it already exists, before environment creation.&#10;:param symlinks: If True, attempt to symlink rather than copy files into&#10;                 virtual environment.&#10;:param upgrade: If True, upgrade an existing virtual environment.&#10;:param with_pip: If True, ensure pip is installed in the virtual&#10;                 environment&#10;:param prompt: Alternative terminal prefix for the environment.">
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.clear_directory" />
		<KeyWord name="venv.EnvBuilder.create" func="yes">
			<Overload retVal="" descr="Create a virtual environment in a directory.&#10;&#10;:param env_dir: The target directory to create an environment in.">
				<Param name="self" />
				<Param name="env_dir" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.create_configuration" func="yes">
			<Overload retVal="" descr="Create a configuration file indicating where the environment's Python&#10;was copied from, and whether the system site-packages should be made&#10;available in the environment.&#10;&#10;:param context: The information for the environment creation request&#10;                being processed.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.ensure_directories" func="yes">
			<Overload retVal="" descr="Create the directories for the environment.&#10;&#10;Returns a context object which holds paths in the environment,&#10;for use by subsequent logic.">
				<Param name="self" />
				<Param name="env_dir" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.include_binary" />
		<KeyWord name="venv.EnvBuilder.install_scripts" func="yes">
			<Overload retVal="" descr="Install scripts into the created environment from a directory.&#10;&#10;:param context: The information for the environment creation request&#10;                being processed.&#10;:param path:    Absolute pathname of a directory containing script.&#10;                Scripts in the 'common' subdirectory of this directory,&#10;                and those in the directory named for the platform&#10;                being run on, are installed in the created environment.&#10;                Placeholder variables are replaced with environment-&#10;                specific values.">
				<Param name="self" />
				<Param name="context" />
				<Param name="path" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.post_setup" func="yes">
			<Overload retVal="" descr="Hook for post-setup modification of the venv. Subclasses may install&#10;additional packages or scripts here, add activation shell scripts, etc.&#10;&#10;:param context: The information for the environment creation request&#10;                being processed.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.replace_variables" func="yes">
			<Overload retVal="" descr="Replace variable placeholders in script text with context-specific&#10;variables.&#10;&#10;Return the text passed in , but with variables replaced.&#10;&#10;:param text: The text in which to replace placeholder variables.&#10;:param context: The information for the environment creation request&#10;                being processed.">
				<Param name="self" />
				<Param name="text" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.setup_python" func="yes">
			<Overload retVal="" descr="Set up a Python executable in the environment.&#10;&#10;:param context: The information for the environment creation request&#10;                being processed.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.setup_scripts" func="yes">
			<Overload retVal="" descr="Set up scripts into the created environment from a directory.&#10;&#10;This method installs the default scripts into the environment&#10;being created. You can prevent the default installation by overriding&#10;this method if you really need to, or if you need to specify&#10;a different location for the scripts to install. By default, the&#10;'scripts' directory in the venv package is used as the source of&#10;scripts to install.">
				<Param name="self" />
				<Param name="context" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.EnvBuilder.symlink_or_copy" func="yes">
			<Overload retVal="" descr="Try symlinking a file, and if that fails, fall back to copying.">
				<Param name="self" />
				<Param name="src" />
				<Param name="dst" />
				<Param name="[relative_symlinks_ok=False]" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.create" func="yes">
			<Overload retVal="" descr="Create a virtual environment in a directory.">
				<Param name="env_dir" />
				<Param name="[system_site_packages=False" />
				<Param name="[clear=False" />
				<Param name="[symlinks=False" />
				<Param name="[with_pip=False" />
				<Param name="[prompt=None]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="venv.logger" func="yes">
			<Overload retVal="" descr="(Logger)">
			</Overload>
		</KeyWord>
		<KeyWord name="venv.main" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="verify" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="verify_request" func="yes">
			<Overload retVal="" descr="Function of socketserver.BaseServer">
			</Overload>
		</KeyWord>
		<KeyWord name="version" func="yes">
			<Overload retVal="" descr="Function of ensurepip">
			</Overload>
		</KeyWord>
		<KeyWord name="version_ok" func="yes">
			<Overload retVal="" descr="Function of setuptools.Require">
			</Overload>
		</KeyWord>
		<KeyWord name="vformat" func="yes">
			<Overload retVal="" descr="Function of string.Formatter">
			</Overload>
		</KeyWord>
		<KeyWord name="visiblename" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="visit" func="yes">
			<Overload retVal="" descr="Function of ast.NodeTransformer">
			</Overload>
		</KeyWord>
		<KeyWord name="voidcmd" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="voidresp" func="yes">
			<Overload retVal="" descr="Function of ftplib.FTP">
			</Overload>
		</KeyWord>
		<KeyWord name="vonmisesvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="vrfy" func="yes">
			<Overload retVal="" descr="Function of smtplib.LMTP">
			</Overload>
		</KeyWord>
		<KeyWord name="wait" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="wait_closed" func="yes">
			<Overload retVal="" descr="Function of asyncio.AbstractServer">
			</Overload>
		</KeyWord>
		<KeyWord name="wait_for" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="wait_for_handle" func="yes">
			<Overload retVal="" descr="Function of asyncio.IocpProactor">
			</Overload>
		</KeyWord>
		<KeyWord name="waitpid" func="yes">
			<Overload retVal="" descr="Function of os">
			</Overload>
		</KeyWord>
		<KeyWord name="walk" func="yes">
			<Overload retVal="" descr="Function of ast">
			</Overload>
		</KeyWord>
		<KeyWord name="walk_packages" func="yes">
			<Overload retVal="" descr="Function of pkgutil">
			</Overload>
		</KeyWord>
		<KeyWord name="walk_stack" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="walk_tb" func="yes">
			<Overload retVal="" descr="Function of traceback">
			</Overload>
		</KeyWord>
		<KeyWord name="walktree" func="yes">
			<Overload retVal="" descr="Function of inspect">
			</Overload>
		</KeyWord>
		<KeyWord name="warn" func="yes">
			<Overload retVal="" descr="Function of cgi">
			</Overload>
		</KeyWord>
		<KeyWord name="warn_deprecated" func="yes">
			<Overload retVal="" descr="Function of setuptools.Feature">
			</Overload>
		</KeyWord>
		<KeyWord name="warn_explicit" func="yes">
			<Overload retVal="" descr="Function of warnings">
			</Overload>
		</KeyWord>
		<KeyWord name="warning" func="yes">
			<Overload retVal="" descr="Function of logging">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings" func="yes">
			<Overload retVal="" descr="Python part of the warnings subsystem.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.WarningMessage" />
		<KeyWord name="warnings.catch_warnings" func="yes">
			<Overload retVal="" descr="A context manager that copies and restores the warnings filter upon&#10;exiting the context.&#10;&#10;The 'record' argument specifies whether warnings should be captured by a&#10;custom implementation of warnings.showwarning() and be appended to a list&#10;returned by the context manager. Otherwise None is returned by the context&#10;manager. The objects appended to the list are arguments whose attributes&#10;mirror the arguments to showwarning().&#10;&#10;The 'module' argument is to specify an alternative module to the module&#10;named 'warnings' and imported under that name. This argument is only useful&#10;when testing the warnings module itself.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.defaultaction" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.filters" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.filterwarnings" func="yes">
			<Overload retVal="" descr="Insert an entry into the list of warnings filters (at the front).&#10;&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'message' -- a regex that the warning message must match&#10;'category' -- a class that the warning must be a subclass of&#10;'module' -- a regex that the module name must match&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[message" />
				<Param name="[category=<class 'Warning'>" />
				<Param name="[module" />
				<Param name="[lineno=0" />
				<Param name="[append=False]]]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.formatwarning" func="yes">
			<Overload retVal="" descr="Function to format a warning the standard way.">
				<Param name="message" />
				<Param name="category" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[line=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.resetwarnings" func="yes">
			<Overload retVal="" descr="Clear the list of warning filters, so that no filters are active.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.showwarning" func="yes">
			<Overload retVal="" descr="Hook to write a warning to a file; replace if you like.">
				<Param name="message" />
				<Param name="category" />
				<Param name="filename" />
				<Param name="lineno" />
				<Param name="[file=None" />
				<Param name="[line=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.simplefilter" func="yes">
			<Overload retVal="" descr="Insert a simple entry into the list of warnings filters (at the front).&#10;&#10;A simple filter matches all modules and messages.&#10;'action' -- one of &quot;error&quot;, &quot;ignore&quot;, &quot;always&quot;, &quot;default&quot;, &quot;module&quot;,&#10;            or &quot;once&quot;&#10;'category' -- a class that the warning must be a subclass of&#10;'lineno' -- an integer line number, 0 matches all warnings&#10;'append' -- if true, append to the list of filters">
				<Param name="action" />
				<Param name="[category=<class 'Warning'>" />
				<Param name="[lineno=0" />
				<Param name="[append=False]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.warn" func="yes">
			<Overload retVal="" descr="Issue a warning, or maybe ignore it or raise an exception.">
			</Overload>
		</KeyWord>
		<KeyWord name="warnings.warn_explicit" func="yes">
			<Overload retVal="" descr="Low-level inferface to warnings functionality.">
			</Overload>
		</KeyWord>
		<KeyWord name="wasSuccessful" func="yes">
			<Overload retVal="" descr="Function of unittest.TestResult">
			</Overload>
		</KeyWord>
		<KeyWord name="wave" func="yes">
			<Overload retVal="" descr="Stuff to parse WAVE files.&#10;&#10;Usage.&#10;&#10;Reading WAVE files:&#10;      f = wave.open(file, 'r')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods read(), seek(), and close().&#10;When the setpos() and rewind() methods are not used, the seek()&#10;method is not  necessary.&#10;&#10;This returns an instance of a class with the following public methods:&#10;      getnchannels()  -- returns number of audio channels (1 for&#10;                         mono, 2 for stereo)&#10;      getsampwidth()  -- returns sample width in bytes&#10;      getframerate()  -- returns sampling frequency&#10;      getnframes()    -- returns number of audio frames&#10;      getcomptype()   -- returns compression type ('NONE' for linear samples)&#10;      getcompname()   -- returns human-readable version of&#10;                         compression type ('not compressed' linear samples)&#10;      getparams()     -- returns a namedtuple consisting of all of the&#10;                         above in the above order&#10;      getmarkers()    -- returns None (for compatibility with the&#10;                         aifc module)&#10;      getmark(id)     -- raises an error since the mark does not&#10;                         exist (for compatibility with the aifc module)&#10;      readframes(n)   -- returns at most n frames of audio&#10;      rewind()        -- rewind to the beginning of the audio stream&#10;      setpos(pos)     -- seek to the specified position&#10;      tell()          -- return the current position&#10;      close()         -- close the instance (make it unusable)&#10;The position returned by tell() and the position given to setpos()&#10;are compatible and have nothing to do with the actual position in the&#10;file.&#10;The close() method is called automatically when the class instance&#10;is destroyed.&#10;&#10;Writing WAVE files:&#10;      f = wave.open(file, 'w')&#10;where file is either the name of a file or an open file pointer.&#10;The open file pointer must have methods write(), tell(), seek(), and&#10;close().&#10;&#10;This returns an instance of a class with the following public methods:&#10;      setnchannels(n) -- set the number of channels&#10;      setsampwidth(n) -- set the sample width&#10;      setframerate(n) -- set the frame rate&#10;      setnframes(n)   -- set the number of frames&#10;      setcomptype(type, name)&#10;                      -- set the compression type and the&#10;                         human-readable compression type&#10;      setparams(tuple)&#10;                      -- set all parameters at once&#10;      tell()          -- return current position in output file&#10;      writeframesraw(data)&#10;                      -- write audio frames without pathing up the&#10;                         file header&#10;      writeframes(data)&#10;                      -- write audio frames and patch up the file header&#10;      close()         -- patch up the file header and close the&#10;                         output file&#10;You should set the parameters before the first writeframesraw or&#10;writeframes.  The total number of frames does not need to be set,&#10;but when it is set to the correct value, the header does not have to&#10;be patched up.&#10;It is best to first set all parameters, perhaps possibly the&#10;compression type, and then write audio frames using writeframesraw.&#10;When all frames have been written, either call writeframes(b'') or&#10;close() to patch up the sizes in the header.&#10;The close() method is called automatically when the class instance&#10;is destroyed.">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk" />
		<KeyWord name="wave.Chunk.close" />
		<KeyWord name="wave.Chunk.getname" func="yes">
			<Overload retVal="" descr="Return the name (ID) of the current chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk.getsize" func="yes">
			<Overload retVal="" descr="Return the size of the current chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk.isatty" />
		<KeyWord name="wave.Chunk.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes from the chunk.&#10;If size is omitted or negative, read until the end&#10;of the chunk.">
				<Param name="self" />
				<Param name="[size=-1]" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk.seek" func="yes">
			<Overload retVal="" descr="Seek to specified position into the chunk.&#10;Default position is 0 (start of chunk).&#10;If the file is not seekable, this will result in an error.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="[whence=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk.skip" func="yes">
			<Overload retVal="" descr="Skip the rest of the chunk.&#10;If you are not interested in the contents of the chunk,&#10;this method should be called so that the file points to&#10;the start of the next chunk.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Chunk.tell" />
		<KeyWord name="wave.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.WAVE_FORMAT_PCM" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Wave_read" func="yes">
			<Overload retVal="" descr="Variables used in this class:&#10;&#10;These variables are available to the user though appropriate&#10;methods of this class:&#10;_file -- the open file with methods read(), close(), and seek()&#10;          set through the __init__() method&#10;_nchannels -- the number of audio channels&#10;          available through the getnchannels() method&#10;_nframes -- the number of audio frames&#10;          available through the getnframes() method&#10;_sampwidth -- the number of bytes per audio sample&#10;          available through the getsampwidth() method&#10;_framerate -- the sampling frequency&#10;          available through the getframerate() method&#10;_comptype -- the AIFF-C compression type ('NONE' if AIFF)&#10;          available through the getcomptype() method&#10;_compname -- the human-readable AIFF-C compression type&#10;          available through the getcomptype() method&#10;_soundpos -- the position in the audio stream&#10;          available through the tell() method, set through the&#10;          setpos() method&#10;&#10;These variables are used internally only:&#10;_fmt_chunk_read -- 1 iff the FMT chunk has been read&#10;_data_seek_needed -- 1 iff positioned correctly in audio&#10;          file for readframes()&#10;_data_chunk -- instantiation of a chunk class for the DATA chunk&#10;_framesize -- size of one frame in the file">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Wave_read.close" />
		<KeyWord name="wave.Wave_read.getcompname" />
		<KeyWord name="wave.Wave_read.getcomptype" />
		<KeyWord name="wave.Wave_read.getfp" />
		<KeyWord name="wave.Wave_read.getframerate" />
		<KeyWord name="wave.Wave_read.getmark" />
		<KeyWord name="wave.Wave_read.getmarkers" />
		<KeyWord name="wave.Wave_read.getnchannels" />
		<KeyWord name="wave.Wave_read.getnframes" />
		<KeyWord name="wave.Wave_read.getparams" />
		<KeyWord name="wave.Wave_read.getsampwidth" />
		<KeyWord name="wave.Wave_read.initfp" />
		<KeyWord name="wave.Wave_read.readframes" />
		<KeyWord name="wave.Wave_read.rewind" />
		<KeyWord name="wave.Wave_read.setpos" />
		<KeyWord name="wave.Wave_read.tell" />
		<KeyWord name="wave.Wave_write" func="yes">
			<Overload retVal="" descr="Variables used in this class:&#10;&#10;These variables are user settable through appropriate methods&#10;of this class:&#10;_file -- the open file with methods write(), close(), tell(), seek()&#10;          set through the __init__() method&#10;_comptype -- the AIFF-C compression type ('NONE' in AIFF)&#10;          set through the setcomptype() or setparams() method&#10;_compname -- the human-readable AIFF-C compression type&#10;          set through the setcomptype() or setparams() method&#10;_nchannels -- the number of audio channels&#10;          set through the setnchannels() or setparams() method&#10;_sampwidth -- the number of bytes per audio sample&#10;          set through the setsampwidth() or setparams() method&#10;_framerate -- the sampling frequency&#10;          set through the setframerate() or setparams() method&#10;_nframes -- the number of audio frames written to the header&#10;          set through the setnframes() or setparams() method&#10;&#10;These variables are used internally only:&#10;_datalength -- the size of the audio samples written to the header&#10;_nframeswritten -- the number of frames actually written&#10;_datawritten -- the size of the audio samples actually written">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.Wave_write.close" />
		<KeyWord name="wave.Wave_write.getcompname" />
		<KeyWord name="wave.Wave_write.getcomptype" />
		<KeyWord name="wave.Wave_write.getframerate" />
		<KeyWord name="wave.Wave_write.getmark" />
		<KeyWord name="wave.Wave_write.getmarkers" />
		<KeyWord name="wave.Wave_write.getnchannels" />
		<KeyWord name="wave.Wave_write.getnframes" />
		<KeyWord name="wave.Wave_write.getparams" />
		<KeyWord name="wave.Wave_write.getsampwidth" />
		<KeyWord name="wave.Wave_write.initfp" />
		<KeyWord name="wave.Wave_write.setcomptype" />
		<KeyWord name="wave.Wave_write.setframerate" />
		<KeyWord name="wave.Wave_write.setmark" />
		<KeyWord name="wave.Wave_write.setnchannels" />
		<KeyWord name="wave.Wave_write.setnframes" />
		<KeyWord name="wave.Wave_write.setparams" />
		<KeyWord name="wave.Wave_write.setsampwidth" />
		<KeyWord name="wave.Wave_write.tell" />
		<KeyWord name="wave.Wave_write.writeframes" />
		<KeyWord name="wave.Wave_write.writeframesraw" />
		<KeyWord name="wave.namedtuple" func="yes">
			<Overload retVal="" descr="Returns a new subclass of tuple with named fields.&#10;&#10;&gt;&gt;&gt; Point = namedtuple('Point', ['x', 'y'])&#10;&gt;&gt;&gt; Point.__doc__                   # docstring for the new class&#10;'Point(x, y)'&#10;&gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords&#10;&gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple&#10;33&#10;&gt;&gt;&gt; x, y = p                        # unpack like a regular tuple&#10;&gt;&gt;&gt; x, y&#10;(11, 22)&#10;&gt;&gt;&gt; p.x + p.y                       # fields also accessible by name&#10;33&#10;&gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary&#10;&gt;&gt;&gt; d['x']&#10;11&#10;&gt;&gt;&gt; Point(**d)                      # convert from a dictionary&#10;Point(x=11, y=22)&#10;&gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields&#10;Point(x=100, y=22)">
			</Overload>
		</KeyWord>
		<KeyWord name="wave.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="wave.openfp" func="yes">
			<Overload retVal="" descr=>
				<Param name="f" />
				<Param name="[mode=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="weakref" func="yes">
			<Overload retVal="" descr="Weak reference support for Python.&#10;&#10;This module is an implementation of PEP 205:&#10;&#10;http://www.python.org/dev/peps/pep-0205/">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.CallableProxyType" />
		<KeyWord name="weakref.KeyedRef" func="yes">
			<Overload retVal="" descr="Specialized reference that includes a key corresponding to the value.&#10;&#10;This is used in the WeakValueDictionary to avoid having to create&#10;a function object for each key stored in the mapping.  A shared&#10;callback object can use the 'key' attribute of a KeyedRef instead&#10;of getting a reference to the key from an enclosing scope.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.KeyedRef.key" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ProxyType" />
		<KeyWord name="weakref.ProxyTypes" func="yes">
			<Overload retVal="" descr="(tuple)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ReferenceType" />
		<KeyWord name="weakref.WeakKeyDictionary" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.WeakMethod" func="yes">
			<Overload retVal="" descr="A custom `weakref.ref` subclass which simulates a weak reference to&#10;a bound method, working around the lifetime problem of bound methods.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.WeakSet" />
		<KeyWord name="weakref.WeakSet.add" />
		<KeyWord name="weakref.WeakSet.clear" />
		<KeyWord name="weakref.WeakSet.copy" />
		<KeyWord name="weakref.WeakSet.difference" />
		<KeyWord name="weakref.WeakSet.difference_update" />
		<KeyWord name="weakref.WeakSet.discard" />
		<KeyWord name="weakref.WeakSet.intersection" />
		<KeyWord name="weakref.WeakSet.intersection_update" />
		<KeyWord name="weakref.WeakSet.isdisjoint" />
		<KeyWord name="weakref.WeakSet.issubset" />
		<KeyWord name="weakref.WeakSet.issuperset" />
		<KeyWord name="weakref.WeakSet.pop" />
		<KeyWord name="weakref.WeakSet.remove" />
		<KeyWord name="weakref.WeakSet.symmetric_difference" />
		<KeyWord name="weakref.WeakSet.symmetric_difference_update" />
		<KeyWord name="weakref.WeakSet.union" />
		<KeyWord name="weakref.WeakSet.update" />
		<KeyWord name="weakref.WeakValueDictionary" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.finalize" func="yes">
			<Overload retVal="" descr="Class for finalization of weakrefable objects&#10;&#10;finalize(obj, func, *args, **kwargs) returns a callable finalizer&#10;object which will be called when obj is garbage collected. The&#10;first time the finalizer is called it evaluates func(*arg, **kwargs)&#10;and returns the result. After this the finalizer is dead, and&#10;calling it just returns None.&#10;&#10;When the program exits any remaining finalizers for which the&#10;atexit attribute is true will be run in reverse order of creation.&#10;By default atexit is true.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.finalize.alive" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.finalize.atexit" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.finalize.detach" func="yes">
			<Overload retVal="" descr="If alive then mark as dead and return (obj, func, args, kwargs);&#10;otherwise return None">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.finalize.peek" func="yes">
			<Overload retVal="" descr="If alive then return (obj, func, args, kwargs);&#10;otherwise return None">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.getweakrefcount" func="yes">
			<Overload retVal="" descr="Return the number of weak references to 'object'.">
				<Param name="object" />
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.getweakrefs" func="yes">
			<Overload retVal="" descr="getweakrefs(object) -- return a list of all weak reference objects&#10;that point to 'object'.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.proxy" func="yes">
			<Overload retVal="" descr="proxy(object[, callback]) -- create a proxy object that weakly&#10;references 'object'.  'callback', if given, is called with a&#10;reference to the proxy when 'object' is about to be finalized.">
			</Overload>
		</KeyWord>
		<KeyWord name="weakref.ref" />
		<KeyWord name="webbrowser" func="yes">
			<Overload retVal="" descr="Interfaces for launching and remotely controlling Web browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser" func="yes">
			<Overload retVal="" descr="Class for all browsers which are to be started in the&#10;background.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BackgroundBrowser.open_new" />
		<KeyWord name="webbrowser.BackgroundBrowser.open_new_tab" />
		<KeyWord name="webbrowser.BaseBrowser" func="yes">
			<Overload retVal="" descr="Parent class for all browsers. Do not use directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BaseBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BaseBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.BaseBrowser.open_new" />
		<KeyWord name="webbrowser.BaseBrowser.open_new_tab" />
		<KeyWord name="webbrowser.Chrome" func="yes">
			<Overload retVal="" descr="Launcher class for Google Chrome browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.open_new" />
		<KeyWord name="webbrowser.Chrome.open_new_tab" />
		<KeyWord name="webbrowser.Chrome.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chrome.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium" func="yes">
			<Overload retVal="" descr="Launcher class for Google Chrome browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.open_new" />
		<KeyWord name="webbrowser.Chromium.open_new_tab" />
		<KeyWord name="webbrowser.Chromium.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Chromium.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks" func="yes">
			<Overload retVal="" descr="Launcher class for Elinks browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.open_new" />
		<KeyWord name="webbrowser.Elinks.open_new_tab" />
		<KeyWord name="webbrowser.Elinks.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Elinks.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon" func="yes">
			<Overload retVal="" descr="Launcher class for Galeon/Epiphany browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.open_new" />
		<KeyWord name="webbrowser.Galeon.open_new_tab" />
		<KeyWord name="webbrowser.Galeon.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.remote_action" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Galeon.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser" func="yes">
			<Overload retVal="" descr="Class for all browsers started with a command&#10;and without remote functionality.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.GenericBrowser.open_new" />
		<KeyWord name="webbrowser.GenericBrowser.open_new_tab" />
		<KeyWord name="webbrowser.Grail" func="yes">
			<Overload retVal="" descr="Parent class for all browsers. Do not use directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Grail.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Grail.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Grail.open_new" />
		<KeyWord name="webbrowser.Grail.open_new_tab" />
		<KeyWord name="webbrowser.Konqueror" func="yes">
			<Overload retVal="" descr="Controller for the KDE File Manager (kfm, or Konqueror).&#10;&#10;See the output of ``kfmclient --commands``&#10;for more information on the Konqueror remote-control interface.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Konqueror.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Konqueror.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Konqueror.open_new" />
		<KeyWord name="webbrowser.Konqueror.open_new_tab" />
		<KeyWord name="webbrowser.Mozilla" func="yes">
			<Overload retVal="" descr="Launcher class for Mozilla browsers.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.open_new" />
		<KeyWord name="webbrowser.Mozilla.open_new_tab" />
		<KeyWord name="webbrowser.Mozilla.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Mozilla.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape" func="yes">
			<Overload retVal="" descr="Launcher class for Netscape browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.open_new" />
		<KeyWord name="webbrowser.Netscape.open_new_tab" />
		<KeyWord name="webbrowser.Netscape.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Netscape.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera" func="yes">
			<Overload retVal="" descr="Launcher class for Opera browser.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.background" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.open_new" />
		<KeyWord name="webbrowser.Opera.open_new_tab" />
		<KeyWord name="webbrowser.Opera.raise_opts" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.remote_action_newtab" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.remote_action_newwin" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.Opera.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser" func="yes">
			<Overload retVal="" descr="Parent class for all Unix browsers with remote functionality.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.open_new" />
		<KeyWord name="webbrowser.UnixBrowser.open_new_tab" />
		<KeyWord name="webbrowser.UnixBrowser.redirect_stdout" func="yes">
			<Overload retVal="" descr="(bool)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.UnixBrowser.remote_args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault" func="yes">
			<Overload retVal="" descr="Parent class for all browsers. Do not use directly.">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault.args" func="yes">
			<Overload retVal="" descr="(list)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="self" />
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.WindowsDefault.open_new" />
		<KeyWord name="webbrowser.WindowsDefault.open_new_tab" />
		<KeyWord name="webbrowser.browser" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.get" func="yes">
			<Overload retVal="" descr="Return a browser launcher instance appropriate for the environment.">
				<Param name="[using=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.iexplore" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.main" />
		<KeyWord name="webbrowser.open" func="yes">
			<Overload retVal="" descr=>
				<Param name="url" />
				<Param name="[new=0" />
				<Param name="[autoraise=True]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.open_new" />
		<KeyWord name="webbrowser.open_new_tab" />
		<KeyWord name="webbrowser.register" func="yes">
			<Overload retVal="" descr="Register a browser connector and, optionally, connection.">
				<Param name="name" />
				<Param name="klass" />
				<Param name="[instance=None" />
				<Param name="[update_tryorder=1]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="webbrowser.register_X_browsers" />
		<KeyWord name="week" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="weekday" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="weekheader" func="yes">
			<Overload retVal="" descr="Function of calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="weibullvariate" func="yes">
			<Overload retVal="" descr="Function of random">
			</Overload>
		</KeyWord>
		<KeyWord name="what" func="yes">
			<Overload retVal="" descr="Function of imghdr">
			</Overload>
		</KeyWord>
		<KeyWord name="whathdr" func="yes">
			<Overload retVal="" descr="Function of sndhdr">
			</Overload>
		</KeyWord>
		<KeyWord name="which" func="yes">
			<Overload retVal="" descr="Function of shutil">
			</Overload>
		</KeyWord>
		<KeyWord name="whichdb" func="yes">
			<Overload retVal="" descr="Function of dbm">
			</Overload>
		</KeyWord>
		<KeyWord name="whichmodule" func="yes">
			<Overload retVal="" descr="Function of pickle">
			</Overload>
		</KeyWord>
		<KeyWord name="while" />
		<KeyWord name="win32_ver" func="yes">
			<Overload retVal="" descr="Function of platform">
			</Overload>
		</KeyWord>
		<KeyWord name="win_getpass" func="yes">
			<Overload retVal="" descr="Function of getpass">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound" func="yes">
			<Overload retVal="" descr="PlaySound(sound, flags) - play a sound&#10;SND_FILENAME - sound is a wav file name&#10;SND_ALIAS - sound is a registry sound association name&#10;SND_LOOP - Play the sound repeatedly; must also specify SND_ASYNC&#10;SND_MEMORY - sound is a memory image of a wav file&#10;SND_PURGE - stop all instances of the specified sound&#10;SND_ASYNC - PlaySound returns immediately&#10;SND_NODEFAULT - Do not play a default beep if the sound can not be found&#10;SND_NOSTOP - Do not interrupt any sounds currently playing&#10;SND_NOWAIT - Return immediately if the sound driver is busy&#10;&#10;Beep(frequency, duration) - Make a beep through the PC speaker.&#10;MessageBeep(type) - Call Windows MessageBeep.">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.Beep" func="yes">
			<Overload retVal="" descr="A wrapper around the Windows Beep API.&#10;&#10;frequency&#10;  Frequency of the sound in hertz.&#10;  Must be in the range 37 through 32,767.&#10;duration&#10;  How long the sound should play, in milliseconds.">
				<Param name="frequency" />
				<Param name="duration" />
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONASTERISK" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONEXCLAMATION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONHAND" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MB_ICONQUESTION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.MessageBeep" func="yes">
			<Overload retVal="" descr="Call Windows MessageBeep(x).&#10;&#10;x defaults to MB_OK.">
				<Param name="[type=0]" />
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.PlaySound" func="yes">
			<Overload retVal="" descr="A wrapper around the Windows PlaySound API.&#10;&#10;sound&#10;  The sound to play; a filename, data, or None.&#10;flags&#10;  Flag values, ored together.  See module documentation.">
				<Param name="sound" />
				<Param name="flags" />
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_ALIAS" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_APPLICATION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_ASYNC" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_FILENAME" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_LOOP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_MEMORY" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_NODEFAULT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_NOSTOP" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_NOWAIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="winsound.SND_PURGE" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="with" />
		<KeyWord name="with_context" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualVersionConflict">
			</Overload>
		</KeyWord>
		<KeyWord name="with_name" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="with_suffix" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="wrap" func="yes">
			<Overload retVal="" descr="Function of textwrap">
			</Overload>
		</KeyWord>
		<KeyWord name="wrap_bio" func="yes">
			<Overload retVal="" descr="Function of ssl.SSLContext">
			</Overload>
		</KeyWord>
		<KeyWord name="wrap_future" func="yes">
			<Overload retVal="" descr="Function of asyncio">
			</Overload>
		</KeyWord>
		<KeyWord name="wrap_socket" func="yes">
			<Overload retVal="" descr="Function of ssl">
			</Overload>
		</KeyWord>
		<KeyWord name="wraps" func="yes">
			<Overload retVal="" descr="Function of contextlib">
			</Overload>
		</KeyWord>
		<KeyWord name="writable" func="yes">
			<Overload retVal="" descr="Function of asynchat.async_chat">
			</Overload>
		</KeyWord>
		<KeyWord name="write" func="yes">
			<Overload retVal="" descr="Function of asyncore">
			</Overload>
		</KeyWord>
		<KeyWord name="write32u" func="yes">
			<Overload retVal="" descr="Function of gzip">
			</Overload>
		</KeyWord>
		<KeyWord name="writePlist" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="writePlistToBytes" func="yes">
			<Overload retVal="" descr="Function of plistlib">
			</Overload>
		</KeyWord>
		<KeyWord name="write_bytes" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="write_eof" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="write_results" func="yes">
			<Overload retVal="" descr="Function of trace.CoverageResults">
			</Overload>
		</KeyWord>
		<KeyWord name="write_results_file" func="yes">
			<Overload retVal="" descr="Function of trace.CoverageResults">
			</Overload>
		</KeyWord>
		<KeyWord name="write_rsrc" func="yes">
			<Overload retVal="" descr="Function of binhex.BinHex">
			</Overload>
		</KeyWord>
		<KeyWord name="write_text" func="yes">
			<Overload retVal="" descr="Function of pathlib.Path">
			</Overload>
		</KeyWord>
		<KeyWord name="writedoc" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="writedocs" func="yes">
			<Overload retVal="" descr="Function of pydoc">
			</Overload>
		</KeyWord>
		<KeyWord name="writeframes" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="writeframesraw" func="yes">
			<Overload retVal="" descr="Function of aifc.Aifc_write">
			</Overload>
		</KeyWord>
		<KeyWord name="writeheader" func="yes">
			<Overload retVal="" descr="Function of csv.DictWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="writelines" func="yes">
			<Overload retVal="" descr="Function of asyncio.StreamWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="writepy" func="yes">
			<Overload retVal="" descr="Function of zipfile.PyZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="writer" func="yes">
			<Overload retVal="" descr="Function of csv">
			</Overload>
		</KeyWord>
		<KeyWord name="writerow" func="yes">
			<Overload retVal="" descr="Function of csv.DictWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="writerows" func="yes">
			<Overload retVal="" descr="Function of csv.DictWriter">
			</Overload>
		</KeyWord>
		<KeyWord name="writestr" func="yes">
			<Overload retVal="" descr="Function of pkg_resources.ContextualZipFile">
			</Overload>
		</KeyWord>
		<KeyWord name="wsgiref" func="yes">
			<Overload retVal="" descr="wsgiref -- a WSGI (PEP 3333) Reference Library&#10;&#10;Current Contents:&#10;&#10;* util -- Miscellaneous useful functions and wrappers&#10;&#10;* headers -- Manage response headers&#10;&#10;* handlers -- base classes for server/gateway implementations&#10;&#10;* simple_server -- a simple BaseHTTPServer that supports WSGI&#10;&#10;* validate -- validation wrapper that sits between an app and a server&#10;  to detect errors in either&#10;&#10;To-Do:&#10;&#10;* cgi_gateway -- Run WSGI apps under CGI (pending a deployment standard)&#10;&#10;* cgi_wrapper -- Run CGI apps under WSGI&#10;&#10;* router -- a simple middleware component that handles URL traversal">
			</Overload>
		</KeyWord>
		<KeyWord name="wstring_at" func="yes">
			<Overload retVal="" descr="Function of ctypes">
			</Overload>
		</KeyWord>
		<KeyWord name="xatom" func="yes">
			<Overload retVal="" descr="Function of imaplib.IMAP4">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib" func="yes">
			<Overload retVal="" descr="Implements (a subset of) Sun XDR -- eXternal Data Representation.&#10;&#10;See: RFC 1014">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO" func="yes">
			<Overload retVal="" descr="Buffered I/O implementation using an in-memory bytes buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.close" func="yes">
			<Overload retVal="" descr="Disable all I/O operations.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.closed" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.detach" func="yes">
			<Overload retVal="" descr="Disconnect this buffer from its underlying raw stream and return it.&#10;&#10;After the raw stream has been detached, the buffer is in an unusable&#10;state.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.fileno" func="yes">
			<Overload retVal="" descr="Returns underlying file descriptor if one exists.&#10;&#10;OSError is raised if the IO object does not use a file descriptor.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.flush" func="yes">
			<Overload retVal="" descr="Does nothing.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.getbuffer" func="yes">
			<Overload retVal="" descr="Get a read-write view over the contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.getvalue" func="yes">
			<Overload retVal="" descr="Retrieve the entire contents of the BytesIO object.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.isatty" func="yes">
			<Overload retVal="" descr="Always returns False.&#10;&#10;BytesIO objects are not connected to a TTY-like device.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.read" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.read1" func="yes">
			<Overload retVal="" descr="Read at most size bytes, returned as a bytes object.&#10;&#10;If the size argument is negative or omitted, read until EOF is reached.&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.readable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be read.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.readinto" func="yes">
			<Overload retVal="" descr="Read bytes into buffer.&#10;&#10;Returns number of bytes read (0 for EOF), or None if the object&#10;is set not to block and has no data to read.">
				<Param name="self" />
				<Param name="buffer" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.readinto1" />
		<KeyWord name="xdrlib.BytesIO.readline" func="yes">
			<Overload retVal="" descr="Next line from the file, as a bytes object.&#10;&#10;Retain newline.  A non-negative size argument limits the maximum&#10;number of bytes to return (an incomplete line may be returned then).&#10;Return an empty bytes object at EOF.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.readlines" func="yes">
			<Overload retVal="" descr="List of bytes objects, each a line from the file.&#10;&#10;Call readline() repeatedly and return a list of the lines so read.&#10;The optional size argument, if given, is an approximate bound on the&#10;total number of bytes in the lines returned.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.seek" func="yes">
			<Overload retVal="" descr="Change stream position.&#10;&#10;Seek to byte offset pos relative to position indicated by whence:&#10;     0  Start of stream (the default).  pos should be &gt;= 0;&#10;     1  Current position - pos may be negative;&#10;     2  End of stream - pos usually negative.&#10;Returns the new absolute position.">
				<Param name="self" />
				<Param name="pos" />
				<Param name="whence" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.seekable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be seeked.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.tell" func="yes">
			<Overload retVal="" descr="Current file position, an integer.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.truncate" func="yes">
			<Overload retVal="" descr="Truncate the file to at most size bytes.&#10;&#10;Size defaults to the current file position, as returned by tell().&#10;The current file position is unchanged.  Returns the new size.">
				<Param name="self" />
				<Param name="size" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.writable" func="yes">
			<Overload retVal="" descr="Returns True if the IO object can be written.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.write" func="yes">
			<Overload retVal="" descr="Write bytes to file.&#10;&#10;Return the number of bytes written.">
				<Param name="self" />
				<Param name="b" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.BytesIO.writelines" func="yes">
			<Overload retVal="" descr="Write lines to the file.&#10;&#10;Note that newlines are not added.  lines can be any iterable object&#10;producing bytes-like objects. This is equivalent to calling write() for&#10;each element.">
				<Param name="self" />
				<Param name="lines" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.ConversionError" func="yes">
			<Overload retVal="" descr="Exception class for this module. Use:&#10;&#10;except xdrlib.Error as var:&#10;    # var has the Error instance for the exception&#10;&#10;Public ivars:&#10;    msg -- contains the message">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.ConversionError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.ConversionError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Error" func="yes">
			<Overload retVal="" descr="Exception class for this module. Use:&#10;&#10;except xdrlib.Error as var:&#10;    # var has the Error instance for the exception&#10;&#10;Public ivars:&#10;    msg -- contains the message">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Packer" func="yes">
			<Overload retVal="" descr="Pack various data representations into a buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Packer.get_buf" />
		<KeyWord name="xdrlib.Packer.get_buffer" />
		<KeyWord name="xdrlib.Packer.pack_array" />
		<KeyWord name="xdrlib.Packer.pack_bool" />
		<KeyWord name="xdrlib.Packer.pack_bytes" />
		<KeyWord name="xdrlib.Packer.pack_double" />
		<KeyWord name="xdrlib.Packer.pack_enum" />
		<KeyWord name="xdrlib.Packer.pack_farray" />
		<KeyWord name="xdrlib.Packer.pack_float" />
		<KeyWord name="xdrlib.Packer.pack_fopaque" />
		<KeyWord name="xdrlib.Packer.pack_fstring" />
		<KeyWord name="xdrlib.Packer.pack_hyper" />
		<KeyWord name="xdrlib.Packer.pack_int" />
		<KeyWord name="xdrlib.Packer.pack_list" />
		<KeyWord name="xdrlib.Packer.pack_opaque" />
		<KeyWord name="xdrlib.Packer.pack_string" />
		<KeyWord name="xdrlib.Packer.pack_uhyper" />
		<KeyWord name="xdrlib.Packer.pack_uint" />
		<KeyWord name="xdrlib.Packer.reset" />
		<KeyWord name="xdrlib.Unpacker" func="yes">
			<Overload retVal="" descr="Unpacks various data representations from the given buffer.">
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.Unpacker.done" />
		<KeyWord name="xdrlib.Unpacker.get_buffer" />
		<KeyWord name="xdrlib.Unpacker.get_position" />
		<KeyWord name="xdrlib.Unpacker.reset" />
		<KeyWord name="xdrlib.Unpacker.set_position" />
		<KeyWord name="xdrlib.Unpacker.unpack_array" />
		<KeyWord name="xdrlib.Unpacker.unpack_bool" />
		<KeyWord name="xdrlib.Unpacker.unpack_bytes" />
		<KeyWord name="xdrlib.Unpacker.unpack_double" />
		<KeyWord name="xdrlib.Unpacker.unpack_enum" />
		<KeyWord name="xdrlib.Unpacker.unpack_farray" />
		<KeyWord name="xdrlib.Unpacker.unpack_float" />
		<KeyWord name="xdrlib.Unpacker.unpack_fopaque" />
		<KeyWord name="xdrlib.Unpacker.unpack_fstring" />
		<KeyWord name="xdrlib.Unpacker.unpack_hyper" />
		<KeyWord name="xdrlib.Unpacker.unpack_int" />
		<KeyWord name="xdrlib.Unpacker.unpack_list" />
		<KeyWord name="xdrlib.Unpacker.unpack_opaque" />
		<KeyWord name="xdrlib.Unpacker.unpack_string" />
		<KeyWord name="xdrlib.Unpacker.unpack_uhyper" />
		<KeyWord name="xdrlib.Unpacker.unpack_uint" />
		<KeyWord name="xdrlib.raise_conversion_error" func="yes">
			<Overload retVal="" descr="Wrap any raised struct.errors in a ConversionError.">
				<Param name="function" />
			</Overload>
		</KeyWord>
		<KeyWord name="xdrlib.wraps" func="yes">
			<Overload retVal="" descr="Decorator factory to apply update_wrapper() to a wrapper function&#10;&#10;Returns a decorator that invokes update_wrapper() with the decorated&#10;function as the wrapper argument and the arguments to wraps() as the&#10;remaining arguments. Default arguments are as for update_wrapper().&#10;This is a convenience function to simplify applying partial() to&#10;update_wrapper().">
				<Param name="wrapped" />
				<Param name="[assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')" />
				<Param name="[updated=('__dict__',)]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="xgtitle" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="xhdr" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlcharrefreplace_errors" func="yes">
			<Overload retVal="" descr="Function of codecs">
			</Overload>
		</KeyWord>
		<KeyWord name="xmlrpc" />
		<KeyWord name="xor" func="yes">
			<Overload retVal="" descr="Function of operator">
			</Overload>
		</KeyWord>
		<KeyWord name="xover" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="xpath" func="yes">
			<Overload retVal="" descr="Function of nntplib.NNTP">
			</Overload>
		</KeyWord>
		<KeyWord name="xzopen" func="yes">
			<Overload retVal="" descr="Function of tarfile.TarFile">
			</Overload>
		</KeyWord>
		<KeyWord name="yeardatescalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="yeardays2calendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="yeardayscalendar" func="yes">
			<Overload retVal="" descr="Function of calendar.Calendar">
			</Overload>
		</KeyWord>
		<KeyWord name="yield" />
		<KeyWord name="yield_lines" func="yes">
			<Overload retVal="" descr="Function of pkg_resources">
			</Overload>
		</KeyWord>
		<KeyWord name="yiq_to_rgb" func="yes">
			<Overload retVal="" descr="Function of colorsys">
			</Overload>
		</KeyWord>
		<KeyWord name="zfill" func="yes">
			<Overload retVal="" descr="S.zfill(width) -&gt; str&#10;&#10;Pad a numeric string S with zeros on the left, to fill a field&#10;of the specified width. The string S is never truncated.">
			</Overload>
		</KeyWord>
		<KeyWord name="zip" func="yes">
			<Overload retVal="" descr="zip(iter1 [,iter2 [...]]) --&gt; zip object&#10;&#10;Return a zip object whose .__next__() method returns a tuple where&#10;the i-th element comes from the i-th iterable argument.  The .__next__()&#10;method continues until the shortest iterable in the argument sequence&#10;is exhausted and then it raises StopIteration.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp" />
		<KeyWord name="zipapp.MAIN_TEMPLATE" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp.ZipAppError" func="yes">
			<Overload retVal="" descr="Inappropriate argument value (of correct type).">
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp.ZipAppError.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp.ZipAppError.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp.create_archive" func="yes">
			<Overload retVal="" descr="Create an application archive from SOURCE.&#10;&#10;The SOURCE can be the name of a directory, or a filename or a file-like&#10;object referring to an existing archive.&#10;&#10;The content of SOURCE is packed into an application archive in TARGET,&#10;which can be a filename or a file-like object.  If SOURCE is a directory,&#10;TARGET can be omitted and will default to the name of SOURCE with .pyz&#10;appended.&#10;&#10;The created application archive will have a shebang line specifying&#10;that it should run with INTERPRETER (there will be no shebang line if&#10;INTERPRETER is None), and a __main__.py which runs MAIN (if MAIN is&#10;not specified, an existing __main__.py will be used).  It is an error&#10;to specify MAIN for anything other than a directory source with no&#10;__main__.py, and it is an error to omit MAIN if the directory has no&#10;__main__.py.">
				<Param name="source" />
				<Param name="[target=None" />
				<Param name="[interpreter=None" />
				<Param name="[main=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp.get_interpreter" />
		<KeyWord name="zipapp.main" func="yes">
			<Overload retVal="" descr="Run the zipapp command line interface.&#10;&#10;The ARGS parameter lets you specify the argument list directly.&#10;Omitting ARGS (or setting it to None) works as for argparse, using&#10;sys.argv[1:] as the argument list.">
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipapp.shebang_encoding" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile" func="yes">
			<Overload retVal="" descr="Read and write ZIP files.&#10;&#10;XXX references to utf-8 need further investigation.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BZIP2_VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipFile" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipFile.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipFile.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipfile" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipfile.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.BadZipfile.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.DEFAULT_VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LZMACompressor" />
		<KeyWord name="zipfile.LZMACompressor.compress" />
		<KeyWord name="zipfile.LZMACompressor.flush" />
		<KeyWord name="zipfile.LZMADecompressor" />
		<KeyWord name="zipfile.LZMADecompressor.decompress" />
		<KeyWord name="zipfile.LZMA_VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LargeZipFile" func="yes">
			<Overload retVal="" descr="Raised when writing a zipfile, the zipfile requires ZIP64 extensions&#10;and those extensions are disabled.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LargeZipFile.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.LargeZipFile.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.MAX_EXTRACT_VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile" func="yes">
			<Overload retVal="" descr="Class to create ZIP archives with Python library files and packages.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.close" func="yes">
			<Overload retVal="" descr="Close the file, and for mode 'w', 'x' and 'a' write the ending&#10;records.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.comment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a ZipInfo object. You can&#10;specify a different directory using `path'.">
				<Param name="self" />
				<Param name="member" />
				<Param name="[path=None" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory. `path' specifies a different directory to extract to.&#10;`members' is optional and must be a subset of the list returned&#10;by namelist().">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[members=None" />
				<Param name="[pwd=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.getinfo" func="yes">
			<Overload retVal="" descr="Return the instance of ZipInfo given 'name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.infolist" func="yes">
			<Overload retVal="" descr="Return a list of class ZipInfo instances for files in the&#10;archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.namelist" func="yes">
			<Overload retVal="" descr="Return a list of file names in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.open" func="yes">
			<Overload retVal="" descr="Return file-like object for 'name'.&#10;&#10;name is a string for the file name within the ZIP file, or a ZipInfo&#10;object.&#10;&#10;mode should be 'r' to read a file already in the ZIP file, or 'w' to&#10;write to a file newly added to the archive.&#10;&#10;pwd is the password to decrypt files (only used for reading).&#10;&#10;When writing, if the file size is not known in advance but may exceed&#10;2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large&#10;files.  If the size is known in advance, it is best to pass a ZipInfo&#10;instance for name, with zinfo.file_size set.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.printdir" func="yes">
			<Overload retVal="" descr="Print a table of contents for the zip file.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.read" func="yes">
			<Overload retVal="" descr="Return file bytes (as a string) for name.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[pwd=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.setpassword" func="yes">
			<Overload retVal="" descr="Set default password for encrypted files.">
				<Param name="self" />
				<Param name="pwd" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.testzip" func="yes">
			<Overload retVal="" descr="Read all the files and check the CRC.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.write" func="yes">
			<Overload retVal="" descr="Put the bytes from filename into the archive under the name&#10;arcname.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="[arcname=None" />
				<Param name="[compress_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.writepy" func="yes">
			<Overload retVal="" descr='Add all files from "pathname" to the ZIP archive.&#10;&#10;If pathname is a package directory, search the directory and&#10;all package subdirectories recursively for all *.py and enter&#10;the modules into the archive.  If pathname is a plain&#10;directory, listdir *.py and enter all modules.  Else, pathname&#10;must be a Python *.py file and the module will be put into the&#10;archive.  Added modules are always module.pyc.&#10;This method will compile the module.py into module.pyc if&#10;necessary.&#10;If filterfunc(pathname) is given, it is called with every argument.&#10;When it is False, the file or directory is skipped.'>
				<Param name="self" />
				<Param name="pathname" />
				<Param name="[basename" />
				<Param name="[filterfunc=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.PyZipFile.writestr" func="yes">
			<Overload retVal="" descr="Write a file into the archive.  The contents is 'data', which&#10;may be either a 'str' or a 'bytes' instance; if it is a 'str',&#10;it is encoded as UTF-8 first.&#10;'zinfo_or_arcname' is either a ZipInfo instance or&#10;the name of the file in the archive.">
				<Param name="self" />
				<Param name="zinfo_or_arcname" />
				<Param name="data" />
				<Param name="[compress_type=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP64_LIMIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP64_VERSION" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_BZIP2" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_DEFLATED" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_FILECOUNT_LIMIT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_LZMA" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZIP_MAX_COMMENT" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipExtFile" func="yes">
			<Overload retVal="" descr="(ABCMeta)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile" func="yes">
			<Overload retVal="" descr="Class with methods to open, read, write, close, list zip files.&#10;&#10;z = ZipFile(file, mode=&quot;r&quot;, compression=ZIP_STORED, allowZip64=True)&#10;&#10;file: Either the path to the file, or a file-like object.&#10;      If it is a path, the file will be opened and closed by ZipFile.&#10;mode: The mode can be either read 'r', write 'w', exclusive create 'x',&#10;      or append 'a'.&#10;compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),&#10;             ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).&#10;allowZip64: if True ZipFile will create files with ZIP64 extensions when&#10;            needed, otherwise it will raise an exception when this would&#10;            be necessary.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.close" func="yes">
			<Overload retVal="" descr="Close the file, and for mode 'w', 'x' and 'a' write the ending&#10;records.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.comment" func="yes">
			<Overload retVal="" descr="(property)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.extract" func="yes">
			<Overload retVal="" descr="Extract a member from the archive to the current working directory,&#10;using its full name. Its file information is extracted as accurately&#10;as possible. `member' may be a filename or a ZipInfo object. You can&#10;specify a different directory using `path'.">
				<Param name="self" />
				<Param name="member" />
				<Param name="[path=None" />
				<Param name="[pwd=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.extractall" func="yes">
			<Overload retVal="" descr="Extract all members from the archive to the current working&#10;directory. `path' specifies a different directory to extract to.&#10;`members' is optional and must be a subset of the list returned&#10;by namelist().">
				<Param name="self" />
				<Param name="[path=None" />
				<Param name="[members=None" />
				<Param name="[pwd=None]]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.getinfo" func="yes">
			<Overload retVal="" descr="Return the instance of ZipInfo given 'name'.">
				<Param name="self" />
				<Param name="name" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.infolist" func="yes">
			<Overload retVal="" descr="Return a list of class ZipInfo instances for files in the&#10;archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.namelist" func="yes">
			<Overload retVal="" descr="Return a list of file names in the archive.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.open" func="yes">
			<Overload retVal="" descr="Return file-like object for 'name'.&#10;&#10;name is a string for the file name within the ZIP file, or a ZipInfo&#10;object.&#10;&#10;mode should be 'r' to read a file already in the ZIP file, or 'w' to&#10;write to a file newly added to the archive.&#10;&#10;pwd is the password to decrypt files (only used for reading).&#10;&#10;When writing, if the file size is not known in advance but may exceed&#10;2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large&#10;files.  If the size is known in advance, it is best to pass a ZipInfo&#10;instance for name, with zinfo.file_size set.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.printdir" func="yes">
			<Overload retVal="" descr="Print a table of contents for the zip file.">
				<Param name="self" />
				<Param name="[file=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.read" func="yes">
			<Overload retVal="" descr="Return file bytes (as a string) for name.">
				<Param name="self" />
				<Param name="name" />
				<Param name="[pwd=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.setpassword" func="yes">
			<Overload retVal="" descr="Set default password for encrypted files.">
				<Param name="self" />
				<Param name="pwd" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.testzip" func="yes">
			<Overload retVal="" descr="Read all the files and check the CRC.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.write" func="yes">
			<Overload retVal="" descr="Put the bytes from filename into the archive under the name&#10;arcname.">
				<Param name="self" />
				<Param name="filename" />
				<Param name="[arcname=None" />
				<Param name="[compress_type=None]]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipFile.writestr" func="yes">
			<Overload retVal="" descr="Write a file into the archive.  The contents is 'data', which&#10;may be either a 'str' or a 'bytes' instance; if it is a 'str',&#10;it is encoded as UTF-8 first.&#10;'zinfo_or_arcname' is either a ZipInfo instance or&#10;the name of the file in the archive.">
				<Param name="self" />
				<Param name="zinfo_or_arcname" />
				<Param name="data" />
				<Param name="[compress_type=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo" func="yes">
			<Overload retVal="" descr="Class with attributes describing each file in the ZIP archive.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.CRC" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.FileHeader" func="yes">
			<Overload retVal="" descr="Return the per-file header as a string.">
				<Param name="self" />
				<Param name="[zip64=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.comment" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.compress_size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.compress_type" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.create_system" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.create_version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.date_time" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.external_attr" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.extra" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.extract_version" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.file_size" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.flag_bits" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.from_file" func="yes">
			<Overload retVal="" descr="Construct an appropriate ZipInfo for a file on the filesystem.&#10;&#10;filename should be the path to a file or directory on the filesystem.&#10;&#10;arcname is the name which it will have within the archive (by default,&#10;this will be the same as filename, but without a drive letter and with&#10;leading path separators removed).">
				<Param name="cls" />
				<Param name="filename" />
				<Param name="[arcname=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.header_offset" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.internal_attr" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.is_dir" func="yes">
			<Overload retVal="" descr="Return True if this archive member is a directory.">
				<Param name="self" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.orig_filename" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.reserved" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.ZipInfo.volume" func="yes">
			<Overload retVal="" descr="(member_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.compressor_names" func="yes">
			<Overload retVal="" descr="(dict)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.crc32" func="yes">
			<Overload retVal="" descr="Compute a CRC-32 checksum of data.&#10;&#10;  value&#10;    Starting value of the checksum.&#10;&#10;The returned checksum is an integer.">
				<Param name="data" />
				<Param name="value" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.error" func="yes">
			<Overload retVal="" descr="Common base class for all non-exit exceptions.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.error.args" func="yes">
			<Overload retVal="" descr="(getset_descriptor)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.error.with_traceback" func="yes">
			<Overload retVal="" descr="Exception.with_traceback(tb) --&#10;set self.__traceback__ to tb and return self.">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.is_zipfile" func="yes">
			<Overload retVal="" descr="Quickly see if a file is a ZIP file by checking the magic number.&#10;&#10;The filename argument may be a file or file-like object too.">
				<Param name="filename" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.main" func="yes">
			<Overload retVal="" descr=>
				<Param name="[args=None]" />
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeCentralDir" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeEndCentDir" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeEndCentDir64" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeEndCentDir64Locator" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.sizeFileHeader" func="yes">
			<Overload retVal="" descr="(int)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringCentralDir" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringEndArchive" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringEndArchive64" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringEndArchive64Locator" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.stringFileHeader" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structCentralDir" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structEndArchive" func="yes">
			<Overload retVal="" descr="(bytes)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structEndArchive64" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structEndArchive64Locator" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipfile.structFileHeader" func="yes">
			<Overload retVal="" descr="(str)">
			</Overload>
		</KeyWord>
		<KeyWord name="zipimporter" func="yes">
			<Overload retVal="" descr="Function of pkgutil.zipimporter">
			</Overload>
		</KeyWord>
	</AutoComplete>
</NotepadPlus>
